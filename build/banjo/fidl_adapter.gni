# Copyright 2021 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/banjo/toolchain.gni")
import("//build/compiled_action.gni")
import("//build/fidl/fidl_library.gni")
import("//build/fidl/toolchain.gni")
import("//build/testing/golden_file.gni")

# Exposes a Banjo library as a FIDL library.
#
# This template is used in the Banjo deprecation project (fxb/67196).
# Banjo sources are processed as FIDL sources, generating a FIDL IR file. That
# file is then fed to fidlgen_banjo which generates bindings identical to the
# ones generated by the legacy banjo tool (as verified by a build step).
#
# This template accepts the same parameters as the `banjo` template, but only
# uses `name` and `sources`.

template("fidl_adapter") {
  not_needed(invoker,
             [
               "needs_composite",
               "sdk_category",
             ])

  main_target_name = "$target_name.fidl"
  library_name = target_name
  if (defined(invoker.name)) {
    library_name = invoker.name
  }

  if (current_toolchain == fidl_toolchain) {
    deps = []
    if (defined(invoker.deps)) {
      foreach(dep, invoker.deps) {
        if (dep == "//sdk/banjo/zx") {
          deps += [ "//zircon/vdso/zx" ]
        } else {
          name = get_label_info(dep, "name")
          dir = get_label_info(dep, "dir")
          deps += [ "$dir:$name.fidl" ]
        }
      }
    }

    fidl_library(main_target_name) {
      name = library_name
      sources = invoker.sources
      should_lint = false
      public_deps = deps
    }
  } else if (is_fuchsia) {
    not_needed(invoker, "*")

    c_target_name = "${library_name}_banjo_c"
    fidlgen_target_name = "$c_target_name.gen"
    config_target_name = "$c_target_name.config"
    verification_target_name = "${library_name}.verify"

    ir_dep = ":$main_target_name($fidl_toolchain)"
    ir_gen_dir = get_label_info(ir_dep, "target_gen_dir")
    ir_file = "$ir_gen_dir/$main_target_name.fidl.json"

    header_path = string_replace(library_name, ".", "/")
    header_path = string_replace(header_path, "_", "-")
    header_include_base = "$target_gen_dir/$c_target_name"
    header_file = "$header_include_base/$header_path/c/banjo.h"

    # Run fidlgen_banjo on the IR and generate C code.
    compiled_action(fidlgen_target_name) {
      tool = "//src/devices/tools/fidlgen_banjo:bin"
      tool_output_name = "fidlgen_banjo"

      inputs = [ ir_file ]

      outputs = [ header_file ]

      deps = [ ir_dep ]

      args = [
        "--ir",
        rebase_path(ir_file, root_build_dir),
        "--output",
        rebase_path(header_file, root_build_dir),
        "--backend",
        "c",
      ]
    }

    banjo_dep = ":${target_name}_c_compile($banjo_toolchain)"
    banjo_gen_dir = get_label_info(banjo_dep, "root_gen_dir")
    banjo_header_file = "$banjo_gen_dir/$header_path/c/banjo.h"

    # Verify that the new-style and old-style bindings are identical.
    golden_file(verification_target_name) {
      golden = banjo_header_file

      current = header_file

      deps = [
        ":$fidlgen_target_name",
        banjo_dep,
      ]
    }

    # This config ensures dependents can find the generated header within the
    # output directory.
    config(config_target_name) {
      include_dirs = [ header_include_base ]
    }

    # Exposes the bindings as C sources to the rest of the build.
    # Eventually this target will be surfaced via the `fidl` template.
    source_set(c_target_name) {
      public = [ header_file ]

      public_configs = [ ":$config_target_name" ]

      deps = [ ":$fidlgen_target_name" ]

      deps += [ ":$verification_target_name" ]
    }
  } else {
    assert(false,
           "Unable to translate Banjo target to FIDL in $current_toolchain.")
  }
}

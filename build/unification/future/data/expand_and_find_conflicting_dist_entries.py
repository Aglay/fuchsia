#!/usr/bin/env python2.7
# Copyright 2020 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
'''Reads the contents of a manifest file generated by the build and verifies
   that there are no collisions among destination paths.
   '''

import argparse
import collections
import json
import sys

Entry = collections.namedtuple('Entry', ['source', 'destination', 'label'])


def expand(items):
    '''Reads metadata produced by GN and expands file references found within
       that metadata.
       See distribution_manifest.gni for a description of the metadata format.
       '''
    entries = []
    for item in items:
        if 'source' in item:
            entries.append(item)
        elif 'file' in item:
            with open(item['file'], 'r') as data_file:
                data = json.load(data_file)
            for entry in data:
                entry['label'] = item['label']
                entries.append(entry)
    return [Entry(**e) for e in entries]


def main():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        '--input', help='Path to original manifest', required=True)
    parser.add_argument(
        '--output', help='Path to the updated manifest', required=True)
    args = parser.parse_args()

    with open(args.input, 'r') as input_file:
        contents = json.load(input_file)

    entries = expand(contents)
    entries_by_dest = {
        d: set(e for e in entries if e.destination == d) for d in set(
            e.destination for e in entries)
    }
    conflicts = {d: e for d, e in entries_by_dest.iteritems() if len(e) > 1}
    # Only report a conflict if the source files differ.
    # TODO(45680): remove this additional filtering when dependency trees are
    # cleaned up and //build/package.gni has gone the way of the dodo.
    conflicts = {
        d: e
        for d, e in conflicts.iteritems()
        if len(set(entry.source for entry in e)) >= 2
    }
    if conflicts:
        for destination in conflicts:
            print('Conflicts for path ' + destination + ':')
            for conflict in conflicts[destination]:
                print(' - ' + conflict.source)
                print('   from ' + conflict.label)
        print('Error: conflicting distribution entries!')
        return 1

    with open(args.output, 'w') as output_file:
        json.dump(
            sorted(e._asdict() for e in entries),
            output_file,
            indent=2,
            sort_keys=True,
            separators=(',', ': '))

    return 0


if __name__ == '__main__':
    sys.exit(main())

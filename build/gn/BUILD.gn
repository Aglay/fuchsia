# Copyright 2016 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/compiled_action.gni")
import("//build/config/fuchsia/zircon.gni")
import("//build/gn/packages.gni")
import("//build/package.gni")
import("//build/testing/platforms.gni")
import("//build/toolchain/goma.gni")

# Permit dependencies on testonly targets from packages.
testonly = true

group("packages") {
  deps = available_packages
  data_deps = package_data_deps
}

group("default") {
  deps = [
    ":host_tests",
    ":packages",
  ]
  if (preinstall_packages != [] || monolith_packages != []) {
    deps += [ "//build/images" ]
  }
  if (available_packages != []) {
    deps += [ "//build/images:updates" ]
  }
}

# Instantiate the packages synthesized from the build argument.
foreach(pkg, synthesize_packages) {
  package(pkg.name) {
    forward_variables_from(pkg, "*", [ "name" ])
  }
}

# Copy host test binaries to $root_build_dir/host_tests.
# TODO(IN-819): Delete this copy target once host tests are no longer run out
# of a single directory.
if (package_host_tests != []) {
  copy("host_tests") {
    deps = []
    sources = []
    bindir = get_label_info("//anything($host_toolchain)", "root_out_dir")

    # package_host_tests may contain duplicate entries. Those entries must be
    # de-duplicated here to avoid output collisions.
    foreach(label, package_host_tests) {
      _full_label = "$label($host_toolchain)"
      deps += [ _full_label ]
      binary = get_label_info(label, "name")
      sources += [ "$bindir/$binary" ]
    }

    outputs = [
      "$root_build_dir/host_tests/{{source_file_part}}",
    ]
  }
} else {
  group("host_tests") {
  }
}

# TODO(joshuaseaton|mcgrathr): Make this a formal build_api_module.
#
# Aggregates metadata about all tests within the build graph to create a
# top-level manifest.
generated_file("tests") {
  outputs = [
    "$root_build_dir/tests.json",
  ]
  data_keys = [ "test_spec" ]
  output_conversion = "json"
  deps = [
    ":host_tests",
    ":packages",
  ]
}

# Write a JSON metadata file about the host tests in the build.
host_tests = []
foreach(label, package_host_tests) {
  host_label = "$label($host_toolchain)"
  host_tests += [
    {
      dir = get_label_info(host_label, "dir")
      name = get_label_info(host_label, "name")
      build_dir = rebase_path(get_label_info(host_label, "target_out_dir"),
                              root_build_dir)
    },
  ]
}
write_file("$root_build_dir/host_tests.json", host_tests, "json")

# Collect the source files that are dependencies of the create_gn_rules.py
# script, below.  Unfortunately, exec_script cannot use a depfile produced
# by the script and only supports a separately computed list of dependencies.
zircon_files =
    exec_script("//build/zircon/list_source_files.py", [], "list lines")

supporting_templates = [
  "//build/zircon/boards.mako",
  "//build/zircon/header.mako",
  "//build/zircon/host_tool.mako",
  "//build/zircon/main.mako",
  "//build/zircon/shared_library.mako",
  "//build/zircon/source_library.mako",
  "//build/zircon/static_library.mako",
  "//build/zircon/sysroot.mako",
]

# The following script generates GN build files for Zircon objects.  It is
# placed before everything else so that //zircon targets are available in
# due time.  See //build/zircon/README.md for more details.
exec_script("//build/zircon/create_gn_rules.py",
            [
              "--out",
              rebase_path("//zircon/public"),
              "--staging",
              rebase_path("$root_out_dir/zircon-gn"),
              "--zircon-user-build",
              rebase_path(zircon_build_abi_dir),
              "--zircon-tool-build",
              rebase_path("$zircon_tools_dir/.."),
              "--make",
              zircon_make_path,
            ],
            "",
            zircon_files + supporting_templates)

# Write a file that can be sourced by `fx`.  This file is produced
# by `gn gen` and is not known to Ninja at all, so it has nothing to
# do with the build itself.  Its sole purpose is to leave bread
# crumbs about the settings `gn gen` used for `fx` to use later.
_relative_build_dir = rebase_path(root_build_dir, "//", "//")
_fx_config_lines = [
  "# Generated by `gn gen`.",
  "FUCHSIA_BUILD_DIR='${_relative_build_dir}'",
  "FUCHSIA_ARCH='${target_cpu}'",
]
if (use_goma) {
  _fx_config_lines += [
    "# This will affect Zircon's make via //scripts/build-zircon.sh.",
    "export GOMACC='${goma_dir}/gomacc'",
  ]
}
_fx_build_zircon_args = ""
if (zircon_use_asan) {
  _fx_build_zircon_args += " -A"
}
foreach(selector, select_variant) {
  if (selector == "host_asan") {
    _fx_build_zircon_args += " -H"
  }
}
if (_fx_build_zircon_args != "") {
  _fx_config_lines += [ "FUCHSIA_BUILD_ZIRCON_ARGS=($_fx_build_zircon_args)" ]
}
write_file("$root_build_dir/fx.config", _fx_config_lines)

# Generates breakpad symbol data for unstripped binaries.
#
# This symbol data is consumed by infrastructure tools and uploaded to Crash
# servers to enable crash reporting.  These files are uniquely important for
# release builds and this step may take a few minutes to complete, so it is
# not recommended that this be included in the default build.
action("breakpad_symbols") {
  testonly = true
  script = "//buildtools/${host_platform}/dump_breakpad_symbols"

  deps = [
    "//build/images:ids.txt",
  ]

  inputs = [
    "//buildtools/${host_platform}/dump_syms/dump_syms",
  ]
  sources = [
    "$root_out_dir/ids.txt",
  ]

  # This action generates a single xxx.sym file for each binary in the ids file
  # and produces an archived output of them all.
  outputs = [
    "$root_out_dir/breakpad_symbols/breakpad_symbols.tar.gz",
  ]

  depfile = "${outputs[0]}.d"

  args = [
           "-out-dir",
           rebase_path("$root_out_dir/breakpad_symbols"),
           "-dump-syms-path",
           rebase_path("//buildtools/${host_platform}/dump_syms/dump_syms"),
           "-depfile",
           rebase_path(depfile, root_build_dir),
           "-tar-file",
           rebase_path(outputs[0], root_build_dir),
         ] + rebase_path(sources, root_build_dir)
}

# Generates an archive of package metadata.
amber_files = rebase_path("$root_build_dir/amber-files")
host_out_dir = get_label_info("//anything($host_toolchain)", "root_out_dir")
pm_tool = rebase_path("$host_out_dir/pm")
pkg_archive_contents = [
  "amber-files/repository=$amber_files/repository",

  # TODO(IN-915): this should never contain the root key. In the future, this
  # should contain no keys, once infra is managing key material itself.
  # These keys are consumed by the infra train promote scripts.
  "amber-files/keys=$amber_files/keys",
  "pm=$pm_tool",
]
pkg_archive_manifest = "$target_gen_dir/package_archive_manifest"
write_file(pkg_archive_manifest, pkg_archive_contents)

pkg_archive = "$root_build_dir/packages.tar.gz"
compiled_action("package_archive") {
  testonly = true
  tool = "//build/tools/tar_maker"
  inputs = [
    pkg_archive_manifest,
  ]
  outputs = [
    pkg_archive,
  ]
  args = [
    "-manifest",
    rebase_path(pkg_archive_manifest),
    "-output",
    rebase_path(pkg_archive),
  ]
  deps = [
    "//build/images:updates",
  ]
}

# Generates a JSON manifest of the platforms available for testing, along with
# their properties.
target_platforms = []
foreach(platform, test_platforms) {
  if (!defined(platform.cpu) || platform.cpu == current_cpu) {
    target_platforms += [ platform ]
  }
}
write_file("$root_build_dir/platforms.json", target_platforms, "json")

// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// Code generated by tools/fidl/gidl-conformance-suite/regen.sh; DO NOT EDIT.

#include <lib/fidl/cpp/test/test_util.h>

#include <conformance/cpp/fidl.h>
#include <gtest/gtest.h>

TEST(Conformance, 3ByteObjectAlignmentInStruct_Encode) {
  conformance::ThreeByteInStruct v1;

  conformance::ThreeByte v2;

  uint8_t v3 = 1ull;
  v2.elem1 = std::move(v3);

  uint8_t v4 = 2ull;
  v2.elem2 = std::move(v4);

  uint8_t v5 = 3ull;
  v2.elem3 = std::move(v5);
  v1.elem1 = std::move(v2);

  conformance::ThreeByte v6;

  uint8_t v7 = 4ull;
  v6.elem1 = std::move(v7);

  uint8_t v8 = 5ull;
  v6.elem2 = std::move(v8);

  uint8_t v9 = 6ull;
  v6.elem3 = std::move(v9);
  v1.elem2 = std::move(v6);

  conformance::ThreeByte v10;

  uint8_t v11 = 7ull;
  v10.elem1 = std::move(v11);

  uint8_t v12 = 8ull;
  v10.elem2 = std::move(v12);

  uint8_t v13 = 9ull;
  v10.elem3 = std::move(v13);
  v1.elem3 = std::move(v10);

  auto expected = std::vector<uint8_t>{
      0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
      0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, 5ByteObjectAlignmentInStruct_Encode) {
  conformance::FiveByteInStruct v1;

  conformance::FiveByte v2;

  uint32_t v3 = 16909060ull;
  v2.elem1 = std::move(v3);

  uint8_t v4 = 5ull;
  v2.elem2 = std::move(v4);
  v1.elem1 = std::move(v2);

  conformance::FiveByte v5;

  uint32_t v6 = 101124105ull;
  v5.elem1 = std::move(v6);

  uint8_t v7 = 10ull;
  v5.elem2 = std::move(v7);
  v1.elem2 = std::move(v5);

  conformance::FiveByte v8;

  uint32_t v9 = 185339150ull;
  v8.elem1 = std::move(v9);

  uint8_t v10 = 15ull;
  v8.elem2 = std::move(v10);
  v1.elem3 = std::move(v8);

  auto expected = std::vector<uint8_t>{
      0x04, 0x03, 0x02, 0x01, 0x05, 0x00, 0x00, 0x00, 0x09, 0x08, 0x07, 0x06,
      0x0a, 0x00, 0x00, 0x00, 0x0e, 0x0d, 0x0c, 0x0b, 0x0f, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, 3ByteObjectAlignmentInVector_Encode) {
  conformance::ThreeByteInVector v1;

  conformance::ThreeByte v2;

  uint8_t v3 = 1ull;
  v2.elem1 = std::move(v3);

  uint8_t v4 = 2ull;
  v2.elem2 = std::move(v4);

  uint8_t v5 = 3ull;
  v2.elem3 = std::move(v5);
  conformance::ThreeByte v6;

  uint8_t v7 = 4ull;
  v6.elem1 = std::move(v7);

  uint8_t v8 = 5ull;
  v6.elem2 = std::move(v8);

  uint8_t v9 = 6ull;
  v6.elem3 = std::move(v9);
  conformance::ThreeByte v10;

  uint8_t v11 = 7ull;
  v10.elem1 = std::move(v11);

  uint8_t v12 = 8ull;
  v10.elem2 = std::move(v12);

  uint8_t v13 = 9ull;
  v10.elem3 = std::move(v13);
  std::vector<conformance::ThreeByte> v14;
  v14.push_back(std::move(v2));
  v14.push_back(std::move(v6));
  v14.push_back(std::move(v10));
  v1.elems = std::move(v14);

  auto expected = std::vector<uint8_t>{
      0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
      0x07, 0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, 5ByteObjectAlignmentInVector_Encode) {
  conformance::FiveByteInVector v1;

  conformance::FiveByte v2;

  uint32_t v3 = 16909060ull;
  v2.elem1 = std::move(v3);

  uint8_t v4 = 5ull;
  v2.elem2 = std::move(v4);
  conformance::FiveByte v5;

  uint32_t v6 = 101124105ull;
  v5.elem1 = std::move(v6);

  uint8_t v7 = 10ull;
  v5.elem2 = std::move(v7);
  conformance::FiveByte v8;

  uint32_t v9 = 185339150ull;
  v8.elem1 = std::move(v9);

  uint8_t v10 = 15ull;
  v8.elem2 = std::move(v10);
  std::vector<conformance::FiveByte> v11;
  v11.push_back(std::move(v2));
  v11.push_back(std::move(v5));
  v11.push_back(std::move(v8));
  v1.elems = std::move(v11);

  auto expected = std::vector<uint8_t>{
      0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x04, 0x03, 0x02, 0x01, 0x05, 0x00, 0x00, 0x00, 0x09, 0x08, 0x07, 0x06,
      0x0a, 0x00, 0x00, 0x00, 0x0e, 0x0d, 0x0c, 0x0b, 0x0f, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, 3ByteObjectAlignmentInArray_Encode) {
  conformance::ThreeByteInArray v1;

  conformance::ThreeByte v2;

  uint8_t v3 = 1ull;
  v2.elem1 = std::move(v3);

  uint8_t v4 = 2ull;
  v2.elem2 = std::move(v4);

  uint8_t v5 = 3ull;
  v2.elem3 = std::move(v5);
  conformance::ThreeByte v6;

  uint8_t v7 = 4ull;
  v6.elem1 = std::move(v7);

  uint8_t v8 = 5ull;
  v6.elem2 = std::move(v8);

  uint8_t v9 = 6ull;
  v6.elem3 = std::move(v9);
  conformance::ThreeByte v10;

  uint8_t v11 = 7ull;
  v10.elem1 = std::move(v11);

  uint8_t v12 = 8ull;
  v10.elem2 = std::move(v12);

  uint8_t v13 = 9ull;
  v10.elem3 = std::move(v13);
  auto v14 = std::array<conformance::ThreeByte, 3>{std::move(v2), std::move(v6), std::move(v10)};
  v1.elems = std::move(v14);

  auto expected = std::vector<uint8_t>{
      0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
      0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, 5ByteObjectAlignmentInArray_Encode) {
  conformance::FiveByteInArray v1;

  conformance::FiveByte v2;

  uint32_t v3 = 16909060ull;
  v2.elem1 = std::move(v3);

  uint8_t v4 = 5ull;
  v2.elem2 = std::move(v4);
  conformance::FiveByte v5;

  uint32_t v6 = 101124105ull;
  v5.elem1 = std::move(v6);

  uint8_t v7 = 10ull;
  v5.elem2 = std::move(v7);
  conformance::FiveByte v8;

  uint32_t v9 = 185339150ull;
  v8.elem1 = std::move(v9);

  uint8_t v10 = 15ull;
  v8.elem2 = std::move(v10);
  auto v11 = std::array<conformance::FiveByte, 3>{std::move(v2), std::move(v5), std::move(v8)};
  v1.elems = std::move(v11);

  auto expected = std::vector<uint8_t>{
      0x04, 0x03, 0x02, 0x01, 0x05, 0x00, 0x00, 0x00, 0x09, 0x08, 0x07, 0x06,
      0x0a, 0x00, 0x00, 0x00, 0x0e, 0x0d, 0x0c, 0x0b, 0x0f, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, EmptyStruct_Encode) {
  conformance::EmptyStruct v1;

  auto expected = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, EmptyStructSandwich_Encode) {
  conformance::EmptyStructSandwich v1;

  std::string v2("before");
  v1.before = std::move(v2);

  conformance::EmptyStruct v3;
  v1.es = std::move(v3);

  std::string v4("after");
  v1.after = std::move(v4);

  auto expected = std::vector<uint8_t>{
      0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x65,
      0x66, 0x6f, 0x72, 0x65, 0x00, 0x00, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Uint8Uint16Uint32Uint64_Encode) {
  conformance::Uint8Uint16Uint32Uint64 v1;

  uint8_t v2 = 1ull;
  v1.f1 = std::move(v2);

  uint16_t v3 = 515ull;
  v1.f2 = std::move(v3);

  uint32_t v4 = 67438087ull;
  v1.f3 = std::move(v4);

  uint64_t v5 = 579005069656919567ull;
  v1.f4 = std::move(v5);

  auto expected = std::vector<uint8_t>{
      0x01, 0x00, 0x03, 0x02, 0x07, 0x06, 0x05, 0x04,
      0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a, 0x09, 0x08,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Uint64Uint32Uint16Uint8_Encode) {
  conformance::Uint64Uint32Uint16Uint8 v1;

  uint64_t v2 = 579005069656919567ull;
  v1.f1 = std::move(v2);

  uint32_t v3 = 67438087ull;
  v1.f2 = std::move(v3);

  uint16_t v4 = 515ull;
  v1.f3 = std::move(v4);

  uint8_t v5 = 1ull;
  v1.f4 = std::move(v5);

  auto expected = std::vector<uint8_t>{
      0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a, 0x09, 0x08,
      0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, SimpleTableEmpty_Encode) {
  conformance::StructOfSimpleTable v1;

  conformance::SimpleTable v2;
  v1.table = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, SimpleTableXAndY_Encode) {
  conformance::StructOfSimpleTable v1;

  conformance::SimpleTable v2;

  int64_t v3 = 42ull;
  v2.set_x(std::move(v3));

  int64_t v4 = 67ull;
  v2.set_y(std::move(v4));
  v1.table = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2a, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, SimpleTableJustY_Encode) {
  conformance::StructOfSimpleTable v1;

  conformance::SimpleTable v2;

  int64_t v3 = 67ull;
  v2.set_y(std::move(v3));
  v1.table = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, TableWithStringAndVectorNoVectorContent_Encode) {
  conformance::StructOfTableWithStringAndVector v1;

  conformance::TableWithStringAndVector v2;

  std::string v3("hello");
  v2.set_foo(std::move(v3));

  int32_t v4 = 27ull;
  v2.set_bar(std::move(v4));
  v1.table = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x00,
      0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, SimpleTableThenUint64_Encode) {
  conformance::SimpleTableThenUint64 v1;

  conformance::SimpleTable v2;

  int64_t v3 = 42ull;
  v2.set_x(std::move(v3));

  int64_t v4 = 67ull;
  v2.set_y(std::move(v4));
  v1.table = std::move(v2);

  uint64_t v5 = 16045690984833335023ull;
  v1.number = std::move(v5);

  auto expected = std::vector<uint8_t>{
      0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xef, 0xbe, 0xad, 0xde, 0xef, 0xbe, 0xad, 0xde, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2a,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, InlineXUnionInStruct_Encode) {
  conformance::TestInlineXUnionInStruct v1;

  std::string v2("before");
  v1.before = std::move(v2);

  conformance::SampleXUnion v3;

  uint32_t v4 = 3735928559ull;
  v3.set_u(std::move(v4));
  v1.xu = std::move(v3);

  std::string v5("after");
  v1.after = std::move(v5);

  auto expected = std::vector<uint8_t>{
      0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xb2, 0x56, 0x9c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x00, 0x00, 0xef, 0xbe, 0xad, 0xde, 0x00, 0x00,
      0x00, 0x00, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, OptionalXUnionInStructAbsent_Encode) {
  conformance::TestOptionalXUnionInStruct v1;

  std::string v2("before");
  v1.before = std::move(v2);

  std::string v3("after");
  v1.after = std::move(v3);

  auto expected = std::vector<uint8_t>{
      0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x65, 0x66, 0x6f,
      0x72, 0x65, 0x00, 0x00, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, OptionalXUnionInStructPresent_Encode) {
  conformance::TestOptionalXUnionInStruct v1;

  std::string v2("before");
  v1.before = std::move(v2);

  std::unique_ptr<conformance::SampleXUnion> v3 = std::make_unique<conformance::SampleXUnion>();

  uint32_t v4 = 3735928559ull;
  v3->set_u(std::move(v4));
  v1.xu = std::move(v3);

  std::string v5("after");
  v1.after = std::move(v5);

  auto expected = std::vector<uint8_t>{
      0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xb2, 0x56, 0x9c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x00, 0x00, 0xef, 0xbe, 0xad, 0xde, 0x00, 0x00,
      0x00, 0x00, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, XUnionInTableXUnionAbsent_Encode) {
  conformance::TestXUnionInTable v1;

  conformance::XUnionInTable v2;

  std::string v3("before");
  v2.set_before(std::move(v3));

  std::string v4("after");
  v2.set_after(std::move(v4));
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x65, 0x66, 0x6f,
      0x72, 0x65, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, XUnionInTableXUnionPresent_Encode) {
  conformance::TestXUnionInTable v1;

  conformance::XUnionInTable v2;

  std::string v3("before");
  v2.set_before(std::move(v3));

  conformance::SampleXUnion v4;

  uint32_t v5 = 3735928559ull;
  v4.set_u(std::move(v5));
  v2.set_xu(std::move(v4));

  std::string v6("after");
  v2.set_after(std::move(v6));
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x00, 0x00, 0xb2, 0x56,
      0x9c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xbe, 0xad, 0xde, 0x00, 0x00, 0x00, 0x00,
      0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, StrictXUnion_Encode) {
  conformance::TestStrictXUnionInStruct v1;

  conformance::SampleStrictXUnion v2;

  uint32_t v3 = 3735928559ull;
  v2.set_u(std::move(v3));
  v1.xu = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x72, 0xea, 0xe2, 0x08, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xef, 0xbe, 0xad, 0xde, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, AddEthernetDeviceRequest_Encode) {
  conformance::TestAddEthernetDeviceRequest v1;

  std::string v2("@/dev/sys/pci/00:03.0/e1000/ethernet");
  v1.topological_path = std::move(v2);

  conformance::InterfaceConfig v3;

  std::string v4("ethp0003");
  v3.name = std::move(v4);

  conformance::IpAddressConfig v5;

  bool v6 = true;
  v5.set_dhcp(std::move(v6));
  v3.ip_address_config = std::move(v5);
  v1.config = std::move(v3);

  uint32_t v7 = 4294967295ull;
  v1.this_should_be_a_handle = std::move(v7);

  auto expected = std::vector<uint8_t>{
      0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x40, 0x2f, 0x64,
      0x65, 0x76, 0x2f, 0x73, 0x79, 0x73, 0x2f, 0x70, 0x63, 0x69, 0x2f, 0x30, 0x30, 0x3a, 0x30,
      0x33, 0x2e, 0x30, 0x2f, 0x65, 0x31, 0x30, 0x30, 0x30, 0x2f, 0x65, 0x74, 0x68, 0x65, 0x72,
      0x6e, 0x65, 0x74, 0x00, 0x00, 0x00, 0x00, 0x65, 0x74, 0x68, 0x70, 0x30, 0x30, 0x30, 0x33,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, FileGetAttrResponse_Encode) {
  conformance::FileGetAttrResponse v1;

  int32_t v2 = 2125315759ull;
  v1.s = std::move(v2);

  conformance::NodeAttributes v3;

  uint32_t v4 = 2518909348ull;
  v3.mode = std::move(v4);

  uint64_t v5 = 1ull;
  v3.id = std::move(v5);

  uint64_t v6 = 231ull;
  v3.content_size = std::move(v6);

  uint64_t v7 = 231ull;
  v3.storage_size = std::move(v7);

  uint64_t v8 = 1ull;
  v3.link_count = std::move(v8);

  uint64_t v9 = 9833440827789222417ull;
  v3.creation_time = std::move(v9);

  uint64_t v10 = 72038755451251353ull;
  v3.modification_time = std::move(v10);
  v1.attributes = std::move(v3);

  auto expected = std::vector<uint8_t>{
      0xaf, 0xbe, 0xad, 0x7e, 0x00, 0x00, 0x00, 0x00, 0xa4, 0x81, 0x23, 0x96, 0x00,
      0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe7, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x22, 0x33, 0x44,
      0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Optionals_Encode) {
  conformance::StructWithOptionals v1;

  conformance::EmptyStruct v2;
  v1.s = std::move(v2);

  std::unique_ptr<conformance::EmptyStruct> v3 = std::make_unique<conformance::EmptyStruct>();
  v1.s2 = std::move(v3);

  conformance::TableWithEmptyStruct v4;

  conformance::EmptyStruct v5;
  v4.set_s(std::move(v5));
  v1.t = std::move(v4);

  conformance::XUnionWithEmptyStruct v6;

  conformance::EmptyStruct v7;
  v6.set_s(std::move(v7));
  v1.xu = std::move(v6);

  std::unique_ptr<conformance::XUnionWithEmptyStruct> v8 =
      std::make_unique<conformance::XUnionWithEmptyStruct>();

  conformance::EmptyStruct v9;
  v8->set_s(std::move(v9));
  v1.xu2 = std::move(v8);

  conformance::UnionWithEmptyStruct v10;

  conformance::EmptyStruct v11;
  v10.set_s(std::move(v11));
  v1.u = std::move(v10);

  std::unique_ptr<conformance::UnionWithEmptyStruct> v12 =
      std::make_unique<conformance::UnionWithEmptyStruct>();

  conformance::EmptyStruct v13;
  v12->set_s(std::move(v13));
  v1.u2 = std::move(v12);

  auto expected = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xfe, 0xe0, 0x99, 0x74, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xfe, 0xe0, 0x99, 0x74, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Arrays_Encode) {
  conformance::StructWithArrays v1;

  int32_t v2 = 1ull;
  int32_t v3 = 2ull;
  auto v4 = std::array<int32_t, 2>{std::move(v2), std::move(v3)};
  v1.arr_int = std::move(v4);

  std::string v5("a");
  std::string v6("b");
  auto v7 = std::array<std::string, 2>{std::move(v5), std::move(v6)};
  v1.arr_string = std::move(v7);

  ::fidl::StringPtr v8("c");
  ::fidl::StringPtr v9;
  auto v10 = std::array<::fidl::StringPtr, 2>{std::move(v8), std::move(v9)};
  v1.arr_nullable_string = std::move(v10);

  conformance::StructWithInt v11;

  int32_t v12 = 1ull;
  v11.x = std::move(v12);
  conformance::StructWithInt v13;

  int32_t v14 = 2ull;
  v13.x = std::move(v14);
  auto v15 = std::array<conformance::StructWithInt, 2>{std::move(v11), std::move(v13)};
  v1.arr_struct = std::move(v15);

  std::unique_ptr<conformance::StructWithInt> v16;
  std::unique_ptr<conformance::StructWithInt> v17 = std::make_unique<conformance::StructWithInt>();

  int32_t v18 = 16909060ull;
  v17->x = std::move(v18);
  auto v19 =
      std::array<std::unique_ptr<conformance::StructWithInt>, 2>{std::move(v16), std::move(v17)};
  v1.arr_nullable_struct = std::move(v19);

  int32_t v20 = 1ull;
  int32_t v21 = 2ull;
  int32_t v22 = 3ull;
  auto v23 = std::array<int32_t, 3>{std::move(v20), std::move(v21), std::move(v22)};
  int32_t v24 = 4ull;
  int32_t v25 = 5ull;
  int32_t v26 = 6ull;
  auto v27 = std::array<int32_t, 3>{std::move(v24), std::move(v25), std::move(v26)};
  auto v28 = std::array<std::array<int32_t, 3>, 2>{std::move(v23), std::move(v27)};
  v1.arr_arr_int = std::move(v28);

  auto expected = std::vector<uint8_t>{
      0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00,
      0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x05, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x04, 0x03, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Vectors_Encode) {
  conformance::StructWithVectors v1;

  std::vector<int32_t> v2;
  v1.vec_empty = std::move(v2);

  int32_t v3 = 1ull;
  int32_t v4 = 2ull;
  std::vector<int32_t> v5;
  v5.push_back(std::move(v3));
  v5.push_back(std::move(v4));
  v1.vec_int = std::move(v5);

  std::string v6("a");
  std::string v7("b");
  std::vector<std::string> v8;
  v8.push_back(std::move(v6));
  v8.push_back(std::move(v7));
  v1.vec_string = std::move(v8);

  ::fidl::StringPtr v9;
  ::fidl::StringPtr v10("c");
  ::fidl::StringPtr v11;
  std::vector<::fidl::StringPtr> v12;
  v12.push_back(std::move(v9));
  v12.push_back(std::move(v10));
  v12.push_back(std::move(v11));
  v1.vec_nullable_string = std::move(v12);

  conformance::StructWithInt v13;

  int32_t v14 = 1ull;
  v13.x = std::move(v14);
  std::vector<conformance::StructWithInt> v15;
  v15.push_back(std::move(v13));
  v1.vec_struct = std::move(v15);

  std::unique_ptr<conformance::StructWithInt> v16;
  std::unique_ptr<conformance::StructWithInt> v17;
  std::unique_ptr<conformance::StructWithInt> v18 = std::make_unique<conformance::StructWithInt>();

  int32_t v19 = 2ull;
  v18->x = std::move(v19);
  std::vector<std::unique_ptr<conformance::StructWithInt>> v20;
  v20.push_back(std::move(v16));
  v20.push_back(std::move(v17));
  v20.push_back(std::move(v18));
  v1.vec_nullable_struct = std::move(v20);

  int32_t v21 = 1ull;
  int32_t v22 = 2ull;
  std::vector<int32_t> v23;
  v23.push_back(std::move(v21));
  v23.push_back(std::move(v22));
  int32_t v24 = 3ull;
  std::vector<int32_t> v25;
  v25.push_back(std::move(v24));
  std::vector<std::vector<int32_t>> v26;
  v26.push_back(std::move(v23));
  v26.push_back(std::move(v25));
  v1.vec_vec_int = std::move(v26);

  auto expected = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00,
      0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, BoolTrue_Encode) {
  conformance::MyBool v1;

  bool v2 = true;
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, BoolFalse_Encode) {
  conformance::MyBool v1;

  bool v2 = false;
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, ByteZero_Encode) {
  conformance::MyByte v1;

  uint8_t v2 = 0ull;
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Byte255_Encode) {
  conformance::MyByte v1;

  uint8_t v2 = 255ull;
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Int8Min_Encode) {
  conformance::MyInt8 v1;

  int8_t v2 = -128ll;
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Int8Zero_Encode) {
  conformance::MyInt8 v1;

  int8_t v2 = 0ull;
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Int8Max_Encode) {
  conformance::MyInt8 v1;

  int8_t v2 = 127ull;
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Int16Min_Encode) {
  conformance::MyInt16 v1;

  int16_t v2 = -32768ll;
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Int16Zero_Encode) {
  conformance::MyInt16 v1;

  int16_t v2 = 0ull;
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Int16Max_Encode) {
  conformance::MyInt16 v1;

  int16_t v2 = 32767ull;
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Int32Min_Encode) {
  conformance::MyInt32 v1;

  int32_t v2 = -2147483648ll;
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Int32Zero_Encode) {
  conformance::MyInt32 v1;

  int32_t v2 = 0ull;
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Int32Max_Encode) {
  conformance::MyInt32 v1;

  int32_t v2 = 2147483647ull;
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0xff, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Int64Min_Encode) {
  conformance::MyInt64 v1;

  int64_t v2 = -9223372036854775807ll - 1;
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Int64Zero_Encode) {
  conformance::MyInt64 v1;

  int64_t v2 = 0ull;
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Int64Max_Encode) {
  conformance::MyInt64 v1;

  int64_t v2 = 9223372036854775807ull;
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Uint8Zero_Encode) {
  conformance::MyUint8 v1;

  uint8_t v2 = 0ull;
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Uint8Max_Encode) {
  conformance::MyUint8 v1;

  uint8_t v2 = 255ull;
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Uint16Zero_Encode) {
  conformance::MyUint16 v1;

  uint16_t v2 = 0ull;
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Uint16Max_Encode) {
  conformance::MyUint16 v1;

  uint16_t v2 = 65535ull;
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Uint32Zero_Encode) {
  conformance::MyUint32 v1;

  uint32_t v2 = 0ull;
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Uint32Max_Encode) {
  conformance::MyUint32 v1;

  uint32_t v2 = 4294967295ull;
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Uint64Zero_Encode) {
  conformance::MyUint64 v1;

  uint64_t v2 = 0ull;
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Uint64Max_Encode) {
  conformance::MyUint64 v1;

  uint64_t v2 = 18446744073709551615ull;
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Float32Zero_Encode) {
  conformance::MyFloat32 v1;

  float v2 = 0;
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Float32One_Encode) {
  conformance::MyFloat32 v1;

  float v2 = 1;
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Float32MinusOne_Encode) {
  conformance::MyFloat32 v1;

  float v2 = -1;
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x00, 0x00, 0x80, 0xbf, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Float32Max_Encode) {
  conformance::MyFloat32 v1;

  float v2 = 3.4028234663852886e+38;
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0xff, 0xff, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Float64Zero_Encode) {
  conformance::MyFloat64 v1;

  double v2 = 0;
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Float64One_Encode) {
  conformance::MyFloat64 v1;

  double v2 = 1;
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Float64MinusOne_Encode) {
  conformance::MyFloat64 v1;

  double v2 = -1;
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xbf,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Float64Max_Encode) {
  conformance::MyFloat64 v1;

  double v2 = 1.7976931348623157e+308;
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0x7f,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, UnionWithBoundString_Encode) {
  conformance::UnionWithBoundStringStruct v1;

  conformance::UnionWithBoundString v2;

  std::string v3("abcd");
  v2.set_boundFiveStr(std::move(v3));
  v1.v = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x61, 0x62, 0x63, 0x64, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, 3ByteObjectAlignmentInStruct_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
      0x07, 0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::ThreeByteInStruct v1;

  conformance::ThreeByte v2;

  uint8_t v3 = 1ull;
  v2.elem1 = std::move(v3);

  uint8_t v4 = 2ull;
  v2.elem2 = std::move(v4);

  uint8_t v5 = 3ull;
  v2.elem3 = std::move(v5);
  v1.elem1 = std::move(v2);

  conformance::ThreeByte v6;

  uint8_t v7 = 4ull;
  v6.elem1 = std::move(v7);

  uint8_t v8 = 5ull;
  v6.elem2 = std::move(v8);

  uint8_t v9 = 6ull;
  v6.elem3 = std::move(v9);
  v1.elem2 = std::move(v6);

  conformance::ThreeByte v10;

  uint8_t v11 = 7ull;
  v10.elem1 = std::move(v11);

  uint8_t v12 = 8ull;
  v10.elem2 = std::move(v12);

  uint8_t v13 = 9ull;
  v10.elem3 = std::move(v13);
  v1.elem3 = std::move(v10);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, 5ByteObjectAlignmentInStruct_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x04, 0x03, 0x02, 0x01, 0x05, 0x00, 0x00, 0x00, 0x09, 0x08, 0x07, 0x06,
      0x0a, 0x00, 0x00, 0x00, 0x0e, 0x0d, 0x0c, 0x0b, 0x0f, 0x00, 0x00, 0x00,

  };

  conformance::FiveByteInStruct v1;

  conformance::FiveByte v2;

  uint32_t v3 = 16909060ull;
  v2.elem1 = std::move(v3);

  uint8_t v4 = 5ull;
  v2.elem2 = std::move(v4);
  v1.elem1 = std::move(v2);

  conformance::FiveByte v5;

  uint32_t v6 = 101124105ull;
  v5.elem1 = std::move(v6);

  uint8_t v7 = 10ull;
  v5.elem2 = std::move(v7);
  v1.elem2 = std::move(v5);

  conformance::FiveByte v8;

  uint32_t v9 = 185339150ull;
  v8.elem1 = std::move(v9);

  uint8_t v10 = 15ull;
  v8.elem2 = std::move(v10);
  v1.elem3 = std::move(v8);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, 3ByteObjectAlignmentInVector_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x02, 0x03, 0x04,
      0x05, 0x06, 0x07, 0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::ThreeByteInVector v1;

  conformance::ThreeByte v2;

  uint8_t v3 = 1ull;
  v2.elem1 = std::move(v3);

  uint8_t v4 = 2ull;
  v2.elem2 = std::move(v4);

  uint8_t v5 = 3ull;
  v2.elem3 = std::move(v5);
  conformance::ThreeByte v6;

  uint8_t v7 = 4ull;
  v6.elem1 = std::move(v7);

  uint8_t v8 = 5ull;
  v6.elem2 = std::move(v8);

  uint8_t v9 = 6ull;
  v6.elem3 = std::move(v9);
  conformance::ThreeByte v10;

  uint8_t v11 = 7ull;
  v10.elem1 = std::move(v11);

  uint8_t v12 = 8ull;
  v10.elem2 = std::move(v12);

  uint8_t v13 = 9ull;
  v10.elem3 = std::move(v13);
  std::vector<conformance::ThreeByte> v14;
  v14.push_back(std::move(v2));
  v14.push_back(std::move(v6));
  v14.push_back(std::move(v10));
  v1.elems = std::move(v14);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, 5ByteObjectAlignmentInVector_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0x04, 0x03, 0x02, 0x01, 0x05, 0x00, 0x00, 0x00, 0x09, 0x08,
      0x07, 0x06, 0x0a, 0x00, 0x00, 0x00, 0x0e, 0x0d, 0x0c, 0x0b, 0x0f, 0x00, 0x00, 0x00,

  };

  conformance::FiveByteInVector v1;

  conformance::FiveByte v2;

  uint32_t v3 = 16909060ull;
  v2.elem1 = std::move(v3);

  uint8_t v4 = 5ull;
  v2.elem2 = std::move(v4);
  conformance::FiveByte v5;

  uint32_t v6 = 101124105ull;
  v5.elem1 = std::move(v6);

  uint8_t v7 = 10ull;
  v5.elem2 = std::move(v7);
  conformance::FiveByte v8;

  uint32_t v9 = 185339150ull;
  v8.elem1 = std::move(v9);

  uint8_t v10 = 15ull;
  v8.elem2 = std::move(v10);
  std::vector<conformance::FiveByte> v11;
  v11.push_back(std::move(v2));
  v11.push_back(std::move(v5));
  v11.push_back(std::move(v8));
  v1.elems = std::move(v11);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, 3ByteObjectAlignmentInArray_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
      0x07, 0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::ThreeByteInArray v1;

  conformance::ThreeByte v2;

  uint8_t v3 = 1ull;
  v2.elem1 = std::move(v3);

  uint8_t v4 = 2ull;
  v2.elem2 = std::move(v4);

  uint8_t v5 = 3ull;
  v2.elem3 = std::move(v5);
  conformance::ThreeByte v6;

  uint8_t v7 = 4ull;
  v6.elem1 = std::move(v7);

  uint8_t v8 = 5ull;
  v6.elem2 = std::move(v8);

  uint8_t v9 = 6ull;
  v6.elem3 = std::move(v9);
  conformance::ThreeByte v10;

  uint8_t v11 = 7ull;
  v10.elem1 = std::move(v11);

  uint8_t v12 = 8ull;
  v10.elem2 = std::move(v12);

  uint8_t v13 = 9ull;
  v10.elem3 = std::move(v13);
  auto v14 = std::array<conformance::ThreeByte, 3>{std::move(v2), std::move(v6), std::move(v10)};
  v1.elems = std::move(v14);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, 5ByteObjectAlignmentInArray_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x04, 0x03, 0x02, 0x01, 0x05, 0x00, 0x00, 0x00, 0x09, 0x08, 0x07, 0x06,
      0x0a, 0x00, 0x00, 0x00, 0x0e, 0x0d, 0x0c, 0x0b, 0x0f, 0x00, 0x00, 0x00,

  };

  conformance::FiveByteInArray v1;

  conformance::FiveByte v2;

  uint32_t v3 = 16909060ull;
  v2.elem1 = std::move(v3);

  uint8_t v4 = 5ull;
  v2.elem2 = std::move(v4);
  conformance::FiveByte v5;

  uint32_t v6 = 101124105ull;
  v5.elem1 = std::move(v6);

  uint8_t v7 = 10ull;
  v5.elem2 = std::move(v7);
  conformance::FiveByte v8;

  uint32_t v9 = 185339150ull;
  v8.elem1 = std::move(v9);

  uint8_t v10 = 15ull;
  v8.elem2 = std::move(v10);
  auto v11 = std::array<conformance::FiveByte, 3>{std::move(v2), std::move(v5), std::move(v8)};
  v1.elems = std::move(v11);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, EmptyStruct_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::EmptyStruct v1;

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, EmptyStructSandwich_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x65, 0x66, 0x6f,
      0x72, 0x65, 0x00, 0x00, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,

  };

  conformance::EmptyStructSandwich v1;

  std::string v2("before");
  v1.before = std::move(v2);

  conformance::EmptyStruct v3;
  v1.es = std::move(v3);

  std::string v4("after");
  v1.after = std::move(v4);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Uint8Uint16Uint32Uint64_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x02, 0x07, 0x06,
      0x05, 0x04, 0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a, 0x09, 0x08,

  };

  conformance::Uint8Uint16Uint32Uint64 v1;

  uint8_t v2 = 1ull;
  v1.f1 = std::move(v2);

  uint16_t v3 = 515ull;
  v1.f2 = std::move(v3);

  uint32_t v4 = 67438087ull;
  v1.f3 = std::move(v4);

  uint64_t v5 = 579005069656919567ull;
  v1.f4 = std::move(v5);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Uint64Uint32Uint16Uint8_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a,
      0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00,

  };

  conformance::Uint64Uint32Uint16Uint8 v1;

  uint64_t v2 = 579005069656919567ull;
  v1.f1 = std::move(v2);

  uint32_t v3 = 67438087ull;
  v1.f2 = std::move(v3);

  uint16_t v4 = 515ull;
  v1.f3 = std::move(v4);

  uint8_t v5 = 1ull;
  v1.f4 = std::move(v5);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, SimpleTableEmpty_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

  };

  conformance::StructOfSimpleTable v1;

  conformance::SimpleTable v2;
  v1.table = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, SimpleTableXAndY_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::StructOfSimpleTable v1;

  conformance::SimpleTable v2;

  int64_t v3 = 42ull;
  v2.set_x(std::move(v3));

  int64_t v4 = 67ull;
  v2.set_y(std::move(v4));
  v1.table = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, SimpleTableJustY_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::StructOfSimpleTable v1;

  conformance::SimpleTable v2;

  int64_t v3 = 67ull;
  v2.set_y(std::move(v3));
  v1.table = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, TableWithStringAndVectorNoVectorContent_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x68, 0x65, 0x6c, 0x6c,
      0x6f, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::StructOfTableWithStringAndVector v1;

  conformance::TableWithStringAndVector v2;

  std::string v3("hello");
  v2.set_foo(std::move(v3));

  int32_t v4 = 27ull;
  v2.set_bar(std::move(v4));
  v1.table = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, SimpleTableThenUint64_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xef, 0xbe, 0xad, 0xde, 0xef, 0xbe, 0xad, 0xde, 0x08, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::SimpleTableThenUint64 v1;

  conformance::SimpleTable v2;

  int64_t v3 = 42ull;
  v2.set_x(std::move(v3));

  int64_t v4 = 67ull;
  v2.set_y(std::move(v4));
  v1.table = std::move(v2);

  uint64_t v5 = 16045690984833335023ull;
  v1.number = std::move(v5);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, InlineXUnionInStruct_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xb2, 0x56, 0x9c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x00, 0x00, 0xef, 0xbe, 0xad, 0xde,
      0x00, 0x00, 0x00, 0x00, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,

  };

  conformance::TestInlineXUnionInStruct v1;

  std::string v2("before");
  v1.before = std::move(v2);

  conformance::SampleXUnion v3;

  uint32_t v4 = 3735928559ull;
  v3.set_u(std::move(v4));
  v1.xu = std::move(v3);

  std::string v5("after");
  v1.after = std::move(v5);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, OptionalXUnionInStructAbsent_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x65, 0x66,
      0x6f, 0x72, 0x65, 0x00, 0x00, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,

  };

  conformance::TestOptionalXUnionInStruct v1;

  std::string v2("before");
  v1.before = std::move(v2);

  std::string v3("after");
  v1.after = std::move(v3);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, OptionalXUnionInStructPresent_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xb2, 0x56, 0x9c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x00, 0x00, 0xef, 0xbe, 0xad, 0xde,
      0x00, 0x00, 0x00, 0x00, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,

  };

  conformance::TestOptionalXUnionInStruct v1;

  std::string v2("before");
  v1.before = std::move(v2);

  std::unique_ptr<conformance::SampleXUnion> v3 = std::make_unique<conformance::SampleXUnion>();

  uint32_t v4 = 3735928559ull;
  v3->set_u(std::move(v4));
  v1.xu = std::move(v3);

  std::string v5("after");
  v1.after = std::move(v5);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, XUnionInTableXUnionAbsent_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x00, 0x00, 0x05,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,

  };

  conformance::TestXUnionInTable v1;

  conformance::XUnionInTable v2;

  std::string v3("before");
  v2.set_before(std::move(v3));

  std::string v4("after");
  v2.set_after(std::move(v4));
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, XUnionInTableXUnionPresent_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x00, 0x00, 0xb2,
      0x56, 0x9c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xbe, 0xad, 0xde, 0x00, 0x00, 0x00,
      0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,

  };

  conformance::TestXUnionInTable v1;

  conformance::XUnionInTable v2;

  std::string v3("before");
  v2.set_before(std::move(v3));

  conformance::SampleXUnion v4;

  uint32_t v5 = 3735928559ull;
  v4.set_u(std::move(v5));
  v2.set_xu(std::move(v4));

  std::string v6("after");
  v2.set_after(std::move(v6));
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, StrictXUnion_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x72, 0xea, 0xe2, 0x08, 0x00, 0x00, 0x00, 0x00,
      0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xef, 0xbe, 0xad, 0xde, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::TestStrictXUnionInStruct v1;

  conformance::SampleStrictXUnion v2;

  uint32_t v3 = 3735928559ull;
  v2.set_u(std::move(v3));
  v1.xu = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, AddEthernetDeviceRequest_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0x00, 0x00, 0x00, 0x00, 0x40, 0x2f, 0x64, 0x65, 0x76, 0x2f, 0x73, 0x79, 0x73, 0x2f,
      0x70, 0x63, 0x69, 0x2f, 0x30, 0x30, 0x3a, 0x30, 0x33, 0x2e, 0x30, 0x2f, 0x65, 0x31,
      0x30, 0x30, 0x30, 0x2f, 0x65, 0x74, 0x68, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x00, 0x00,
      0x00, 0x00, 0x65, 0x74, 0x68, 0x70, 0x30, 0x30, 0x30, 0x33,

  };

  conformance::TestAddEthernetDeviceRequest v1;

  std::string v2("@/dev/sys/pci/00:03.0/e1000/ethernet");
  v1.topological_path = std::move(v2);

  conformance::InterfaceConfig v3;

  std::string v4("ethp0003");
  v3.name = std::move(v4);

  conformance::IpAddressConfig v5;

  bool v6 = true;
  v5.set_dhcp(std::move(v6));
  v3.ip_address_config = std::move(v5);
  v1.config = std::move(v3);

  uint32_t v7 = 4294967295ull;
  v1.this_should_be_a_handle = std::move(v7);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, FileGetAttrResponse_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0xaf, 0xbe, 0xad, 0x7e, 0x00, 0x00, 0x00, 0x00, 0xa4, 0x81, 0x23, 0x96,
      0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe7, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66,
      0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00,

  };

  conformance::FileGetAttrResponse v1;

  int32_t v2 = 2125315759ull;
  v1.s = std::move(v2);

  conformance::NodeAttributes v3;

  uint32_t v4 = 2518909348ull;
  v3.mode = std::move(v4);

  uint64_t v5 = 1ull;
  v3.id = std::move(v5);

  uint64_t v6 = 231ull;
  v3.content_size = std::move(v6);

  uint64_t v7 = 231ull;
  v3.storage_size = std::move(v7);

  uint64_t v8 = 1ull;
  v3.link_count = std::move(v8);

  uint64_t v9 = 9833440827789222417ull;
  v3.creation_time = std::move(v9);

  uint64_t v10 = 72038755451251353ull;
  v3.modification_time = std::move(v10);
  v1.attributes = std::move(v3);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Optionals_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xfe, 0xe0, 0x99, 0x74, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xe0, 0x99,
      0x74, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00,

  };

  conformance::StructWithOptionals v1;

  conformance::EmptyStruct v2;
  v1.s = std::move(v2);

  std::unique_ptr<conformance::EmptyStruct> v3 = std::make_unique<conformance::EmptyStruct>();
  v1.s2 = std::move(v3);

  conformance::TableWithEmptyStruct v4;

  conformance::EmptyStruct v5;
  v4.set_s(std::move(v5));
  v1.t = std::move(v4);

  conformance::XUnionWithEmptyStruct v6;

  conformance::EmptyStruct v7;
  v6.set_s(std::move(v7));
  v1.xu = std::move(v6);

  std::unique_ptr<conformance::XUnionWithEmptyStruct> v8 =
      std::make_unique<conformance::XUnionWithEmptyStruct>();

  conformance::EmptyStruct v9;
  v8->set_s(std::move(v9));
  v1.xu2 = std::move(v8);

  conformance::UnionWithEmptyStruct v10;

  conformance::EmptyStruct v11;
  v10.set_s(std::move(v11));
  v1.u = std::move(v10);

  std::unique_ptr<conformance::UnionWithEmptyStruct> v12 =
      std::make_unique<conformance::UnionWithEmptyStruct>();

  conformance::EmptyStruct v13;
  v12->set_s(std::move(v13));
  v1.u2 = std::move(v12);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Arrays_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00,
      0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x61, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x03, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::StructWithArrays v1;

  int32_t v2 = 1ull;
  int32_t v3 = 2ull;
  auto v4 = std::array<int32_t, 2>{std::move(v2), std::move(v3)};
  v1.arr_int = std::move(v4);

  std::string v5("a");
  std::string v6("b");
  auto v7 = std::array<std::string, 2>{std::move(v5), std::move(v6)};
  v1.arr_string = std::move(v7);

  ::fidl::StringPtr v8("c");
  ::fidl::StringPtr v9;
  auto v10 = std::array<::fidl::StringPtr, 2>{std::move(v8), std::move(v9)};
  v1.arr_nullable_string = std::move(v10);

  conformance::StructWithInt v11;

  int32_t v12 = 1ull;
  v11.x = std::move(v12);
  conformance::StructWithInt v13;

  int32_t v14 = 2ull;
  v13.x = std::move(v14);
  auto v15 = std::array<conformance::StructWithInt, 2>{std::move(v11), std::move(v13)};
  v1.arr_struct = std::move(v15);

  std::unique_ptr<conformance::StructWithInt> v16;
  std::unique_ptr<conformance::StructWithInt> v17 = std::make_unique<conformance::StructWithInt>();

  int32_t v18 = 16909060ull;
  v17->x = std::move(v18);
  auto v19 =
      std::array<std::unique_ptr<conformance::StructWithInt>, 2>{std::move(v16), std::move(v17)};
  v1.arr_nullable_struct = std::move(v19);

  int32_t v20 = 1ull;
  int32_t v21 = 2ull;
  int32_t v22 = 3ull;
  auto v23 = std::array<int32_t, 3>{std::move(v20), std::move(v21), std::move(v22)};
  int32_t v24 = 4ull;
  int32_t v25 = 5ull;
  int32_t v26 = 6ull;
  auto v27 = std::array<int32_t, 3>{std::move(v24), std::move(v25), std::move(v26)};
  auto v28 = std::array<std::array<int32_t, 3>, 2>{std::move(v23), std::move(v27)};
  v1.arr_arr_int = std::move(v28);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Vectors_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00,
      0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::StructWithVectors v1;

  std::vector<int32_t> v2;
  v1.vec_empty = std::move(v2);

  int32_t v3 = 1ull;
  int32_t v4 = 2ull;
  std::vector<int32_t> v5;
  v5.push_back(std::move(v3));
  v5.push_back(std::move(v4));
  v1.vec_int = std::move(v5);

  std::string v6("a");
  std::string v7("b");
  std::vector<std::string> v8;
  v8.push_back(std::move(v6));
  v8.push_back(std::move(v7));
  v1.vec_string = std::move(v8);

  ::fidl::StringPtr v9;
  ::fidl::StringPtr v10("c");
  ::fidl::StringPtr v11;
  std::vector<::fidl::StringPtr> v12;
  v12.push_back(std::move(v9));
  v12.push_back(std::move(v10));
  v12.push_back(std::move(v11));
  v1.vec_nullable_string = std::move(v12);

  conformance::StructWithInt v13;

  int32_t v14 = 1ull;
  v13.x = std::move(v14);
  std::vector<conformance::StructWithInt> v15;
  v15.push_back(std::move(v13));
  v1.vec_struct = std::move(v15);

  std::unique_ptr<conformance::StructWithInt> v16;
  std::unique_ptr<conformance::StructWithInt> v17;
  std::unique_ptr<conformance::StructWithInt> v18 = std::make_unique<conformance::StructWithInt>();

  int32_t v19 = 2ull;
  v18->x = std::move(v19);
  std::vector<std::unique_ptr<conformance::StructWithInt>> v20;
  v20.push_back(std::move(v16));
  v20.push_back(std::move(v17));
  v20.push_back(std::move(v18));
  v1.vec_nullable_struct = std::move(v20);

  int32_t v21 = 1ull;
  int32_t v22 = 2ull;
  std::vector<int32_t> v23;
  v23.push_back(std::move(v21));
  v23.push_back(std::move(v22));
  int32_t v24 = 3ull;
  std::vector<int32_t> v25;
  v25.push_back(std::move(v24));
  std::vector<std::vector<int32_t>> v26;
  v26.push_back(std::move(v23));
  v26.push_back(std::move(v25));
  v1.vec_vec_int = std::move(v26);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, BoolTrue_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::MyBool v1;

  bool v2 = true;
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, BoolFalse_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::MyBool v1;

  bool v2 = false;
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, ByteZero_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::MyByte v1;

  uint8_t v2 = 0ull;
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Byte255_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::MyByte v1;

  uint8_t v2 = 255ull;
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Int8Min_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::MyInt8 v1;

  int8_t v2 = -128ll;
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Int8Zero_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::MyInt8 v1;

  int8_t v2 = 0ull;
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Int8Max_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::MyInt8 v1;

  int8_t v2 = 127ull;
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Int16Min_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::MyInt16 v1;

  int16_t v2 = -32768ll;
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Int16Zero_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::MyInt16 v1;

  int16_t v2 = 0ull;
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Int16Max_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::MyInt16 v1;

  int16_t v2 = 32767ull;
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Int32Min_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::MyInt32 v1;

  int32_t v2 = -2147483648ll;
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Int32Zero_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::MyInt32 v1;

  int32_t v2 = 0ull;
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Int32Max_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::MyInt32 v1;

  int32_t v2 = 2147483647ull;
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Int64Min_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,

  };

  conformance::MyInt64 v1;

  int64_t v2 = -9223372036854775807ll - 1;
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Int64Zero_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::MyInt64 v1;

  int64_t v2 = 0ull;
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Int64Max_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f,

  };

  conformance::MyInt64 v1;

  int64_t v2 = 9223372036854775807ull;
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Uint8Zero_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::MyUint8 v1;

  uint8_t v2 = 0ull;
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Uint8Max_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::MyUint8 v1;

  uint8_t v2 = 255ull;
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Uint16Zero_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::MyUint16 v1;

  uint16_t v2 = 0ull;
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Uint16Max_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::MyUint16 v1;

  uint16_t v2 = 65535ull;
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Uint32Zero_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::MyUint32 v1;

  uint32_t v2 = 0ull;
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Uint32Max_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::MyUint32 v1;

  uint32_t v2 = 4294967295ull;
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Uint64Zero_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::MyUint64 v1;

  uint64_t v2 = 0ull;
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Uint64Max_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

  };

  conformance::MyUint64 v1;

  uint64_t v2 = 18446744073709551615ull;
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Float32Zero_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::MyFloat32 v1;

  float v2 = 0;
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Float32One_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::MyFloat32 v1;

  float v2 = 1;
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Float32MinusOne_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xbf, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::MyFloat32 v1;

  float v2 = -1;
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Float32Max_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::MyFloat32 v1;

  float v2 = 3.4028234663852886e+38;
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Float64Zero_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::MyFloat64 v1;

  double v2 = 0;
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Float64One_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,

  };

  conformance::MyFloat64 v1;

  double v2 = 1;
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Float64MinusOne_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xbf,

  };

  conformance::MyFloat64 v1;

  double v2 = -1;
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Float64Max_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0x7f,

  };

  conformance::MyFloat64 v1;

  double v2 = 1.7976931348623157e+308;
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, UnionWithBoundString_Decode) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0x61, 0x62, 0x63, 0x64, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::UnionWithBoundStringStruct v1;

  conformance::UnionWithBoundString v2;

  std::string v3("abcd");
  v2.set_boundFiveStr(std::move(v3));
  v1.v = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, StringExceedsLimit_Encode_Failure) {
  conformance::Length2StringWrapper v1;

  std::string v2("abc");
  v1.length_2_string = std::move(v2);

  zx_status_t expected = ZX_ERR_INVALID_ARGS;

  ::fidl::test::util::CheckEncodeFailure(v1, expected);
}

TEST(Conformance, UnionWithBoundString_ExceedsBounds_Encode_Failure) {
  conformance::UnionWithBoundStringStruct v1;

  conformance::UnionWithBoundString v2;

  std::string v3("abcdef");
  v2.set_boundFiveStr(std::move(v3));
  v1.v = std::move(v2);

  zx_status_t expected = ZX_ERR_INVALID_ARGS;

  ::fidl::test::util::CheckEncodeFailure(v1, expected);
}

TEST(Conformance, NonEmptyStringWithNullPtrBody_Decode_Failure) {
  auto input = std::vector<uint8_t>{
      0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };
  zx_status_t expected = ZX_ERR_INVALID_ARGS;

  ::fidl::test::util::CheckDecodeFailure<conformance::StringWrapper>(input, expected);
}

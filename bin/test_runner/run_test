#!/usr/bin/python

# Copyright 2017 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import argparse
import csv
import hashlib
import json
import os
import os.path
import random
import re
import socket
import subprocess
import sys

from subprocess import call


class color:
  PURPLE = "\033[95m"
  CYAN = "\033[96m"
  DARKCYAN = "\033[36m"
  BLUE = "\033[94m"
  GREEN = "\033[92m"
  YELLOW = "\033[93m"
  RED = "\033[91m"
  BOLD = "\033[1m"
  UNDERLINE = "\033[4m"
  END = "\033[0m"


def error(text):
  print "%serror: %s%s" % (color.RED, text, color.END)


def is_ipv4_address(address):
  try:
    socket.inet_aton(address)
    return True
  except socket.error:
    return False


def magenta_ipv6_to_fuchsia(mac):
  parts = mac.split(":")

  # Magenta uses 4d:fe. Link local is ff:fe.
  parts[3] = parts[3][:2] + "ff"

  return ":".join(parts)


def read_log_listener(listener_process, test_id):
  """ Returns the output of loglistener up until it sees the |test_id|."""
  termination_substring = "test_runner: teardown %s" % test_id
  lines = []
  while True:
    line = listener_process.stdout.readline()
    if line == "" or line.find(termination_substring) != -1:
      return "".join(lines) + line
    lines.append(line)

  return "".join(lines)


def copy_files(fuchsia_tools_dir, hostname, copy_map):
  """ copy is a map of destination directories on the device to source
    files in $FUCHSIA_BUILD_DIR """
  if type(copy_map) is not dict:
    error("malformed \"copy\" map in JSON file")
    return False
  if hostname is None:
    error("cannot copy files to ipv4 addresses")
    return False

  for dirname, files in copy_map.iteritems():
    for filename in files:
      filepath = os.path.join(os.environ["FUCHSIA_BUILD_DIR"], filename)
      command_line = [
          fuchsia_tools_dir + "netcp", filepath,
          hostname + ":" + os.path.join(dirname, filename)
      ]
      print "Copying %s" % filename
      # netcp returns the error value from magenta
      if call(command_line) != 0:
        error("netcp failed to copy %s" % filename)
        return False
  return True


def run_test(sock, listener_process, command_str):
  """ Runs |command_str| on the remote test runner server, waits for the
    result, and prints the relevant device log snippet in the event of a
    failure. """
  test_id = hashlib.sha1(command_str + str(random.random())).hexdigest()
  status = 0

  sock.send("run %s %s\n" % (test_id, command_str))
  read_sock_file = sock.makefile()
  for line in read_sock_file:
    ret_test_id, op, msg = line.split(" ", 2)
    msg = msg.strip()
    assert ret_test_id == test_id, "Uhoh, wrong test result returned."

    if op == "teardown":
      result = ".. %s" % msg
      if msg == "fail":
        status = 1
        print "%s%s%s" % (color.RED, result, color.END)
      else:
        print "%s" % result
      # Consume the log output, whether or not we print it.
      log_output = read_log_listener(listener_process, test_id)
      if msg == "fail":
        print log_output
      return status
    elif op == "log":
      print msg
    else:
      error("UNRECOGNIZED STRING: %s" % line.strip())

  return status


def get_device_table(fuchsia_tools_dir):
  """ Get devices table from netls """
  netls_path = fuchsia_tools_dir + "netls"
  netls_process = subprocess.Popen([netls_path], stdout=subprocess.PIPE)
  (output, err) = netls_process.communicate()
  exit_code = netls_process.wait()
  names = ["Device Type", "Device Name", "IPV6 Address"]

  reader = csv.DictReader(
      output.splitlines(),
      fieldnames=names,
      skipinitialspace=True,
      delimiter=" ")

  return [device for device in reader if device["Device Type"] == "device"]


def translate_name_to_ipv6(fuchsia_tools_dir, devices, server):
  """ Given a node name or a colon, find the related ipv6 Magenta address """
  assert not is_ipv4_address(server), "Do not pass ipv4 to this routine"

  if len(devices) == 0:
    error("No devices were found on the local subnet.")
    return None

  if server == ":":
    if len(devices) > 1:
      error("multiple devices were found on the local subnet:\n%s" % devices)
      return None
    hostipv6 = devices[0]["IPV6 Address"]
  elif re.match("\w+-\w+-\w+", server):
    matches = [device for device in devices if device["Device Name"] == server]
    if len(matches) == 0:
      error("no device by the name %s" % server)
      print("Available devices:\n%s") % devices
      return None
    hostipv6 = matches[0]["IPV6 Address"]
  else:
    error("server name was not in a recognized format.\n%s" % devices)
    return None

  return hostipv6


def translate_ipv6_to_name(devices, ipv6):
  """ Given a Magenta ipv6 address, find the related node name """
  matches = [
      device for device in devices
      if normalize_ipv6(device["IPV6 Address"]) == ipv6
  ]
  if len(matches) == 0:
    error("no device with the address %s" % ipv6)
    print("Available devices:\n%s") % devices
    return None
  return matches[0]["Device Name"]


def normalize_ipv6(ipv6):
  """ Fixup variations in ipv6 syntax """
  if ipv6[0] == "(" or ipv6[0] == "[":
    ipv6 = ipv6[1:-1]
  ipv6 = ipv6.replace("/", "%")
  return ipv6


def get_ipv4_addrinfo(fuchsia_tools_dir, hostipv4, port):
  addrinfo = socket.getaddrinfo(hostipv4, port, socket.AF_INET,
                                socket.SOCK_STREAM)
  return None, addrinfo


def get_ipv6_addrinfo(fuchsia_tools_dir, hostipv6, port):
  devices = get_device_table(fuchsia_tools_dir)

  if hostipv6[:4] != "fe80":
    hostipv6 = translate_name_to_ipv6(fuchsia_tools_dir, devices, hostipv6)
  if hostipv6 is None:
    return None

  hostipv6 = normalize_ipv6(hostipv6)
  if hostipv6.find("%") <= 0:
    error("ipv6 address must include the interface.")
    return None

  hostname = translate_ipv6_to_name(devices, hostipv6)
  if hostname is None:
    return None

  # hostipv6 is now the *magenta* link local address, which works for netcp
  # but does not allow us to talk to test_runner. So we need to calculate the
  # "normal" Fuchsia link-local ipv6 address.
  fuchsia_hostipv6 = magenta_ipv6_to_fuchsia(hostipv6)
  addrinfo = socket.getaddrinfo(fuchsia_hostipv6, port, socket.AF_INET6,
                                socket.SOCK_STREAM)
  return hostname, addrinfo


def main(argv):
  for dir in ["FUCHSIA_BUILD_DIR", "FUCHSIA_OUT_DIR"]:
    if not dir in os.environ:
      error("could not find env variable $%s" % dir)
      return 1

  fuchsia_tools_dir = os.path.join(os.environ["FUCHSIA_OUT_DIR"],
                                   "build-magenta/tools/")

  # A link-local ipv6 address must include the interface after a % sign. eg:
  # run_test --server "fe80::8eae:4cff:fef4:350d%em1"
  # run_test --server "fe80::8eae:4cff:fef4:350d%2"
  default_server = ":"
  default_port = 8342
  sync_files = False

  parser = argparse.ArgumentParser()
  parser.add_argument(
      "--server",
      help=
      "Host name or ipv6 address where the test_runner daemon is running. Default: "
      + default_server,
      type=str,
      default=default_server)
  parser.add_argument(
      "--port",
      help="Port where the test_runner daemon is running. Default: " +
      str(default_port),
      type=int,
      default=default_port)
  parser.add_argument(
      "--loglistener_path",
      help="Path to the loglistener binary",
      type=str,
      default=fuchsia_tools_dir + "loglistener")
  parser.add_argument(
      "--test_file",
      help="Path to a json file containing a series of tests to run.",
      type=str,
      default="")
  parser.add_argument(
      "--sync",
      help="If using test_file, copy the dependent files to the device.",
      dest="sync_files",
      action="store_true")
  parser.add_argument(
      "--no-sync",
      help="If using test_file, don't copy the dependent files to the device.",
      dest="sync_files",
      action="store_false")
  parser.set_defaults(sync_files=False)
  parser.add_argument("command", nargs="*")
  args = parser.parse_args()

  if args.test_file == "" and len(args.command) == 0:
    error("either a single test command, or --test_file must be specified.")
    return 1

  if len(args.command) == 1:
    if is_ipv4_address(args.command[0]) or args.command[0][:4] == "fe80":
      error("The ip address must be specified with the --server option.")
      return 1

  # Server name could be any of:
  #   ipv4 address (for automated testing only - can't copy files)
  #   ipv6 address (must include interface)
  #   : (uses netls to find the default)
  #   node name (uses netls to translate to ipv6)
  if is_ipv4_address(args.server):
    hostname, addrinfo = get_ipv4_addrinfo(fuchsia_tools_dir, args.server,
                                           args.port)
  else:
    hostname, addrinfo = get_ipv6_addrinfo(fuchsia_tools_dir, args.server,
                                           args.port)
  if addrinfo is None or len(addrinfo) == 0:
    return 1

  (family, socktype, proto, canonname, sockaddr) = addrinfo[0]

  # 1. Start listening to the device log.
  starting_dirname = os.getcwd()
  loglistener_dirname = os.path.dirname(args.loglistener_path)
  loglistener_basename = os.path.basename(args.loglistener_path)
  loglistener_executable = './%s' % loglistener_basename

  # if hostname is None, then this is an ipv4 address and we don't have
  # the device name.
  if hostname is None:
    listener_command = loglistener_executable
  else:
    listener_command = [loglistener_executable, hostname]

  # start loglistener from its own directory so its banner fits on a line.
  os.chdir(loglistener_dirname)
  listener_process = subprocess.Popen(listener_command, stdout=subprocess.PIPE)
  os.chdir(starting_dirname)

  # 2. Open up a connection to the on-device test runner server.
  sock = socket.socket(family, socktype)
  try:
    sock.connect(sockaddr)
  except socket.error, exc:
    error("Can't connect socket %s for\n%s. Did you start test_runner on "
          "Fuchsia?" % (exc, hostname))
    return 1

  # 3. Read commands and send them to the test runner server.
  try:
    if len(args.command) > 0:
      command_str = " ".join(args.command)
      # Run a single command
      print "%sRunning %s ..%s" % (color.BOLD, command_str, color.END)
      sys.stdout.flush()
      return run_test(sock, listener_process, command_str)
    else:
      # Run series of commands from test file
      status = 0
      with open(args.test_file) as f:
        tests = json.load(f)
        for test in tests["tests"]:
          print "%sRunning %s ..%s" % (color.BOLD, test["name"], color.END)
          sys.stdout.flush()
          if sync_files and "copy" in test:
            if not copy_files(fuchsia_tools_dir, hostname, test["copy"]):
              return 1
          if run_test(sock, listener_process, test["exec"]):
            status = 1
      return status
  finally:
    # 4. Cleanup
    listener_process.terminate()
    sock.close()


if __name__ == "__main__":
  sys.exit(main(sys.argv))

// Copyright 2018 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "garnet/bin/zxdb/client/step_thread_controller.h"
#include "garnet/bin/zxdb/client/process.h"
#include "garnet/bin/zxdb/client/symbols/line_details.h"
#include "garnet/bin/zxdb/client/symbols/mock_module_symbols.h"
#include "garnet/bin/zxdb/client/thread.h"
#include "garnet/bin/zxdb/client/thread_controller_test.h"
#include "garnet/bin/zxdb/common/err.h"
#include "garnet/lib/debug_ipc/protocol.h"

namespace zxdb {

class StepThreadControllerTest : public ThreadControllerTest {};

// Software exceptions should always stop execution. These might be from
// something like a hardcoded breakpoint instruction in the code. Doing "step"
// shouldn't skip over these.
TEST_F(StepThreadControllerTest, SofwareException) {
  // Step as long as we're in this range. Using the "code range" for stepping
  // allows us to avoid dependencies on the symbol subsystem.
  constexpr uint64_t kBeginAddr = 0x1000;
  constexpr uint64_t kEndAddr = 0x1010;

  // Set up the thread to be stopped at the beginning of our range.
  debug_ipc::NotifyException exception;
  exception.process_koid = process()->GetKoid();
  exception.type = debug_ipc::NotifyException::Type::kHardware;
  exception.thread.koid = thread()->GetKoid();
  exception.thread.state = debug_ipc::ThreadRecord::State::kBlocked;
  exception.frames.resize(2);
  exception.frames[0].ip = kBeginAddr;
  exception.frames[0].sp = 0x5000;
  exception.frames[0].bp = 0x5000;
  InjectException(exception);

  // Continue the thread with the controller stepping in range.
  auto step_into = std::make_unique<StepThreadController>(
      AddressRange(kBeginAddr, kEndAddr));
  bool continued = false;
  thread()->ContinueWith(std::move(step_into), [&continued](const Err& err) {
    if (!err.has_error())
      continued = true;
  });

  // It should have been able to step without doing any further async work.
  EXPECT_TRUE(continued);
  EXPECT_EQ(1, resume_count());

  // Issue a software exception in the range.
  exception.type = debug_ipc::NotifyException::Type::kSoftware;
  exception.frames[0].ip += 4;
  InjectException(exception);

  // It should have stayed stopped despite being in range.
  EXPECT_EQ(1, resume_count());  // Same count as above.
  EXPECT_EQ(debug_ipc::ThreadRecord::State::kBlocked, thread()->GetState());
}

// Some entries in the line table may have their line number set to zero. These
// indicate code generated by the compiler not associated with any line number.
// These should be transparently stepped over when stepping by line.
//
// This test tests the case where the line table has 10, 0, 10 11. Stepping
// from the first "10" line should end up on "11".
TEST_F(StepThreadControllerTest, Line0) {
  FileLine line0("/path/file.cc", 0);
  FileLine line10("/path/file.cc", 10);
  FileLine line11("/path/file.cc", 11);

  const uint64_t kAddr1 = kModuleAddress + 0x100;  // Line 10
  const uint64_t kAddr2 = kAddr1 + 4;              // Line 0
  const uint64_t kAddr3 = kAddr2 + 4;              // Line 10
  const uint64_t kAddr4 = kAddr3 + 4;              // Line 11

  LineDetails line_details1(line10);
  line_details1.entries().push_back({20, AddressRange(kAddr1, kAddr2)});

  LineDetails line_details2(line0);
  line_details2.entries().push_back({0, AddressRange(kAddr2, kAddr3)});

  LineDetails line_details3(line10);
  line_details3.entries().push_back({10, AddressRange(kAddr3, kAddr4)});

  LineDetails line_details4(line11);
  line_details4.entries().push_back({0, AddressRange(kAddr4, kAddr4 + 4)});

  module_symbols()->AddLineDetails(kAddr1, line_details1);
  module_symbols()->AddLineDetails(kAddr2, line_details2);
  module_symbols()->AddLineDetails(kAddr3, line_details3);
  module_symbols()->AddLineDetails(kAddr4, line_details4);

  // Set up the thread to be stopped at the beginning of our range.
  debug_ipc::NotifyException exception;
  exception.process_koid = process()->GetKoid();
  exception.type = debug_ipc::NotifyException::Type::kHardware;
  exception.thread.koid = thread()->GetKoid();
  exception.thread.state = debug_ipc::ThreadRecord::State::kBlocked;
  exception.frames.resize(2);
  exception.frames[0].ip = kAddr1;
  exception.frames[0].sp = 0x5000;
  exception.frames[0].bp = 0x5000;
  InjectException(exception);

  // Continue the thread with the controller stepping in range.
  auto step_into =
      std::make_unique<StepThreadController>(StepMode::kSourceLine);
  bool continued = false;
  thread()->ContinueWith(std::move(step_into), [&continued](const Err& err) {
    if (!err.has_error())
      continued = true;
  });

  // It should have been able to step without doing any further async work.
  EXPECT_TRUE(continued);
  EXPECT_EQ(1, resume_count());

  // Stop on 2nd instruction (line 0). This should be automatically resumed.
  exception.frames[0].ip = kAddr2;
  InjectException(exception);
  EXPECT_EQ(2, resume_count());

  // Stop on 3rd instruction (line 10). Since this matches the original line,
  // it should be automatically resumed.
  exception.frames[0].ip = kAddr3;
  InjectException(exception);
  EXPECT_EQ(3, resume_count());

  // Stop on 4th instruction. Since this is line 11, we should stay stopped.
  exception.frames[0].ip = kAddr4;
  InjectException(exception);
  EXPECT_EQ(3, resume_count());  // Same count as above.
  EXPECT_EQ(debug_ipc::ThreadRecord::State::kBlocked, thread()->GetState());
}

}  // namespace zxdb

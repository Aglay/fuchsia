// Copyright 2016 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

library modular;

struct Proposal {
  // Identifies a proposal, namespaced internally to the proposing component and
  // proposal channel (Query or Next/Interruption).
  string id;

  // Id of the story from which the proposal originates.
  string? source_story;

  // The story ID this proposal applies to. A null story_id will create a new
  // story.
  // NOTE(thatguy): Deprecate all story_id fields on Actions.
  string? story_id;

  // If set to true, this proposal will only show up when |story_id| is in the
  // foreground.
  bool story_affinity;

  // The list of actions to take when the user selects the associated
  // Suggestion.
  vector<Action> on_selected;

  // An optional hint about the probability that this proposal would be chosen
  // if it were the only proposal presented to the user. A confidence of 0.0
  // indicates no hint. The confidence assigned by the system may be subject to
  // other considerations such as performance metrics.
  float32 confidence = 0.0;

  SuggestionDisplay display;

  // A listener interface that is notified when the proposal is accepted by
  // the system.
  //
  // The listener is currently notified once when a proposal is accepted. Thus the
  // |story_id| provided will be of the first create story action in |on_selected|,
  // and subsequent create story actions will not notify the listener.
  ProposalListener? listener;
};

// An interface that allows Proposal creators to be notified when a proposal
// is accepted by the system.
interface ProposalListener {
  // Indicates that a proposal was accepted by the system.
  //
  // |proposal_id| The identifier of the accepted proposal.
  // |story_id| The identifier of the created story, if a story was created.
  1: OnProposalAccepted(string proposal_id, string? story_id);
};

union Action {
  CreateStory create_story;
  FocusStory focus_story;
  AddModule add_module;
  SetLinkValueAction set_link_value_action;
  CustomAction custom_action;
  QueryAction query_action;
};

// Creates a new story with the specified module
struct CreateStory {
  // Deprecated. These are left in for backwards compatibility. Internally,
  // an appropriate Intent is constructed with equivalent semantics.
  // TODO(thatguy): Remove all clients.
  string? module_id;
  string? initial_data;

  // The intent used to add the first module to the created story.
  // If set, the |module_id| and |initial_data| is disregarded.
  Intent? intent;
};

// Brings an existing story into focus.
struct FocusStory {
  string story_id;
};

// Adds a module from an Intent to an existing story.
struct AddModule {
  // The identifier of the story that the Intent is to be added to.
  string story_id;

  // The name of the module that will be added as a result of this proposal.  A
  // proposal for the same |story_id|, |module_name| and
  // |surface_parent_module_path| from the same Agent will result in replacing
  // the module at |module_name|, not adding a new one.
  string module_name;

  // The Intent that is to be added to the story.
  Intent intent;

  // The relation, relative to |surface_parent_module_path| to use. This
  // information is passed to the story shell for visual module composition.
  SurfaceRelation surface_relation;

  // The module path of an existing module to assign as the surface-relationship
  // parent of this new module.
  vector<string> surface_parent_module_path;
};

struct SetLinkValueAction {
  // Identifies the link within the story.
  LinkPath link_path;

  // The bytes that will be written to the link.
  // If empty, unsets the link value.
  string? value;
};

// An action that calls back to the proposal publisher to be performed.
// The callback can optionally resolve to a sequence of actions to perform.
// This can be used to defer expensive RPCs until the suggestion has been
// selected.
interface CustomAction {
  1: Execute() -> (vector<Action?>? actions);
};

// Performs a query with the given text. Once the proposals from the query are
// received, the first top-ranked proposal (not necessarily first proposal
// received) is automatically executed.
struct QueryAction {
  UserInput input;
};

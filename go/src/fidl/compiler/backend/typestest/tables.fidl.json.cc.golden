// Copyright 2018 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// WARNING: This file is machine generated by fidlgen.

#include <tables.fidl.json.h>

#include "lib/fidl/cpp/internal/implementation.h"
namespace test {
namespace name {

extern "C" const fidl_type_t test_name_OlderSimpleTableTable;
const fidl_type_t* OlderSimpleTable::FidlType = &test_name_OlderSimpleTableTable;

OlderSimpleTable::OlderSimpleTable() :
  
  has_x_(false) {
}

OlderSimpleTable::OlderSimpleTable(OlderSimpleTable&& other) {
  has_x_ = other.has_x_;
  if (has_x_) {
    Construct(&x_.value, std::move(other.x_.value));
  }
}

OlderSimpleTable::~OlderSimpleTable() {
  if (has_x_) {
    Destruct(&x_.value);
  }
}

OlderSimpleTable& OlderSimpleTable::operator=(OlderSimpleTable&& other) {
  if (other.has_x_) {
    if (has_x_) {
      x_.value = std::move(other.x_.value);
    } else {
      has_x_ = true;
      Construct(&x_.value, std::move(other.x_.value));
    }
  } else if (has_x_) {
    has_x_ = false;
    Destruct(&x_.value);
  }
  return *this;
}

void OlderSimpleTable::Encode(::fidl::Encoder* encoder, size_t offset) {
  ::fidl::EncodeVectorPointer(encoder, 1, offset);
  size_t base = encoder->Alloc(1 * sizeof(uint64_t));
  if (has_x_) {
    const size_t length_before = encoder->CurrentLength();
    const size_t handles_before = encoder->CurrentHandleCount();
    ::fidl::Encode(
        encoder,
        &x_.value,
        encoder->Alloc(CodingTraits<int64_t>::encoded_size));
    uint64_t presence =
        ((encoder->CurrentLength() - length_before) << 32) |
        (encoder->CurrentHandleCount() - handles_before);
    ::fidl::Encode(encoder, &presence, base + (1 - 1) * sizeof(uint64_t));
  }
}

void OlderSimpleTable::Decode(::fidl::Decoder* decoder, OlderSimpleTable* value, size_t offset) {
  fidl_vector_t* encoded = decoder->GetPtr<fidl_vector_t>(offset);
  size_t base;
  size_t count;
  if (!encoded->data) {
    goto clear_all;
  }

  base = decoder->GetOffset(encoded->data);
  count = encoded->count;
  if (count >= 1) {
    uint64_t presence;
    ::fidl::Decode(decoder, &presence, base + (1 - 1) * sizeof(uint64_t));
    if (presence != 0) {
      ::fidl::Decode(decoder, value->mutable_x(), decoder->GetOffset(presence));
    } else {
      value->clear_x();
    }
  } else {
    goto done_1;
  }

  return;

  // Clear unset values.
clear_all:
done_1:
  value->clear_x();
  return;
}

zx_status_t OlderSimpleTable::Clone(OlderSimpleTable* result) const {
  if (has_x_) {
    zx_status_t _status = ::fidl::Clone(x_.value, result->mutable_x());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_x();
  }
  return ZX_OK;
}

bool operator==(const OlderSimpleTable& lhs, const OlderSimpleTable& rhs) {
  if (lhs.has_x()) {
    if (!rhs.has_x()) {
      return false;
    }
    if (!::fidl::Equals(*lhs.x(), *rhs.x())) {
      return false;
    }
  } else if (rhs.has_x()) {
    return false;
  }
  return true;
}
extern "C" const fidl_type_t test_name_NewerSimpleTableTable;
const fidl_type_t* NewerSimpleTable::FidlType = &test_name_NewerSimpleTableTable;

NewerSimpleTable::NewerSimpleTable() :
  
  has_x_(false)
  ,
  has_y_(false)
  ,
  has_z_(false) {
}

NewerSimpleTable::NewerSimpleTable(NewerSimpleTable&& other) {
  has_x_ = other.has_x_;
  if (has_x_) {
    Construct(&x_.value, std::move(other.x_.value));
  }
  has_y_ = other.has_y_;
  if (has_y_) {
    Construct(&y_.value, std::move(other.y_.value));
  }
  has_z_ = other.has_z_;
  if (has_z_) {
    Construct(&z_.value, std::move(other.z_.value));
  }
}

NewerSimpleTable::~NewerSimpleTable() {
  if (has_x_) {
    Destruct(&x_.value);
  }
  if (has_y_) {
    Destruct(&y_.value);
  }
  if (has_z_) {
    Destruct(&z_.value);
  }
}

NewerSimpleTable& NewerSimpleTable::operator=(NewerSimpleTable&& other) {
  if (other.has_x_) {
    if (has_x_) {
      x_.value = std::move(other.x_.value);
    } else {
      has_x_ = true;
      Construct(&x_.value, std::move(other.x_.value));
    }
  } else if (has_x_) {
    has_x_ = false;
    Destruct(&x_.value);
  }
  if (other.has_y_) {
    if (has_y_) {
      y_.value = std::move(other.y_.value);
    } else {
      has_y_ = true;
      Construct(&y_.value, std::move(other.y_.value));
    }
  } else if (has_y_) {
    has_y_ = false;
    Destruct(&y_.value);
  }
  if (other.has_z_) {
    if (has_z_) {
      z_.value = std::move(other.z_.value);
    } else {
      has_z_ = true;
      Construct(&z_.value, std::move(other.z_.value));
    }
  } else if (has_z_) {
    has_z_ = false;
    Destruct(&z_.value);
  }
  return *this;
}

void NewerSimpleTable::Encode(::fidl::Encoder* encoder, size_t offset) {
  ::fidl::EncodeVectorPointer(encoder, 6, offset);
  size_t base = encoder->Alloc(6 * sizeof(uint64_t));
  if (has_x_) {
    const size_t length_before = encoder->CurrentLength();
    const size_t handles_before = encoder->CurrentHandleCount();
    ::fidl::Encode(
        encoder,
        &x_.value,
        encoder->Alloc(CodingTraits<int64_t>::encoded_size));
    uint64_t presence =
        ((encoder->CurrentLength() - length_before) << 32) |
        (encoder->CurrentHandleCount() - handles_before);
    ::fidl::Encode(encoder, &presence, base + (1 - 1) * sizeof(uint64_t));
  }
  if (has_y_) {
    const size_t length_before = encoder->CurrentLength();
    const size_t handles_before = encoder->CurrentHandleCount();
    ::fidl::Encode(
        encoder,
        &y_.value,
        encoder->Alloc(CodingTraits<int64_t>::encoded_size));
    uint64_t presence =
        ((encoder->CurrentLength() - length_before) << 32) |
        (encoder->CurrentHandleCount() - handles_before);
    ::fidl::Encode(encoder, &presence, base + (5 - 1) * sizeof(uint64_t));
  }
  if (has_z_) {
    const size_t length_before = encoder->CurrentLength();
    const size_t handles_before = encoder->CurrentHandleCount();
    ::fidl::Encode(
        encoder,
        &z_.value,
        encoder->Alloc(CodingTraits<int64_t>::encoded_size));
    uint64_t presence =
        ((encoder->CurrentLength() - length_before) << 32) |
        (encoder->CurrentHandleCount() - handles_before);
    ::fidl::Encode(encoder, &presence, base + (6 - 1) * sizeof(uint64_t));
  }
}

void NewerSimpleTable::Decode(::fidl::Decoder* decoder, NewerSimpleTable* value, size_t offset) {
  fidl_vector_t* encoded = decoder->GetPtr<fidl_vector_t>(offset);
  size_t base;
  size_t count;
  if (!encoded->data) {
    goto clear_all;
  }

  base = decoder->GetOffset(encoded->data);
  count = encoded->count;
  if (count >= 1) {
    uint64_t presence;
    ::fidl::Decode(decoder, &presence, base + (1 - 1) * sizeof(uint64_t));
    if (presence != 0) {
      ::fidl::Decode(decoder, value->mutable_x(), decoder->GetOffset(presence));
    } else {
      value->clear_x();
    }
  } else {
    goto done_1;
  }
  if (count >= 5) {
    uint64_t presence;
    ::fidl::Decode(decoder, &presence, base + (5 - 1) * sizeof(uint64_t));
    if (presence != 0) {
      ::fidl::Decode(decoder, value->mutable_y(), decoder->GetOffset(presence));
    } else {
      value->clear_y();
    }
  } else {
    goto done_5;
  }
  if (count >= 6) {
    uint64_t presence;
    ::fidl::Decode(decoder, &presence, base + (6 - 1) * sizeof(uint64_t));
    if (presence != 0) {
      ::fidl::Decode(decoder, value->mutable_z(), decoder->GetOffset(presence));
    } else {
      value->clear_z();
    }
  } else {
    goto done_6;
  }

  return;

  // Clear unset values.
clear_all:
done_1:
  value->clear_x();
done_5:
  value->clear_y();
done_6:
  value->clear_z();
  return;
}

zx_status_t NewerSimpleTable::Clone(NewerSimpleTable* result) const {
  if (has_x_) {
    zx_status_t _status = ::fidl::Clone(x_.value, result->mutable_x());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_x();
  }
  if (has_y_) {
    zx_status_t _status = ::fidl::Clone(y_.value, result->mutable_y());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_y();
  }
  if (has_z_) {
    zx_status_t _status = ::fidl::Clone(z_.value, result->mutable_z());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_z();
  }
  return ZX_OK;
}

bool operator==(const NewerSimpleTable& lhs, const NewerSimpleTable& rhs) {
  if (lhs.has_x()) {
    if (!rhs.has_x()) {
      return false;
    }
    if (!::fidl::Equals(*lhs.x(), *rhs.x())) {
      return false;
    }
  } else if (rhs.has_x()) {
    return false;
  }
  if (lhs.has_y()) {
    if (!rhs.has_y()) {
      return false;
    }
    if (!::fidl::Equals(*lhs.y(), *rhs.y())) {
      return false;
    }
  } else if (rhs.has_y()) {
    return false;
  }
  if (lhs.has_z()) {
    if (!rhs.has_z()) {
      return false;
    }
    if (!::fidl::Equals(*lhs.z(), *rhs.z())) {
      return false;
    }
  } else if (rhs.has_z()) {
    return false;
  }
  return true;
}
extern "C" const fidl_type_t test_name_SimpleTableTable;
const fidl_type_t* SimpleTable::FidlType = &test_name_SimpleTableTable;

SimpleTable::SimpleTable() :
  
  has_x_(false)
  ,
  has_y_(false) {
}

SimpleTable::SimpleTable(SimpleTable&& other) {
  has_x_ = other.has_x_;
  if (has_x_) {
    Construct(&x_.value, std::move(other.x_.value));
  }
  has_y_ = other.has_y_;
  if (has_y_) {
    Construct(&y_.value, std::move(other.y_.value));
  }
}

SimpleTable::~SimpleTable() {
  if (has_x_) {
    Destruct(&x_.value);
  }
  if (has_y_) {
    Destruct(&y_.value);
  }
}

SimpleTable& SimpleTable::operator=(SimpleTable&& other) {
  if (other.has_x_) {
    if (has_x_) {
      x_.value = std::move(other.x_.value);
    } else {
      has_x_ = true;
      Construct(&x_.value, std::move(other.x_.value));
    }
  } else if (has_x_) {
    has_x_ = false;
    Destruct(&x_.value);
  }
  if (other.has_y_) {
    if (has_y_) {
      y_.value = std::move(other.y_.value);
    } else {
      has_y_ = true;
      Construct(&y_.value, std::move(other.y_.value));
    }
  } else if (has_y_) {
    has_y_ = false;
    Destruct(&y_.value);
  }
  return *this;
}

void SimpleTable::Encode(::fidl::Encoder* encoder, size_t offset) {
  ::fidl::EncodeVectorPointer(encoder, 5, offset);
  size_t base = encoder->Alloc(5 * sizeof(uint64_t));
  if (has_x_) {
    const size_t length_before = encoder->CurrentLength();
    const size_t handles_before = encoder->CurrentHandleCount();
    ::fidl::Encode(
        encoder,
        &x_.value,
        encoder->Alloc(CodingTraits<int64_t>::encoded_size));
    uint64_t presence =
        ((encoder->CurrentLength() - length_before) << 32) |
        (encoder->CurrentHandleCount() - handles_before);
    ::fidl::Encode(encoder, &presence, base + (1 - 1) * sizeof(uint64_t));
  }
  if (has_y_) {
    const size_t length_before = encoder->CurrentLength();
    const size_t handles_before = encoder->CurrentHandleCount();
    ::fidl::Encode(
        encoder,
        &y_.value,
        encoder->Alloc(CodingTraits<int64_t>::encoded_size));
    uint64_t presence =
        ((encoder->CurrentLength() - length_before) << 32) |
        (encoder->CurrentHandleCount() - handles_before);
    ::fidl::Encode(encoder, &presence, base + (5 - 1) * sizeof(uint64_t));
  }
}

void SimpleTable::Decode(::fidl::Decoder* decoder, SimpleTable* value, size_t offset) {
  fidl_vector_t* encoded = decoder->GetPtr<fidl_vector_t>(offset);
  size_t base;
  size_t count;
  if (!encoded->data) {
    goto clear_all;
  }

  base = decoder->GetOffset(encoded->data);
  count = encoded->count;
  if (count >= 1) {
    uint64_t presence;
    ::fidl::Decode(decoder, &presence, base + (1 - 1) * sizeof(uint64_t));
    if (presence != 0) {
      ::fidl::Decode(decoder, value->mutable_x(), decoder->GetOffset(presence));
    } else {
      value->clear_x();
    }
  } else {
    goto done_1;
  }
  if (count >= 5) {
    uint64_t presence;
    ::fidl::Decode(decoder, &presence, base + (5 - 1) * sizeof(uint64_t));
    if (presence != 0) {
      ::fidl::Decode(decoder, value->mutable_y(), decoder->GetOffset(presence));
    } else {
      value->clear_y();
    }
  } else {
    goto done_5;
  }

  return;

  // Clear unset values.
clear_all:
done_1:
  value->clear_x();
done_5:
  value->clear_y();
  return;
}

zx_status_t SimpleTable::Clone(SimpleTable* result) const {
  if (has_x_) {
    zx_status_t _status = ::fidl::Clone(x_.value, result->mutable_x());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_x();
  }
  if (has_y_) {
    zx_status_t _status = ::fidl::Clone(y_.value, result->mutable_y());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_y();
  }
  return ZX_OK;
}

bool operator==(const SimpleTable& lhs, const SimpleTable& rhs) {
  if (lhs.has_x()) {
    if (!rhs.has_x()) {
      return false;
    }
    if (!::fidl::Equals(*lhs.x(), *rhs.x())) {
      return false;
    }
  } else if (rhs.has_x()) {
    return false;
  }
  if (lhs.has_y()) {
    if (!rhs.has_y()) {
      return false;
    }
    if (!::fidl::Equals(*lhs.y(), *rhs.y())) {
      return false;
    }
  } else if (rhs.has_y()) {
    return false;
  }
  return true;
}
}  // namespace name
}  // namespace test

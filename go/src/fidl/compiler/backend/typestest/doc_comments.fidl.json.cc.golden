// WARNING: This file is machine generated by fidlgen.

#include <doc_comments.fidl.json.h>

#include "lib/fidl/cpp/internal/implementation.h"
namespace test {
namespace name {

namespace {
  
constexpr uint32_t kInterface_Method_GenOrdinal = 1061382220u;
constexpr uint32_t kInterface_Method_Ordinal = 1u;
extern "C" const fidl_type_t test_name_InterfaceMethodRequestTable;

}  // namespace

Interface::~Interface() = default;

Interface_EventSender::~Interface_EventSender() = default;

Interface_Sync::~Interface_Sync() = default;

Interface_Proxy::Interface_Proxy(::fidl::internal::ProxyController* controller)
    : controller_(controller) {
  (void)controller_;
}

Interface_Proxy::~Interface_Proxy() = default;

zx_status_t Interface_Proxy::Dispatch_(::fidl::Message message) {
  zx_status_t status = ZX_OK;
  switch (message.ordinal()) {
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}


void Interface_Proxy::Method() {
  ::fidl::Encoder _encoder(kInterface_Method_Ordinal);
  controller_->Send(&test_name_InterfaceMethodRequestTable, _encoder.GetMessage(), nullptr);
}

Interface_Stub::Interface_Stub(Interface_clazz* impl) : impl_(impl) {
  (void)impl_;
}

Interface_Stub::~Interface_Stub() = default;

namespace {

}  // namespace

zx_status_t Interface_Stub::Dispatch_(
    ::fidl::Message message,
    ::fidl::internal::PendingResponse response) {
  zx_status_t status = ZX_OK;
  uint32_t ordinal = message.ordinal();
  switch (ordinal) {
    case kInterface_Method_GenOrdinal:
    case kInterface_Method_Ordinal: {
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_InterfaceMethodRequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_InterfaceMethodRequestTable, error_msg);
        break;
      }
      impl_->Method();
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}

Interface_SyncProxy::Interface_SyncProxy(::zx::channel channel)
    : proxy_(::std::move(channel)) {}

Interface_SyncProxy::~Interface_SyncProxy() = default;
zx_status_t Interface_SyncProxy::Method() {
  ::fidl::Encoder _encoder(kInterface_Method_Ordinal);
  return proxy_.Send(&test_name_InterfaceMethodRequestTable, _encoder.GetMessage());
}


extern "C" const fidl_type_t test_name_StructTable;
const fidl_type_t* Struct::FidlType = &test_name_StructTable;

void Struct::Encode(::fidl::Encoder* encoder, size_t offset) {
  ::fidl::Encode(encoder, &Field, offset + 0);
}

void Struct::Decode(::fidl::Decoder* decoder, Struct* value, size_t offset) {
  ::fidl::Decode(decoder, &value->Field, offset + 0);
}

zx_status_t Struct::Clone(Struct* result) const {
  zx_status_t _status = ::fidl::Clone(Field, &result->Field);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

bool operator==(const Struct& lhs, const Struct& rhs) {
  if (!::fidl::Equals(lhs.Field, rhs.Field)) {
    return false;
  }
  return true;
}
Union::Union() : value_() {}

Union::~Union() {
}

Union::Union(Union&& other) : value_(std::move(other.value_)) {
}

Union& Union::operator=(Union&& other) {
  if (this != &other) {
    value_ = std::move(other.value_);
  }
  return *this;
}

void Union::Encode(::fidl::Encoder* encoder, size_t offset) {
  fidl_union_tag_t tag = static_cast<fidl_union_tag_t>(Which());
  ::fidl::Encode(encoder, &tag, offset);
  switch (tag) {
   case 0:
    ::fidl::Encode(encoder, &Field(), offset + 4);
    break;
   default:
    break;
  }
}

void Union::Decode(::fidl::Decoder* decoder, Union* value, size_t offset) {
  fidl_union_tag_t tag;
  ::fidl::Decode(decoder, &tag, offset);
  switch (tag) {
   case 0:
    {
      int32_t member{};
      ::fidl::Decode(decoder, &member, offset + 4);
      value->set_Field(std::move(member));
      break;
    }
   default:
    value->value_.emplace<0>();
  }
}

zx_status_t Union::Clone(Union* result) const {
  zx_status_t status = ZX_OK;
  switch (Which()) {
    case Tag::kField:
      {
        int32_t member{};
        status = ::fidl::Clone(Field(), &member);
        if (status == ZX_OK) {
	  result->set_Field(std::move(member));
        }
      }
      break;
    case Tag::Invalid:
      result->value_.emplace<0>();
      break;
  }
  return status;
}

bool operator==(const Union& lhs, const Union& rhs) {
  if (lhs.Which() != rhs.Which()) {
    return false;
  }
  switch (lhs.Which()) {
    case Union::Tag::kField:
      return ::fidl::Equals(lhs.Field(), rhs.Field());
    case Union::Tag::Invalid:
      return true;
    default:
      return false;
  }
}

void Union::set_Field(int32_t value) {
  value_.emplace<static_cast<size_t>(Tag::kField) + 1>(std::move(value));
}
extern "C" const fidl_type_t test_name_TableTable;
const fidl_type_t* Table::FidlType = &test_name_TableTable;

Table::Table() :
  
  has_Field_(false) {
}

Table::Table(Table&& other) {
  has_Field_ = other.has_Field_;
  if (has_Field_) {
    Construct(&Field_.value, std::move(other.Field_.value));
  }
}

Table::~Table() {
  if (has_Field_) {
    Destruct(&Field_.value);
  }
}

Table& Table::operator=(Table&& other) {
  if (other.has_Field_) {
    if (has_Field_) {
      Field_.value = std::move(other.Field_.value);
    } else {
      has_Field_ = true;
      Construct(&Field_.value, std::move(other.Field_.value));
    }
  } else if (has_Field_) {
    has_Field_ = false;
    Destruct(&Field_.value);
  }
  return *this;
}

void Table::Encode(::fidl::Encoder* encoder, size_t offset) {
  size_t max_ordinal = 0;
  if (has_Field_) max_ordinal = 1;
  ::fidl::EncodeVectorPointer(encoder, max_ordinal, offset);
  if (max_ordinal == 0) return;
  size_t base = encoder->Alloc(max_ordinal * 2 * sizeof(uint64_t));
  if (has_Field_) {
    const size_t length_before = encoder->CurrentLength();
    const size_t handles_before = encoder->CurrentHandleCount();
    ::fidl::Encode(
        encoder,
        &Field_.value,
        encoder->Alloc(::fidl::CodingTraits<int32_t>::encoded_size));
    size_t envelope_base = base + (1 - 1) * 2 * sizeof(uint64_t);
    uint64_t num_bytes_then_num_handles =
        (encoder->CurrentLength() - length_before) |
        ((encoder->CurrentHandleCount() - handles_before) << 32);
    ::fidl::Encode(encoder, &num_bytes_then_num_handles, envelope_base);
    *encoder->GetPtr<uintptr_t>(envelope_base + sizeof(uint64_t)) = FIDL_ALLOC_PRESENT;
  }
}

void Table::Decode(::fidl::Decoder* decoder, Table* value, size_t offset) {
  fidl_vector_t* encoded = decoder->GetPtr<fidl_vector_t>(offset);
  size_t base;
  size_t count;
  if (!encoded->data) {
    goto clear_all;
  }

  base = decoder->GetOffset(encoded->data);
  count = encoded->count;
  if (count >= 1) {
    size_t envelope_base = base + (1 - 1) * 2 * sizeof(uint64_t);
    uint64_t presence;
    ::fidl::Decode(decoder, &presence, envelope_base + sizeof(uint64_t));
    if (presence != 0) {
      ::fidl::Decode(decoder, value->mutable_Field(), decoder->GetOffset(presence));
    } else {
      value->clear_Field();
    }
  } else {
    goto done_1;
  }

  return;

  // Clear unset values.
clear_all:
done_1:
  value->clear_Field();
  return;
}

zx_status_t Table::Clone(Table* result) const {
  if (has_Field_) {
    zx_status_t _status = ::fidl::Clone(Field_.value, result->mutable_Field());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_Field();
  }
  return ZX_OK;
}

bool operator==(const Table& lhs, const Table& rhs) {
  if (lhs.has_Field()) {
    if (!rhs.has_Field()) {
      return false;
    }
    if (!::fidl::Equals(*lhs.Field(), *rhs.Field())) {
      return false;
    }
  } else if (rhs.has_Field()) {
    return false;
  }
  return true;
}
}  // namespace name
}  // namespace test

// WARNING: This file is machine generated by fidlgen.

#include <union.fidl.json.h>

#include "lib/fidl/cpp/internal/implementation.h"
namespace test {
namespace name {

Union::Union() : tag_(::std::numeric_limits<::fidl_union_tag_t>::max()) {}

Union::~Union() {
  Destroy();
}

Union::Union(Union&& other) : tag_(other.tag_) {
  switch (tag_) {
   case 0:
    Primitive_ = std::move(other.Primitive_);
    break;
   case 1:
    new (&StringNeedsConstructor_) ::fidl::StringPtr();
    StringNeedsConstructor_ = std::move(other.StringNeedsConstructor_);
    break;
   case 2:
    new (&VectorStringAlsoNeedsConstructor_) ::fidl::VectorPtr<::fidl::StringPtr>();
    VectorStringAlsoNeedsConstructor_ = std::move(other.VectorStringAlsoNeedsConstructor_);
    break;
   default:
    break;
  }
}

Union& Union::operator=(Union&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
     case 0:
      Primitive_ = std::move(other.Primitive_);
      break;
     case 1:
      new (&StringNeedsConstructor_) ::fidl::StringPtr();
      StringNeedsConstructor_ = std::move(other.StringNeedsConstructor_);
      break;
     case 2:
      new (&VectorStringAlsoNeedsConstructor_) ::fidl::VectorPtr<::fidl::StringPtr>();
      VectorStringAlsoNeedsConstructor_ = std::move(other.VectorStringAlsoNeedsConstructor_);
      break;
     default:
      break;
    }
  }
  return *this;
}

void Union::Encode(::fidl::Encoder* encoder, size_t offset) {
  ::fidl::Encode(encoder, &tag_, offset);
  switch (tag_) {
   case 0:
    ::fidl::Encode(encoder, &Primitive_, offset + 8);
    break;
   case 1:
    ::fidl::Encode(encoder, &StringNeedsConstructor_, offset + 8);
    break;
   case 2:
    ::fidl::Encode(encoder, &VectorStringAlsoNeedsConstructor_, offset + 8);
    break;
   default:
    break;
  }
}

void Union::Decode(::fidl::Decoder* decoder, Union* value, size_t offset) {
  value->Destroy();
  ::fidl::Decode(decoder, &value->tag_, offset);
  switch (value->tag_) {
   case 0:
    ::fidl::Decode(decoder, &value->Primitive_, offset + 8);
    break;
   case 1:
    new (&value->StringNeedsConstructor_) ::fidl::StringPtr();
    ::fidl::Decode(decoder, &value->StringNeedsConstructor_, offset + 8);
    break;
   case 2:
    new (&value->VectorStringAlsoNeedsConstructor_) ::fidl::VectorPtr<::fidl::StringPtr>();
    ::fidl::Decode(decoder, &value->VectorStringAlsoNeedsConstructor_, offset + 8);
    break;
   default:
    break;
  }
}

zx_status_t Union::Clone(Union* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case 0:
      return ::fidl::Clone(Primitive_, &result->Primitive_);
    case 1:
      new (&result->StringNeedsConstructor_) ::fidl::StringPtr();
      return ::fidl::Clone(StringNeedsConstructor_, &result->StringNeedsConstructor_);
    case 2:
      new (&result->VectorStringAlsoNeedsConstructor_) ::fidl::VectorPtr<::fidl::StringPtr>();
      return ::fidl::Clone(VectorStringAlsoNeedsConstructor_, &result->VectorStringAlsoNeedsConstructor_);
    default:
      return ZX_OK;
  }
}

bool operator==(const Union& lhs, const Union& rhs) {
  if (lhs.tag_ != rhs.tag_) {
    return false;
  }
  switch (lhs.tag_) {
    case 0:
      return ::fidl::Equals(lhs.Primitive_, rhs.Primitive_);
    case 1:
      return ::fidl::Equals(lhs.StringNeedsConstructor_, rhs.StringNeedsConstructor_);
    case 2:
      return ::fidl::Equals(lhs.VectorStringAlsoNeedsConstructor_, rhs.VectorStringAlsoNeedsConstructor_);
    case ::std::numeric_limits<::fidl_union_tag_t>::max():
      return true;
    default:
      return false;
  }
}

void Union::set_Primitive(int32_t value) {
  EnsureStorageInitialized(0);
  Primitive_ = std::move(value);
}

void Union::set_StringNeedsConstructor(::fidl::StringPtr value) {
  EnsureStorageInitialized(1);
  StringNeedsConstructor_ = std::move(value);
}

void Union::set_VectorStringAlsoNeedsConstructor(::fidl::VectorPtr<::fidl::StringPtr> value) {
  EnsureStorageInitialized(2);
  VectorStringAlsoNeedsConstructor_ = std::move(value);
}

void Union::Destroy() {
  switch (tag_) {
   case 0:
    break;
   case 1:
    StringNeedsConstructor_.~StringPtr();
    break;
   case 2:
    VectorStringAlsoNeedsConstructor_.~VectorPtr();
    break;
   default:
    break;
  }
  tag_ = ::std::numeric_limits<::fidl_union_tag_t>::max();
}

void Union::EnsureStorageInitialized(::fidl_union_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case 1:
        new (&StringNeedsConstructor_) ::fidl::StringPtr();
        break;
      case 2:
        new (&VectorStringAlsoNeedsConstructor_) ::fidl::VectorPtr<::fidl::StringPtr>();
        break;
      default:
        break;
    }
  }
}
}  // namespace name
}  // namespace test

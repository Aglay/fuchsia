// Copyright 2018 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Package install implements the `pm install` command
package install

import (
	"bytes"
	"flag"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"sync"

	"fuchsia.googlesource.com/far"
	"fuchsia.googlesource.com/merkle"
	"fuchsia.googlesource.com/pm/build"
)

// Run reads an archive given in flags.Arg(1) (the first argument after
// `install`) and unpacks the archive, adding it's contents to the appropriate
// locations in /pkgfs to install the package.
func Run(cfg *build.Config) error {
	af, err := os.Open(flag.Arg(1))
	if err != nil {
		return err
	}
	defer af.Close()

	pkgArchive, err := far.NewReader(af)
	if err != nil {
		return err
	}

	b, err := pkgArchive.ReadFile("meta.far")
	if err != nil {
		return err
	}

	var tree merkle.Tree
	_, err = tree.ReadFrom(bytes.NewReader(b))
	if err != nil {
		return err
	}
	merkleroot := tree.Root()

	f, err := os.Create(filepath.Join("/pkgfs/install/pkg", fmt.Sprintf("%x", merkleroot)))
	if err != nil {
		return err
	}
	f.Truncate(int64(len(b)))
	_, err = f.Write(b)
	if err != nil {
		f.Close()
		return err
	}
	if err := f.Close(); err != nil {
		return err
	}

	// Use a channel as a counting semaphore to limit parallelism.
	semaphore := make(chan bool, runtime.NumCPU())

	// Channel for returning errors generated by install worker jobs.
	// The error ordering is arbitrary.
	errors := make(chan error)
	quit := make(chan bool)
	num_blobs := 0
	archiveMutex := &sync.Mutex{}

	// Inserts blobs in parallel.
	for _, name := range pkgArchive.List() {
		if name == "meta.far" {
			continue
		}

		num_blobs++
		go func(name string) {
			// Block until the |semaphore| channel has spare capacity.
			semaphore <- true
			defer func() { <-semaphore }() // Decrement the semaphore at goroutine exit.

			// Exit early if the parent function has finished.
			select {
			case <-quit:
				return
			default:
			}

			if len(name) != 64 || strings.Contains(name, "/") {
				errors <- fmt.Errorf("Invalid package blob in archive: %s", name)
				return
			}

			// skip blobs that the package manager does not request (it already has them)
			if _, err := os.Stat(filepath.Join("/pkgfs/needs/blobs", name)); os.IsNotExist(err) {
				errors <- nil
				return
			}

			f, err := os.Create(filepath.Join("/pkgfs/install/blob", name))
			if os.IsExist(err) {
				errors <- nil
				return
			}
			if err != nil {
				errors <- err
				return
			}
			defer f.Close()

			archiveMutex.Lock()
			size := int64(pkgArchive.GetSize(name))
			r, err := pkgArchive.Open(name)
			archiveMutex.Unlock()
			if err != nil {
				errors <- err
				return
			}

			if err := f.Truncate(size); err != nil {
				errors <- err
				return
			}

			var pos int64
			var buf [32 * 1024]byte
			for {
				n, err := r.ReadAt(buf[:], pos)
				if n > 0 {
					if _, err := f.Write(buf[:n]); err != nil {
						errors <- err
						return
					}
				}
				pos += int64(n)
				if err == io.EOF {
					break
				}
				if err != nil {
					errors <- err
					return
				}
			}
			err = f.Close()
			if err != nil {
				errors <- err
				return
			}
			errors <- nil
		}(name)
	}

	// Find the an error reported by a worker and return it, if it exists.
	// This section also acts as a join, by blocking execution until all
	// statuses have been received via the |err| channel.
	for i := 0; i < num_blobs; i++ {
		err := <-errors
		if err != nil {
			quit <- true
			return err
		}
	}

	return nil
}

# Copyright 2019 The Fuchsia Authors
#
# Use of this source code is governed by a MIT-style
# license that can be found in the LICENSE file or at
# https://opensource.org/licenses/MIT

import("//build/zircon/migrated_targets.gni")

zx_library("instrumentation") {
  kernel = true
  sources = []
  public_deps = [ "$zx/system/ulib/fbl:headers" ]
  if (is_kernel) {
    sources += [ "vmo.cc" ]
    deps = [
      ":profile",
      ":sancov",
      "$zx/kernel/lib/ktl",
      "$zx/kernel/lib/version",
      "$zx/kernel/object",
      "$zx/system/ulib/fbl",
      "asan",
    ]
    public_deps += [
      # <lib/instrumentation/asan/asan-init-x64.cc> has #include <lib/counters.h>
      # TODO(fxbug.dev/51163): Move this to deps when possible.
      "$zx/kernel/lib/counters",

      # <lib/instrumentation/vmo.h> has #include <ktl/array.h>.
      "$zx/kernel/lib/ktl:headers",

      # TODO(fxbug.dev/51163): Move this to deps when possible.
      # <lib/instrumentation/asan/asan-init.cc> has #include <vm/vm_aspace.h>.
      "$zx/kernel/vm:headers",
    ]
  }
}

# This defines C symbol `__llvm_profile_header` with reference to the other
# `__llvm_prof*` sections generated by the compiler.  These pasted together in
# the right order make up the data file format understood by `llvm-profdata`.
# That can be done statically in a linker script, or dynamically at run time
# by code referring to the various implicit `__start___llvm_prof*` symbols.
# The compiler also generates a dummy reference to `__llvm_profile_runtime`,
# so a symbol by that name must be defined at link time regardless; this file
# also defines it.
source_set("profile") {
  if (zx == "/") {
    _profile_config = [ "$zx/public/gn/config/instrumentation:profile" ]
    _has_profile = toolchain.configs + _profile_config - _profile_config !=
                   toolchain.configs
  } else {
    _profile_config = [ "//build/config/profile" ]
    _has_profile = toolchain_variant.configs + _profile_config -
                   _profile_config != toolchain_variant.configs
  }
  if (_has_profile) {
    sources = [ "profile.cc" ]

    if (current_os == "win") {
      # The LLVM header file describing the instrumentation data tests this.
      defines = [ "_WIN32" ]
    }
  }
}

source_set("sancov") {
  _sancov_config = [ "$zx_build_config/instrumentation:sancov" ]
  if (configs + _sancov_config - _sancov_config != configs) {
    configs -= _sancov_config
    sources = [ "sancov.cc" ]
  }

  # sancov code shouldn't make asan checks.
  # Annotating the functions with NO_ASAN is not enough, as it doesnt
  # allow for ktl::atomic operations to be inlined.
  _asan_config = [ "$zx_build_config/instrumentation:asan" ]
  if (configs + _asan_config - _asan_config != configs) {
    configs -= _asan_config
  }
}

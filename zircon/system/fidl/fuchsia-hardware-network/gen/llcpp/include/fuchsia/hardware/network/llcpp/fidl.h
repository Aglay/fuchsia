// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/txn_header.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/connect_service.h>
#include <lib/fidl/llcpp/service_handler_interface.h>
#include <lib/fidl/llcpp/string_view.h>
#include <lib/fidl/llcpp/sync_call.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/fidl/llcpp/vector_view.h>
#include <lib/fit/function.h>
#include <lib/zx/channel.h>
#include <lib/zx/fifo.h>
#include <lib/zx/vmo.h>
#include <zircon/fidl.h>

#include <fuchsia/net/llcpp/fidl.h>

namespace llcpp {

namespace fuchsia {
namespace hardware {
namespace network {

class TxReturnFlags final {
public:
  constexpr TxReturnFlags() : value_(0u) {}
  explicit constexpr TxReturnFlags(uint32_t value) : value_(value) {}
  const static TxReturnFlags TX_RET_NOT_SUPPORTED;
  const static TxReturnFlags TX_RET_OUT_OF_RESOURCES;
  const static TxReturnFlags TX_RET_NOT_AVAILABLE;
  const static TxReturnFlags TX_RET_ERROR;
  const static TxReturnFlags mask;

  explicit constexpr inline operator uint32_t() const { return value_; }
  explicit constexpr inline operator bool() const { return static_cast<bool>(value_); }
  constexpr inline bool operator==(const TxReturnFlags& other) const { return value_ == other.value_; }
  constexpr inline bool operator!=(const TxReturnFlags& other) const { return value_ != other.value_; }
  constexpr inline TxReturnFlags operator~() const;
  constexpr inline TxReturnFlags operator|(const TxReturnFlags& other) const;
  constexpr inline TxReturnFlags operator&(const TxReturnFlags& other) const;
  constexpr inline TxReturnFlags operator^(const TxReturnFlags& other) const;
  constexpr inline void operator|=(const TxReturnFlags& other);
  constexpr inline void operator&=(const TxReturnFlags& other);
  constexpr inline void operator^=(const TxReturnFlags& other);

private:
  uint32_t value_;
};
constexpr const ::llcpp::fuchsia::hardware::network::TxReturnFlags TxReturnFlags::TX_RET_NOT_SUPPORTED = ::llcpp::fuchsia::hardware::network::TxReturnFlags(1u);
constexpr const ::llcpp::fuchsia::hardware::network::TxReturnFlags TxReturnFlags::TX_RET_OUT_OF_RESOURCES = ::llcpp::fuchsia::hardware::network::TxReturnFlags(2u);
constexpr const ::llcpp::fuchsia::hardware::network::TxReturnFlags TxReturnFlags::TX_RET_NOT_AVAILABLE = ::llcpp::fuchsia::hardware::network::TxReturnFlags(4u);
constexpr const ::llcpp::fuchsia::hardware::network::TxReturnFlags TxReturnFlags::TX_RET_ERROR = ::llcpp::fuchsia::hardware::network::TxReturnFlags(2147483648u);
constexpr const ::llcpp::fuchsia::hardware::network::TxReturnFlags TxReturnFlags::mask = ::llcpp::fuchsia::hardware::network::TxReturnFlags(2147483655u);

constexpr inline ::llcpp::fuchsia::hardware::network::TxReturnFlags TxReturnFlags::operator~() const {
  return ::llcpp::fuchsia::hardware::network::TxReturnFlags(static_cast<uint32_t>(~this->value_ & mask.value_));
}

constexpr inline ::llcpp::fuchsia::hardware::network::TxReturnFlags TxReturnFlags::operator|(
    const ::llcpp::fuchsia::hardware::network::TxReturnFlags& other) const {
  return ::llcpp::fuchsia::hardware::network::TxReturnFlags(static_cast<uint32_t>(this->value_ | other.value_));
}

constexpr inline ::llcpp::fuchsia::hardware::network::TxReturnFlags TxReturnFlags::operator&(
    const ::llcpp::fuchsia::hardware::network::TxReturnFlags& other) const {
  return ::llcpp::fuchsia::hardware::network::TxReturnFlags(static_cast<uint32_t>(this->value_ & other.value_));
}

constexpr inline ::llcpp::fuchsia::hardware::network::TxReturnFlags TxReturnFlags::operator^(
    const ::llcpp::fuchsia::hardware::network::TxReturnFlags& other) const {
  return ::llcpp::fuchsia::hardware::network::TxReturnFlags(static_cast<uint32_t>(this->value_ ^ other.value_));
}

constexpr inline void TxReturnFlags::operator|=(
    const ::llcpp::fuchsia::hardware::network::TxReturnFlags& other) {
  this->value_ |= other.value_;
}

constexpr inline void TxReturnFlags::operator&=(
    const ::llcpp::fuchsia::hardware::network::TxReturnFlags& other) {
  this->value_ &= other.value_;
}

constexpr inline void TxReturnFlags::operator^=(
    const ::llcpp::fuchsia::hardware::network::TxReturnFlags& other) {
  this->value_ ^= other.value_;
}

class TxFlags final {
public:
  constexpr TxFlags() : value_(0u) {}
  explicit constexpr TxFlags(uint32_t value) : value_(value) {}
  const static TxFlags TX_ACCEL_0;
  const static TxFlags TX_ACCEL_1;
  const static TxFlags TX_ACCEL_2;
  const static TxFlags TX_ACCEL_3;
  const static TxFlags TX_ACCEL_4;
  const static TxFlags TX_ACCEL_5;
  const static TxFlags TX_ACCEL_6;
  const static TxFlags TX_ACCEL_7;
  const static TxFlags TX_ACCEL_8;
  const static TxFlags TX_ACCEL_9;
  const static TxFlags TX_ACCEL_10;
  const static TxFlags TX_ACCEL_11;
  const static TxFlags TX_ACCEL_12;
  const static TxFlags TX_ACCEL_13;
  const static TxFlags TX_ACCEL_14;
  const static TxFlags TX_ACCEL_15;
  const static TxFlags mask;

  explicit constexpr inline operator uint32_t() const { return value_; }
  explicit constexpr inline operator bool() const { return static_cast<bool>(value_); }
  constexpr inline bool operator==(const TxFlags& other) const { return value_ == other.value_; }
  constexpr inline bool operator!=(const TxFlags& other) const { return value_ != other.value_; }
  constexpr inline TxFlags operator~() const;
  constexpr inline TxFlags operator|(const TxFlags& other) const;
  constexpr inline TxFlags operator&(const TxFlags& other) const;
  constexpr inline TxFlags operator^(const TxFlags& other) const;
  constexpr inline void operator|=(const TxFlags& other);
  constexpr inline void operator&=(const TxFlags& other);
  constexpr inline void operator^=(const TxFlags& other);

private:
  uint32_t value_;
};
constexpr const ::llcpp::fuchsia::hardware::network::TxFlags TxFlags::TX_ACCEL_0 = ::llcpp::fuchsia::hardware::network::TxFlags(1u);
constexpr const ::llcpp::fuchsia::hardware::network::TxFlags TxFlags::TX_ACCEL_1 = ::llcpp::fuchsia::hardware::network::TxFlags(2u);
constexpr const ::llcpp::fuchsia::hardware::network::TxFlags TxFlags::TX_ACCEL_2 = ::llcpp::fuchsia::hardware::network::TxFlags(4u);
constexpr const ::llcpp::fuchsia::hardware::network::TxFlags TxFlags::TX_ACCEL_3 = ::llcpp::fuchsia::hardware::network::TxFlags(8u);
constexpr const ::llcpp::fuchsia::hardware::network::TxFlags TxFlags::TX_ACCEL_4 = ::llcpp::fuchsia::hardware::network::TxFlags(16u);
constexpr const ::llcpp::fuchsia::hardware::network::TxFlags TxFlags::TX_ACCEL_5 = ::llcpp::fuchsia::hardware::network::TxFlags(32u);
constexpr const ::llcpp::fuchsia::hardware::network::TxFlags TxFlags::TX_ACCEL_6 = ::llcpp::fuchsia::hardware::network::TxFlags(64u);
constexpr const ::llcpp::fuchsia::hardware::network::TxFlags TxFlags::TX_ACCEL_7 = ::llcpp::fuchsia::hardware::network::TxFlags(128u);
constexpr const ::llcpp::fuchsia::hardware::network::TxFlags TxFlags::TX_ACCEL_8 = ::llcpp::fuchsia::hardware::network::TxFlags(256u);
constexpr const ::llcpp::fuchsia::hardware::network::TxFlags TxFlags::TX_ACCEL_9 = ::llcpp::fuchsia::hardware::network::TxFlags(512u);
constexpr const ::llcpp::fuchsia::hardware::network::TxFlags TxFlags::TX_ACCEL_10 = ::llcpp::fuchsia::hardware::network::TxFlags(1024u);
constexpr const ::llcpp::fuchsia::hardware::network::TxFlags TxFlags::TX_ACCEL_11 = ::llcpp::fuchsia::hardware::network::TxFlags(2048u);
constexpr const ::llcpp::fuchsia::hardware::network::TxFlags TxFlags::TX_ACCEL_12 = ::llcpp::fuchsia::hardware::network::TxFlags(4096u);
constexpr const ::llcpp::fuchsia::hardware::network::TxFlags TxFlags::TX_ACCEL_13 = ::llcpp::fuchsia::hardware::network::TxFlags(8192u);
constexpr const ::llcpp::fuchsia::hardware::network::TxFlags TxFlags::TX_ACCEL_14 = ::llcpp::fuchsia::hardware::network::TxFlags(16384u);
constexpr const ::llcpp::fuchsia::hardware::network::TxFlags TxFlags::TX_ACCEL_15 = ::llcpp::fuchsia::hardware::network::TxFlags(32768u);
constexpr const ::llcpp::fuchsia::hardware::network::TxFlags TxFlags::mask = ::llcpp::fuchsia::hardware::network::TxFlags(65535u);

constexpr inline ::llcpp::fuchsia::hardware::network::TxFlags TxFlags::operator~() const {
  return ::llcpp::fuchsia::hardware::network::TxFlags(static_cast<uint32_t>(~this->value_ & mask.value_));
}

constexpr inline ::llcpp::fuchsia::hardware::network::TxFlags TxFlags::operator|(
    const ::llcpp::fuchsia::hardware::network::TxFlags& other) const {
  return ::llcpp::fuchsia::hardware::network::TxFlags(static_cast<uint32_t>(this->value_ | other.value_));
}

constexpr inline ::llcpp::fuchsia::hardware::network::TxFlags TxFlags::operator&(
    const ::llcpp::fuchsia::hardware::network::TxFlags& other) const {
  return ::llcpp::fuchsia::hardware::network::TxFlags(static_cast<uint32_t>(this->value_ & other.value_));
}

constexpr inline ::llcpp::fuchsia::hardware::network::TxFlags TxFlags::operator^(
    const ::llcpp::fuchsia::hardware::network::TxFlags& other) const {
  return ::llcpp::fuchsia::hardware::network::TxFlags(static_cast<uint32_t>(this->value_ ^ other.value_));
}

constexpr inline void TxFlags::operator|=(
    const ::llcpp::fuchsia::hardware::network::TxFlags& other) {
  this->value_ |= other.value_;
}

constexpr inline void TxFlags::operator&=(
    const ::llcpp::fuchsia::hardware::network::TxFlags& other) {
  this->value_ &= other.value_;
}

constexpr inline void TxFlags::operator^=(
    const ::llcpp::fuchsia::hardware::network::TxFlags& other) {
  this->value_ ^= other.value_;
}

enum class TxAcceleration : uint8_t {
  COMPUTE_ETHERNET_FCS = 0u,
  COMPUTE_IPV4_CHECKSUM = 1u,
  COMPUTE_TCP_CHECKSUM = 2u,
  COMPUTE_UDP_CHECKSUM = 3u,
};


class StatusFlags final {
public:
  constexpr StatusFlags() : value_(0u) {}
  explicit constexpr StatusFlags(uint32_t value) : value_(value) {}
  const static StatusFlags ONLINE;
  const static StatusFlags mask;

  explicit constexpr inline operator uint32_t() const { return value_; }
  explicit constexpr inline operator bool() const { return static_cast<bool>(value_); }
  constexpr inline bool operator==(const StatusFlags& other) const { return value_ == other.value_; }
  constexpr inline bool operator!=(const StatusFlags& other) const { return value_ != other.value_; }
  constexpr inline StatusFlags operator~() const;
  constexpr inline StatusFlags operator|(const StatusFlags& other) const;
  constexpr inline StatusFlags operator&(const StatusFlags& other) const;
  constexpr inline StatusFlags operator^(const StatusFlags& other) const;
  constexpr inline void operator|=(const StatusFlags& other);
  constexpr inline void operator&=(const StatusFlags& other);
  constexpr inline void operator^=(const StatusFlags& other);

private:
  uint32_t value_;
};
constexpr const ::llcpp::fuchsia::hardware::network::StatusFlags StatusFlags::ONLINE = ::llcpp::fuchsia::hardware::network::StatusFlags(1u);
constexpr const ::llcpp::fuchsia::hardware::network::StatusFlags StatusFlags::mask = ::llcpp::fuchsia::hardware::network::StatusFlags(1u);

constexpr inline ::llcpp::fuchsia::hardware::network::StatusFlags StatusFlags::operator~() const {
  return ::llcpp::fuchsia::hardware::network::StatusFlags(static_cast<uint32_t>(~this->value_ & mask.value_));
}

constexpr inline ::llcpp::fuchsia::hardware::network::StatusFlags StatusFlags::operator|(
    const ::llcpp::fuchsia::hardware::network::StatusFlags& other) const {
  return ::llcpp::fuchsia::hardware::network::StatusFlags(static_cast<uint32_t>(this->value_ | other.value_));
}

constexpr inline ::llcpp::fuchsia::hardware::network::StatusFlags StatusFlags::operator&(
    const ::llcpp::fuchsia::hardware::network::StatusFlags& other) const {
  return ::llcpp::fuchsia::hardware::network::StatusFlags(static_cast<uint32_t>(this->value_ & other.value_));
}

constexpr inline ::llcpp::fuchsia::hardware::network::StatusFlags StatusFlags::operator^(
    const ::llcpp::fuchsia::hardware::network::StatusFlags& other) const {
  return ::llcpp::fuchsia::hardware::network::StatusFlags(static_cast<uint32_t>(this->value_ ^ other.value_));
}

constexpr inline void StatusFlags::operator|=(
    const ::llcpp::fuchsia::hardware::network::StatusFlags& other) {
  this->value_ |= other.value_;
}

constexpr inline void StatusFlags::operator&=(
    const ::llcpp::fuchsia::hardware::network::StatusFlags& other) {
  this->value_ &= other.value_;
}

constexpr inline void StatusFlags::operator^=(
    const ::llcpp::fuchsia::hardware::network::StatusFlags& other) {
  this->value_ ^= other.value_;
}

struct Status;
class Session;
class DeviceInstance;
class StatusWatcher;
class SessionFlags final {
public:
  constexpr SessionFlags() : value_(0u) {}
  explicit constexpr SessionFlags(uint16_t value) : value_(value) {}
  const static SessionFlags PRIMARY;
  const static SessionFlags LISTEN_TX;
  const static SessionFlags REPORT_INVALID_RX;
  const static SessionFlags mask;

  explicit constexpr inline operator uint16_t() const { return value_; }
  explicit constexpr inline operator bool() const { return static_cast<bool>(value_); }
  constexpr inline bool operator==(const SessionFlags& other) const { return value_ == other.value_; }
  constexpr inline bool operator!=(const SessionFlags& other) const { return value_ != other.value_; }
  constexpr inline SessionFlags operator~() const;
  constexpr inline SessionFlags operator|(const SessionFlags& other) const;
  constexpr inline SessionFlags operator&(const SessionFlags& other) const;
  constexpr inline SessionFlags operator^(const SessionFlags& other) const;
  constexpr inline void operator|=(const SessionFlags& other);
  constexpr inline void operator&=(const SessionFlags& other);
  constexpr inline void operator^=(const SessionFlags& other);

private:
  uint16_t value_;
};
constexpr const ::llcpp::fuchsia::hardware::network::SessionFlags SessionFlags::PRIMARY = ::llcpp::fuchsia::hardware::network::SessionFlags(1u);
constexpr const ::llcpp::fuchsia::hardware::network::SessionFlags SessionFlags::LISTEN_TX = ::llcpp::fuchsia::hardware::network::SessionFlags(2u);
constexpr const ::llcpp::fuchsia::hardware::network::SessionFlags SessionFlags::REPORT_INVALID_RX = ::llcpp::fuchsia::hardware::network::SessionFlags(4u);
constexpr const ::llcpp::fuchsia::hardware::network::SessionFlags SessionFlags::mask = ::llcpp::fuchsia::hardware::network::SessionFlags(7u);

constexpr inline ::llcpp::fuchsia::hardware::network::SessionFlags SessionFlags::operator~() const {
  return ::llcpp::fuchsia::hardware::network::SessionFlags(static_cast<uint16_t>(~this->value_ & mask.value_));
}

constexpr inline ::llcpp::fuchsia::hardware::network::SessionFlags SessionFlags::operator|(
    const ::llcpp::fuchsia::hardware::network::SessionFlags& other) const {
  return ::llcpp::fuchsia::hardware::network::SessionFlags(static_cast<uint16_t>(this->value_ | other.value_));
}

constexpr inline ::llcpp::fuchsia::hardware::network::SessionFlags SessionFlags::operator&(
    const ::llcpp::fuchsia::hardware::network::SessionFlags& other) const {
  return ::llcpp::fuchsia::hardware::network::SessionFlags(static_cast<uint16_t>(this->value_ & other.value_));
}

constexpr inline ::llcpp::fuchsia::hardware::network::SessionFlags SessionFlags::operator^(
    const ::llcpp::fuchsia::hardware::network::SessionFlags& other) const {
  return ::llcpp::fuchsia::hardware::network::SessionFlags(static_cast<uint16_t>(this->value_ ^ other.value_));
}

constexpr inline void SessionFlags::operator|=(
    const ::llcpp::fuchsia::hardware::network::SessionFlags& other) {
  this->value_ |= other.value_;
}

constexpr inline void SessionFlags::operator&=(
    const ::llcpp::fuchsia::hardware::network::SessionFlags& other) {
  this->value_ &= other.value_;
}

constexpr inline void SessionFlags::operator^=(
    const ::llcpp::fuchsia::hardware::network::SessionFlags& other) {
  this->value_ ^= other.value_;
}

class RxFlags final {
public:
  constexpr RxFlags() : value_(0u) {}
  explicit constexpr RxFlags(uint32_t value) : value_(value) {}
  const static RxFlags RX_ACCEL_0;
  const static RxFlags RX_ACCEL_1;
  const static RxFlags RX_ACCEL_2;
  const static RxFlags RX_ACCEL_3;
  const static RxFlags RX_ACCEL_4;
  const static RxFlags RX_ACCEL_5;
  const static RxFlags RX_ACCEL_6;
  const static RxFlags RX_ACCEL_7;
  const static RxFlags RX_ACCEL_8;
  const static RxFlags RX_ACCEL_9;
  const static RxFlags RX_ACCEL_10;
  const static RxFlags RX_ACCEL_11;
  const static RxFlags RX_ACCEL_12;
  const static RxFlags RX_ACCEL_13;
  const static RxFlags RX_ACCEL_14;
  const static RxFlags RX_ACCEL_15;
  const static RxFlags RX_OVERRUN;
  const static RxFlags RX_VALIDATION_ERROR;
  const static RxFlags RX_ECHOED_TX;
  const static RxFlags mask;

  explicit constexpr inline operator uint32_t() const { return value_; }
  explicit constexpr inline operator bool() const { return static_cast<bool>(value_); }
  constexpr inline bool operator==(const RxFlags& other) const { return value_ == other.value_; }
  constexpr inline bool operator!=(const RxFlags& other) const { return value_ != other.value_; }
  constexpr inline RxFlags operator~() const;
  constexpr inline RxFlags operator|(const RxFlags& other) const;
  constexpr inline RxFlags operator&(const RxFlags& other) const;
  constexpr inline RxFlags operator^(const RxFlags& other) const;
  constexpr inline void operator|=(const RxFlags& other);
  constexpr inline void operator&=(const RxFlags& other);
  constexpr inline void operator^=(const RxFlags& other);

private:
  uint32_t value_;
};
constexpr const ::llcpp::fuchsia::hardware::network::RxFlags RxFlags::RX_ACCEL_0 = ::llcpp::fuchsia::hardware::network::RxFlags(1u);
constexpr const ::llcpp::fuchsia::hardware::network::RxFlags RxFlags::RX_ACCEL_1 = ::llcpp::fuchsia::hardware::network::RxFlags(2u);
constexpr const ::llcpp::fuchsia::hardware::network::RxFlags RxFlags::RX_ACCEL_2 = ::llcpp::fuchsia::hardware::network::RxFlags(4u);
constexpr const ::llcpp::fuchsia::hardware::network::RxFlags RxFlags::RX_ACCEL_3 = ::llcpp::fuchsia::hardware::network::RxFlags(8u);
constexpr const ::llcpp::fuchsia::hardware::network::RxFlags RxFlags::RX_ACCEL_4 = ::llcpp::fuchsia::hardware::network::RxFlags(16u);
constexpr const ::llcpp::fuchsia::hardware::network::RxFlags RxFlags::RX_ACCEL_5 = ::llcpp::fuchsia::hardware::network::RxFlags(32u);
constexpr const ::llcpp::fuchsia::hardware::network::RxFlags RxFlags::RX_ACCEL_6 = ::llcpp::fuchsia::hardware::network::RxFlags(64u);
constexpr const ::llcpp::fuchsia::hardware::network::RxFlags RxFlags::RX_ACCEL_7 = ::llcpp::fuchsia::hardware::network::RxFlags(128u);
constexpr const ::llcpp::fuchsia::hardware::network::RxFlags RxFlags::RX_ACCEL_8 = ::llcpp::fuchsia::hardware::network::RxFlags(256u);
constexpr const ::llcpp::fuchsia::hardware::network::RxFlags RxFlags::RX_ACCEL_9 = ::llcpp::fuchsia::hardware::network::RxFlags(512u);
constexpr const ::llcpp::fuchsia::hardware::network::RxFlags RxFlags::RX_ACCEL_10 = ::llcpp::fuchsia::hardware::network::RxFlags(1024u);
constexpr const ::llcpp::fuchsia::hardware::network::RxFlags RxFlags::RX_ACCEL_11 = ::llcpp::fuchsia::hardware::network::RxFlags(2048u);
constexpr const ::llcpp::fuchsia::hardware::network::RxFlags RxFlags::RX_ACCEL_12 = ::llcpp::fuchsia::hardware::network::RxFlags(4096u);
constexpr const ::llcpp::fuchsia::hardware::network::RxFlags RxFlags::RX_ACCEL_13 = ::llcpp::fuchsia::hardware::network::RxFlags(8192u);
constexpr const ::llcpp::fuchsia::hardware::network::RxFlags RxFlags::RX_ACCEL_14 = ::llcpp::fuchsia::hardware::network::RxFlags(16384u);
constexpr const ::llcpp::fuchsia::hardware::network::RxFlags RxFlags::RX_ACCEL_15 = ::llcpp::fuchsia::hardware::network::RxFlags(32768u);
constexpr const ::llcpp::fuchsia::hardware::network::RxFlags RxFlags::RX_OVERRUN = ::llcpp::fuchsia::hardware::network::RxFlags(536870912u);
constexpr const ::llcpp::fuchsia::hardware::network::RxFlags RxFlags::RX_VALIDATION_ERROR = ::llcpp::fuchsia::hardware::network::RxFlags(1073741824u);
constexpr const ::llcpp::fuchsia::hardware::network::RxFlags RxFlags::RX_ECHOED_TX = ::llcpp::fuchsia::hardware::network::RxFlags(2147483648u);
constexpr const ::llcpp::fuchsia::hardware::network::RxFlags RxFlags::mask = ::llcpp::fuchsia::hardware::network::RxFlags(3758161919u);

constexpr inline ::llcpp::fuchsia::hardware::network::RxFlags RxFlags::operator~() const {
  return ::llcpp::fuchsia::hardware::network::RxFlags(static_cast<uint32_t>(~this->value_ & mask.value_));
}

constexpr inline ::llcpp::fuchsia::hardware::network::RxFlags RxFlags::operator|(
    const ::llcpp::fuchsia::hardware::network::RxFlags& other) const {
  return ::llcpp::fuchsia::hardware::network::RxFlags(static_cast<uint32_t>(this->value_ | other.value_));
}

constexpr inline ::llcpp::fuchsia::hardware::network::RxFlags RxFlags::operator&(
    const ::llcpp::fuchsia::hardware::network::RxFlags& other) const {
  return ::llcpp::fuchsia::hardware::network::RxFlags(static_cast<uint32_t>(this->value_ & other.value_));
}

constexpr inline ::llcpp::fuchsia::hardware::network::RxFlags RxFlags::operator^(
    const ::llcpp::fuchsia::hardware::network::RxFlags& other) const {
  return ::llcpp::fuchsia::hardware::network::RxFlags(static_cast<uint32_t>(this->value_ ^ other.value_));
}

constexpr inline void RxFlags::operator|=(
    const ::llcpp::fuchsia::hardware::network::RxFlags& other) {
  this->value_ |= other.value_;
}

constexpr inline void RxFlags::operator&=(
    const ::llcpp::fuchsia::hardware::network::RxFlags& other) {
  this->value_ &= other.value_;
}

constexpr inline void RxFlags::operator^=(
    const ::llcpp::fuchsia::hardware::network::RxFlags& other) {
  this->value_ ^= other.value_;
}

enum class RxAcceleration : uint8_t {
  VALIDATED_ETHERNET_FCS = 0u,
  VALIDATED_IPV4_CHECKSUM = 1u,
  VALIDATED_TCP_CHECKSUM = 2u,
  VALIDATED_UDP_CHECKSUM = 3u,
};


enum class MacFilterMode : uint32_t {
  MULTICAST_FILTER = 0u,
  MULTICAST_PROMISCUOUS = 1u,
  PROMISCUOUS = 2u,
};


class MacAddressing;
enum class InfoType : uint32_t {
  NO_INFO = 0u,
};


enum class FrameType : uint8_t {
  ETHERNET = 1u,
  IPV4 = 2u,
  IPV6 = 3u,
};


struct SessionInfo;
struct FrameTypeSupport;
struct Fifos;
struct Device_OpenSession_Response;
struct Device_OpenSession_Result;
class EthernetFeatures final {
public:
  constexpr EthernetFeatures() : value_(0u) {}
  explicit constexpr EthernetFeatures(uint32_t value) : value_(value) {}
  const static EthernetFeatures RAW;
  const static EthernetFeatures ETHERNET_II;
  const static EthernetFeatures E_802_1_Q;
  const static EthernetFeatures E_802_1_Q_IN_Q;
  const static EthernetFeatures E_802_3_LLC_SNAP;
  const static EthernetFeatures mask;

  explicit constexpr inline operator uint32_t() const { return value_; }
  explicit constexpr inline operator bool() const { return static_cast<bool>(value_); }
  constexpr inline bool operator==(const EthernetFeatures& other) const { return value_ == other.value_; }
  constexpr inline bool operator!=(const EthernetFeatures& other) const { return value_ != other.value_; }
  constexpr inline EthernetFeatures operator~() const;
  constexpr inline EthernetFeatures operator|(const EthernetFeatures& other) const;
  constexpr inline EthernetFeatures operator&(const EthernetFeatures& other) const;
  constexpr inline EthernetFeatures operator^(const EthernetFeatures& other) const;
  constexpr inline void operator|=(const EthernetFeatures& other);
  constexpr inline void operator&=(const EthernetFeatures& other);
  constexpr inline void operator^=(const EthernetFeatures& other);

private:
  uint32_t value_;
};
constexpr const ::llcpp::fuchsia::hardware::network::EthernetFeatures EthernetFeatures::RAW = ::llcpp::fuchsia::hardware::network::EthernetFeatures(1u);
constexpr const ::llcpp::fuchsia::hardware::network::EthernetFeatures EthernetFeatures::ETHERNET_II = ::llcpp::fuchsia::hardware::network::EthernetFeatures(2u);
constexpr const ::llcpp::fuchsia::hardware::network::EthernetFeatures EthernetFeatures::E_802_1_Q = ::llcpp::fuchsia::hardware::network::EthernetFeatures(4u);
constexpr const ::llcpp::fuchsia::hardware::network::EthernetFeatures EthernetFeatures::E_802_1_Q_IN_Q = ::llcpp::fuchsia::hardware::network::EthernetFeatures(8u);
constexpr const ::llcpp::fuchsia::hardware::network::EthernetFeatures EthernetFeatures::E_802_3_LLC_SNAP = ::llcpp::fuchsia::hardware::network::EthernetFeatures(16u);
constexpr const ::llcpp::fuchsia::hardware::network::EthernetFeatures EthernetFeatures::mask = ::llcpp::fuchsia::hardware::network::EthernetFeatures(31u);

constexpr inline ::llcpp::fuchsia::hardware::network::EthernetFeatures EthernetFeatures::operator~() const {
  return ::llcpp::fuchsia::hardware::network::EthernetFeatures(static_cast<uint32_t>(~this->value_ & mask.value_));
}

constexpr inline ::llcpp::fuchsia::hardware::network::EthernetFeatures EthernetFeatures::operator|(
    const ::llcpp::fuchsia::hardware::network::EthernetFeatures& other) const {
  return ::llcpp::fuchsia::hardware::network::EthernetFeatures(static_cast<uint32_t>(this->value_ | other.value_));
}

constexpr inline ::llcpp::fuchsia::hardware::network::EthernetFeatures EthernetFeatures::operator&(
    const ::llcpp::fuchsia::hardware::network::EthernetFeatures& other) const {
  return ::llcpp::fuchsia::hardware::network::EthernetFeatures(static_cast<uint32_t>(this->value_ & other.value_));
}

constexpr inline ::llcpp::fuchsia::hardware::network::EthernetFeatures EthernetFeatures::operator^(
    const ::llcpp::fuchsia::hardware::network::EthernetFeatures& other) const {
  return ::llcpp::fuchsia::hardware::network::EthernetFeatures(static_cast<uint32_t>(this->value_ ^ other.value_));
}

constexpr inline void EthernetFeatures::operator|=(
    const ::llcpp::fuchsia::hardware::network::EthernetFeatures& other) {
  this->value_ |= other.value_;
}

constexpr inline void EthernetFeatures::operator&=(
    const ::llcpp::fuchsia::hardware::network::EthernetFeatures& other) {
  this->value_ &= other.value_;
}

constexpr inline void EthernetFeatures::operator^=(
    const ::llcpp::fuchsia::hardware::network::EthernetFeatures& other) {
  this->value_ ^= other.value_;
}

enum class DeviceClass : uint16_t {
  UNKNOWN = 0u,
  ETHERNET = 1u,
  WLAN = 2u,
  PPP = 3u,
  BRIDGE = 4u,
};


struct Info;
class Device;

extern "C" const fidl_type_t v1_fuchsia_hardware_network_StatusTable;

// Dynamic device information.
struct Status final : private ::fidl::VectorView<fidl_envelope_t> {
  using EnvelopesView = ::fidl::VectorView<fidl_envelope_t>;
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return EnvelopesView::empty(); }

  // Device status flags.
  const ::llcpp::fuchsia::hardware::network::StatusFlags& flags() const {
    ZX_ASSERT(has_flags());
    return *reinterpret_cast<const ::llcpp::fuchsia::hardware::network::StatusFlags*>(EnvelopesView::at(1 - 1).data);
  }
  ::llcpp::fuchsia::hardware::network::StatusFlags& flags() {
    ZX_ASSERT(has_flags());
    return *reinterpret_cast<::llcpp::fuchsia::hardware::network::StatusFlags*>(EnvelopesView::at(1 - 1).data);
  }
  bool has_flags() const {
    return EnvelopesView::count() >= 1 && EnvelopesView::at(1 - 1).data != nullptr;
  }

  // Maximum transmit unit for this device, in bytes. The reported `MTU` is the size of an ENTIRE
  // frame, including any header and trailer bytes for whatever protocol the
  // [`fuchsia.hardware.network/FrameType`]s of this device support.
  const uint32_t& mtu() const {
    ZX_ASSERT(has_mtu());
    return *reinterpret_cast<const uint32_t*>(EnvelopesView::at(2 - 1).data);
  }
  uint32_t& mtu() {
    ZX_ASSERT(has_mtu());
    return *reinterpret_cast<uint32_t*>(EnvelopesView::at(2 - 1).data);
  }
  bool has_mtu() const {
    return EnvelopesView::count() >= 2 && EnvelopesView::at(2 - 1).data != nullptr;
  }

  Status() = default;
  ~Status() = default;
  Status(Status&& other) noexcept = default;
  Status& operator=(Status&& other) noexcept = default;

  class Builder;
  friend class Builder;
  static Builder Build();
  static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_network_StatusTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 48;
  static constexpr bool HasPointer = true;

 private:
  Status(uint64_t max_ordinal, fidl_envelope_t* data) : EnvelopesView(data, max_ordinal) {}
};

class Status::Builder {
 public:
  Status view() { return Status(max_ordinal_, envelopes_.data_); }
  ~Builder() = default;
  Builder(Builder&& other) noexcept = default;
  Builder& operator=(Builder&& other) noexcept = default;

  // Device status flags.
  Builder&& set_flags(::llcpp::fuchsia::hardware::network::StatusFlags* elem);

  // Maximum transmit unit for this device, in bytes. The reported `MTU` is the size of an ENTIRE
  // frame, including any header and trailer bytes for whatever protocol the
  // [`fuchsia.hardware.network/FrameType`]s of this device support.
  Builder&& set_mtu(uint32_t* elem);

 private:
  Builder() = default;
  friend Builder Status::Build();

  uint64_t max_ordinal_ = 0;
  ::fidl::Array<fidl_envelope_t, 2> envelopes_ = {};
};

extern "C" const fidl_type_t v1_fuchsia_hardware_network_Device_OpenSession_ResultTable;

struct Device_OpenSession_Result {
  Device_OpenSession_Result() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal() == Ordinal::kResponse; }

  static Device_OpenSession_Result WithResponse(::llcpp::fuchsia::hardware::network::Device_OpenSession_Response* val) {
    Device_OpenSession_Result result;
    result.set_response(val);
    return result;
  }

  void set_response(::llcpp::fuchsia::hardware::network::Device_OpenSession_Response* elem) {
    ordinal_ = Ordinal::kResponse;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::hardware::network::Device_OpenSession_Response& mutable_response() {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::hardware::network::Device_OpenSession_Response*>(envelope_.data);
  }
  const ::llcpp::fuchsia::hardware::network::Device_OpenSession_Response& response() const {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::hardware::network::Device_OpenSession_Response*>(envelope_.data);
  }

  bool is_err() const { return ordinal() == Ordinal::kErr; }

  static Device_OpenSession_Result WithErr(int32_t* val) {
    Device_OpenSession_Result result;
    result.set_err(val);
    return result;
  }

  void set_err(int32_t* elem) {
    ordinal_ = Ordinal::kErr;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_err() {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_network_Device_OpenSession_ResultTable;
  static constexpr uint32_t MaxNumHandles = 3;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 16;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_fuchsia_hardware_network_SessionSetPausedRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_SessionSetPausedResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_SessionCloseRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_SessionCloseResponseTable;

// Represents a session with a Network device.
// A session has a data plane and a control plane. The `Session` protocol represents the control
// plane of the session and the FIFOs and VMOs exchanged during the
// [`fuchsia.hardware.network/Device.OpenSession`] call are the data plane. Lifetime of the session
// is controlled by a `Session` protocol handle. Sessions are always created in a paused state.
class Session final {
  Session() = delete;
 public:

  struct SetPausedRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    bool paused;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_network_SessionSetPausedRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  using CloseRequest = ::fidl::AnyZeroArgMessage;


  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    class SetPaused_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      SetPaused_Impl(::zx::unowned_channel _client_end, bool paused);
      ~SetPaused_Impl() = default;
      SetPaused_Impl(SetPaused_Impl&& other) = default;
      SetPaused_Impl& operator=(SetPaused_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class Close_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Close_Impl(::zx::unowned_channel _client_end);
      ~Close_Impl() = default;
      Close_Impl(Close_Impl&& other) = default;
      Close_Impl& operator=(Close_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };

   public:
    using SetPaused = SetPaused_Impl;
    using Close = Close_Impl;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    class SetPaused_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      SetPaused_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, bool paused);
      ~SetPaused_Impl() = default;
      SetPaused_Impl(SetPaused_Impl&& other) = default;
      SetPaused_Impl& operator=(SetPaused_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class Close_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Close_Impl(::zx::unowned_channel _client_end);
      ~Close_Impl() = default;
      Close_Impl(Close_Impl&& other) = default;
      Close_Impl& operator=(Close_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };

   public:
    using SetPaused = SetPaused_Impl;
    using Close = Close_Impl;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Pauses or unpauses reception of frames on this session.
    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::SetPaused SetPaused(bool paused);

    // Pauses or unpauses reception of frames on this session.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetPaused SetPaused(::fidl::BytePart _request_buffer, bool paused);

    // Cleanly closes a session. This will cause the session to send a `ZX_ERR_CANCELLED` epitaph
    // and proceed to close the Session channel. Clients may only assume that they own all the
    // buffers that are currently owned by the session (sent over either the Rx or Tx FIFOs) once
    // the epitaph is received. Closing the Rx or Tx FIFO is equivalent to calling `Close`.
    // Allocates 16 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Close Close();


   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Pauses or unpauses reception of frames on this session.
    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::SetPaused SetPaused(::zx::unowned_channel _client_end, bool paused);

    // Pauses or unpauses reception of frames on this session.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetPaused SetPaused(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, bool paused);

    // Cleanly closes a session. This will cause the session to send a `ZX_ERR_CANCELLED` epitaph
    // and proceed to close the Session channel. Clients may only assume that they own all the
    // buffers that are currently owned by the session (sent over either the Rx or Tx FIFOs) once
    // the epitaph is received. Closing the Rx or Tx FIFO is equivalent to calling `Close`.
    // Allocates 16 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Close Close(::zx::unowned_channel _client_end);


  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Pauses or unpauses reception of frames on this session.
    static ::fidl::internal::StatusAndError SetPaused(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetPausedRequest> params);

    // Cleanly closes a session. This will cause the session to send a `ZX_ERR_CANCELLED` epitaph
    // and proceed to close the Session channel. Clients may only assume that they own all the
    // buffers that are currently owned by the session (sent over either the Rx or Tx FIFOs) once
    // the epitaph is received. Closing the Rx or Tx FIFO is equivalent to calling `Close`.
    static ::fidl::internal::StatusAndError Close(::zx::unowned_channel _client_end);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Session;
    using _Base = ::fidl::CompleterBase;

    using SetPausedCompleter = ::fidl::Completer<>;

    virtual void SetPaused(bool paused, SetPausedCompleter::Sync _completer) = 0;

    using CloseCompleter = ::fidl::Completer<>;

    virtual void Close(CloseCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void SetPausedRequest(const ::fidl::DecodedMessage<Session::SetPausedRequest>& _msg);
    static void CloseRequest(const ::fidl::DecodedMessage<Session::CloseRequest>& _msg);
  };
};

extern "C" const fidl_type_t v1_fuchsia_hardware_network_DeviceInstanceGetDeviceRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_DeviceInstanceGetDeviceResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_DeviceInstanceGetMacAddressingRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_DeviceInstanceGetMacAddressingResponseTable;

// An instance of a network device that may be capable of MAC address filtering.
class DeviceInstance final {
  DeviceInstance() = delete;
 public:

  struct GetDeviceRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::channel device;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_network_DeviceInstanceGetDeviceRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct GetMacAddressingRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::channel mac;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_network_DeviceInstanceGetMacAddressingRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };


  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    class GetDevice_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      GetDevice_Impl(::zx::unowned_channel _client_end, ::zx::channel device);
      ~GetDevice_Impl() = default;
      GetDevice_Impl(GetDevice_Impl&& other) = default;
      GetDevice_Impl& operator=(GetDevice_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class GetMacAddressing_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      GetMacAddressing_Impl(::zx::unowned_channel _client_end, ::zx::channel mac);
      ~GetMacAddressing_Impl() = default;
      GetMacAddressing_Impl(GetMacAddressing_Impl&& other) = default;
      GetMacAddressing_Impl& operator=(GetMacAddressing_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };

   public:
    using GetDevice = GetDevice_Impl;
    using GetMacAddressing = GetMacAddressing_Impl;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    class GetDevice_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      GetDevice_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel device);
      ~GetDevice_Impl() = default;
      GetDevice_Impl(GetDevice_Impl&& other) = default;
      GetDevice_Impl& operator=(GetDevice_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class GetMacAddressing_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      GetMacAddressing_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel mac);
      ~GetMacAddressing_Impl() = default;
      GetMacAddressing_Impl(GetMacAddressing_Impl&& other) = default;
      GetMacAddressing_Impl& operator=(GetMacAddressing_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };

   public:
    using GetDevice = GetDevice_Impl;
    using GetMacAddressing = GetMacAddressing_Impl;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Connects to the [`fuchsia.hardware.network/Device`] implementation, giving access to
    // data-plane features.
    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetDevice GetDevice(::zx::channel device);

    // Connects to the [`fuchsia.hardware.network/Device`] implementation, giving access to
    // data-plane features.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetDevice GetDevice(::fidl::BytePart _request_buffer, ::zx::channel device);

    // Connects to the [`fuchsia.hardware.network/MacAddressing`] implementation, giving access to
    // MAC filtering control. `DeviceInstance`s that do not support `MacAddressing` will have the
    // request immediately closed.
    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetMacAddressing GetMacAddressing(::zx::channel mac);

    // Connects to the [`fuchsia.hardware.network/MacAddressing`] implementation, giving access to
    // MAC filtering control. `DeviceInstance`s that do not support `MacAddressing` will have the
    // request immediately closed.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetMacAddressing GetMacAddressing(::fidl::BytePart _request_buffer, ::zx::channel mac);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Connects to the [`fuchsia.hardware.network/Device`] implementation, giving access to
    // data-plane features.
    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetDevice GetDevice(::zx::unowned_channel _client_end, ::zx::channel device);

    // Connects to the [`fuchsia.hardware.network/Device`] implementation, giving access to
    // data-plane features.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetDevice GetDevice(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel device);

    // Connects to the [`fuchsia.hardware.network/MacAddressing`] implementation, giving access to
    // MAC filtering control. `DeviceInstance`s that do not support `MacAddressing` will have the
    // request immediately closed.
    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetMacAddressing GetMacAddressing(::zx::unowned_channel _client_end, ::zx::channel mac);

    // Connects to the [`fuchsia.hardware.network/MacAddressing`] implementation, giving access to
    // MAC filtering control. `DeviceInstance`s that do not support `MacAddressing` will have the
    // request immediately closed.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetMacAddressing GetMacAddressing(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel mac);

  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Connects to the [`fuchsia.hardware.network/Device`] implementation, giving access to
    // data-plane features.
    static ::fidl::internal::StatusAndError GetDevice(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetDeviceRequest> params);

    // Connects to the [`fuchsia.hardware.network/MacAddressing`] implementation, giving access to
    // MAC filtering control. `DeviceInstance`s that do not support `MacAddressing` will have the
    // request immediately closed.
    static ::fidl::internal::StatusAndError GetMacAddressing(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetMacAddressingRequest> params);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = DeviceInstance;
    using _Base = ::fidl::CompleterBase;

    using GetDeviceCompleter = ::fidl::Completer<>;

    virtual void GetDevice(::zx::channel device, GetDeviceCompleter::Sync _completer) = 0;

    using GetMacAddressingCompleter = ::fidl::Completer<>;

    virtual void GetMacAddressing(::zx::channel mac, GetMacAddressingCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void GetDeviceRequest(const ::fidl::DecodedMessage<DeviceInstance::GetDeviceRequest>& _msg);
    static void GetMacAddressingRequest(const ::fidl::DecodedMessage<DeviceInstance::GetMacAddressingRequest>& _msg);
  };
};

extern "C" const fidl_type_t v1_fuchsia_hardware_network_StatusWatcherWatchStatusRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_StatusWatcherWatchStatusResponseTable;

// Provides a way to receive updates on device status changes.
class StatusWatcher final {
  StatusWatcher() = delete;
 public:

  struct WatchStatusResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::network::Status device_status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_network_StatusWatcherWatchStatusResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 48;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using WatchStatusRequest = ::fidl::AnyZeroArgMessage;


  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    template <typename ResponseType>
    class WatchStatus_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      WatchStatus_Impl(::zx::unowned_channel _client_end);
      ~WatchStatus_Impl() = default;
      WatchStatus_Impl(WatchStatus_Impl&& other) = default;
      WatchStatus_Impl& operator=(WatchStatus_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using WatchStatus = WatchStatus_Impl<WatchStatusResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    template <typename ResponseType>
    class WatchStatus_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      WatchStatus_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~WatchStatus_Impl() = default;
      WatchStatus_Impl(WatchStatus_Impl&& other) = default;
      WatchStatus_Impl& operator=(WatchStatus_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using WatchStatus = WatchStatus_Impl<WatchStatusResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // `WatchStatus` will block until the device's status has changed.
    // The first call to `WatchStatus` will always return immediately with the current device
    // status, subsequent calls will only complete when the device status differs from the last one
    // that was returned through this `StatusWatcher`.
    // If `StatusWatcher` was created with a buffer value larger than 1, `WatchStatus` may return a
    // queued status change, depending on how many status changed happened since the last call to
    // `WatchStatus`.
    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::WatchStatus WatchStatus();

    // `WatchStatus` will block until the device's status has changed.
    // The first call to `WatchStatus` will always return immediately with the current device
    // status, subsequent calls will only complete when the device status differs from the last one
    // that was returned through this `StatusWatcher`.
    // If `StatusWatcher` was created with a buffer value larger than 1, `WatchStatus` may return a
    // queued status change, depending on how many status changed happened since the last call to
    // `WatchStatus`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::WatchStatus WatchStatus(::fidl::BytePart _response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // `WatchStatus` will block until the device's status has changed.
    // The first call to `WatchStatus` will always return immediately with the current device
    // status, subsequent calls will only complete when the device status differs from the last one
    // that was returned through this `StatusWatcher`.
    // If `StatusWatcher` was created with a buffer value larger than 1, `WatchStatus` may return a
    // queued status change, depending on how many status changed happened since the last call to
    // `WatchStatus`.
    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::WatchStatus WatchStatus(::zx::unowned_channel _client_end);

    // `WatchStatus` will block until the device's status has changed.
    // The first call to `WatchStatus` will always return immediately with the current device
    // status, subsequent calls will only complete when the device status differs from the last one
    // that was returned through this `StatusWatcher`.
    // If `StatusWatcher` was created with a buffer value larger than 1, `WatchStatus` may return a
    // queued status change, depending on how many status changed happened since the last call to
    // `WatchStatus`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::WatchStatus WatchStatus(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // `WatchStatus` will block until the device's status has changed.
    // The first call to `WatchStatus` will always return immediately with the current device
    // status, subsequent calls will only complete when the device status differs from the last one
    // that was returned through this `StatusWatcher`.
    // If `StatusWatcher` was created with a buffer value larger than 1, `WatchStatus` may return a
    // queued status change, depending on how many status changed happened since the last call to
    // `WatchStatus`.
    static ::fidl::DecodeResult<WatchStatusResponse> WatchStatus(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = StatusWatcher;
    using _Base = ::fidl::CompleterBase;

    class WatchStatusCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::hardware::network::Status device_status);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::network::Status device_status);
      void Reply(::fidl::DecodedMessage<WatchStatusResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using WatchStatusCompleter = ::fidl::Completer<WatchStatusCompleterBase>;

    virtual void WatchStatus(WatchStatusCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void WatchStatusRequest(const ::fidl::DecodedMessage<StatusWatcher::WatchStatusRequest>& _msg);
    static void WatchStatusResponse(const ::fidl::DecodedMessage<StatusWatcher::WatchStatusResponse>& _msg);
  };
};

extern "C" const fidl_type_t v1_fuchsia_hardware_network_MacAddressingGetUnicastAddressRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_MacAddressingGetUnicastAddressResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_MacAddressingSetModeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_MacAddressingSetModeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_MacAddressingAddMulticastAddressRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_MacAddressingAddMulticastAddressResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_MacAddressingRemoveMulticastAddressRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_MacAddressingRemoveMulticastAddressResponseTable;

class MacAddressing final {
  MacAddressing() = delete;
 public:
  static constexpr char Name[] = "fuchsia.hardware.network.MacAddressing";

  struct GetUnicastAddressResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::net::MacAddress address;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_network_MacAddressingGetUnicastAddressResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetUnicastAddressRequest = ::fidl::AnyZeroArgMessage;

  struct SetModeResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_network_MacAddressingSetModeResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SetModeRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::network::MacFilterMode mode;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_network_MacAddressingSetModeRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SetModeResponse;
  };

  struct AddMulticastAddressResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_network_MacAddressingAddMulticastAddressResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct AddMulticastAddressRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::net::MacAddress address;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_network_MacAddressingAddMulticastAddressRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = AddMulticastAddressResponse;
  };

  struct RemoveMulticastAddressResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_network_MacAddressingRemoveMulticastAddressResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct RemoveMulticastAddressRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::net::MacAddress address;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_network_MacAddressingRemoveMulticastAddressRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = RemoveMulticastAddressResponse;
  };


  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    template <typename ResponseType>
    class GetUnicastAddress_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetUnicastAddress_Impl(::zx::unowned_channel _client_end);
      ~GetUnicastAddress_Impl() = default;
      GetUnicastAddress_Impl(GetUnicastAddress_Impl&& other) = default;
      GetUnicastAddress_Impl& operator=(GetUnicastAddress_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetMode_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      SetMode_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::network::MacFilterMode mode);
      ~SetMode_Impl() = default;
      SetMode_Impl(SetMode_Impl&& other) = default;
      SetMode_Impl& operator=(SetMode_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class AddMulticastAddress_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      AddMulticastAddress_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::net::MacAddress address);
      ~AddMulticastAddress_Impl() = default;
      AddMulticastAddress_Impl(AddMulticastAddress_Impl&& other) = default;
      AddMulticastAddress_Impl& operator=(AddMulticastAddress_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class RemoveMulticastAddress_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      RemoveMulticastAddress_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::net::MacAddress address);
      ~RemoveMulticastAddress_Impl() = default;
      RemoveMulticastAddress_Impl(RemoveMulticastAddress_Impl&& other) = default;
      RemoveMulticastAddress_Impl& operator=(RemoveMulticastAddress_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using GetUnicastAddress = GetUnicastAddress_Impl<GetUnicastAddressResponse>;
    using SetMode = SetMode_Impl<SetModeResponse>;
    using AddMulticastAddress = AddMulticastAddress_Impl<AddMulticastAddressResponse>;
    using RemoveMulticastAddress = RemoveMulticastAddress_Impl<RemoveMulticastAddressResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    template <typename ResponseType>
    class GetUnicastAddress_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetUnicastAddress_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetUnicastAddress_Impl() = default;
      GetUnicastAddress_Impl(GetUnicastAddress_Impl&& other) = default;
      GetUnicastAddress_Impl& operator=(GetUnicastAddress_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetMode_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      SetMode_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::network::MacFilterMode mode, ::fidl::BytePart _response_buffer);
      ~SetMode_Impl() = default;
      SetMode_Impl(SetMode_Impl&& other) = default;
      SetMode_Impl& operator=(SetMode_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class AddMulticastAddress_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      AddMulticastAddress_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::net::MacAddress address, ::fidl::BytePart _response_buffer);
      ~AddMulticastAddress_Impl() = default;
      AddMulticastAddress_Impl(AddMulticastAddress_Impl&& other) = default;
      AddMulticastAddress_Impl& operator=(AddMulticastAddress_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class RemoveMulticastAddress_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      RemoveMulticastAddress_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::net::MacAddress address, ::fidl::BytePart _response_buffer);
      ~RemoveMulticastAddress_Impl() = default;
      RemoveMulticastAddress_Impl(RemoveMulticastAddress_Impl&& other) = default;
      RemoveMulticastAddress_Impl& operator=(RemoveMulticastAddress_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using GetUnicastAddress = GetUnicastAddress_Impl<GetUnicastAddressResponse>;
    using SetMode = SetMode_Impl<SetModeResponse>;
    using AddMulticastAddress = AddMulticastAddress_Impl<AddMulticastAddressResponse>;
    using RemoveMulticastAddress = RemoveMulticastAddress_Impl<RemoveMulticastAddressResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Gets the Device's current unicast MAC address.
    // Implementers of this API do not need to return a uniquely identifiable MAC; the unicast
    // address returned is the one that is *currently* in use to filter unicast frames, or that
    // identifies the device on a link it's *currently* on. Users of this API must not rely on the
    // stability or uniqueness of the returned value to identify or disambiguate device instances.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetUnicastAddress GetUnicastAddress();

    // Gets the Device's current unicast MAC address.
    // Implementers of this API do not need to return a uniquely identifiable MAC; the unicast
    // address returned is the one that is *currently* in use to filter unicast frames, or that
    // identifies the device on a link it's *currently* on. Users of this API must not rely on the
    // stability or uniqueness of the returned value to identify or disambiguate device instances.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetUnicastAddress GetUnicastAddress(::fidl::BytePart _response_buffer);

    // Sets requested operating mode of this device to `mode`.
    //
    // The requested mode is attached to the current client connection to the device. Because
    // multiple clients can be attached to the same device at once, the mode with the least
    // restrictions will be the one actively put into effect into the underlying device
    // implementation.
    //
    // If the device does not support the requested mode, but supports a mode that is more open
    // than the requested one, `SetMode` will succeed regardless. Otherwise, if the device only
    // supports *more restrictive* modes than the one requested, `SetMode` returns
    // `ZX_ERR_NOT_SUPPORTED`.
    //
    // Clients must be aware that the resource being accessed is shared, and that the device may be
    // effectively operating at a more open level than the one that was requested (although never
    // at one more restrictive).
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::SetMode SetMode(::llcpp::fuchsia::hardware::network::MacFilterMode mode);

    // Sets requested operating mode of this device to `mode`.
    //
    // The requested mode is attached to the current client connection to the device. Because
    // multiple clients can be attached to the same device at once, the mode with the least
    // restrictions will be the one actively put into effect into the underlying device
    // implementation.
    //
    // If the device does not support the requested mode, but supports a mode that is more open
    // than the requested one, `SetMode` will succeed regardless. Otherwise, if the device only
    // supports *more restrictive* modes than the one requested, `SetMode` returns
    // `ZX_ERR_NOT_SUPPORTED`.
    //
    // Clients must be aware that the resource being accessed is shared, and that the device may be
    // effectively operating at a more open level than the one that was requested (although never
    // at one more restrictive).
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetMode SetMode(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::network::MacFilterMode mode, ::fidl::BytePart _response_buffer);

    // Adds multicast address to the list of multicast groups.
    //
    // The list of multicast addresses kept is untouched by calls to `SetMode`. If the device's
    // mode is not `MULTICAST_FILTER`, the list of multicast addresses is ignored.
    //
    // Returns `ZX_ERR_INVALID_ARGS` if the provided `address` is not a multicast address.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::AddMulticastAddress AddMulticastAddress(::llcpp::fuchsia::net::MacAddress address);

    // Adds multicast address to the list of multicast groups.
    //
    // The list of multicast addresses kept is untouched by calls to `SetMode`. If the device's
    // mode is not `MULTICAST_FILTER`, the list of multicast addresses is ignored.
    //
    // Returns `ZX_ERR_INVALID_ARGS` if the provided `address` is not a multicast address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::AddMulticastAddress AddMulticastAddress(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::net::MacAddress address, ::fidl::BytePart _response_buffer);

    // Removes multicast address from the list of multicast groups.
    //
    // Returns `ZX_ERR_INVALID_ARGS` if the provided `address` is not a multicast address.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::RemoveMulticastAddress RemoveMulticastAddress(::llcpp::fuchsia::net::MacAddress address);

    // Removes multicast address from the list of multicast groups.
    //
    // Returns `ZX_ERR_INVALID_ARGS` if the provided `address` is not a multicast address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::RemoveMulticastAddress RemoveMulticastAddress(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::net::MacAddress address, ::fidl::BytePart _response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Gets the Device's current unicast MAC address.
    // Implementers of this API do not need to return a uniquely identifiable MAC; the unicast
    // address returned is the one that is *currently* in use to filter unicast frames, or that
    // identifies the device on a link it's *currently* on. Users of this API must not rely on the
    // stability or uniqueness of the returned value to identify or disambiguate device instances.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetUnicastAddress GetUnicastAddress(::zx::unowned_channel _client_end);

    // Gets the Device's current unicast MAC address.
    // Implementers of this API do not need to return a uniquely identifiable MAC; the unicast
    // address returned is the one that is *currently* in use to filter unicast frames, or that
    // identifies the device on a link it's *currently* on. Users of this API must not rely on the
    // stability or uniqueness of the returned value to identify or disambiguate device instances.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetUnicastAddress GetUnicastAddress(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Sets requested operating mode of this device to `mode`.
    //
    // The requested mode is attached to the current client connection to the device. Because
    // multiple clients can be attached to the same device at once, the mode with the least
    // restrictions will be the one actively put into effect into the underlying device
    // implementation.
    //
    // If the device does not support the requested mode, but supports a mode that is more open
    // than the requested one, `SetMode` will succeed regardless. Otherwise, if the device only
    // supports *more restrictive* modes than the one requested, `SetMode` returns
    // `ZX_ERR_NOT_SUPPORTED`.
    //
    // Clients must be aware that the resource being accessed is shared, and that the device may be
    // effectively operating at a more open level than the one that was requested (although never
    // at one more restrictive).
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::SetMode SetMode(::zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::network::MacFilterMode mode);

    // Sets requested operating mode of this device to `mode`.
    //
    // The requested mode is attached to the current client connection to the device. Because
    // multiple clients can be attached to the same device at once, the mode with the least
    // restrictions will be the one actively put into effect into the underlying device
    // implementation.
    //
    // If the device does not support the requested mode, but supports a mode that is more open
    // than the requested one, `SetMode` will succeed regardless. Otherwise, if the device only
    // supports *more restrictive* modes than the one requested, `SetMode` returns
    // `ZX_ERR_NOT_SUPPORTED`.
    //
    // Clients must be aware that the resource being accessed is shared, and that the device may be
    // effectively operating at a more open level than the one that was requested (although never
    // at one more restrictive).
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetMode SetMode(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::network::MacFilterMode mode, ::fidl::BytePart _response_buffer);

    // Adds multicast address to the list of multicast groups.
    //
    // The list of multicast addresses kept is untouched by calls to `SetMode`. If the device's
    // mode is not `MULTICAST_FILTER`, the list of multicast addresses is ignored.
    //
    // Returns `ZX_ERR_INVALID_ARGS` if the provided `address` is not a multicast address.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::AddMulticastAddress AddMulticastAddress(::zx::unowned_channel _client_end, ::llcpp::fuchsia::net::MacAddress address);

    // Adds multicast address to the list of multicast groups.
    //
    // The list of multicast addresses kept is untouched by calls to `SetMode`. If the device's
    // mode is not `MULTICAST_FILTER`, the list of multicast addresses is ignored.
    //
    // Returns `ZX_ERR_INVALID_ARGS` if the provided `address` is not a multicast address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::AddMulticastAddress AddMulticastAddress(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::net::MacAddress address, ::fidl::BytePart _response_buffer);

    // Removes multicast address from the list of multicast groups.
    //
    // Returns `ZX_ERR_INVALID_ARGS` if the provided `address` is not a multicast address.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::RemoveMulticastAddress RemoveMulticastAddress(::zx::unowned_channel _client_end, ::llcpp::fuchsia::net::MacAddress address);

    // Removes multicast address from the list of multicast groups.
    //
    // Returns `ZX_ERR_INVALID_ARGS` if the provided `address` is not a multicast address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::RemoveMulticastAddress RemoveMulticastAddress(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::net::MacAddress address, ::fidl::BytePart _response_buffer);

  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Gets the Device's current unicast MAC address.
    // Implementers of this API do not need to return a uniquely identifiable MAC; the unicast
    // address returned is the one that is *currently* in use to filter unicast frames, or that
    // identifies the device on a link it's *currently* on. Users of this API must not rely on the
    // stability or uniqueness of the returned value to identify or disambiguate device instances.
    static ::fidl::DecodeResult<GetUnicastAddressResponse> GetUnicastAddress(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Sets requested operating mode of this device to `mode`.
    //
    // The requested mode is attached to the current client connection to the device. Because
    // multiple clients can be attached to the same device at once, the mode with the least
    // restrictions will be the one actively put into effect into the underlying device
    // implementation.
    //
    // If the device does not support the requested mode, but supports a mode that is more open
    // than the requested one, `SetMode` will succeed regardless. Otherwise, if the device only
    // supports *more restrictive* modes than the one requested, `SetMode` returns
    // `ZX_ERR_NOT_SUPPORTED`.
    //
    // Clients must be aware that the resource being accessed is shared, and that the device may be
    // effectively operating at a more open level than the one that was requested (although never
    // at one more restrictive).
    static ::fidl::DecodeResult<SetModeResponse> SetMode(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetModeRequest> params, ::fidl::BytePart response_buffer);

    // Adds multicast address to the list of multicast groups.
    //
    // The list of multicast addresses kept is untouched by calls to `SetMode`. If the device's
    // mode is not `MULTICAST_FILTER`, the list of multicast addresses is ignored.
    //
    // Returns `ZX_ERR_INVALID_ARGS` if the provided `address` is not a multicast address.
    static ::fidl::DecodeResult<AddMulticastAddressResponse> AddMulticastAddress(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<AddMulticastAddressRequest> params, ::fidl::BytePart response_buffer);

    // Removes multicast address from the list of multicast groups.
    //
    // Returns `ZX_ERR_INVALID_ARGS` if the provided `address` is not a multicast address.
    static ::fidl::DecodeResult<RemoveMulticastAddressResponse> RemoveMulticastAddress(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<RemoveMulticastAddressRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = MacAddressing;
    using _Base = ::fidl::CompleterBase;

    class GetUnicastAddressCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::net::MacAddress address);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::net::MacAddress address);
      void Reply(::fidl::DecodedMessage<GetUnicastAddressResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetUnicastAddressCompleter = ::fidl::Completer<GetUnicastAddressCompleterBase>;

    virtual void GetUnicastAddress(GetUnicastAddressCompleter::Sync _completer) = 0;

    class SetModeCompleterBase : public _Base {
     public:
      void Reply(int32_t status);
      void Reply(::fidl::BytePart _buffer, int32_t status);
      void Reply(::fidl::DecodedMessage<SetModeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetModeCompleter = ::fidl::Completer<SetModeCompleterBase>;

    virtual void SetMode(::llcpp::fuchsia::hardware::network::MacFilterMode mode, SetModeCompleter::Sync _completer) = 0;

    class AddMulticastAddressCompleterBase : public _Base {
     public:
      void Reply(int32_t status);
      void Reply(::fidl::BytePart _buffer, int32_t status);
      void Reply(::fidl::DecodedMessage<AddMulticastAddressResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using AddMulticastAddressCompleter = ::fidl::Completer<AddMulticastAddressCompleterBase>;

    virtual void AddMulticastAddress(::llcpp::fuchsia::net::MacAddress address, AddMulticastAddressCompleter::Sync _completer) = 0;

    class RemoveMulticastAddressCompleterBase : public _Base {
     public:
      void Reply(int32_t status);
      void Reply(::fidl::BytePart _buffer, int32_t status);
      void Reply(::fidl::DecodedMessage<RemoveMulticastAddressResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using RemoveMulticastAddressCompleter = ::fidl::Completer<RemoveMulticastAddressCompleterBase>;

    virtual void RemoveMulticastAddress(::llcpp::fuchsia::net::MacAddress address, RemoveMulticastAddressCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void GetUnicastAddressRequest(const ::fidl::DecodedMessage<MacAddressing::GetUnicastAddressRequest>& _msg);
    static void GetUnicastAddressResponse(const ::fidl::DecodedMessage<MacAddressing::GetUnicastAddressResponse>& _msg);
    static void SetModeRequest(const ::fidl::DecodedMessage<MacAddressing::SetModeRequest>& _msg);
    static void SetModeResponse(const ::fidl::DecodedMessage<MacAddressing::SetModeResponse>& _msg);
    static void AddMulticastAddressRequest(const ::fidl::DecodedMessage<MacAddressing::AddMulticastAddressRequest>& _msg);
    static void AddMulticastAddressResponse(const ::fidl::DecodedMessage<MacAddressing::AddMulticastAddressResponse>& _msg);
    static void RemoveMulticastAddressRequest(const ::fidl::DecodedMessage<MacAddressing::RemoveMulticastAddressRequest>& _msg);
    static void RemoveMulticastAddressResponse(const ::fidl::DecodedMessage<MacAddressing::RemoveMulticastAddressResponse>& _msg);
  };
};

// The maximum number of status samples that can be buffered by a
// [`fuchsia.hardware.network/StatusWatcher`].
constexpr uint32_t MAX_STATUS_BUFFER = 50u;

// Maximum length of session label.
constexpr uint32_t MAX_SESSION_NAME = 64u;

// Maximum numbers of supported frame types for Rx or Tx.
constexpr uint32_t MAX_FRAME_TYPES = 4u;

// Maximum number of chained descriptors that describe a single frame.
constexpr uint8_t MAX_DESCRIPTOR_CHAIN = 4u;

// Maximum number of acceleration flags.
// Each descriptor has 16 bits of space for acceleration flags
// ([`fuchsia.hardware.network/RxFlags`] and [`fuchsia.hardware.network/TxFlags`]) thus the maximum
// number of reported accelerations is 16. Each descriptor reports which accelerations were applied
// (`RxFlags`) or are requested (`TxFlags`) by mapping indexes in the vector of supported
// accelerations ([`fuchsia.hardware.network/Info.rx_accel`] and
// ([`fuchsia.hardware.network/Info.tx_accel`]) to bits in the respective acceleration flags
// bitfield.
constexpr uint32_t MAX_ACCEL_FLAGS = 16u;

extern "C" const fidl_type_t v1_fuchsia_hardware_network_SessionInfoTable;

// Session configuration.
struct SessionInfo {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_network_SessionInfoTable;
  static constexpr uint32_t MaxNumHandles = 2;
  static constexpr uint32_t PrimarySize = 32;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasPointer = true;

  // VMO containing the descriptors. 16-bit indices transmitted over the FIFOs index a descriptor
  // in this VMO (byte offset = descriptor_length * 8 * index).
  ::zx::vmo descriptors = {};

  // VMO containing frame data. Descriptors contain byte-offsets that are used to index
  // arbitrary regions in `data`.
  ::zx::vmo data = {};

  // Requested descriptor version. If the network device does not support the requested
  // descriptor version, [`fuchsia.hardware.network/Device.OpenSession`] will fail with
  // `ZX_ERR_NOT_SUPPORTED`.
  uint8_t descriptor_version = {};

  // Descriptor length, in 64-bit words. The length of each descriptor in the `descriptors` VMO.
  // This is used as a multiplier to find byte offsets in `descriptors` given a descriptor index
  // passed through the Rx or Tx FIFOs.
  uint8_t descriptor_length = {};

  // Total number of descriptors that can be used by this session. Descriptor indices transferred
  // through either the Rx or Tx FIFO must be in the range [0, `descriptor_count`).
  uint16_t descriptor_count = {};

  // Extra options.
  ::llcpp::fuchsia::hardware::network::SessionFlags options = {};

  // List of frame types the client is subscribing to.
  ::fidl::VectorView<::llcpp::fuchsia::hardware::network::FrameType> rx_frames = {};
};

extern "C" const fidl_type_t v1_fuchsia_hardware_network_FrameTypeSupportTable;

// Specifies a frame type and features and supported flags associated with that type.
// This is used by clients to read the supported frames on the Tx path for a given
// Network Device.
// Some Network Devices may parse outgoing frames to perform frame transformation or specific
// hardware support. Each frame type has an associated
// [`fuchsia.hardware.network/FrameTypeSupport.features`] bits enumeration that lists
// FrameType-specific features that may or may not be supported. Devices that do not perform
// parsing are encouraged to just use the [`fuchsia.hardware.network/FRAME_FEATURES_RAW`] bit in
// `features`, which will inform the client that all frame features are allowed.
struct FrameTypeSupport {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_network_FrameTypeSupportTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 12;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  // The frame type this support entry refers to.
  ::llcpp::fuchsia::hardware::network::FrameType type = {};

  // The frame type-specific features supported.
  uint32_t features = {};

  // The flags supported for the given frame type.
  ::llcpp::fuchsia::hardware::network::TxFlags supported_flags = {};
};

extern "C" const fidl_type_t v1_fuchsia_hardware_network_FifosTable;

// Data-plane FIFOs.
struct Fifos {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_network_FifosTable;
  static constexpr uint32_t MaxNumHandles = 2;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  // Handle for the rx FIFO.
  // Clients must write 16-bit descriptor indexes to this FIFO to be able to receive
  // frames.
  ::zx::fifo rx = {};

  // Handle for the tx FIFO.
  // Clients write 16-bit descriptor indexes to this FIFO to enqueue outgoing frames.
  ::zx::fifo tx = {};
};

extern "C" const fidl_type_t v1_fuchsia_hardware_network_Device_OpenSession_ResponseTable;

struct Device_OpenSession_Response {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_network_Device_OpenSession_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 3;
  static constexpr uint32_t PrimarySize = 12;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  ::zx::channel session = {};

  ::llcpp::fuchsia::hardware::network::Fifos fifos = {};
};

// Blanket definition for raw frames. Devices that do not perform any sort of parsing of outbound
// traffic should define `FRAME_FEATURES_RAW` in the [`fuchsia.hardware.network/FrameTypeSupport`]
// entry.
constexpr uint32_t FRAME_FEATURES_RAW = 1u;

extern "C" const fidl_type_t v1_fuchsia_hardware_network_InfoTable;

// Network device information.
struct Info {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_network_InfoTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 96;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 88;
  static constexpr bool HasPointer = true;

  // Device's class, defined in [`fuchsia.hardware.network/DeviceClass`].
  ::llcpp::fuchsia::hardware::network::DeviceClass class_ = {};

  // Minimum descriptor length, in 64-bit words.
  // Expresses the minimum length that each buffer descriptor must have for correct operation
  // with this device. Devices that support extra frame metadata inform larger minimum descriptor
  // lengths that reflect the minimum space needed to be able to store frame metadata.
  uint8_t min_descriptor_length = {};

  // Accepted descriptor version.
  uint8_t descriptor_version = {};

  // Maximum number of items in Rx FIFO (per session).
  // `rx_depth` is calculated based on the size of the actual backing hardware rx queue.
  uint32_t rx_depth = {};

  // Maximum number of items in Tx FIFO (per session).
  // `tx_depth` is calculated based on the size of the actual backing hardware tx queue.
  uint32_t tx_depth = {};

  // Alignment requirement for buffers in the data VMO. All buffers in the data VMO *must* be
  // aligned to `buffer_alignment` relative to the start of the VMO.
  uint32_t buffer_alignment = {};

  // Maximum supported length of buffers in the data VMO, in bytes.
  uint32_t max_buffer_length = {};

  // The minimum RX buffer length for correct operation, in bytes.
  uint32_t min_rx_buffer_length = {};

  // The number of bytes the device requests be free as `head` space in a Tx buffer. Devices
  // may choose to reject Tx buffers that do not satisfy this constraint.
  uint16_t min_tx_buffer_head = {};

  // The amount of bytes the device requests be free as `tail` space in a Tx buffer. Devices
  // may choose to reject Tx buffers that to not satisfy this constraint.
  uint16_t min_tx_buffer_tail = {};

  // Supported Rx frame types on this device.
  //
  // Clients may open sessions subscribing to a subset of `rx_types` frame types on this device.
  // Clients will only receive the frame types they are subscribed to in this session
  ::fidl::VectorView<::llcpp::fuchsia::hardware::network::FrameType> rx_types = {};

  // Supported Tx frame types on this device.
  //
  // A client is free to send any frame type on an open session, as long as the frame type is
  // part of `tx_types`. Some network devices may need to perform partial frame parsing and
  // serialization and, for that reason, `tx_types` is a vector of
  // [`fuchsia.hardware.network/FrameTypeSupport`] which includes specific features per frame
  // type.
  //
  // For example, a device that supports Ethernet frames but needs to convert the Ethernet header
  // may only support standard EthernetII frames, and not any "raw" Ethernet frame.
  ::fidl::VectorView<::llcpp::fuchsia::hardware::network::FrameTypeSupport> tx_types = {};

  // Available Rx acceleration flags for this device. `rx_accel` maps the `RX_ACCEL_*` flags in
  // the frame descriptors with semantic acceleration features described by
  // [`fuchsia.hardware.network/RxAcceleration`]. Position `n` of `rx_accel` conveys the meaning
  // of the `RX_ACCEL_n` flag.
  ::fidl::VectorView<::llcpp::fuchsia::hardware::network::RxAcceleration> rx_accel = {};

  // Available Tx acceleration flags for this device. `tx_accel` maps the `TX_ACCEL_*` flags in
  // the frame descriptors with semantic acceleration features described by
  // [`fuchsia.hardware.network/TxAcceleration]`. Position `n` of `tx_accel` conveys the meaning
  // of the `TX_ACCEL_n` flag.
  ::fidl::VectorView<::llcpp::fuchsia::hardware::network::TxAcceleration> tx_accel = {};
};

extern "C" const fidl_type_t v1_fuchsia_hardware_network_DeviceGetInfoRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_DeviceGetInfoResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_DeviceGetStatusRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_DeviceGetStatusResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_DeviceGetStatusWatcherRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_DeviceGetStatusWatcherResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_DeviceOpenSessionRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_DeviceOpenSessionResponseTable;

// A Network Device.
class Device final {
  Device() = delete;
 public:
  static constexpr char Name[] = "fuchsia.hardware.network.Device";

  struct GetInfoResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::network::Info info;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_network_DeviceGetInfoResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 112;
    static constexpr uint32_t MaxOutOfLine = 88;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetInfoRequest = ::fidl::AnyZeroArgMessage;

  struct GetStatusResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::network::Status device_status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_network_DeviceGetStatusResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 48;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetStatusRequest = ::fidl::AnyZeroArgMessage;

  struct GetStatusWatcherRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::channel watcher;
    uint32_t buffer;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_network_DeviceGetStatusWatcherRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct OpenSessionResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::network::Device_OpenSession_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_network_DeviceOpenSessionResponseTable;
    static constexpr uint32_t MaxNumHandles = 3;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 16;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct OpenSessionRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::StringView session_name;
    ::llcpp::fuchsia::hardware::network::SessionInfo session_info;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_network_DeviceOpenSessionRequestTable;
    static constexpr uint32_t MaxNumHandles = 2;
    static constexpr uint32_t PrimarySize = 64;
    static constexpr uint32_t MaxOutOfLine = 72;
    static constexpr uint32_t AltPrimarySize = 64;
    static constexpr uint32_t AltMaxOutOfLine = 72;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = OpenSessionResponse;
  };


  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    template <typename ResponseType>
    class GetInfo_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetInfo_Impl(::zx::unowned_channel _client_end);
      ~GetInfo_Impl() = default;
      GetInfo_Impl(GetInfo_Impl&& other) = default;
      GetInfo_Impl& operator=(GetInfo_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetStatus_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetStatus_Impl(::zx::unowned_channel _client_end);
      ~GetStatus_Impl() = default;
      GetStatus_Impl(GetStatus_Impl&& other) = default;
      GetStatus_Impl& operator=(GetStatus_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    class GetStatusWatcher_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      GetStatusWatcher_Impl(::zx::unowned_channel _client_end, ::zx::channel watcher, uint32_t buffer);
      ~GetStatusWatcher_Impl() = default;
      GetStatusWatcher_Impl(GetStatusWatcher_Impl&& other) = default;
      GetStatusWatcher_Impl& operator=(GetStatusWatcher_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class OpenSession_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      OpenSession_Impl(::zx::unowned_channel _client_end, ::fidl::StringView session_name, ::llcpp::fuchsia::hardware::network::SessionInfo session_info);
      ~OpenSession_Impl() = default;
      OpenSession_Impl(OpenSession_Impl&& other) = default;
      OpenSession_Impl& operator=(OpenSession_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using GetInfo = GetInfo_Impl<GetInfoResponse>;
    using GetStatus = GetStatus_Impl<GetStatusResponse>;
    using GetStatusWatcher = GetStatusWatcher_Impl;
    using OpenSession = OpenSession_Impl<OpenSessionResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    template <typename ResponseType>
    class GetInfo_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetInfo_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetInfo_Impl() = default;
      GetInfo_Impl(GetInfo_Impl&& other) = default;
      GetInfo_Impl& operator=(GetInfo_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetStatus_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetStatus_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetStatus_Impl() = default;
      GetStatus_Impl(GetStatus_Impl&& other) = default;
      GetStatus_Impl& operator=(GetStatus_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    class GetStatusWatcher_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      GetStatusWatcher_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel watcher, uint32_t buffer);
      ~GetStatusWatcher_Impl() = default;
      GetStatusWatcher_Impl(GetStatusWatcher_Impl&& other) = default;
      GetStatusWatcher_Impl& operator=(GetStatusWatcher_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class OpenSession_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      OpenSession_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView session_name, ::llcpp::fuchsia::hardware::network::SessionInfo session_info, ::fidl::BytePart _response_buffer);
      ~OpenSession_Impl() = default;
      OpenSession_Impl(OpenSession_Impl&& other) = default;
      OpenSession_Impl& operator=(OpenSession_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using GetInfo = GetInfo_Impl<GetInfoResponse>;
    using GetStatus = GetStatus_Impl<GetStatusResponse>;
    using GetStatusWatcher = GetStatusWatcher_Impl;
    using OpenSession = OpenSession_Impl<OpenSessionResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Obtain information about device
    // Allocates 216 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetInfo GetInfo();

    // Obtain information about device
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetInfo GetInfo(::fidl::BytePart _response_buffer);

    // Obtain the operating device status.
    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::GetStatus GetStatus();

    // Obtain the operating device status.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetStatus GetStatus(::fidl::BytePart _response_buffer);

    // Connects to a [`fuchsia.hardware.network/StatusWatcher`] to observe device status changes.
    //
    // `buffer` is the number of status changes that the client requests to be stored by
    // `StatusWatcher`, limited to [`fuchsia.hardware.network/MAX_STATUS_BUFFER`]. A value of 0 or
    // 1 will cause the `StatusWatcher` to not keep any buffers on status changed. Clients that
    // need to observe all changes to status (as opposed to only the current state) are encouraged
    // to set a buffer value larger than 1, so that all edges can be observed. If `StatusWatcher`'s
    // internal queue is filled and new status changes occur, the oldest samples will be dropped to
    // make room for new ones.
    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetStatusWatcher GetStatusWatcher(::zx::channel watcher, uint32_t buffer);

    // Connects to a [`fuchsia.hardware.network/StatusWatcher`] to observe device status changes.
    //
    // `buffer` is the number of status changes that the client requests to be stored by
    // `StatusWatcher`, limited to [`fuchsia.hardware.network/MAX_STATUS_BUFFER`]. A value of 0 or
    // 1 will cause the `StatusWatcher` to not keep any buffers on status changed. Clients that
    // need to observe all changes to status (as opposed to only the current state) are encouraged
    // to set a buffer value larger than 1, so that all edges can be observed. If `StatusWatcher`'s
    // internal queue is filled and new status changes occur, the oldest samples will be dropped to
    // make room for new ones.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetStatusWatcher GetStatusWatcher(::fidl::BytePart _request_buffer, ::zx::channel watcher, uint32_t buffer);

    // Opens a new session with the network device.
    // `session_name` is used only as a debug label.
    // `session_info` contains the necessary information to setup the session's data exchange.
    // Allocates 192 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::OpenSession OpenSession(::fidl::StringView session_name, ::llcpp::fuchsia::hardware::network::SessionInfo session_info);

    // Opens a new session with the network device.
    // `session_name` is used only as a debug label.
    // `session_info` contains the necessary information to setup the session's data exchange.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::OpenSession OpenSession(::fidl::BytePart _request_buffer, ::fidl::StringView session_name, ::llcpp::fuchsia::hardware::network::SessionInfo session_info, ::fidl::BytePart _response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Obtain information about device
    // Allocates 216 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetInfo GetInfo(::zx::unowned_channel _client_end);

    // Obtain information about device
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetInfo GetInfo(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Obtain the operating device status.
    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::GetStatus GetStatus(::zx::unowned_channel _client_end);

    // Obtain the operating device status.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetStatus GetStatus(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Connects to a [`fuchsia.hardware.network/StatusWatcher`] to observe device status changes.
    //
    // `buffer` is the number of status changes that the client requests to be stored by
    // `StatusWatcher`, limited to [`fuchsia.hardware.network/MAX_STATUS_BUFFER`]. A value of 0 or
    // 1 will cause the `StatusWatcher` to not keep any buffers on status changed. Clients that
    // need to observe all changes to status (as opposed to only the current state) are encouraged
    // to set a buffer value larger than 1, so that all edges can be observed. If `StatusWatcher`'s
    // internal queue is filled and new status changes occur, the oldest samples will be dropped to
    // make room for new ones.
    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetStatusWatcher GetStatusWatcher(::zx::unowned_channel _client_end, ::zx::channel watcher, uint32_t buffer);

    // Connects to a [`fuchsia.hardware.network/StatusWatcher`] to observe device status changes.
    //
    // `buffer` is the number of status changes that the client requests to be stored by
    // `StatusWatcher`, limited to [`fuchsia.hardware.network/MAX_STATUS_BUFFER`]. A value of 0 or
    // 1 will cause the `StatusWatcher` to not keep any buffers on status changed. Clients that
    // need to observe all changes to status (as opposed to only the current state) are encouraged
    // to set a buffer value larger than 1, so that all edges can be observed. If `StatusWatcher`'s
    // internal queue is filled and new status changes occur, the oldest samples will be dropped to
    // make room for new ones.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetStatusWatcher GetStatusWatcher(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel watcher, uint32_t buffer);

    // Opens a new session with the network device.
    // `session_name` is used only as a debug label.
    // `session_info` contains the necessary information to setup the session's data exchange.
    // Allocates 192 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::OpenSession OpenSession(::zx::unowned_channel _client_end, ::fidl::StringView session_name, ::llcpp::fuchsia::hardware::network::SessionInfo session_info);

    // Opens a new session with the network device.
    // `session_name` is used only as a debug label.
    // `session_info` contains the necessary information to setup the session's data exchange.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::OpenSession OpenSession(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView session_name, ::llcpp::fuchsia::hardware::network::SessionInfo session_info, ::fidl::BytePart _response_buffer);

  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Obtain information about device
    static ::fidl::DecodeResult<GetInfoResponse> GetInfo(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Obtain the operating device status.
    static ::fidl::DecodeResult<GetStatusResponse> GetStatus(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Connects to a [`fuchsia.hardware.network/StatusWatcher`] to observe device status changes.
    //
    // `buffer` is the number of status changes that the client requests to be stored by
    // `StatusWatcher`, limited to [`fuchsia.hardware.network/MAX_STATUS_BUFFER`]. A value of 0 or
    // 1 will cause the `StatusWatcher` to not keep any buffers on status changed. Clients that
    // need to observe all changes to status (as opposed to only the current state) are encouraged
    // to set a buffer value larger than 1, so that all edges can be observed. If `StatusWatcher`'s
    // internal queue is filled and new status changes occur, the oldest samples will be dropped to
    // make room for new ones.
    static ::fidl::internal::StatusAndError GetStatusWatcher(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetStatusWatcherRequest> params);

    // Opens a new session with the network device.
    // `session_name` is used only as a debug label.
    // `session_info` contains the necessary information to setup the session's data exchange.
    static ::fidl::DecodeResult<OpenSessionResponse> OpenSession(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<OpenSessionRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Device;
    using _Base = ::fidl::CompleterBase;

    class GetInfoCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::hardware::network::Info info);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::network::Info info);
      void Reply(::fidl::DecodedMessage<GetInfoResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetInfoCompleter = ::fidl::Completer<GetInfoCompleterBase>;

    virtual void GetInfo(GetInfoCompleter::Sync _completer) = 0;

    class GetStatusCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::hardware::network::Status device_status);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::network::Status device_status);
      void Reply(::fidl::DecodedMessage<GetStatusResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetStatusCompleter = ::fidl::Completer<GetStatusCompleterBase>;

    virtual void GetStatus(GetStatusCompleter::Sync _completer) = 0;

    using GetStatusWatcherCompleter = ::fidl::Completer<>;

    virtual void GetStatusWatcher(::zx::channel watcher, uint32_t buffer, GetStatusWatcherCompleter::Sync _completer) = 0;

    class OpenSessionCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::hardware::network::Device_OpenSession_Result result);
      void ReplySuccess(::zx::channel session, ::llcpp::fuchsia::hardware::network::Fifos fifos);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::network::Device_OpenSession_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, ::zx::channel session, ::llcpp::fuchsia::hardware::network::Fifos fifos);
      void Reply(::fidl::DecodedMessage<OpenSessionResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using OpenSessionCompleter = ::fidl::Completer<OpenSessionCompleterBase>;

    virtual void OpenSession(::fidl::StringView session_name, ::llcpp::fuchsia::hardware::network::SessionInfo session_info, OpenSessionCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void GetInfoRequest(const ::fidl::DecodedMessage<Device::GetInfoRequest>& _msg);
    static void GetInfoResponse(const ::fidl::DecodedMessage<Device::GetInfoResponse>& _msg);
    static void GetStatusRequest(const ::fidl::DecodedMessage<Device::GetStatusRequest>& _msg);
    static void GetStatusResponse(const ::fidl::DecodedMessage<Device::GetStatusResponse>& _msg);
    static void GetStatusWatcherRequest(const ::fidl::DecodedMessage<Device::GetStatusWatcherRequest>& _msg);
    static void OpenSessionRequest(const ::fidl::DecodedMessage<Device::OpenSessionRequest>& _msg);
    static void OpenSessionResponse(const ::fidl::DecodedMessage<Device::OpenSessionResponse>& _msg);
  };
};

}  // namespace network
}  // namespace hardware
}  // namespace fuchsia
}  // namespace llcpp

namespace fidl {

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::network::TxReturnFlags> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::network::TxReturnFlags>);
static_assert(sizeof(::llcpp::fuchsia::hardware::network::TxReturnFlags) == sizeof(uint32_t));

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::network::TxFlags> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::network::TxFlags>);
static_assert(sizeof(::llcpp::fuchsia::hardware::network::TxFlags) == sizeof(uint32_t));

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::network::StatusFlags> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::network::StatusFlags>);
static_assert(sizeof(::llcpp::fuchsia::hardware::network::StatusFlags) == sizeof(uint32_t));

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::network::Status> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::network::Status>);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::network::Session::SetPausedRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::network::Session::SetPausedRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::network::Session::SetPausedRequest)
    == ::llcpp::fuchsia::hardware::network::Session::SetPausedRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::Session::SetPausedRequest, paused) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::network::DeviceInstance::GetDeviceRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::network::DeviceInstance::GetDeviceRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::network::DeviceInstance::GetDeviceRequest)
    == ::llcpp::fuchsia::hardware::network::DeviceInstance::GetDeviceRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::DeviceInstance::GetDeviceRequest, device) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::network::DeviceInstance::GetMacAddressingRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::network::DeviceInstance::GetMacAddressingRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::network::DeviceInstance::GetMacAddressingRequest)
    == ::llcpp::fuchsia::hardware::network::DeviceInstance::GetMacAddressingRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::DeviceInstance::GetMacAddressingRequest, mac) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::network::StatusWatcher::WatchStatusResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::network::StatusWatcher::WatchStatusResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::network::StatusWatcher::WatchStatusResponse)
    == ::llcpp::fuchsia::hardware::network::StatusWatcher::WatchStatusResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::StatusWatcher::WatchStatusResponse, device_status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::network::SessionFlags> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::network::SessionFlags>);
static_assert(sizeof(::llcpp::fuchsia::hardware::network::SessionFlags) == sizeof(uint16_t));

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::network::RxFlags> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::network::RxFlags>);
static_assert(sizeof(::llcpp::fuchsia::hardware::network::RxFlags) == sizeof(uint32_t));

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::network::MacAddressing::GetUnicastAddressResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::network::MacAddressing::GetUnicastAddressResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::network::MacAddressing::GetUnicastAddressResponse)
    == ::llcpp::fuchsia::hardware::network::MacAddressing::GetUnicastAddressResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::MacAddressing::GetUnicastAddressResponse, address) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::network::MacAddressing::SetModeRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::network::MacAddressing::SetModeRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::network::MacAddressing::SetModeRequest)
    == ::llcpp::fuchsia::hardware::network::MacAddressing::SetModeRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::MacAddressing::SetModeRequest, mode) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::network::MacAddressing::SetModeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::network::MacAddressing::SetModeResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::network::MacAddressing::SetModeResponse)
    == ::llcpp::fuchsia::hardware::network::MacAddressing::SetModeResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::MacAddressing::SetModeResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::network::MacAddressing::AddMulticastAddressRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::network::MacAddressing::AddMulticastAddressRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::network::MacAddressing::AddMulticastAddressRequest)
    == ::llcpp::fuchsia::hardware::network::MacAddressing::AddMulticastAddressRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::MacAddressing::AddMulticastAddressRequest, address) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::network::MacAddressing::AddMulticastAddressResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::network::MacAddressing::AddMulticastAddressResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::network::MacAddressing::AddMulticastAddressResponse)
    == ::llcpp::fuchsia::hardware::network::MacAddressing::AddMulticastAddressResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::MacAddressing::AddMulticastAddressResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::network::MacAddressing::RemoveMulticastAddressRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::network::MacAddressing::RemoveMulticastAddressRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::network::MacAddressing::RemoveMulticastAddressRequest)
    == ::llcpp::fuchsia::hardware::network::MacAddressing::RemoveMulticastAddressRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::MacAddressing::RemoveMulticastAddressRequest, address) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::network::MacAddressing::RemoveMulticastAddressResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::network::MacAddressing::RemoveMulticastAddressResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::network::MacAddressing::RemoveMulticastAddressResponse)
    == ::llcpp::fuchsia::hardware::network::MacAddressing::RemoveMulticastAddressResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::MacAddressing::RemoveMulticastAddressResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::network::SessionInfo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::network::SessionInfo>);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::SessionInfo, descriptors) == 0);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::SessionInfo, data) == 4);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::SessionInfo, descriptor_version) == 8);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::SessionInfo, descriptor_length) == 9);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::SessionInfo, descriptor_count) == 10);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::SessionInfo, options) == 12);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::SessionInfo, rx_frames) == 16);
static_assert(sizeof(::llcpp::fuchsia::hardware::network::SessionInfo) == ::llcpp::fuchsia::hardware::network::SessionInfo::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::network::FrameTypeSupport> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::network::FrameTypeSupport>);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::FrameTypeSupport, type) == 0);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::FrameTypeSupport, features) == 4);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::FrameTypeSupport, supported_flags) == 8);
static_assert(sizeof(::llcpp::fuchsia::hardware::network::FrameTypeSupport) == ::llcpp::fuchsia::hardware::network::FrameTypeSupport::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::network::Fifos> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::network::Fifos>);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::Fifos, rx) == 0);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::Fifos, tx) == 4);
static_assert(sizeof(::llcpp::fuchsia::hardware::network::Fifos) == ::llcpp::fuchsia::hardware::network::Fifos::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::network::Device_OpenSession_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::network::Device_OpenSession_Response>);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::Device_OpenSession_Response, session) == 0);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::Device_OpenSession_Response, fifos) == 4);
static_assert(sizeof(::llcpp::fuchsia::hardware::network::Device_OpenSession_Response) == ::llcpp::fuchsia::hardware::network::Device_OpenSession_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::network::Device_OpenSession_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::network::Device_OpenSession_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::network::EthernetFeatures> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::network::EthernetFeatures>);
static_assert(sizeof(::llcpp::fuchsia::hardware::network::EthernetFeatures) == sizeof(uint32_t));

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::network::Info> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::network::Info>);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::Info, class_) == 0);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::Info, min_descriptor_length) == 2);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::Info, descriptor_version) == 3);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::Info, rx_depth) == 4);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::Info, tx_depth) == 8);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::Info, buffer_alignment) == 12);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::Info, max_buffer_length) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::Info, min_rx_buffer_length) == 20);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::Info, min_tx_buffer_head) == 24);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::Info, min_tx_buffer_tail) == 26);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::Info, rx_types) == 32);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::Info, tx_types) == 48);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::Info, rx_accel) == 64);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::Info, tx_accel) == 80);
static_assert(sizeof(::llcpp::fuchsia::hardware::network::Info) == ::llcpp::fuchsia::hardware::network::Info::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::network::Device::GetInfoResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::network::Device::GetInfoResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::network::Device::GetInfoResponse)
    == ::llcpp::fuchsia::hardware::network::Device::GetInfoResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::Device::GetInfoResponse, info) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::network::Device::GetStatusResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::network::Device::GetStatusResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::network::Device::GetStatusResponse)
    == ::llcpp::fuchsia::hardware::network::Device::GetStatusResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::Device::GetStatusResponse, device_status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::network::Device::GetStatusWatcherRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::network::Device::GetStatusWatcherRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::network::Device::GetStatusWatcherRequest)
    == ::llcpp::fuchsia::hardware::network::Device::GetStatusWatcherRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::Device::GetStatusWatcherRequest, watcher) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::Device::GetStatusWatcherRequest, buffer) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::network::Device::OpenSessionRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::network::Device::OpenSessionRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::network::Device::OpenSessionRequest)
    == ::llcpp::fuchsia::hardware::network::Device::OpenSessionRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::Device::OpenSessionRequest, session_name) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::Device::OpenSessionRequest, session_info) == 32);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::network::Device::OpenSessionResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::network::Device::OpenSessionResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::network::Device::OpenSessionResponse)
    == ::llcpp::fuchsia::hardware::network::Device::OpenSessionResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::network::Device::OpenSessionResponse, result) == 16);

}  // namespace fidl

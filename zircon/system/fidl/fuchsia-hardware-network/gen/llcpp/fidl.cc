// WARNING: This file is machine generated by fidlgen.

#include <fuchsia/hardware/network/llcpp/fidl.h>
#include <memory>

namespace llcpp {

namespace fuchsia {
namespace hardware {
namespace network {

::llcpp::fuchsia::hardware::network::Status::Builder Status::Build() {
  return Status::Builder();
}

auto ::llcpp::fuchsia::hardware::network::Status::Builder::set_flags(::llcpp::fuchsia::hardware::network::StatusFlags* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[1 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 1) {
    max_ordinal_ = 1;
  }
  return std::move(*this);
}

auto ::llcpp::fuchsia::hardware::network::Status::Builder::set_mtu(uint32_t* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[2 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 2) {
    max_ordinal_ = 2;
  }
  return std::move(*this);
}

namespace {

[[maybe_unused]]
constexpr uint64_t kSession_SetPaused_Ordinal = 0x236b6bda00000000lu;
[[maybe_unused]]
constexpr uint64_t kSession_SetPaused_GenOrdinal = 0x463e604fa765a658lu;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_SessionSetPausedRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_SessionSetPausedResponseTable;
[[maybe_unused]]
constexpr uint64_t kSession_Close_Ordinal = 0x609d569d00000000lu;
[[maybe_unused]]
constexpr uint64_t kSession_Close_GenOrdinal = 0x393d5070394a92f6lu;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_SessionCloseRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_SessionCloseResponseTable;

}  // namespace

Session::ResultOf::SetPaused_Impl::SetPaused_Impl(::zx::unowned_channel _client_end, bool paused) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetPausedRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetPausedRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetPausedRequest*>(_write_bytes);
  _request.paused = std::move(paused);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetPausedRequest));
  ::fidl::DecodedMessage<SetPausedRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Session::InPlace::SetPaused(std::move(_client_end), std::move(_decoded_request)));
}

Session::ResultOf::SetPaused Session::SyncClient::SetPaused(bool paused) {
    return ResultOf::SetPaused(::zx::unowned_channel(this->channel_), std::move(paused));
}

Session::ResultOf::SetPaused Session::Call::SetPaused(::zx::unowned_channel _client_end, bool paused) {
  return ResultOf::SetPaused(std::move(_client_end), std::move(paused));
}


Session::UnownedResultOf::SetPaused_Impl::SetPaused_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, bool paused) {
  if (_request_buffer.capacity() < SetPausedRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, SetPausedRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetPausedRequest*>(_request_buffer.data());
  _request.paused = std::move(paused);
  _request_buffer.set_actual(sizeof(SetPausedRequest));
  ::fidl::DecodedMessage<SetPausedRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Session::InPlace::SetPaused(std::move(_client_end), std::move(_decoded_request)));
}

Session::UnownedResultOf::SetPaused Session::SyncClient::SetPaused(::fidl::BytePart _request_buffer, bool paused) {
  return UnownedResultOf::SetPaused(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(paused));
}

Session::UnownedResultOf::SetPaused Session::Call::SetPaused(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, bool paused) {
  return UnownedResultOf::SetPaused(std::move(_client_end), std::move(_request_buffer), std::move(paused));
}

::fidl::internal::StatusAndError Session::InPlace::SetPaused(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetPausedRequest> params) {
  Session::SetTransactionHeaderFor::SetPausedRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Session::ResultOf::Close_Impl::Close_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CloseRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseRequest));
  ::fidl::DecodedMessage<CloseRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Session::InPlace::Close(std::move(_client_end)));
}

Session::ResultOf::Close Session::SyncClient::Close() {
    return ResultOf::Close(::zx::unowned_channel(this->channel_));
}

Session::ResultOf::Close Session::Call::Close(::zx::unowned_channel _client_end) {
  return ResultOf::Close(std::move(_client_end));
}

::fidl::internal::StatusAndError Session::InPlace::Close(::zx::unowned_channel _client_end) {
  constexpr uint32_t _write_num_bytes = sizeof(CloseRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<CloseRequest> params(std::move(_request_buffer));
  Session::SetTransactionHeaderFor::CloseRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


bool Session::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kSession_SetPaused_Ordinal:
    case kSession_SetPaused_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetPausedRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetPaused(std::move(message->paused),
          Interface::SetPausedCompleter::Sync(txn));
      return true;
    }
    case kSession_Close_Ordinal:
    case kSession_Close_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<CloseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Close(
          Interface::CloseCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Session::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}



void Session::SetTransactionHeaderFor::SetPausedRequest(const ::fidl::DecodedMessage<Session::SetPausedRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kSession_SetPaused_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Session::SetTransactionHeaderFor::CloseRequest(const ::fidl::DecodedMessage<Session::CloseRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kSession_Close_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

namespace {

[[maybe_unused]]
constexpr uint64_t kDeviceInstance_GetDevice_Ordinal = 0x8c0818e00000000lu;
[[maybe_unused]]
constexpr uint64_t kDeviceInstance_GetDevice_GenOrdinal = 0x775270585575cef7lu;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_DeviceInstanceGetDeviceRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_DeviceInstanceGetDeviceResponseTable;
[[maybe_unused]]
constexpr uint64_t kDeviceInstance_GetMacAddressing_Ordinal = 0x43ba144700000000lu;
[[maybe_unused]]
constexpr uint64_t kDeviceInstance_GetMacAddressing_GenOrdinal = 0x545e6ef5d5737c62lu;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_DeviceInstanceGetMacAddressingRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_DeviceInstanceGetMacAddressingResponseTable;

}  // namespace

DeviceInstance::ResultOf::GetDevice_Impl::GetDevice_Impl(::zx::unowned_channel _client_end, ::zx::channel device) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetDeviceRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetDeviceRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetDeviceRequest*>(_write_bytes);
  _request.device = std::move(device);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetDeviceRequest));
  ::fidl::DecodedMessage<GetDeviceRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      DeviceInstance::InPlace::GetDevice(std::move(_client_end), std::move(_decoded_request)));
}

DeviceInstance::ResultOf::GetDevice DeviceInstance::SyncClient::GetDevice(::zx::channel device) {
    return ResultOf::GetDevice(::zx::unowned_channel(this->channel_), std::move(device));
}

DeviceInstance::ResultOf::GetDevice DeviceInstance::Call::GetDevice(::zx::unowned_channel _client_end, ::zx::channel device) {
  return ResultOf::GetDevice(std::move(_client_end), std::move(device));
}


DeviceInstance::UnownedResultOf::GetDevice_Impl::GetDevice_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel device) {
  if (_request_buffer.capacity() < GetDeviceRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, GetDeviceRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetDeviceRequest*>(_request_buffer.data());
  _request.device = std::move(device);
  _request_buffer.set_actual(sizeof(GetDeviceRequest));
  ::fidl::DecodedMessage<GetDeviceRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      DeviceInstance::InPlace::GetDevice(std::move(_client_end), std::move(_decoded_request)));
}

DeviceInstance::UnownedResultOf::GetDevice DeviceInstance::SyncClient::GetDevice(::fidl::BytePart _request_buffer, ::zx::channel device) {
  return UnownedResultOf::GetDevice(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(device));
}

DeviceInstance::UnownedResultOf::GetDevice DeviceInstance::Call::GetDevice(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel device) {
  return UnownedResultOf::GetDevice(std::move(_client_end), std::move(_request_buffer), std::move(device));
}

::fidl::internal::StatusAndError DeviceInstance::InPlace::GetDevice(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetDeviceRequest> params) {
  DeviceInstance::SetTransactionHeaderFor::GetDeviceRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


DeviceInstance::ResultOf::GetMacAddressing_Impl::GetMacAddressing_Impl(::zx::unowned_channel _client_end, ::zx::channel mac) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetMacAddressingRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetMacAddressingRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetMacAddressingRequest*>(_write_bytes);
  _request.mac = std::move(mac);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetMacAddressingRequest));
  ::fidl::DecodedMessage<GetMacAddressingRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      DeviceInstance::InPlace::GetMacAddressing(std::move(_client_end), std::move(_decoded_request)));
}

DeviceInstance::ResultOf::GetMacAddressing DeviceInstance::SyncClient::GetMacAddressing(::zx::channel mac) {
    return ResultOf::GetMacAddressing(::zx::unowned_channel(this->channel_), std::move(mac));
}

DeviceInstance::ResultOf::GetMacAddressing DeviceInstance::Call::GetMacAddressing(::zx::unowned_channel _client_end, ::zx::channel mac) {
  return ResultOf::GetMacAddressing(std::move(_client_end), std::move(mac));
}


DeviceInstance::UnownedResultOf::GetMacAddressing_Impl::GetMacAddressing_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel mac) {
  if (_request_buffer.capacity() < GetMacAddressingRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, GetMacAddressingRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetMacAddressingRequest*>(_request_buffer.data());
  _request.mac = std::move(mac);
  _request_buffer.set_actual(sizeof(GetMacAddressingRequest));
  ::fidl::DecodedMessage<GetMacAddressingRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      DeviceInstance::InPlace::GetMacAddressing(std::move(_client_end), std::move(_decoded_request)));
}

DeviceInstance::UnownedResultOf::GetMacAddressing DeviceInstance::SyncClient::GetMacAddressing(::fidl::BytePart _request_buffer, ::zx::channel mac) {
  return UnownedResultOf::GetMacAddressing(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(mac));
}

DeviceInstance::UnownedResultOf::GetMacAddressing DeviceInstance::Call::GetMacAddressing(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel mac) {
  return UnownedResultOf::GetMacAddressing(std::move(_client_end), std::move(_request_buffer), std::move(mac));
}

::fidl::internal::StatusAndError DeviceInstance::InPlace::GetMacAddressing(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetMacAddressingRequest> params) {
  DeviceInstance::SetTransactionHeaderFor::GetMacAddressingRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


bool DeviceInstance::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kDeviceInstance_GetDevice_Ordinal:
    case kDeviceInstance_GetDevice_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetDeviceRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->GetDevice(std::move(message->device),
          Interface::GetDeviceCompleter::Sync(txn));
      return true;
    }
    case kDeviceInstance_GetMacAddressing_Ordinal:
    case kDeviceInstance_GetMacAddressing_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetMacAddressingRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->GetMacAddressing(std::move(message->mac),
          Interface::GetMacAddressingCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool DeviceInstance::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}



void DeviceInstance::SetTransactionHeaderFor::GetDeviceRequest(const ::fidl::DecodedMessage<DeviceInstance::GetDeviceRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDeviceInstance_GetDevice_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void DeviceInstance::SetTransactionHeaderFor::GetMacAddressingRequest(const ::fidl::DecodedMessage<DeviceInstance::GetMacAddressingRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDeviceInstance_GetMacAddressing_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

namespace {

[[maybe_unused]]
constexpr uint64_t kStatusWatcher_WatchStatus_Ordinal = 0x58a9002800000000lu;
[[maybe_unused]]
constexpr uint64_t kStatusWatcher_WatchStatus_GenOrdinal = 0x1369a8125c0862b9lu;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_StatusWatcherWatchStatusRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_StatusWatcherWatchStatusResponseTable;

}  // namespace
template <>
StatusWatcher::ResultOf::WatchStatus_Impl<StatusWatcher::WatchStatusResponse>::WatchStatus_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WatchStatusRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, WatchStatusRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(WatchStatusRequest));
  ::fidl::DecodedMessage<WatchStatusRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      StatusWatcher::InPlace::WatchStatus(std::move(_client_end), Super::response_buffer()));
}

StatusWatcher::ResultOf::WatchStatus StatusWatcher::SyncClient::WatchStatus() {
    return ResultOf::WatchStatus(::zx::unowned_channel(this->channel_));
}

StatusWatcher::ResultOf::WatchStatus StatusWatcher::Call::WatchStatus(::zx::unowned_channel _client_end) {
  return ResultOf::WatchStatus(std::move(_client_end));
}

template <>
StatusWatcher::UnownedResultOf::WatchStatus_Impl<StatusWatcher::WatchStatusResponse>::WatchStatus_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(WatchStatusRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, WatchStatusRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(WatchStatusRequest));
  ::fidl::DecodedMessage<WatchStatusRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      StatusWatcher::InPlace::WatchStatus(std::move(_client_end), std::move(_response_buffer)));
}

StatusWatcher::UnownedResultOf::WatchStatus StatusWatcher::SyncClient::WatchStatus(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WatchStatus(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

StatusWatcher::UnownedResultOf::WatchStatus StatusWatcher::Call::WatchStatus(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WatchStatus(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<StatusWatcher::WatchStatusResponse> StatusWatcher::InPlace::WatchStatus(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(WatchStatusRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<WatchStatusRequest> params(std::move(_request_buffer));
  StatusWatcher::SetTransactionHeaderFor::WatchStatusRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<StatusWatcher::WatchStatusResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<WatchStatusRequest, WatchStatusResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<StatusWatcher::WatchStatusResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool StatusWatcher::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kStatusWatcher_WatchStatus_Ordinal:
    case kStatusWatcher_WatchStatus_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<WatchStatusRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->WatchStatus(
          Interface::WatchStatusCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool StatusWatcher::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void StatusWatcher::Interface::WatchStatusCompleterBase::Reply(::llcpp::fuchsia::hardware::network::Status device_status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WatchStatusResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  WatchStatusResponse _response = {};
  StatusWatcher::SetTransactionHeaderFor::WatchStatusResponse(
      ::fidl::DecodedMessage<WatchStatusResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WatchStatusResponse::PrimarySize,
              WatchStatusResponse::PrimarySize)));
  _response.device_status = std::move(device_status);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void StatusWatcher::Interface::WatchStatusCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::network::Status device_status) {
  if (_buffer.capacity() < WatchStatusResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  WatchStatusResponse _response = {};
  StatusWatcher::SetTransactionHeaderFor::WatchStatusResponse(
      ::fidl::DecodedMessage<WatchStatusResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WatchStatusResponse::PrimarySize,
              WatchStatusResponse::PrimarySize)));
  _response.device_status = std::move(device_status);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void StatusWatcher::Interface::WatchStatusCompleterBase::Reply(::fidl::DecodedMessage<WatchStatusResponse> params) {
  StatusWatcher::SetTransactionHeaderFor::WatchStatusResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void StatusWatcher::SetTransactionHeaderFor::WatchStatusRequest(const ::fidl::DecodedMessage<StatusWatcher::WatchStatusRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kStatusWatcher_WatchStatus_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void StatusWatcher::SetTransactionHeaderFor::WatchStatusResponse(const ::fidl::DecodedMessage<StatusWatcher::WatchStatusResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kStatusWatcher_WatchStatus_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

namespace {

[[maybe_unused]]
constexpr uint64_t kMacAddressing_GetUnicastAddress_Ordinal = 0x64e141600000000lu;
[[maybe_unused]]
constexpr uint64_t kMacAddressing_GetUnicastAddress_GenOrdinal = 0x2c60b82a4ecfaebelu;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_MacAddressingGetUnicastAddressRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_MacAddressingGetUnicastAddressResponseTable;
[[maybe_unused]]
constexpr uint64_t kMacAddressing_SetMode_Ordinal = 0x19eee98100000000lu;
[[maybe_unused]]
constexpr uint64_t kMacAddressing_SetMode_GenOrdinal = 0x6297b8dbf03c58clu;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_MacAddressingSetModeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_MacAddressingSetModeResponseTable;
[[maybe_unused]]
constexpr uint64_t kMacAddressing_AddMulticastAddress_Ordinal = 0xb21e0fe00000000lu;
[[maybe_unused]]
constexpr uint64_t kMacAddressing_AddMulticastAddress_GenOrdinal = 0xf5637ff11cf0c25lu;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_MacAddressingAddMulticastAddressRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_MacAddressingAddMulticastAddressResponseTable;
[[maybe_unused]]
constexpr uint64_t kMacAddressing_RemoveMulticastAddress_Ordinal = 0x6e1bba1f00000000lu;
[[maybe_unused]]
constexpr uint64_t kMacAddressing_RemoveMulticastAddress_GenOrdinal = 0x5dddf4e3ba4e2560lu;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_MacAddressingRemoveMulticastAddressRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_MacAddressingRemoveMulticastAddressResponseTable;

}  // namespace
template <>
MacAddressing::ResultOf::GetUnicastAddress_Impl<MacAddressing::GetUnicastAddressResponse>::GetUnicastAddress_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetUnicastAddressRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetUnicastAddressRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetUnicastAddressRequest));
  ::fidl::DecodedMessage<GetUnicastAddressRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      MacAddressing::InPlace::GetUnicastAddress(std::move(_client_end), Super::response_buffer()));
}

MacAddressing::ResultOf::GetUnicastAddress MacAddressing::SyncClient::GetUnicastAddress() {
    return ResultOf::GetUnicastAddress(::zx::unowned_channel(this->channel_));
}

MacAddressing::ResultOf::GetUnicastAddress MacAddressing::Call::GetUnicastAddress(::zx::unowned_channel _client_end) {
  return ResultOf::GetUnicastAddress(std::move(_client_end));
}

template <>
MacAddressing::UnownedResultOf::GetUnicastAddress_Impl<MacAddressing::GetUnicastAddressResponse>::GetUnicastAddress_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetUnicastAddressRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetUnicastAddressRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetUnicastAddressRequest));
  ::fidl::DecodedMessage<GetUnicastAddressRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      MacAddressing::InPlace::GetUnicastAddress(std::move(_client_end), std::move(_response_buffer)));
}

MacAddressing::UnownedResultOf::GetUnicastAddress MacAddressing::SyncClient::GetUnicastAddress(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetUnicastAddress(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

MacAddressing::UnownedResultOf::GetUnicastAddress MacAddressing::Call::GetUnicastAddress(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetUnicastAddress(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<MacAddressing::GetUnicastAddressResponse> MacAddressing::InPlace::GetUnicastAddress(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetUnicastAddressRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetUnicastAddressRequest> params(std::move(_request_buffer));
  MacAddressing::SetTransactionHeaderFor::GetUnicastAddressRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MacAddressing::GetUnicastAddressResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetUnicastAddressRequest, GetUnicastAddressResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MacAddressing::GetUnicastAddressResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
MacAddressing::ResultOf::SetMode_Impl<MacAddressing::SetModeResponse>::SetMode_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::network::MacFilterMode mode) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetModeRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetModeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetModeRequest*>(_write_bytes);
  _request.mode = std::move(mode);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetModeRequest));
  ::fidl::DecodedMessage<SetModeRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      MacAddressing::InPlace::SetMode(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

MacAddressing::ResultOf::SetMode MacAddressing::SyncClient::SetMode(::llcpp::fuchsia::hardware::network::MacFilterMode mode) {
    return ResultOf::SetMode(::zx::unowned_channel(this->channel_), std::move(mode));
}

MacAddressing::ResultOf::SetMode MacAddressing::Call::SetMode(::zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::network::MacFilterMode mode) {
  return ResultOf::SetMode(std::move(_client_end), std::move(mode));
}

template <>
MacAddressing::UnownedResultOf::SetMode_Impl<MacAddressing::SetModeResponse>::SetMode_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::network::MacFilterMode mode, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < SetModeRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<SetModeResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, SetModeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetModeRequest*>(_request_buffer.data());
  _request.mode = std::move(mode);
  _request_buffer.set_actual(sizeof(SetModeRequest));
  ::fidl::DecodedMessage<SetModeRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      MacAddressing::InPlace::SetMode(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

MacAddressing::UnownedResultOf::SetMode MacAddressing::SyncClient::SetMode(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::network::MacFilterMode mode, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetMode(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(mode), std::move(_response_buffer));
}

MacAddressing::UnownedResultOf::SetMode MacAddressing::Call::SetMode(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::network::MacFilterMode mode, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetMode(std::move(_client_end), std::move(_request_buffer), std::move(mode), std::move(_response_buffer));
}

::fidl::DecodeResult<MacAddressing::SetModeResponse> MacAddressing::InPlace::SetMode(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetModeRequest> params, ::fidl::BytePart response_buffer) {
  MacAddressing::SetTransactionHeaderFor::SetModeRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MacAddressing::SetModeResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SetModeRequest, SetModeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MacAddressing::SetModeResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
MacAddressing::ResultOf::AddMulticastAddress_Impl<MacAddressing::AddMulticastAddressResponse>::AddMulticastAddress_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::net::MacAddress address) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<AddMulticastAddressRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, AddMulticastAddressRequest::PrimarySize);
  auto& _request = *reinterpret_cast<AddMulticastAddressRequest*>(_write_bytes);
  _request.address = std::move(address);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(AddMulticastAddressRequest));
  ::fidl::DecodedMessage<AddMulticastAddressRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      MacAddressing::InPlace::AddMulticastAddress(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

MacAddressing::ResultOf::AddMulticastAddress MacAddressing::SyncClient::AddMulticastAddress(::llcpp::fuchsia::net::MacAddress address) {
    return ResultOf::AddMulticastAddress(::zx::unowned_channel(this->channel_), std::move(address));
}

MacAddressing::ResultOf::AddMulticastAddress MacAddressing::Call::AddMulticastAddress(::zx::unowned_channel _client_end, ::llcpp::fuchsia::net::MacAddress address) {
  return ResultOf::AddMulticastAddress(std::move(_client_end), std::move(address));
}

template <>
MacAddressing::UnownedResultOf::AddMulticastAddress_Impl<MacAddressing::AddMulticastAddressResponse>::AddMulticastAddress_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::net::MacAddress address, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < AddMulticastAddressRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<AddMulticastAddressResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, AddMulticastAddressRequest::PrimarySize);
  auto& _request = *reinterpret_cast<AddMulticastAddressRequest*>(_request_buffer.data());
  _request.address = std::move(address);
  _request_buffer.set_actual(sizeof(AddMulticastAddressRequest));
  ::fidl::DecodedMessage<AddMulticastAddressRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      MacAddressing::InPlace::AddMulticastAddress(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

MacAddressing::UnownedResultOf::AddMulticastAddress MacAddressing::SyncClient::AddMulticastAddress(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::net::MacAddress address, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::AddMulticastAddress(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(address), std::move(_response_buffer));
}

MacAddressing::UnownedResultOf::AddMulticastAddress MacAddressing::Call::AddMulticastAddress(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::net::MacAddress address, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::AddMulticastAddress(std::move(_client_end), std::move(_request_buffer), std::move(address), std::move(_response_buffer));
}

::fidl::DecodeResult<MacAddressing::AddMulticastAddressResponse> MacAddressing::InPlace::AddMulticastAddress(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<AddMulticastAddressRequest> params, ::fidl::BytePart response_buffer) {
  MacAddressing::SetTransactionHeaderFor::AddMulticastAddressRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MacAddressing::AddMulticastAddressResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<AddMulticastAddressRequest, AddMulticastAddressResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MacAddressing::AddMulticastAddressResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
MacAddressing::ResultOf::RemoveMulticastAddress_Impl<MacAddressing::RemoveMulticastAddressResponse>::RemoveMulticastAddress_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::net::MacAddress address) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RemoveMulticastAddressRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, RemoveMulticastAddressRequest::PrimarySize);
  auto& _request = *reinterpret_cast<RemoveMulticastAddressRequest*>(_write_bytes);
  _request.address = std::move(address);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(RemoveMulticastAddressRequest));
  ::fidl::DecodedMessage<RemoveMulticastAddressRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      MacAddressing::InPlace::RemoveMulticastAddress(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

MacAddressing::ResultOf::RemoveMulticastAddress MacAddressing::SyncClient::RemoveMulticastAddress(::llcpp::fuchsia::net::MacAddress address) {
    return ResultOf::RemoveMulticastAddress(::zx::unowned_channel(this->channel_), std::move(address));
}

MacAddressing::ResultOf::RemoveMulticastAddress MacAddressing::Call::RemoveMulticastAddress(::zx::unowned_channel _client_end, ::llcpp::fuchsia::net::MacAddress address) {
  return ResultOf::RemoveMulticastAddress(std::move(_client_end), std::move(address));
}

template <>
MacAddressing::UnownedResultOf::RemoveMulticastAddress_Impl<MacAddressing::RemoveMulticastAddressResponse>::RemoveMulticastAddress_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::net::MacAddress address, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < RemoveMulticastAddressRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<RemoveMulticastAddressResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, RemoveMulticastAddressRequest::PrimarySize);
  auto& _request = *reinterpret_cast<RemoveMulticastAddressRequest*>(_request_buffer.data());
  _request.address = std::move(address);
  _request_buffer.set_actual(sizeof(RemoveMulticastAddressRequest));
  ::fidl::DecodedMessage<RemoveMulticastAddressRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      MacAddressing::InPlace::RemoveMulticastAddress(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

MacAddressing::UnownedResultOf::RemoveMulticastAddress MacAddressing::SyncClient::RemoveMulticastAddress(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::net::MacAddress address, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::RemoveMulticastAddress(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(address), std::move(_response_buffer));
}

MacAddressing::UnownedResultOf::RemoveMulticastAddress MacAddressing::Call::RemoveMulticastAddress(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::net::MacAddress address, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::RemoveMulticastAddress(std::move(_client_end), std::move(_request_buffer), std::move(address), std::move(_response_buffer));
}

::fidl::DecodeResult<MacAddressing::RemoveMulticastAddressResponse> MacAddressing::InPlace::RemoveMulticastAddress(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<RemoveMulticastAddressRequest> params, ::fidl::BytePart response_buffer) {
  MacAddressing::SetTransactionHeaderFor::RemoveMulticastAddressRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MacAddressing::RemoveMulticastAddressResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<RemoveMulticastAddressRequest, RemoveMulticastAddressResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MacAddressing::RemoveMulticastAddressResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool MacAddressing::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kMacAddressing_GetUnicastAddress_Ordinal:
    case kMacAddressing_GetUnicastAddress_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetUnicastAddressRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetUnicastAddress(
          Interface::GetUnicastAddressCompleter::Sync(txn));
      return true;
    }
    case kMacAddressing_SetMode_Ordinal:
    case kMacAddressing_SetMode_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetModeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetMode(std::move(message->mode),
          Interface::SetModeCompleter::Sync(txn));
      return true;
    }
    case kMacAddressing_AddMulticastAddress_Ordinal:
    case kMacAddressing_AddMulticastAddress_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<AddMulticastAddressRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->AddMulticastAddress(std::move(message->address),
          Interface::AddMulticastAddressCompleter::Sync(txn));
      return true;
    }
    case kMacAddressing_RemoveMulticastAddress_Ordinal:
    case kMacAddressing_RemoveMulticastAddress_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<RemoveMulticastAddressRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->RemoveMulticastAddress(std::move(message->address),
          Interface::RemoveMulticastAddressCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool MacAddressing::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void MacAddressing::Interface::GetUnicastAddressCompleterBase::Reply(::llcpp::fuchsia::net::MacAddress address) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetUnicastAddressResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetUnicastAddressResponse*>(_write_bytes);
  MacAddressing::SetTransactionHeaderFor::GetUnicastAddressResponse(
      ::fidl::DecodedMessage<GetUnicastAddressResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetUnicastAddressResponse::PrimarySize,
              GetUnicastAddressResponse::PrimarySize)));
  _response.address = std::move(address);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetUnicastAddressResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetUnicastAddressResponse>(std::move(_response_bytes)));
}

void MacAddressing::Interface::GetUnicastAddressCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::net::MacAddress address) {
  if (_buffer.capacity() < GetUnicastAddressResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetUnicastAddressResponse*>(_buffer.data());
  MacAddressing::SetTransactionHeaderFor::GetUnicastAddressResponse(
      ::fidl::DecodedMessage<GetUnicastAddressResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetUnicastAddressResponse::PrimarySize,
              GetUnicastAddressResponse::PrimarySize)));
  _response.address = std::move(address);
  _buffer.set_actual(sizeof(GetUnicastAddressResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetUnicastAddressResponse>(std::move(_buffer)));
}

void MacAddressing::Interface::GetUnicastAddressCompleterBase::Reply(::fidl::DecodedMessage<GetUnicastAddressResponse> params) {
  MacAddressing::SetTransactionHeaderFor::GetUnicastAddressResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void MacAddressing::Interface::SetModeCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetModeResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SetModeResponse*>(_write_bytes);
  MacAddressing::SetTransactionHeaderFor::SetModeResponse(
      ::fidl::DecodedMessage<SetModeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetModeResponse::PrimarySize,
              SetModeResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetModeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetModeResponse>(std::move(_response_bytes)));
}

void MacAddressing::Interface::SetModeCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < SetModeResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SetModeResponse*>(_buffer.data());
  MacAddressing::SetTransactionHeaderFor::SetModeResponse(
      ::fidl::DecodedMessage<SetModeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetModeResponse::PrimarySize,
              SetModeResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(SetModeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetModeResponse>(std::move(_buffer)));
}

void MacAddressing::Interface::SetModeCompleterBase::Reply(::fidl::DecodedMessage<SetModeResponse> params) {
  MacAddressing::SetTransactionHeaderFor::SetModeResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void MacAddressing::Interface::AddMulticastAddressCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<AddMulticastAddressResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<AddMulticastAddressResponse*>(_write_bytes);
  MacAddressing::SetTransactionHeaderFor::AddMulticastAddressResponse(
      ::fidl::DecodedMessage<AddMulticastAddressResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              AddMulticastAddressResponse::PrimarySize,
              AddMulticastAddressResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(AddMulticastAddressResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<AddMulticastAddressResponse>(std::move(_response_bytes)));
}

void MacAddressing::Interface::AddMulticastAddressCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < AddMulticastAddressResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<AddMulticastAddressResponse*>(_buffer.data());
  MacAddressing::SetTransactionHeaderFor::AddMulticastAddressResponse(
      ::fidl::DecodedMessage<AddMulticastAddressResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              AddMulticastAddressResponse::PrimarySize,
              AddMulticastAddressResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(AddMulticastAddressResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<AddMulticastAddressResponse>(std::move(_buffer)));
}

void MacAddressing::Interface::AddMulticastAddressCompleterBase::Reply(::fidl::DecodedMessage<AddMulticastAddressResponse> params) {
  MacAddressing::SetTransactionHeaderFor::AddMulticastAddressResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void MacAddressing::Interface::RemoveMulticastAddressCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RemoveMulticastAddressResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<RemoveMulticastAddressResponse*>(_write_bytes);
  MacAddressing::SetTransactionHeaderFor::RemoveMulticastAddressResponse(
      ::fidl::DecodedMessage<RemoveMulticastAddressResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              RemoveMulticastAddressResponse::PrimarySize,
              RemoveMulticastAddressResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(RemoveMulticastAddressResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<RemoveMulticastAddressResponse>(std::move(_response_bytes)));
}

void MacAddressing::Interface::RemoveMulticastAddressCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < RemoveMulticastAddressResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<RemoveMulticastAddressResponse*>(_buffer.data());
  MacAddressing::SetTransactionHeaderFor::RemoveMulticastAddressResponse(
      ::fidl::DecodedMessage<RemoveMulticastAddressResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              RemoveMulticastAddressResponse::PrimarySize,
              RemoveMulticastAddressResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(RemoveMulticastAddressResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<RemoveMulticastAddressResponse>(std::move(_buffer)));
}

void MacAddressing::Interface::RemoveMulticastAddressCompleterBase::Reply(::fidl::DecodedMessage<RemoveMulticastAddressResponse> params) {
  MacAddressing::SetTransactionHeaderFor::RemoveMulticastAddressResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void MacAddressing::SetTransactionHeaderFor::GetUnicastAddressRequest(const ::fidl::DecodedMessage<MacAddressing::GetUnicastAddressRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMacAddressing_GetUnicastAddress_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void MacAddressing::SetTransactionHeaderFor::GetUnicastAddressResponse(const ::fidl::DecodedMessage<MacAddressing::GetUnicastAddressResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMacAddressing_GetUnicastAddress_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void MacAddressing::SetTransactionHeaderFor::SetModeRequest(const ::fidl::DecodedMessage<MacAddressing::SetModeRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMacAddressing_SetMode_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void MacAddressing::SetTransactionHeaderFor::SetModeResponse(const ::fidl::DecodedMessage<MacAddressing::SetModeResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMacAddressing_SetMode_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void MacAddressing::SetTransactionHeaderFor::AddMulticastAddressRequest(const ::fidl::DecodedMessage<MacAddressing::AddMulticastAddressRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMacAddressing_AddMulticastAddress_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void MacAddressing::SetTransactionHeaderFor::AddMulticastAddressResponse(const ::fidl::DecodedMessage<MacAddressing::AddMulticastAddressResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMacAddressing_AddMulticastAddress_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void MacAddressing::SetTransactionHeaderFor::RemoveMulticastAddressRequest(const ::fidl::DecodedMessage<MacAddressing::RemoveMulticastAddressRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMacAddressing_RemoveMulticastAddress_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void MacAddressing::SetTransactionHeaderFor::RemoveMulticastAddressResponse(const ::fidl::DecodedMessage<MacAddressing::RemoveMulticastAddressResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMacAddressing_RemoveMulticastAddress_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void ::llcpp::fuchsia::hardware::network::Device_OpenSession_Result::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(Device_OpenSession_Result) == sizeof(fidl_xunion_t));
  static_assert(offsetof(Device_OpenSession_Result, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(Device_OpenSession_Result, envelope_) == offsetof(fidl_xunion_t, envelope));
}

namespace {

[[maybe_unused]]
constexpr uint64_t kDevice_GetInfo_Ordinal = 0x758cc71900000000lu;
[[maybe_unused]]
constexpr uint64_t kDevice_GetInfo_GenOrdinal = 0x3c500ca9341e8f56lu;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_DeviceGetInfoRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_DeviceGetInfoResponseTable;
[[maybe_unused]]
constexpr uint64_t kDevice_GetStatus_Ordinal = 0x6e0b631700000000lu;
[[maybe_unused]]
constexpr uint64_t kDevice_GetStatus_GenOrdinal = 0x3e15c944b7e06cedlu;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_DeviceGetStatusRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_DeviceGetStatusResponseTable;
[[maybe_unused]]
constexpr uint64_t kDevice_GetStatusWatcher_Ordinal = 0x253afc7e00000000lu;
[[maybe_unused]]
constexpr uint64_t kDevice_GetStatusWatcher_GenOrdinal = 0x65079698371e1163lu;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_DeviceGetStatusWatcherRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_DeviceGetStatusWatcherResponseTable;
[[maybe_unused]]
constexpr uint64_t kDevice_OpenSession_Ordinal = 0x34d4098f00000000lu;
[[maybe_unused]]
constexpr uint64_t kDevice_OpenSession_GenOrdinal = 0x25940b82146dcf67lu;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_DeviceOpenSessionRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_network_DeviceOpenSessionResponseTable;

}  // namespace
template <>
Device::ResultOf::GetInfo_Impl<Device::GetInfoResponse>::GetInfo_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetInfoRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetInfoRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetInfoRequest));
  ::fidl::DecodedMessage<GetInfoRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Device::InPlace::GetInfo(std::move(_client_end), Super::response_buffer()));
}

Device::ResultOf::GetInfo Device::SyncClient::GetInfo() {
    return ResultOf::GetInfo(::zx::unowned_channel(this->channel_));
}

Device::ResultOf::GetInfo Device::Call::GetInfo(::zx::unowned_channel _client_end) {
  return ResultOf::GetInfo(std::move(_client_end));
}

template <>
Device::UnownedResultOf::GetInfo_Impl<Device::GetInfoResponse>::GetInfo_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetInfoRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetInfoRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetInfoRequest));
  ::fidl::DecodedMessage<GetInfoRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Device::InPlace::GetInfo(std::move(_client_end), std::move(_response_buffer)));
}

Device::UnownedResultOf::GetInfo Device::SyncClient::GetInfo(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetInfo(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Device::UnownedResultOf::GetInfo Device::Call::GetInfo(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetInfo(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::GetInfoResponse> Device::InPlace::GetInfo(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetInfoRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetInfoRequest> params(std::move(_request_buffer));
  Device::SetTransactionHeaderFor::GetInfoRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::GetInfoResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetInfoRequest, GetInfoResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::GetInfoResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Device::ResultOf::GetStatus_Impl<Device::GetStatusResponse>::GetStatus_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetStatusRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetStatusRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetStatusRequest));
  ::fidl::DecodedMessage<GetStatusRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Device::InPlace::GetStatus(std::move(_client_end), Super::response_buffer()));
}

Device::ResultOf::GetStatus Device::SyncClient::GetStatus() {
    return ResultOf::GetStatus(::zx::unowned_channel(this->channel_));
}

Device::ResultOf::GetStatus Device::Call::GetStatus(::zx::unowned_channel _client_end) {
  return ResultOf::GetStatus(std::move(_client_end));
}

template <>
Device::UnownedResultOf::GetStatus_Impl<Device::GetStatusResponse>::GetStatus_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetStatusRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetStatusRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetStatusRequest));
  ::fidl::DecodedMessage<GetStatusRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Device::InPlace::GetStatus(std::move(_client_end), std::move(_response_buffer)));
}

Device::UnownedResultOf::GetStatus Device::SyncClient::GetStatus(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetStatus(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Device::UnownedResultOf::GetStatus Device::Call::GetStatus(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetStatus(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::GetStatusResponse> Device::InPlace::GetStatus(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetStatusRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetStatusRequest> params(std::move(_request_buffer));
  Device::SetTransactionHeaderFor::GetStatusRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::GetStatusResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetStatusRequest, GetStatusResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::GetStatusResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


Device::ResultOf::GetStatusWatcher_Impl::GetStatusWatcher_Impl(::zx::unowned_channel _client_end, ::zx::channel watcher, uint32_t buffer) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetStatusWatcherRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetStatusWatcherRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetStatusWatcherRequest*>(_write_bytes);
  _request.watcher = std::move(watcher);
  _request.buffer = std::move(buffer);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetStatusWatcherRequest));
  ::fidl::DecodedMessage<GetStatusWatcherRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Device::InPlace::GetStatusWatcher(std::move(_client_end), std::move(_decoded_request)));
}

Device::ResultOf::GetStatusWatcher Device::SyncClient::GetStatusWatcher(::zx::channel watcher, uint32_t buffer) {
    return ResultOf::GetStatusWatcher(::zx::unowned_channel(this->channel_), std::move(watcher), std::move(buffer));
}

Device::ResultOf::GetStatusWatcher Device::Call::GetStatusWatcher(::zx::unowned_channel _client_end, ::zx::channel watcher, uint32_t buffer) {
  return ResultOf::GetStatusWatcher(std::move(_client_end), std::move(watcher), std::move(buffer));
}


Device::UnownedResultOf::GetStatusWatcher_Impl::GetStatusWatcher_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel watcher, uint32_t buffer) {
  if (_request_buffer.capacity() < GetStatusWatcherRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, GetStatusWatcherRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetStatusWatcherRequest*>(_request_buffer.data());
  _request.watcher = std::move(watcher);
  _request.buffer = std::move(buffer);
  _request_buffer.set_actual(sizeof(GetStatusWatcherRequest));
  ::fidl::DecodedMessage<GetStatusWatcherRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Device::InPlace::GetStatusWatcher(std::move(_client_end), std::move(_decoded_request)));
}

Device::UnownedResultOf::GetStatusWatcher Device::SyncClient::GetStatusWatcher(::fidl::BytePart _request_buffer, ::zx::channel watcher, uint32_t buffer) {
  return UnownedResultOf::GetStatusWatcher(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(watcher), std::move(buffer));
}

Device::UnownedResultOf::GetStatusWatcher Device::Call::GetStatusWatcher(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel watcher, uint32_t buffer) {
  return UnownedResultOf::GetStatusWatcher(std::move(_client_end), std::move(_request_buffer), std::move(watcher), std::move(buffer));
}

::fidl::internal::StatusAndError Device::InPlace::GetStatusWatcher(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetStatusWatcherRequest> params) {
  Device::SetTransactionHeaderFor::GetStatusWatcherRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
Device::ResultOf::OpenSession_Impl<Device::OpenSessionResponse>::OpenSession_Impl(::zx::unowned_channel _client_end, ::fidl::StringView session_name, ::llcpp::fuchsia::hardware::network::SessionInfo session_info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OpenSessionRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  OpenSessionRequest _request = {};
  _request.session_name = std::move(session_name);
  _request.session_info = std::move(session_info);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<OpenSessionRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Device::InPlace::OpenSession(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Device::ResultOf::OpenSession Device::SyncClient::OpenSession(::fidl::StringView session_name, ::llcpp::fuchsia::hardware::network::SessionInfo session_info) {
    return ResultOf::OpenSession(::zx::unowned_channel(this->channel_), std::move(session_name), std::move(session_info));
}

Device::ResultOf::OpenSession Device::Call::OpenSession(::zx::unowned_channel _client_end, ::fidl::StringView session_name, ::llcpp::fuchsia::hardware::network::SessionInfo session_info) {
  return ResultOf::OpenSession(std::move(_client_end), std::move(session_name), std::move(session_info));
}

template <>
Device::UnownedResultOf::OpenSession_Impl<Device::OpenSessionResponse>::OpenSession_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView session_name, ::llcpp::fuchsia::hardware::network::SessionInfo session_info, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < OpenSessionRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<OpenSessionResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  OpenSessionRequest _request = {};
  _request.session_name = std::move(session_name);
  _request.session_info = std::move(session_info);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<OpenSessionRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Device::InPlace::OpenSession(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Device::UnownedResultOf::OpenSession Device::SyncClient::OpenSession(::fidl::BytePart _request_buffer, ::fidl::StringView session_name, ::llcpp::fuchsia::hardware::network::SessionInfo session_info, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::OpenSession(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(session_name), std::move(session_info), std::move(_response_buffer));
}

Device::UnownedResultOf::OpenSession Device::Call::OpenSession(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView session_name, ::llcpp::fuchsia::hardware::network::SessionInfo session_info, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::OpenSession(std::move(_client_end), std::move(_request_buffer), std::move(session_name), std::move(session_info), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::OpenSessionResponse> Device::InPlace::OpenSession(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<OpenSessionRequest> params, ::fidl::BytePart response_buffer) {
  Device::SetTransactionHeaderFor::OpenSessionRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::OpenSessionResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<OpenSessionRequest, OpenSessionResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::OpenSessionResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool Device::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kDevice_GetInfo_Ordinal:
    case kDevice_GetInfo_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetInfoRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetInfo(
          Interface::GetInfoCompleter::Sync(txn));
      return true;
    }
    case kDevice_GetStatus_Ordinal:
    case kDevice_GetStatus_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetStatusRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetStatus(
          Interface::GetStatusCompleter::Sync(txn));
      return true;
    }
    case kDevice_GetStatusWatcher_Ordinal:
    case kDevice_GetStatusWatcher_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetStatusWatcherRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->GetStatusWatcher(std::move(message->watcher), std::move(message->buffer),
          Interface::GetStatusWatcherCompleter::Sync(txn));
      return true;
    }
    case kDevice_OpenSession_Ordinal:
    case kDevice_OpenSession_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<OpenSessionRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->OpenSession(std::move(message->session_name), std::move(message->session_info),
          Interface::OpenSessionCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Device::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void Device::Interface::GetInfoCompleterBase::Reply(::llcpp::fuchsia::hardware::network::Info info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetInfoResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  GetInfoResponse _response = {};
  Device::SetTransactionHeaderFor::GetInfoResponse(
      ::fidl::DecodedMessage<GetInfoResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetInfoResponse::PrimarySize,
              GetInfoResponse::PrimarySize)));
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Device::Interface::GetInfoCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::network::Info info) {
  if (_buffer.capacity() < GetInfoResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetInfoResponse _response = {};
  Device::SetTransactionHeaderFor::GetInfoResponse(
      ::fidl::DecodedMessage<GetInfoResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetInfoResponse::PrimarySize,
              GetInfoResponse::PrimarySize)));
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Device::Interface::GetInfoCompleterBase::Reply(::fidl::DecodedMessage<GetInfoResponse> params) {
  Device::SetTransactionHeaderFor::GetInfoResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Device::Interface::GetStatusCompleterBase::Reply(::llcpp::fuchsia::hardware::network::Status device_status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetStatusResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  GetStatusResponse _response = {};
  Device::SetTransactionHeaderFor::GetStatusResponse(
      ::fidl::DecodedMessage<GetStatusResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetStatusResponse::PrimarySize,
              GetStatusResponse::PrimarySize)));
  _response.device_status = std::move(device_status);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Device::Interface::GetStatusCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::network::Status device_status) {
  if (_buffer.capacity() < GetStatusResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetStatusResponse _response = {};
  Device::SetTransactionHeaderFor::GetStatusResponse(
      ::fidl::DecodedMessage<GetStatusResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetStatusResponse::PrimarySize,
              GetStatusResponse::PrimarySize)));
  _response.device_status = std::move(device_status);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Device::Interface::GetStatusCompleterBase::Reply(::fidl::DecodedMessage<GetStatusResponse> params) {
  Device::SetTransactionHeaderFor::GetStatusResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Device::Interface::OpenSessionCompleterBase::Reply(::llcpp::fuchsia::hardware::network::Device_OpenSession_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OpenSessionResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  OpenSessionResponse _response = {};
  Device::SetTransactionHeaderFor::OpenSessionResponse(
      ::fidl::DecodedMessage<OpenSessionResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OpenSessionResponse::PrimarySize,
              OpenSessionResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Device::Interface::OpenSessionCompleterBase::ReplySuccess(::zx::channel session, ::llcpp::fuchsia::hardware::network::Fifos fifos) {
  Device_OpenSession_Response response;
  response.session = std::move(session);
  response.fifos = std::move(fifos);

  Reply(Device_OpenSession_Result::WithResponse(&response));
}
void Device::Interface::OpenSessionCompleterBase::ReplyError(int32_t error) {
  Reply(Device_OpenSession_Result::WithErr(&error));
}

void Device::Interface::OpenSessionCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::network::Device_OpenSession_Result result) {
  if (_buffer.capacity() < OpenSessionResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  OpenSessionResponse _response = {};
  Device::SetTransactionHeaderFor::OpenSessionResponse(
      ::fidl::DecodedMessage<OpenSessionResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OpenSessionResponse::PrimarySize,
              OpenSessionResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Device::Interface::OpenSessionCompleterBase::ReplySuccess(::fidl::BytePart _buffer, ::zx::channel session, ::llcpp::fuchsia::hardware::network::Fifos fifos) {
  Device_OpenSession_Response response;
  response.session = std::move(session);
  response.fifos = std::move(fifos);

  Reply(std::move(_buffer), Device_OpenSession_Result::WithResponse(&response));
}

void Device::Interface::OpenSessionCompleterBase::Reply(::fidl::DecodedMessage<OpenSessionResponse> params) {
  Device::SetTransactionHeaderFor::OpenSessionResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void Device::SetTransactionHeaderFor::GetInfoRequest(const ::fidl::DecodedMessage<Device::GetInfoRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_GetInfo_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Device::SetTransactionHeaderFor::GetInfoResponse(const ::fidl::DecodedMessage<Device::GetInfoResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_GetInfo_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Device::SetTransactionHeaderFor::GetStatusRequest(const ::fidl::DecodedMessage<Device::GetStatusRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_GetStatus_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Device::SetTransactionHeaderFor::GetStatusResponse(const ::fidl::DecodedMessage<Device::GetStatusResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_GetStatus_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Device::SetTransactionHeaderFor::GetStatusWatcherRequest(const ::fidl::DecodedMessage<Device::GetStatusWatcherRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_GetStatusWatcher_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Device::SetTransactionHeaderFor::OpenSessionRequest(const ::fidl::DecodedMessage<Device::OpenSessionRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_OpenSession_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Device::SetTransactionHeaderFor::OpenSessionResponse(const ::fidl::DecodedMessage<Device::OpenSessionResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_OpenSession_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

}  // namespace network
}  // namespace hardware
}  // namespace fuchsia
}  // namespace llcpp

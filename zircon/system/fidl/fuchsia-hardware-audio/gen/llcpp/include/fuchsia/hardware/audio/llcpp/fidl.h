// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/txn_header.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/connect_service.h>
#include <lib/fidl/llcpp/service_handler_interface.h>
#include <lib/fidl/llcpp/string_view.h>
#include <lib/fidl/llcpp/sync_call.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/fidl/llcpp/vector_view.h>
#include <lib/fit/function.h>
#include <lib/zx/channel.h>
#include <lib/zx/vmo.h>
#include <zircon/fidl.h>

namespace llcpp {

namespace fuchsia {
namespace hardware {
namespace audio {

struct RingBufferPositionInfo;
struct PlugState;
struct RingBufferProperties;
class Device;
enum class SampleFormat : uint8_t {
  PCM_SIGNED = 1u,
  PCM_UNSIGNED = 2u,
  PCM_FLOAT = 3u,
};


struct PcmSupportedFormats;
struct SupportedFormats;
struct PcmFormat;
struct Format;
struct RingBuffer_GetVmo_Response;
enum class PlugDetectCapabilities : uint32_t {
  HARDWIRED = 0u,
  CAN_ASYNC_NOTIFY = 1u,
};


struct StreamProperties;
enum class GetVmoError : uint32_t {
  INVALID_ARGS = 1u,
  INTERNAL_ERROR = 2u,
};


struct RingBuffer_GetVmo_Result;
class RingBuffer;
struct GainState;
class StreamConfig;

extern "C" const fidl_type_t fuchsia_hardware_audio_PlugStateTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_PlugStateTable;

// Plug state as returned by the driver.
struct PlugState final : private ::fidl::VectorView<fidl_envelope_t> {
  using EnvelopesView = ::fidl::VectorView<fidl_envelope_t>;
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return EnvelopesView::empty(); }

  // Stream is currently plugged in. Must be included.
  const bool& plugged() const {
    ZX_ASSERT(has_plugged());
    return *reinterpret_cast<const bool*>(EnvelopesView::at(1 - 1).data);
  }
  bool& plugged() {
    ZX_ASSERT(has_plugged());
    return *reinterpret_cast<bool*>(EnvelopesView::at(1 - 1).data);
  }
  bool has_plugged() const {
    return EnvelopesView::count() >= 1 && EnvelopesView::at(1 - 1).data != nullptr;
  }

  // Timestamps the information provided in the rest of the fields of this struct.
  // Must be included.
  const int64_t& plug_state_time() const {
    ZX_ASSERT(has_plug_state_time());
    return *reinterpret_cast<const int64_t*>(EnvelopesView::at(2 - 1).data);
  }
  int64_t& plug_state_time() {
    ZX_ASSERT(has_plug_state_time());
    return *reinterpret_cast<int64_t*>(EnvelopesView::at(2 - 1).data);
  }
  bool has_plug_state_time() const {
    return EnvelopesView::count() >= 2 && EnvelopesView::at(2 - 1).data != nullptr;
  }

  PlugState() = default;
  ~PlugState() = default;
  PlugState(PlugState&& other) noexcept = default;
  PlugState& operator=(PlugState&& other) noexcept = default;

  class Builder;
  friend class Builder;
  static Builder Build();
  static constexpr const fidl_type_t* Type = &fuchsia_hardware_audio_PlugStateTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_audio_PlugStateTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 48;
  static constexpr uint32_t AltPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 48;

 private:
  PlugState(uint64_t max_ordinal, fidl_envelope_t* data) : EnvelopesView(data, max_ordinal) {}
};

class PlugState::Builder {
 public:
  PlugState view() { return PlugState(max_ordinal_, envelopes_.data_); }
  ~Builder() = default;
  Builder(Builder&& other) noexcept = default;
  Builder& operator=(Builder&& other) noexcept = default;

  // Stream is currently plugged in. Must be included.
  Builder&& set_plugged(bool* elem);

  // Timestamps the information provided in the rest of the fields of this struct.
  // Must be included.
  Builder&& set_plug_state_time(int64_t* elem);

 private:
  Builder() = default;
  friend Builder PlugState::Build();

  uint64_t max_ordinal_ = 0;
  ::fidl::Array<fidl_envelope_t, 2> envelopes_ = {};
};

extern "C" const fidl_type_t fuchsia_hardware_audio_RingBufferPropertiesTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_RingBufferPropertiesTable;

struct RingBufferProperties final : private ::fidl::VectorView<fidl_envelope_t> {
  using EnvelopesView = ::fidl::VectorView<fidl_envelope_t>;
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return EnvelopesView::empty(); }

  // The driver's best estimate of the external delay (in nanoseconds) present in the
  // presentation pipeline for the chosen format. When precisely synchronizing presentation
  // across multiple entities (e.g. devices), the external delay should be taken into account.
  const int64_t& external_delay() const {
    ZX_ASSERT(has_external_delay());
    return *reinterpret_cast<const int64_t*>(EnvelopesView::at(1 - 1).data);
  }
  int64_t& external_delay() {
    ZX_ASSERT(has_external_delay());
    return *reinterpret_cast<int64_t*>(EnvelopesView::at(1 - 1).data);
  }
  bool has_external_delay() const {
    return EnvelopesView::count() >= 1 && EnvelopesView::at(1 - 1).data != nullptr;
  }

  // Size (in bytes) representing a temporary buffer used by the driver in order to consume or
  // generate the ring buffer contents. The ring buffer contents must be produced and consumed
  // at the rate specified with the |CreateRingBuffer| command, however some amount of buffering
  // is required when the data is written into and read from the ring buffer. For playback the
  // data is consumed by the driver by reading ahead up to |fifo_depth| bytes. For capture the
  // data is produced by the driver holding up to |fifo_depth| bytes at the time before
  // committing it to main system memory. Hence |fifo_depth| must be taken into account by the
  // client when determining either the minimum lead time requirement (for playback) or the
  // maximum capture delay (for capture).
  //
  // To convert |fifo_depth| to the corresponding number of audio frames, use the frame size
  // returned by |CreateRingBuffer| in the |StreamConfig| protocol, note that the |fifo_depth|
  // is not necessarily a multiple size of an audio frame.
  //
  // The ring buffer data may be directly consumed/generated by hardware, in this case
  // |fifo_depth| maps directly to the size of a hardware FIFO block, since the hardware FIFO
  // block determines the amount of data read ahead or held back.
  //
  // The ring buffer data may instead be consumed/generated by audio driver software that is
  // conceptually situated between the ring buffer and the audio hardware. In this case, for
  // playback the |fifo_depth| read ahead amount is set large enough such that the driver
  // guarantees no undetected underruns, this assuming the client is generating the data as
  // determined by the |CreateRingBuffer| and |Start| commands. For capture, the
  // |fifo_depth| held back amount is set large enough such that the driver guarantees no
  // undetected underruns when generating the data as determined by the |CreateRingBuffer| and
  // |Start| commands. The driver must set |fifo_depth| big enough such that the potential
  // delays added by any software interfacing with the audio hardware do not occur under most
  // scenarios, and must detect and report underruns. How an underrun is reported is not defined
  // in this API.
  const uint32_t& fifo_depth() const {
    ZX_ASSERT(has_fifo_depth());
    return *reinterpret_cast<const uint32_t*>(EnvelopesView::at(2 - 1).data);
  }
  uint32_t& fifo_depth() {
    ZX_ASSERT(has_fifo_depth());
    return *reinterpret_cast<uint32_t*>(EnvelopesView::at(2 - 1).data);
  }
  bool has_fifo_depth() const {
    return EnvelopesView::count() >= 2 && EnvelopesView::at(2 - 1).data != nullptr;
  }

  // An identifier for the clock domain in which this hardware operates. If the hardware is
  // operating in CLOCK_DOMAIN_MONOTONIC, its nominal rate is locked to that of the
  // ZX_CLOCK_MONOTONIC time reference. Given the start time, and a nominal rate, the position
  // of the playback/capture pointer may always be calculated using a clock monotonic timestamp
  // as the pointer's movement is locked to that of ZX_CLOCK_MONOTONIC.
  //
  // Other values indicate that playback/capture is not locked to ZX_CLOCK_MONOTONIC, and moves
  // at its own rate depending on a number of factors. Client will need to make use of the
  // timing information present in the position notification updates in order to recover the
  // clock of the audio stream. The clock_domain comes from an system wide entity (or instance a
  // platform bus or clock tree/global driver). Audio drivers retrieve clock_domain from such
  // system wide entity.
  const uint32_t& clock_domain() const {
    ZX_ASSERT(has_clock_domain());
    return *reinterpret_cast<const uint32_t*>(EnvelopesView::at(3 - 1).data);
  }
  uint32_t& clock_domain() {
    ZX_ASSERT(has_clock_domain());
    return *reinterpret_cast<uint32_t*>(EnvelopesView::at(3 - 1).data);
  }
  bool has_clock_domain() const {
    return EnvelopesView::count() >= 3 && EnvelopesView::at(3 - 1).data != nullptr;
  }

  // When set to true, indicates that clients need to make sure that their data has been flushed
  // all the way to physical memory (in the case of playback) or that their view of the ring
  // buffer will need to be invalidated before read (in the case of capture).
  const bool& needs_cache_flush_or_invalidate() const {
    ZX_ASSERT(has_needs_cache_flush_or_invalidate());
    return *reinterpret_cast<const bool*>(EnvelopesView::at(4 - 1).data);
  }
  bool& needs_cache_flush_or_invalidate() {
    ZX_ASSERT(has_needs_cache_flush_or_invalidate());
    return *reinterpret_cast<bool*>(EnvelopesView::at(4 - 1).data);
  }
  bool has_needs_cache_flush_or_invalidate() const {
    return EnvelopesView::count() >= 4 && EnvelopesView::at(4 - 1).data != nullptr;
  }

  RingBufferProperties() = default;
  ~RingBufferProperties() = default;
  RingBufferProperties(RingBufferProperties&& other) noexcept = default;
  RingBufferProperties& operator=(RingBufferProperties&& other) noexcept = default;

  class Builder;
  friend class Builder;
  static Builder Build();
  static constexpr const fidl_type_t* Type = &fuchsia_hardware_audio_RingBufferPropertiesTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_audio_RingBufferPropertiesTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 96;
  static constexpr uint32_t AltPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 96;

 private:
  RingBufferProperties(uint64_t max_ordinal, fidl_envelope_t* data) : EnvelopesView(data, max_ordinal) {}
};

class RingBufferProperties::Builder {
 public:
  RingBufferProperties view() { return RingBufferProperties(max_ordinal_, envelopes_.data_); }
  ~Builder() = default;
  Builder(Builder&& other) noexcept = default;
  Builder& operator=(Builder&& other) noexcept = default;

  // The driver's best estimate of the external delay (in nanoseconds) present in the
  // presentation pipeline for the chosen format. When precisely synchronizing presentation
  // across multiple entities (e.g. devices), the external delay should be taken into account.
  Builder&& set_external_delay(int64_t* elem);

  // Size (in bytes) representing a temporary buffer used by the driver in order to consume or
  // generate the ring buffer contents. The ring buffer contents must be produced and consumed
  // at the rate specified with the |CreateRingBuffer| command, however some amount of buffering
  // is required when the data is written into and read from the ring buffer. For playback the
  // data is consumed by the driver by reading ahead up to |fifo_depth| bytes. For capture the
  // data is produced by the driver holding up to |fifo_depth| bytes at the time before
  // committing it to main system memory. Hence |fifo_depth| must be taken into account by the
  // client when determining either the minimum lead time requirement (for playback) or the
  // maximum capture delay (for capture).
  //
  // To convert |fifo_depth| to the corresponding number of audio frames, use the frame size
  // returned by |CreateRingBuffer| in the |StreamConfig| protocol, note that the |fifo_depth|
  // is not necessarily a multiple size of an audio frame.
  //
  // The ring buffer data may be directly consumed/generated by hardware, in this case
  // |fifo_depth| maps directly to the size of a hardware FIFO block, since the hardware FIFO
  // block determines the amount of data read ahead or held back.
  //
  // The ring buffer data may instead be consumed/generated by audio driver software that is
  // conceptually situated between the ring buffer and the audio hardware. In this case, for
  // playback the |fifo_depth| read ahead amount is set large enough such that the driver
  // guarantees no undetected underruns, this assuming the client is generating the data as
  // determined by the |CreateRingBuffer| and |Start| commands. For capture, the
  // |fifo_depth| held back amount is set large enough such that the driver guarantees no
  // undetected underruns when generating the data as determined by the |CreateRingBuffer| and
  // |Start| commands. The driver must set |fifo_depth| big enough such that the potential
  // delays added by any software interfacing with the audio hardware do not occur under most
  // scenarios, and must detect and report underruns. How an underrun is reported is not defined
  // in this API.
  Builder&& set_fifo_depth(uint32_t* elem);

  // An identifier for the clock domain in which this hardware operates. If the hardware is
  // operating in CLOCK_DOMAIN_MONOTONIC, its nominal rate is locked to that of the
  // ZX_CLOCK_MONOTONIC time reference. Given the start time, and a nominal rate, the position
  // of the playback/capture pointer may always be calculated using a clock monotonic timestamp
  // as the pointer's movement is locked to that of ZX_CLOCK_MONOTONIC.
  //
  // Other values indicate that playback/capture is not locked to ZX_CLOCK_MONOTONIC, and moves
  // at its own rate depending on a number of factors. Client will need to make use of the
  // timing information present in the position notification updates in order to recover the
  // clock of the audio stream. The clock_domain comes from an system wide entity (or instance a
  // platform bus or clock tree/global driver). Audio drivers retrieve clock_domain from such
  // system wide entity.
  Builder&& set_clock_domain(uint32_t* elem);

  // When set to true, indicates that clients need to make sure that their data has been flushed
  // all the way to physical memory (in the case of playback) or that their view of the ring
  // buffer will need to be invalidated before read (in the case of capture).
  Builder&& set_needs_cache_flush_or_invalidate(bool* elem);

 private:
  Builder() = default;
  friend Builder RingBufferProperties::Build();

  uint64_t max_ordinal_ = 0;
  ::fidl::Array<fidl_envelope_t, 4> envelopes_ = {};
};

extern "C" const fidl_type_t fuchsia_hardware_audio_SupportedFormatsTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_SupportedFormatsTable;

struct SupportedFormats final : private ::fidl::VectorView<fidl_envelope_t> {
  using EnvelopesView = ::fidl::VectorView<fidl_envelope_t>;
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return EnvelopesView::empty(); }

  // Supported formats for non-compressed PCM samples.
  const ::llcpp::fuchsia::hardware::audio::PcmSupportedFormats& pcm_supported_formats() const {
    ZX_ASSERT(has_pcm_supported_formats());
    return *reinterpret_cast<const ::llcpp::fuchsia::hardware::audio::PcmSupportedFormats*>(EnvelopesView::at(1 - 1).data);
  }
  ::llcpp::fuchsia::hardware::audio::PcmSupportedFormats& pcm_supported_formats() {
    ZX_ASSERT(has_pcm_supported_formats());
    return *reinterpret_cast<::llcpp::fuchsia::hardware::audio::PcmSupportedFormats*>(EnvelopesView::at(1 - 1).data);
  }
  bool has_pcm_supported_formats() const {
    return EnvelopesView::count() >= 1 && EnvelopesView::at(1 - 1).data != nullptr;
  }

  SupportedFormats() = default;
  ~SupportedFormats() = default;
  SupportedFormats(SupportedFormats&& other) noexcept = default;
  SupportedFormats& operator=(SupportedFormats&& other) noexcept = default;

  class Builder;
  friend class Builder;
  static Builder Build();
  static constexpr const fidl_type_t* Type = &fuchsia_hardware_audio_SupportedFormatsTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_audio_SupportedFormatsTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 440;
  static constexpr uint32_t AltPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 440;

 private:
  SupportedFormats(uint64_t max_ordinal, fidl_envelope_t* data) : EnvelopesView(data, max_ordinal) {}
};

class SupportedFormats::Builder {
 public:
  SupportedFormats view() { return SupportedFormats(max_ordinal_, envelopes_.data_); }
  ~Builder() = default;
  Builder(Builder&& other) noexcept = default;
  Builder& operator=(Builder&& other) noexcept = default;

  // Supported formats for non-compressed PCM samples.
  Builder&& set_pcm_supported_formats(::llcpp::fuchsia::hardware::audio::PcmSupportedFormats* elem);

 private:
  Builder() = default;
  friend Builder SupportedFormats::Build();

  uint64_t max_ordinal_ = 0;
  ::fidl::Array<fidl_envelope_t, 1> envelopes_ = {};
};

extern "C" const fidl_type_t fuchsia_hardware_audio_FormatTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_FormatTable;

struct Format final : private ::fidl::VectorView<fidl_envelope_t> {
  using EnvelopesView = ::fidl::VectorView<fidl_envelope_t>;
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return EnvelopesView::empty(); }

  // Format supporting non-compressed PCM samples.
  const ::llcpp::fuchsia::hardware::audio::PcmFormat& pcm_format() const {
    ZX_ASSERT(has_pcm_format());
    return *reinterpret_cast<const ::llcpp::fuchsia::hardware::audio::PcmFormat*>(EnvelopesView::at(1 - 1).data);
  }
  ::llcpp::fuchsia::hardware::audio::PcmFormat& pcm_format() {
    ZX_ASSERT(has_pcm_format());
    return *reinterpret_cast<::llcpp::fuchsia::hardware::audio::PcmFormat*>(EnvelopesView::at(1 - 1).data);
  }
  bool has_pcm_format() const {
    return EnvelopesView::count() >= 1 && EnvelopesView::at(1 - 1).data != nullptr;
  }

  Format() = default;
  ~Format() = default;
  Format(Format&& other) noexcept = default;
  Format& operator=(Format&& other) noexcept = default;

  class Builder;
  friend class Builder;
  static Builder Build();
  static constexpr const fidl_type_t* Type = &fuchsia_hardware_audio_FormatTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_audio_FormatTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 40;
  static constexpr uint32_t AltPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 40;

 private:
  Format(uint64_t max_ordinal, fidl_envelope_t* data) : EnvelopesView(data, max_ordinal) {}
};

class Format::Builder {
 public:
  Format view() { return Format(max_ordinal_, envelopes_.data_); }
  ~Builder() = default;
  Builder(Builder&& other) noexcept = default;
  Builder& operator=(Builder&& other) noexcept = default;

  // Format supporting non-compressed PCM samples.
  Builder&& set_pcm_format(::llcpp::fuchsia::hardware::audio::PcmFormat* elem);

 private:
  Builder() = default;
  friend Builder Format::Build();

  uint64_t max_ordinal_ = 0;
  ::fidl::Array<fidl_envelope_t, 1> envelopes_ = {};
};

extern "C" const fidl_type_t fuchsia_hardware_audio_StreamPropertiesTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_StreamPropertiesTable;

struct StreamProperties final : private ::fidl::VectorView<fidl_envelope_t> {
  using EnvelopesView = ::fidl::VectorView<fidl_envelope_t>;
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return EnvelopesView::empty(); }

  // A unique identifier. If not included, there is no unique id for the StreamConfig.
  const ::fidl::Array<uint8_t, 16>& unique_id() const {
    ZX_ASSERT(has_unique_id());
    return *reinterpret_cast<const ::fidl::Array<uint8_t, 16>*>(EnvelopesView::at(1 - 1).data);
  }
  ::fidl::Array<uint8_t, 16>& unique_id() {
    ZX_ASSERT(has_unique_id());
    return *reinterpret_cast<::fidl::Array<uint8_t, 16>*>(EnvelopesView::at(1 - 1).data);
  }
  bool has_unique_id() const {
    return EnvelopesView::count() >= 1 && EnvelopesView::at(1 - 1).data != nullptr;
  }

  // Stream type is input or output. Must be included.
  const bool& is_input() const {
    ZX_ASSERT(has_is_input());
    return *reinterpret_cast<const bool*>(EnvelopesView::at(2 - 1).data);
  }
  bool& is_input() {
    ZX_ASSERT(has_is_input());
    return *reinterpret_cast<bool*>(EnvelopesView::at(2 - 1).data);
  }
  bool has_is_input() const {
    return EnvelopesView::count() >= 2 && EnvelopesView::at(2 - 1).data != nullptr;
  }

  // Gain mute capability. If not included, the StreamConfig can't mute.
  const bool& can_mute() const {
    ZX_ASSERT(has_can_mute());
    return *reinterpret_cast<const bool*>(EnvelopesView::at(3 - 1).data);
  }
  bool& can_mute() {
    ZX_ASSERT(has_can_mute());
    return *reinterpret_cast<bool*>(EnvelopesView::at(3 - 1).data);
  }
  bool has_can_mute() const {
    return EnvelopesView::count() >= 3 && EnvelopesView::at(3 - 1).data != nullptr;
  }

  // Automatic Gain Control (AGC) capability. If not included, the StreamConfig can't AGC.
  const bool& can_agc() const {
    ZX_ASSERT(has_can_agc());
    return *reinterpret_cast<const bool*>(EnvelopesView::at(4 - 1).data);
  }
  bool& can_agc() {
    ZX_ASSERT(has_can_agc());
    return *reinterpret_cast<bool*>(EnvelopesView::at(4 - 1).data);
  }
  bool has_can_agc() const {
    return EnvelopesView::count() >= 4 && EnvelopesView::at(4 - 1).data != nullptr;
  }

  // Minimum gain in decibels. Must be included.
  const float& min_gain_db() const {
    ZX_ASSERT(has_min_gain_db());
    return *reinterpret_cast<const float*>(EnvelopesView::at(5 - 1).data);
  }
  float& min_gain_db() {
    ZX_ASSERT(has_min_gain_db());
    return *reinterpret_cast<float*>(EnvelopesView::at(5 - 1).data);
  }
  bool has_min_gain_db() const {
    return EnvelopesView::count() >= 5 && EnvelopesView::at(5 - 1).data != nullptr;
  }

  // Maximum gain in decibels. Must be included.
  const float& max_gain_db() const {
    ZX_ASSERT(has_max_gain_db());
    return *reinterpret_cast<const float*>(EnvelopesView::at(6 - 1).data);
  }
  float& max_gain_db() {
    ZX_ASSERT(has_max_gain_db());
    return *reinterpret_cast<float*>(EnvelopesView::at(6 - 1).data);
  }
  bool has_max_gain_db() const {
    return EnvelopesView::count() >= 6 && EnvelopesView::at(6 - 1).data != nullptr;
  }

  // Gain step in decibels, this value must not be negative, but may be zero to convey an
  // effectively continuous range of values. Must be included.
  const float& gain_step_db() const {
    ZX_ASSERT(has_gain_step_db());
    return *reinterpret_cast<const float*>(EnvelopesView::at(7 - 1).data);
  }
  float& gain_step_db() {
    ZX_ASSERT(has_gain_step_db());
    return *reinterpret_cast<float*>(EnvelopesView::at(7 - 1).data);
  }
  bool has_gain_step_db() const {
    return EnvelopesView::count() >= 7 && EnvelopesView::at(7 - 1).data != nullptr;
  }

  // Plug Detect Capabilities. Must be included.
  const ::llcpp::fuchsia::hardware::audio::PlugDetectCapabilities& plug_detect_capabilities() const {
    ZX_ASSERT(has_plug_detect_capabilities());
    return *reinterpret_cast<const ::llcpp::fuchsia::hardware::audio::PlugDetectCapabilities*>(EnvelopesView::at(8 - 1).data);
  }
  ::llcpp::fuchsia::hardware::audio::PlugDetectCapabilities& plug_detect_capabilities() {
    ZX_ASSERT(has_plug_detect_capabilities());
    return *reinterpret_cast<::llcpp::fuchsia::hardware::audio::PlugDetectCapabilities*>(EnvelopesView::at(8 - 1).data);
  }
  bool has_plug_detect_capabilities() const {
    return EnvelopesView::count() >= 8 && EnvelopesView::at(8 - 1).data != nullptr;
  }

  // UI string for the manufacturer name. If not included, the manufacturer is unspecified.
  const ::fidl::StringView& manufacturer() const {
    ZX_ASSERT(has_manufacturer());
    return *reinterpret_cast<const ::fidl::StringView*>(EnvelopesView::at(9 - 1).data);
  }
  ::fidl::StringView& manufacturer() {
    ZX_ASSERT(has_manufacturer());
    return *reinterpret_cast<::fidl::StringView*>(EnvelopesView::at(9 - 1).data);
  }
  bool has_manufacturer() const {
    return EnvelopesView::count() >= 9 && EnvelopesView::at(9 - 1).data != nullptr;
  }

  // UI string for the product name. If not included, the product name is unspecified.
  const ::fidl::StringView& product() const {
    ZX_ASSERT(has_product());
    return *reinterpret_cast<const ::fidl::StringView*>(EnvelopesView::at(10 - 1).data);
  }
  ::fidl::StringView& product() {
    ZX_ASSERT(has_product());
    return *reinterpret_cast<::fidl::StringView*>(EnvelopesView::at(10 - 1).data);
  }
  bool has_product() const {
    return EnvelopesView::count() >= 10 && EnvelopesView::at(10 - 1).data != nullptr;
  }

  StreamProperties() = default;
  ~StreamProperties() = default;
  StreamProperties(StreamProperties&& other) noexcept = default;
  StreamProperties& operator=(StreamProperties&& other) noexcept = default;

  class Builder;
  friend class Builder;
  static Builder Build();
  static constexpr const fidl_type_t* Type = &fuchsia_hardware_audio_StreamPropertiesTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_audio_StreamPropertiesTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 776;
  static constexpr uint32_t AltPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 776;

 private:
  StreamProperties(uint64_t max_ordinal, fidl_envelope_t* data) : EnvelopesView(data, max_ordinal) {}
};

class StreamProperties::Builder {
 public:
  StreamProperties view() { return StreamProperties(max_ordinal_, envelopes_.data_); }
  ~Builder() = default;
  Builder(Builder&& other) noexcept = default;
  Builder& operator=(Builder&& other) noexcept = default;

  // A unique identifier. If not included, there is no unique id for the StreamConfig.
  Builder&& set_unique_id(::fidl::Array<uint8_t, 16>* elem);

  // Stream type is input or output. Must be included.
  Builder&& set_is_input(bool* elem);

  // Gain mute capability. If not included, the StreamConfig can't mute.
  Builder&& set_can_mute(bool* elem);

  // Automatic Gain Control (AGC) capability. If not included, the StreamConfig can't AGC.
  Builder&& set_can_agc(bool* elem);

  // Minimum gain in decibels. Must be included.
  Builder&& set_min_gain_db(float* elem);

  // Maximum gain in decibels. Must be included.
  Builder&& set_max_gain_db(float* elem);

  // Gain step in decibels, this value must not be negative, but may be zero to convey an
  // effectively continuous range of values. Must be included.
  Builder&& set_gain_step_db(float* elem);

  // Plug Detect Capabilities. Must be included.
  Builder&& set_plug_detect_capabilities(::llcpp::fuchsia::hardware::audio::PlugDetectCapabilities* elem);

  // UI string for the manufacturer name. If not included, the manufacturer is unspecified.
  Builder&& set_manufacturer(::fidl::StringView* elem);

  // UI string for the product name. If not included, the product name is unspecified.
  Builder&& set_product(::fidl::StringView* elem);

 private:
  Builder() = default;
  friend Builder StreamProperties::Build();

  uint64_t max_ordinal_ = 0;
  ::fidl::Array<fidl_envelope_t, 10> envelopes_ = {};
};

extern "C" const fidl_type_t fuchsia_hardware_audio_RingBuffer_GetVmo_ResultTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_RingBuffer_GetVmo_ResultTable;

struct RingBuffer_GetVmo_Result {
  RingBuffer_GetVmo_Result() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal() == Ordinal::kResponse; }

  static RingBuffer_GetVmo_Result WithResponse(::llcpp::fuchsia::hardware::audio::RingBuffer_GetVmo_Response* val) {
    RingBuffer_GetVmo_Result result;
    result.set_response(val);
    return result;
  }

  void set_response(::llcpp::fuchsia::hardware::audio::RingBuffer_GetVmo_Response* elem) {
    ordinal_ = Ordinal::kResponse;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::hardware::audio::RingBuffer_GetVmo_Response& mutable_response() {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::hardware::audio::RingBuffer_GetVmo_Response*>(envelope_.data);
  }
  const ::llcpp::fuchsia::hardware::audio::RingBuffer_GetVmo_Response& response() const {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::hardware::audio::RingBuffer_GetVmo_Response*>(envelope_.data);
  }

  bool is_err() const { return ordinal() == Ordinal::kErr; }

  static RingBuffer_GetVmo_Result WithErr(::llcpp::fuchsia::hardware::audio::GetVmoError* val) {
    RingBuffer_GetVmo_Result result;
    result.set_err(val);
    return result;
  }

  void set_err(::llcpp::fuchsia::hardware::audio::GetVmoError* elem) {
    ordinal_ = Ordinal::kErr;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::hardware::audio::GetVmoError& mutable_err() {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<::llcpp::fuchsia::hardware::audio::GetVmoError*>(envelope_.data);
  }
  const ::llcpp::fuchsia::hardware::audio::GetVmoError& err() const {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<::llcpp::fuchsia::hardware::audio::GetVmoError*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_audio_RingBuffer_GetVmo_ResultTable;
  static constexpr const fidl_type_t* AltType = &fuchsia_hardware_audio_RingBuffer_GetVmo_ResultTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr uint32_t AltPrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 8;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t fuchsia_hardware_audio_GainStateTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_GainStateTable;

// Gain state requested by the client or returned a current by the driver.
struct GainState final : private ::fidl::VectorView<fidl_envelope_t> {
  using EnvelopesView = ::fidl::VectorView<fidl_envelope_t>;
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return EnvelopesView::empty(); }

  // Current mute state. If not included, the state is unmuted.
  const bool& muted() const {
    ZX_ASSERT(has_muted());
    return *reinterpret_cast<const bool*>(EnvelopesView::at(1 - 1).data);
  }
  bool& muted() {
    ZX_ASSERT(has_muted());
    return *reinterpret_cast<bool*>(EnvelopesView::at(1 - 1).data);
  }
  bool has_muted() const {
    return EnvelopesView::count() >= 1 && EnvelopesView::at(1 - 1).data != nullptr;
  }

  // Current Automatic Gain Control (AGC) state. If not included, AGC is disabled.
  const bool& agc_enabled() const {
    ZX_ASSERT(has_agc_enabled());
    return *reinterpret_cast<const bool*>(EnvelopesView::at(2 - 1).data);
  }
  bool& agc_enabled() {
    ZX_ASSERT(has_agc_enabled());
    return *reinterpret_cast<bool*>(EnvelopesView::at(2 - 1).data);
  }
  bool has_agc_enabled() const {
    return EnvelopesView::count() >= 2 && EnvelopesView::at(2 - 1).data != nullptr;
  }

  // Current gain in decibels. Must be included.
  const float& gain_db() const {
    ZX_ASSERT(has_gain_db());
    return *reinterpret_cast<const float*>(EnvelopesView::at(3 - 1).data);
  }
  float& gain_db() {
    ZX_ASSERT(has_gain_db());
    return *reinterpret_cast<float*>(EnvelopesView::at(3 - 1).data);
  }
  bool has_gain_db() const {
    return EnvelopesView::count() >= 3 && EnvelopesView::at(3 - 1).data != nullptr;
  }

  GainState() = default;
  ~GainState() = default;
  GainState(GainState&& other) noexcept = default;
  GainState& operator=(GainState&& other) noexcept = default;

  class Builder;
  friend class Builder;
  static Builder Build();
  static constexpr const fidl_type_t* Type = &fuchsia_hardware_audio_GainStateTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_audio_GainStateTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 72;
  static constexpr uint32_t AltPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 72;

 private:
  GainState(uint64_t max_ordinal, fidl_envelope_t* data) : EnvelopesView(data, max_ordinal) {}
};

class GainState::Builder {
 public:
  GainState view() { return GainState(max_ordinal_, envelopes_.data_); }
  ~Builder() = default;
  Builder(Builder&& other) noexcept = default;
  Builder& operator=(Builder&& other) noexcept = default;

  // Current mute state. If not included, the state is unmuted.
  Builder&& set_muted(bool* elem);

  // Current Automatic Gain Control (AGC) state. If not included, AGC is disabled.
  Builder&& set_agc_enabled(bool* elem);

  // Current gain in decibels. Must be included.
  Builder&& set_gain_db(float* elem);

 private:
  Builder() = default;
  friend Builder GainState::Build();

  uint64_t max_ordinal_ = 0;
  ::fidl::Array<fidl_envelope_t, 3> envelopes_ = {};
};

extern "C" const fidl_type_t fuchsia_hardware_audio_RingBufferPositionInfoTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_RingBufferPositionInfoTable;

struct RingBufferPositionInfo {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_audio_RingBufferPositionInfoTable;
  static constexpr const fidl_type_t* AltType = &fuchsia_hardware_audio_RingBufferPositionInfoTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  // The driver's best estimate of the time at which the playback/capture pointer reached the
  // position indicated by |position|.
  int64_t timestamp = {};

  // The playback/capture pointer position (in bytes) in the ring buffer at time
  // |timestamp| as estimated by the driver.
  uint32_t position = {};
};

constexpr uint32_t CLOCK_DOMAIN_MONOTONIC = 0u;

constexpr uint32_t CLOCK_DOMAIN_EXTERNAL = 4294967295u;

constexpr uint32_t UNIQUE_ID_SIZE = 16u;

extern "C" const fidl_type_t fuchsia_hardware_audio_DeviceGetChannelRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_DeviceGetChannelRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_audio_DeviceGetChannelResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_DeviceGetChannelResponseTable;

class Device final {
  Device() = delete;
 public:

  struct GetChannelResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::channel channel;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_audio_DeviceGetChannelResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_hardware_audio_DeviceGetChannelResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetChannelRequest = ::fidl::AnyZeroArgMessage;


  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    template <typename ResponseType>
    class GetChannel_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetChannel_Impl(::zx::unowned_channel _client_end);
      ~GetChannel_Impl() = default;
      GetChannel_Impl(GetChannel_Impl&& other) = default;
      GetChannel_Impl& operator=(GetChannel_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using GetChannel = GetChannel_Impl<GetChannelResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    template <typename ResponseType>
    class GetChannel_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetChannel_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetChannel_Impl() = default;
      GetChannel_Impl(GetChannel_Impl&& other) = default;
      GetChannel_Impl& operator=(GetChannel_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using GetChannel = GetChannel_Impl<GetChannelResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // This method obtains a channel in order to serve FIDL over it outside the devhost's control.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetChannel GetChannel();

    // This method obtains a channel in order to serve FIDL over it outside the devhost's control.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetChannel GetChannel(::fidl::BytePart _response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // This method obtains a channel in order to serve FIDL over it outside the devhost's control.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetChannel GetChannel(::zx::unowned_channel _client_end);

    // This method obtains a channel in order to serve FIDL over it outside the devhost's control.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetChannel GetChannel(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // This method obtains a channel in order to serve FIDL over it outside the devhost's control.
    static ::fidl::DecodeResult<GetChannelResponse> GetChannel(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Device;
    using _Base = ::fidl::CompleterBase;

    class GetChannelCompleterBase : public _Base {
     public:
      void Reply(::zx::channel channel);
      void Reply(::fidl::BytePart _buffer, ::zx::channel channel);
      void Reply(::fidl::DecodedMessage<GetChannelResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetChannelCompleter = ::fidl::Completer<GetChannelCompleterBase>;

    virtual void GetChannel(GetChannelCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void GetChannelRequest(const ::fidl::DecodedMessage<Device::GetChannelRequest>& _msg);
    static void GetChannelResponse(const ::fidl::DecodedMessage<Device::GetChannelResponse>& _msg);
  };
};

extern "C" const fidl_type_t fuchsia_hardware_audio_PcmSupportedFormatsTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_PcmSupportedFormatsTable;

// Format supporting non-compressed PCM audio. Frames are made up of |number_of_channels| samples
// which have |valid_bits_per_sample| bits of left-justified data within |bytes_per_sample|
// bytes. All values listed in each vector are supported. When not all combinations supported by
// the driver can be described with one |SupportedFormats| (and hence one |PcmSupportedFormats|),
// |GetSupportedFormats| returns more than one |SupportedFormats| in the returned vector.
// For more detailed information see //zircon/driver_interfaces/audio_streaming.md.
struct PcmSupportedFormats {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_audio_PcmSupportedFormatsTable;
  static constexpr const fidl_type_t* AltType = &fuchsia_hardware_audio_PcmSupportedFormatsTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 80;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 344;
  static constexpr uint32_t AltPrimarySize = 80;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 344;

  // Vector of possible number of channels supported in ascending order.
  ::fidl::VectorView<uint8_t> number_of_channels = {};

  // Vector of possible |SampleFormat|s supported.
  ::fidl::VectorView<::llcpp::fuchsia::hardware::audio::SampleFormat> sample_formats = {};

  // Vector of possible number of bits allocated to hold a sample,
  // equal or bigger than the actual sample size in |valid_bits_per_sample| in ascending order.
  ::fidl::VectorView<uint8_t> bytes_per_sample = {};

  // Vector of possible number of bits in a sample in ascending order, must be equal or smaller
  // than |bytes_per_channel| for samples to fit. If smaller, bits are left justified, and any
  // additional bits will be ignored.
  ::fidl::VectorView<uint8_t> valid_bits_per_sample = {};

  // Vector of possible frame rates supported in ascending order.
  ::fidl::VectorView<uint32_t> frame_rates = {};
};

extern "C" const fidl_type_t fuchsia_hardware_audio_PcmFormatTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_PcmFormatTable;

// Format supporting non-compressed PCM audio. Frames are made up of |number_of_channels| samples
// which have |valid_bits_per_sample| bits of left-justified data within |bytes_per_channel|.
// bytes. For more detailed information see //zircon/driver_interfaces/audio_streaming.md.
struct PcmFormat {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_audio_PcmFormatTable;
  static constexpr const fidl_type_t* AltType = &fuchsia_hardware_audio_PcmFormatTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  // Number of channels.
  uint8_t number_of_channels = {};

  // Which channels to use as a bitmask. Channels not set in the bitmask are ignored.
  // The least significant bit corresponds to index 0.
  uint64_t channels_to_use_bitmask = {};

  // The format of all samples.
  ::llcpp::fuchsia::hardware::audio::SampleFormat sample_format = {};

  // Bytes allocated to hold a sample, equal or bigger than the valid sample size in
  // |valid_bits_per_sample|.
  uint8_t bytes_per_sample = {};

  // Number of valid bits in a sample, must be equal or smaller than bits in |bytes_per_sample|.
  // If smaller, bits are left justified, and any additional bits must be ignored by the
  // receiver.
  uint8_t valid_bits_per_sample = {};

  // The frame rate for all samples.
  uint32_t frame_rate = {};
};

extern "C" const fidl_type_t fuchsia_hardware_audio_RingBuffer_GetVmo_ResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_RingBuffer_GetVmo_ResponseTable;

struct RingBuffer_GetVmo_Response {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_audio_RingBuffer_GetVmo_ResponseTable;
  static constexpr const fidl_type_t* AltType = &fuchsia_hardware_audio_RingBuffer_GetVmo_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  uint32_t num_frames = {};

  ::zx::vmo ring_buffer = {};
};

constexpr uint32_t MAX_UI_STRING_SIZE = 256u;

constexpr uint32_t MAX_COUNT_SUPPORTED_VALID_BITS_PER_SAMPLE = 8u;

constexpr uint32_t MAX_COUNT_SUPPORTED_SAMPLE_FORMATS = 3u;

constexpr uint32_t MAX_COUNT_SUPPORTED_RATES = 64u;

constexpr uint32_t MAX_COUNT_SUPPORTED_NUMBER_OF_CHANNELS = 64u;

constexpr uint32_t MAX_COUNT_SUPPORTED_BYTES_PER_SAMPLE = 8u;

constexpr uint32_t MAX_COUNT_FORMATS = 64u;

constexpr uint32_t MAX_COUNT_CHANNELS_TO_USE = 64u;

extern "C" const fidl_type_t fuchsia_hardware_audio_RingBufferGetPropertiesRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_RingBufferGetPropertiesRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_audio_RingBufferGetPropertiesResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_RingBufferGetPropertiesResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_audio_RingBufferWatchClockRecoveryPositionInfoRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_RingBufferWatchClockRecoveryPositionInfoRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_audio_RingBufferWatchClockRecoveryPositionInfoResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_RingBufferWatchClockRecoveryPositionInfoResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_audio_RingBufferGetVmoRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_RingBufferGetVmoRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_audio_RingBufferGetVmoResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_RingBufferGetVmoResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_audio_RingBufferStartRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_RingBufferStartRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_audio_RingBufferStartResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_RingBufferStartResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_audio_RingBufferStopRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_RingBufferStopRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_audio_RingBufferStopResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_RingBufferStopResponseTable;

class RingBuffer final {
  RingBuffer() = delete;
 public:

  struct GetPropertiesResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::audio::RingBufferProperties properties;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_audio_RingBufferGetPropertiesResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_hardware_audio_RingBufferGetPropertiesResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 96;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 96;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetPropertiesRequest = ::fidl::AnyZeroArgMessage;

  struct WatchClockRecoveryPositionInfoResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::audio::RingBufferPositionInfo position_info;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_audio_RingBufferWatchClockRecoveryPositionInfoResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_hardware_audio_RingBufferWatchClockRecoveryPositionInfoResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using WatchClockRecoveryPositionInfoRequest = ::fidl::AnyZeroArgMessage;

  struct GetVmoResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::audio::RingBuffer_GetVmo_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_audio_RingBufferGetVmoResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_hardware_audio_RingBufferGetVmoResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct GetVmoRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t min_frames;
    uint32_t clock_recovery_notifications_per_ring;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_audio_RingBufferGetVmoRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_hardware_audio_RingBufferGetVmoRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = GetVmoResponse;
  };

  struct StartResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int64_t start_time;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_audio_RingBufferStartResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_hardware_audio_RingBufferStartResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using StartRequest = ::fidl::AnyZeroArgMessage;

  using StopResponse = ::fidl::AnyZeroArgMessage;
  using StopRequest = ::fidl::AnyZeroArgMessage;


  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    template <typename ResponseType>
    class GetProperties_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetProperties_Impl(::zx::unowned_channel _client_end);
      ~GetProperties_Impl() = default;
      GetProperties_Impl(GetProperties_Impl&& other) = default;
      GetProperties_Impl& operator=(GetProperties_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class WatchClockRecoveryPositionInfo_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      WatchClockRecoveryPositionInfo_Impl(::zx::unowned_channel _client_end);
      ~WatchClockRecoveryPositionInfo_Impl() = default;
      WatchClockRecoveryPositionInfo_Impl(WatchClockRecoveryPositionInfo_Impl&& other) = default;
      WatchClockRecoveryPositionInfo_Impl& operator=(WatchClockRecoveryPositionInfo_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetVmo_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetVmo_Impl(::zx::unowned_channel _client_end, uint32_t min_frames, uint32_t clock_recovery_notifications_per_ring);
      ~GetVmo_Impl() = default;
      GetVmo_Impl(GetVmo_Impl&& other) = default;
      GetVmo_Impl& operator=(GetVmo_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Start_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Start_Impl(::zx::unowned_channel _client_end);
      ~Start_Impl() = default;
      Start_Impl(Start_Impl&& other) = default;
      Start_Impl& operator=(Start_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Stop_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Stop_Impl(::zx::unowned_channel _client_end);
      ~Stop_Impl() = default;
      Stop_Impl(Stop_Impl&& other) = default;
      Stop_Impl& operator=(Stop_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using GetProperties = GetProperties_Impl<GetPropertiesResponse>;
    using WatchClockRecoveryPositionInfo = WatchClockRecoveryPositionInfo_Impl<WatchClockRecoveryPositionInfoResponse>;
    using GetVmo = GetVmo_Impl<GetVmoResponse>;
    using Start = Start_Impl<StartResponse>;
    using Stop = Stop_Impl<StopResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    template <typename ResponseType>
    class GetProperties_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetProperties_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetProperties_Impl() = default;
      GetProperties_Impl(GetProperties_Impl&& other) = default;
      GetProperties_Impl& operator=(GetProperties_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class WatchClockRecoveryPositionInfo_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      WatchClockRecoveryPositionInfo_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~WatchClockRecoveryPositionInfo_Impl() = default;
      WatchClockRecoveryPositionInfo_Impl(WatchClockRecoveryPositionInfo_Impl&& other) = default;
      WatchClockRecoveryPositionInfo_Impl& operator=(WatchClockRecoveryPositionInfo_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetVmo_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetVmo_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t min_frames, uint32_t clock_recovery_notifications_per_ring, ::fidl::BytePart _response_buffer);
      ~GetVmo_Impl() = default;
      GetVmo_Impl(GetVmo_Impl&& other) = default;
      GetVmo_Impl& operator=(GetVmo_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Start_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Start_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Start_Impl() = default;
      Start_Impl(Start_Impl&& other) = default;
      Start_Impl& operator=(Start_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Stop_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Stop_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Stop_Impl() = default;
      Stop_Impl(Stop_Impl&& other) = default;
      Stop_Impl& operator=(Stop_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using GetProperties = GetProperties_Impl<GetPropertiesResponse>;
    using WatchClockRecoveryPositionInfo = WatchClockRecoveryPositionInfo_Impl<WatchClockRecoveryPositionInfoResponse>;
    using GetVmo = GetVmo_Impl<GetVmoResponse>;
    using Start = Start_Impl<StartResponse>;
    using Stop = Stop_Impl<StopResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Accessor for top level static properties.
    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::GetProperties GetProperties();

    // Accessor for top level static properties.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetProperties GetProperties(::fidl::BytePart _response_buffer);

    // Gets the ring buffer current position via a hanging get. The driver must immediately
    // respond to a client's first |WatchClockRecoveryPositionInfo| call, but will not respond to
    // subsequent client calls until the position information has changed from what was most
    // recently provided to that client. If |clock_recovery_notifications_per_ring| is not zero,
    // the driver will reply with its estimated position to be used for clock recovery at most at
    // |clock_recovery_notifications_per_ring| frequency.
    // Must be delivered with timestamps that are monotonically increasing.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::WatchClockRecoveryPositionInfo WatchClockRecoveryPositionInfo();

    // Gets the ring buffer current position via a hanging get. The driver must immediately
    // respond to a client's first |WatchClockRecoveryPositionInfo| call, but will not respond to
    // subsequent client calls until the position information has changed from what was most
    // recently provided to that client. If |clock_recovery_notifications_per_ring| is not zero,
    // the driver will reply with its estimated position to be used for clock recovery at most at
    // |clock_recovery_notifications_per_ring| frequency.
    // Must be delivered with timestamps that are monotonically increasing.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::WatchClockRecoveryPositionInfo WatchClockRecoveryPositionInfo(::fidl::BytePart _response_buffer);

    // Requests a shared buffer to be used for moving bulk audio data. Requests the buffer size to
    // fit at least |min_frames|, and returns the actual |num_frames| allocated in
    // |ring_buffer|.
    //
    // If |clock_recovery_notifications_per_ring| is non-zero, the driver will send replies to
    // |WatchClockRecoveryPositionInfo| client requests at most at
    // |clock_recovery_notifications_per_ring| frequency. These notifications are meant to be used
    // for clock recovery.
    //
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetVmo GetVmo(uint32_t min_frames, uint32_t clock_recovery_notifications_per_ring);

    // Requests a shared buffer to be used for moving bulk audio data. Requests the buffer size to
    // fit at least |min_frames|, and returns the actual |num_frames| allocated in
    // |ring_buffer|.
    //
    // If |clock_recovery_notifications_per_ring| is non-zero, the driver will send replies to
    // |WatchClockRecoveryPositionInfo| client requests at most at
    // |clock_recovery_notifications_per_ring| frequency. These notifications are meant to be used
    // for clock recovery.
    //
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetVmo GetVmo(::fidl::BytePart _request_buffer, uint32_t min_frames, uint32_t clock_recovery_notifications_per_ring, ::fidl::BytePart _response_buffer);

    // Start the ring buffer.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Start Start();

    // Start the ring buffer.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Start Start(::fidl::BytePart _response_buffer);

    // Stop the ring buffer. Once this call's response is received, no further position
    // notifications will be sent until Start() is called again. TODO(39494): Add timestamp
    // parameter.
    // Allocates 32 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Stop Stop();


   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Accessor for top level static properties.
    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::GetProperties GetProperties(::zx::unowned_channel _client_end);

    // Accessor for top level static properties.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetProperties GetProperties(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Gets the ring buffer current position via a hanging get. The driver must immediately
    // respond to a client's first |WatchClockRecoveryPositionInfo| call, but will not respond to
    // subsequent client calls until the position information has changed from what was most
    // recently provided to that client. If |clock_recovery_notifications_per_ring| is not zero,
    // the driver will reply with its estimated position to be used for clock recovery at most at
    // |clock_recovery_notifications_per_ring| frequency.
    // Must be delivered with timestamps that are monotonically increasing.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::WatchClockRecoveryPositionInfo WatchClockRecoveryPositionInfo(::zx::unowned_channel _client_end);

    // Gets the ring buffer current position via a hanging get. The driver must immediately
    // respond to a client's first |WatchClockRecoveryPositionInfo| call, but will not respond to
    // subsequent client calls until the position information has changed from what was most
    // recently provided to that client. If |clock_recovery_notifications_per_ring| is not zero,
    // the driver will reply with its estimated position to be used for clock recovery at most at
    // |clock_recovery_notifications_per_ring| frequency.
    // Must be delivered with timestamps that are monotonically increasing.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::WatchClockRecoveryPositionInfo WatchClockRecoveryPositionInfo(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Requests a shared buffer to be used for moving bulk audio data. Requests the buffer size to
    // fit at least |min_frames|, and returns the actual |num_frames| allocated in
    // |ring_buffer|.
    //
    // If |clock_recovery_notifications_per_ring| is non-zero, the driver will send replies to
    // |WatchClockRecoveryPositionInfo| client requests at most at
    // |clock_recovery_notifications_per_ring| frequency. These notifications are meant to be used
    // for clock recovery.
    //
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetVmo GetVmo(::zx::unowned_channel _client_end, uint32_t min_frames, uint32_t clock_recovery_notifications_per_ring);

    // Requests a shared buffer to be used for moving bulk audio data. Requests the buffer size to
    // fit at least |min_frames|, and returns the actual |num_frames| allocated in
    // |ring_buffer|.
    //
    // If |clock_recovery_notifications_per_ring| is non-zero, the driver will send replies to
    // |WatchClockRecoveryPositionInfo| client requests at most at
    // |clock_recovery_notifications_per_ring| frequency. These notifications are meant to be used
    // for clock recovery.
    //
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetVmo GetVmo(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t min_frames, uint32_t clock_recovery_notifications_per_ring, ::fidl::BytePart _response_buffer);

    // Start the ring buffer.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Start Start(::zx::unowned_channel _client_end);

    // Start the ring buffer.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Start Start(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Stop the ring buffer. Once this call's response is received, no further position
    // notifications will be sent until Start() is called again. TODO(39494): Add timestamp
    // parameter.
    // Allocates 32 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Stop Stop(::zx::unowned_channel _client_end);


  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Accessor for top level static properties.
    static ::fidl::DecodeResult<GetPropertiesResponse> GetProperties(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Gets the ring buffer current position via a hanging get. The driver must immediately
    // respond to a client's first |WatchClockRecoveryPositionInfo| call, but will not respond to
    // subsequent client calls until the position information has changed from what was most
    // recently provided to that client. If |clock_recovery_notifications_per_ring| is not zero,
    // the driver will reply with its estimated position to be used for clock recovery at most at
    // |clock_recovery_notifications_per_ring| frequency.
    // Must be delivered with timestamps that are monotonically increasing.
    static ::fidl::DecodeResult<WatchClockRecoveryPositionInfoResponse> WatchClockRecoveryPositionInfo(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Requests a shared buffer to be used for moving bulk audio data. Requests the buffer size to
    // fit at least |min_frames|, and returns the actual |num_frames| allocated in
    // |ring_buffer|.
    //
    // If |clock_recovery_notifications_per_ring| is non-zero, the driver will send replies to
    // |WatchClockRecoveryPositionInfo| client requests at most at
    // |clock_recovery_notifications_per_ring| frequency. These notifications are meant to be used
    // for clock recovery.
    //
    static ::fidl::DecodeResult<GetVmoResponse> GetVmo(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetVmoRequest> params, ::fidl::BytePart response_buffer);

    // Start the ring buffer.
    static ::fidl::DecodeResult<StartResponse> Start(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Stop the ring buffer. Once this call's response is received, no further position
    // notifications will be sent until Start() is called again. TODO(39494): Add timestamp
    // parameter.
    static ::fidl::DecodeResult<StopResponse> Stop(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = RingBuffer;
    using _Base = ::fidl::CompleterBase;

    class GetPropertiesCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::hardware::audio::RingBufferProperties properties);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::audio::RingBufferProperties properties);
      void Reply(::fidl::DecodedMessage<GetPropertiesResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetPropertiesCompleter = ::fidl::Completer<GetPropertiesCompleterBase>;

    virtual void GetProperties(GetPropertiesCompleter::Sync _completer) = 0;

    class WatchClockRecoveryPositionInfoCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::hardware::audio::RingBufferPositionInfo position_info);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::audio::RingBufferPositionInfo position_info);
      void Reply(::fidl::DecodedMessage<WatchClockRecoveryPositionInfoResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using WatchClockRecoveryPositionInfoCompleter = ::fidl::Completer<WatchClockRecoveryPositionInfoCompleterBase>;

    virtual void WatchClockRecoveryPositionInfo(WatchClockRecoveryPositionInfoCompleter::Sync _completer) = 0;

    class GetVmoCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::hardware::audio::RingBuffer_GetVmo_Result result);
      void ReplySuccess(uint32_t num_frames, ::zx::vmo ring_buffer);
      void ReplyError(GetVmoError error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::audio::RingBuffer_GetVmo_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, uint32_t num_frames, ::zx::vmo ring_buffer);
      void Reply(::fidl::DecodedMessage<GetVmoResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetVmoCompleter = ::fidl::Completer<GetVmoCompleterBase>;

    virtual void GetVmo(uint32_t min_frames, uint32_t clock_recovery_notifications_per_ring, GetVmoCompleter::Sync _completer) = 0;

    class StartCompleterBase : public _Base {
     public:
      void Reply(int64_t start_time);
      void Reply(::fidl::BytePart _buffer, int64_t start_time);
      void Reply(::fidl::DecodedMessage<StartResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using StartCompleter = ::fidl::Completer<StartCompleterBase>;

    virtual void Start(StartCompleter::Sync _completer) = 0;

    class StopCompleterBase : public _Base {
     public:
      void Reply();

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using StopCompleter = ::fidl::Completer<StopCompleterBase>;

    virtual void Stop(StopCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void GetPropertiesRequest(const ::fidl::DecodedMessage<RingBuffer::GetPropertiesRequest>& _msg);
    static void GetPropertiesResponse(const ::fidl::DecodedMessage<RingBuffer::GetPropertiesResponse>& _msg);
    static void WatchClockRecoveryPositionInfoRequest(const ::fidl::DecodedMessage<RingBuffer::WatchClockRecoveryPositionInfoRequest>& _msg);
    static void WatchClockRecoveryPositionInfoResponse(const ::fidl::DecodedMessage<RingBuffer::WatchClockRecoveryPositionInfoResponse>& _msg);
    static void GetVmoRequest(const ::fidl::DecodedMessage<RingBuffer::GetVmoRequest>& _msg);
    static void GetVmoResponse(const ::fidl::DecodedMessage<RingBuffer::GetVmoResponse>& _msg);
    static void StartRequest(const ::fidl::DecodedMessage<RingBuffer::StartRequest>& _msg);
    static void StartResponse(const ::fidl::DecodedMessage<RingBuffer::StartResponse>& _msg);
    static void StopRequest(const ::fidl::DecodedMessage<RingBuffer::StopRequest>& _msg);
    static void StopResponse(const ::fidl::DecodedMessage<RingBuffer::StopResponse>& _msg);
  };
};

extern "C" const fidl_type_t fuchsia_hardware_audio_StreamConfigGetPropertiesRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_StreamConfigGetPropertiesRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_audio_StreamConfigGetPropertiesResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_StreamConfigGetPropertiesResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_audio_StreamConfigGetSupportedFormatsRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_StreamConfigGetSupportedFormatsRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_audio_StreamConfigGetSupportedFormatsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_StreamConfigGetSupportedFormatsResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_audio_StreamConfigCreateRingBufferRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_StreamConfigCreateRingBufferRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_audio_StreamConfigCreateRingBufferResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_StreamConfigCreateRingBufferResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_audio_StreamConfigWatchGainStateRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_StreamConfigWatchGainStateRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_audio_StreamConfigWatchGainStateResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_StreamConfigWatchGainStateResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_audio_StreamConfigSetGainRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_StreamConfigSetGainRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_audio_StreamConfigSetGainResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_StreamConfigSetGainResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_audio_StreamConfigWatchPlugStateRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_StreamConfigWatchPlugStateRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_audio_StreamConfigWatchPlugStateResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_audio_StreamConfigWatchPlugStateResponseTable;

class StreamConfig final {
  StreamConfig() = delete;
 public:

  struct GetPropertiesResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::audio::StreamProperties properties;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_audio_StreamConfigGetPropertiesResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_hardware_audio_StreamConfigGetPropertiesResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 776;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 776;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetPropertiesRequest = ::fidl::AnyZeroArgMessage;

  struct GetSupportedFormatsResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::VectorView<::llcpp::fuchsia::hardware::audio::SupportedFormats> supported_formats;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_audio_StreamConfigGetSupportedFormatsResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_hardware_audio_StreamConfigGetSupportedFormatsResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 29184;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 29184;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetSupportedFormatsRequest = ::fidl::AnyZeroArgMessage;

  struct CreateRingBufferRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::audio::Format format;
    ::zx::channel ring_buffer;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_audio_StreamConfigCreateRingBufferRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_hardware_audio_StreamConfigCreateRingBufferRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 40;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 40;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct WatchGainStateResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::audio::GainState gain_state;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_audio_StreamConfigWatchGainStateResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_hardware_audio_StreamConfigWatchGainStateResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 72;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 72;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using WatchGainStateRequest = ::fidl::AnyZeroArgMessage;

  struct SetGainRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::audio::GainState target_state;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_audio_StreamConfigSetGainRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_hardware_audio_StreamConfigSetGainRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 72;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 72;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct WatchPlugStateResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::audio::PlugState plug_state;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_audio_StreamConfigWatchPlugStateResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_hardware_audio_StreamConfigWatchPlugStateResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 48;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 48;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using WatchPlugStateRequest = ::fidl::AnyZeroArgMessage;


  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    template <typename ResponseType>
    class GetProperties_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetProperties_Impl(::zx::unowned_channel _client_end);
      ~GetProperties_Impl() = default;
      GetProperties_Impl(GetProperties_Impl&& other) = default;
      GetProperties_Impl& operator=(GetProperties_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetSupportedFormats_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetSupportedFormats_Impl(::zx::unowned_channel _client_end);
      ~GetSupportedFormats_Impl() = default;
      GetSupportedFormats_Impl(GetSupportedFormats_Impl&& other) = default;
      GetSupportedFormats_Impl& operator=(GetSupportedFormats_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    class CreateRingBuffer_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      CreateRingBuffer_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::audio::Format format, ::zx::channel ring_buffer);
      ~CreateRingBuffer_Impl() = default;
      CreateRingBuffer_Impl(CreateRingBuffer_Impl&& other) = default;
      CreateRingBuffer_Impl& operator=(CreateRingBuffer_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class WatchGainState_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      WatchGainState_Impl(::zx::unowned_channel _client_end);
      ~WatchGainState_Impl() = default;
      WatchGainState_Impl(WatchGainState_Impl&& other) = default;
      WatchGainState_Impl& operator=(WatchGainState_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    class SetGain_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      SetGain_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::audio::GainState target_state);
      ~SetGain_Impl() = default;
      SetGain_Impl(SetGain_Impl&& other) = default;
      SetGain_Impl& operator=(SetGain_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class WatchPlugState_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      WatchPlugState_Impl(::zx::unowned_channel _client_end);
      ~WatchPlugState_Impl() = default;
      WatchPlugState_Impl(WatchPlugState_Impl&& other) = default;
      WatchPlugState_Impl& operator=(WatchPlugState_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using GetProperties = GetProperties_Impl<GetPropertiesResponse>;
    using GetSupportedFormats = GetSupportedFormats_Impl<GetSupportedFormatsResponse>;
    using CreateRingBuffer = CreateRingBuffer_Impl;
    using WatchGainState = WatchGainState_Impl<WatchGainStateResponse>;
    using SetGain = SetGain_Impl;
    using WatchPlugState = WatchPlugState_Impl<WatchPlugStateResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    template <typename ResponseType>
    class GetProperties_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetProperties_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetProperties_Impl() = default;
      GetProperties_Impl(GetProperties_Impl&& other) = default;
      GetProperties_Impl& operator=(GetProperties_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetSupportedFormats_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetSupportedFormats_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetSupportedFormats_Impl() = default;
      GetSupportedFormats_Impl(GetSupportedFormats_Impl&& other) = default;
      GetSupportedFormats_Impl& operator=(GetSupportedFormats_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    class CreateRingBuffer_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      CreateRingBuffer_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::audio::Format format, ::zx::channel ring_buffer);
      ~CreateRingBuffer_Impl() = default;
      CreateRingBuffer_Impl(CreateRingBuffer_Impl&& other) = default;
      CreateRingBuffer_Impl& operator=(CreateRingBuffer_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class WatchGainState_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      WatchGainState_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~WatchGainState_Impl() = default;
      WatchGainState_Impl(WatchGainState_Impl&& other) = default;
      WatchGainState_Impl& operator=(WatchGainState_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    class SetGain_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      SetGain_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::audio::GainState target_state);
      ~SetGain_Impl() = default;
      SetGain_Impl(SetGain_Impl&& other) = default;
      SetGain_Impl& operator=(SetGain_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class WatchPlugState_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      WatchPlugState_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~WatchPlugState_Impl() = default;
      WatchPlugState_Impl(WatchPlugState_Impl&& other) = default;
      WatchPlugState_Impl& operator=(WatchPlugState_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using GetProperties = GetProperties_Impl<GetPropertiesResponse>;
    using GetSupportedFormats = GetSupportedFormats_Impl<GetSupportedFormatsResponse>;
    using CreateRingBuffer = CreateRingBuffer_Impl;
    using WatchGainState = WatchGainState_Impl<WatchGainStateResponse>;
    using SetGain = SetGain_Impl;
    using WatchPlugState = WatchPlugState_Impl<WatchPlugStateResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Retrieves top level static properties.
    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::GetProperties GetProperties();

    // Retrieves top level static properties.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetProperties GetProperties(::fidl::BytePart _response_buffer);

    // Gets formats supported by a given driver. When not all combinations supported by the
    // driver can be described with one |SupportedFormats|, the driver returns more than one
    // |SupportedFormats| in the returned vector. For example, if one |SupportedFormats| allows
    // for 32 bits samples at 48KHz, and 16 bits samples at 96KHz, but not 32 bits samples at
    // 96KHz, then the driver replies with 2 |SupportedFormats|: <<32bits>,<48KHz>> and
    // <<16bits>,<96KHz>>. For simplicity, this example ignores parameters other than rate and
    // bits per sample. In the case where the driver supports either 16 or 32 bits samples at
    // either 48 or 96KHz, the driver would reply with 1 |SupportedFormats|:
    // <<16bits,32bits>,<48KHz,96KHz>>.
    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::GetSupportedFormats GetSupportedFormats();

    // Gets formats supported by a given driver. When not all combinations supported by the
    // driver can be described with one |SupportedFormats|, the driver returns more than one
    // |SupportedFormats| in the returned vector. For example, if one |SupportedFormats| allows
    // for 32 bits samples at 48KHz, and 16 bits samples at 96KHz, but not 32 bits samples at
    // 96KHz, then the driver replies with 2 |SupportedFormats|: <<32bits>,<48KHz>> and
    // <<16bits>,<96KHz>>. For simplicity, this example ignores parameters other than rate and
    // bits per sample. In the case where the driver supports either 16 or 32 bits samples at
    // either 48 or 96KHz, the driver would reply with 1 |SupportedFormats|:
    // <<16bits,32bits>,<48KHz,96KHz>>.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetSupportedFormats GetSupportedFormats(::fidl::BytePart _response_buffer);

    // |CreateRingBuffer| is sent by clients to select a stream format based on information that
    // the driver provides in |GetSupportedFormats| what is supported by the client, and any other
    // requirement. The |ring_buffer| channel is used to control the audio buffer, if a previous
    // ring buffer channel had been established and was still active, the driver must close that
    // (ring buffer) channel and make every attempt to gracefully quiesce any on-going streaming
    // operations in the process.
    // Allocates 80 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::CreateRingBuffer CreateRingBuffer(::llcpp::fuchsia::hardware::audio::Format format, ::zx::channel ring_buffer);

    // |CreateRingBuffer| is sent by clients to select a stream format based on information that
    // the driver provides in |GetSupportedFormats| what is supported by the client, and any other
    // requirement. The |ring_buffer| channel is used to control the audio buffer, if a previous
    // ring buffer channel had been established and was still active, the driver must close that
    // (ring buffer) channel and make every attempt to gracefully quiesce any on-going streaming
    // operations in the process.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::CreateRingBuffer CreateRingBuffer(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::audio::Format format, ::zx::channel ring_buffer);

    // Get the gain state via a hanging get. The driver will reply to the first |WatchGainState|
    // sent by the client. The driver will not respond to subsequent client |WatchGainState| calls
    // until the gain state changes from what was most recently reported.
    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::WatchGainState WatchGainState();

    // Get the gain state via a hanging get. The driver will reply to the first |WatchGainState|
    // sent by the client. The driver will not respond to subsequent client |WatchGainState| calls
    // until the gain state changes from what was most recently reported.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::WatchGainState WatchGainState(::fidl::BytePart _response_buffer);

    // Client update of the gain state.
    // Allocates 104 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::SetGain SetGain(::llcpp::fuchsia::hardware::audio::GainState target_state);

    // Client update of the gain state.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetGain SetGain(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::audio::GainState target_state);

    // Get the plug detect state via a hanging get. The driver will reply to the first
    // |WatchPlugState| sent by the client. The driver will not respond to subsequent client
    // |WatchPlugState| calls until the plug state changes from what was most recently reported.
    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::WatchPlugState WatchPlugState();

    // Get the plug detect state via a hanging get. The driver will reply to the first
    // |WatchPlugState| sent by the client. The driver will not respond to subsequent client
    // |WatchPlugState| calls until the plug state changes from what was most recently reported.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::WatchPlugState WatchPlugState(::fidl::BytePart _response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Retrieves top level static properties.
    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::GetProperties GetProperties(::zx::unowned_channel _client_end);

    // Retrieves top level static properties.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetProperties GetProperties(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Gets formats supported by a given driver. When not all combinations supported by the
    // driver can be described with one |SupportedFormats|, the driver returns more than one
    // |SupportedFormats| in the returned vector. For example, if one |SupportedFormats| allows
    // for 32 bits samples at 48KHz, and 16 bits samples at 96KHz, but not 32 bits samples at
    // 96KHz, then the driver replies with 2 |SupportedFormats|: <<32bits>,<48KHz>> and
    // <<16bits>,<96KHz>>. For simplicity, this example ignores parameters other than rate and
    // bits per sample. In the case where the driver supports either 16 or 32 bits samples at
    // either 48 or 96KHz, the driver would reply with 1 |SupportedFormats|:
    // <<16bits,32bits>,<48KHz,96KHz>>.
    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::GetSupportedFormats GetSupportedFormats(::zx::unowned_channel _client_end);

    // Gets formats supported by a given driver. When not all combinations supported by the
    // driver can be described with one |SupportedFormats|, the driver returns more than one
    // |SupportedFormats| in the returned vector. For example, if one |SupportedFormats| allows
    // for 32 bits samples at 48KHz, and 16 bits samples at 96KHz, but not 32 bits samples at
    // 96KHz, then the driver replies with 2 |SupportedFormats|: <<32bits>,<48KHz>> and
    // <<16bits>,<96KHz>>. For simplicity, this example ignores parameters other than rate and
    // bits per sample. In the case where the driver supports either 16 or 32 bits samples at
    // either 48 or 96KHz, the driver would reply with 1 |SupportedFormats|:
    // <<16bits,32bits>,<48KHz,96KHz>>.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetSupportedFormats GetSupportedFormats(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // |CreateRingBuffer| is sent by clients to select a stream format based on information that
    // the driver provides in |GetSupportedFormats| what is supported by the client, and any other
    // requirement. The |ring_buffer| channel is used to control the audio buffer, if a previous
    // ring buffer channel had been established and was still active, the driver must close that
    // (ring buffer) channel and make every attempt to gracefully quiesce any on-going streaming
    // operations in the process.
    // Allocates 80 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::CreateRingBuffer CreateRingBuffer(::zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::audio::Format format, ::zx::channel ring_buffer);

    // |CreateRingBuffer| is sent by clients to select a stream format based on information that
    // the driver provides in |GetSupportedFormats| what is supported by the client, and any other
    // requirement. The |ring_buffer| channel is used to control the audio buffer, if a previous
    // ring buffer channel had been established and was still active, the driver must close that
    // (ring buffer) channel and make every attempt to gracefully quiesce any on-going streaming
    // operations in the process.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::CreateRingBuffer CreateRingBuffer(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::audio::Format format, ::zx::channel ring_buffer);

    // Get the gain state via a hanging get. The driver will reply to the first |WatchGainState|
    // sent by the client. The driver will not respond to subsequent client |WatchGainState| calls
    // until the gain state changes from what was most recently reported.
    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::WatchGainState WatchGainState(::zx::unowned_channel _client_end);

    // Get the gain state via a hanging get. The driver will reply to the first |WatchGainState|
    // sent by the client. The driver will not respond to subsequent client |WatchGainState| calls
    // until the gain state changes from what was most recently reported.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::WatchGainState WatchGainState(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Client update of the gain state.
    // Allocates 104 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::SetGain SetGain(::zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::audio::GainState target_state);

    // Client update of the gain state.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetGain SetGain(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::audio::GainState target_state);

    // Get the plug detect state via a hanging get. The driver will reply to the first
    // |WatchPlugState| sent by the client. The driver will not respond to subsequent client
    // |WatchPlugState| calls until the plug state changes from what was most recently reported.
    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::WatchPlugState WatchPlugState(::zx::unowned_channel _client_end);

    // Get the plug detect state via a hanging get. The driver will reply to the first
    // |WatchPlugState| sent by the client. The driver will not respond to subsequent client
    // |WatchPlugState| calls until the plug state changes from what was most recently reported.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::WatchPlugState WatchPlugState(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Retrieves top level static properties.
    static ::fidl::DecodeResult<GetPropertiesResponse> GetProperties(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Gets formats supported by a given driver. When not all combinations supported by the
    // driver can be described with one |SupportedFormats|, the driver returns more than one
    // |SupportedFormats| in the returned vector. For example, if one |SupportedFormats| allows
    // for 32 bits samples at 48KHz, and 16 bits samples at 96KHz, but not 32 bits samples at
    // 96KHz, then the driver replies with 2 |SupportedFormats|: <<32bits>,<48KHz>> and
    // <<16bits>,<96KHz>>. For simplicity, this example ignores parameters other than rate and
    // bits per sample. In the case where the driver supports either 16 or 32 bits samples at
    // either 48 or 96KHz, the driver would reply with 1 |SupportedFormats|:
    // <<16bits,32bits>,<48KHz,96KHz>>.
    static ::fidl::DecodeResult<GetSupportedFormatsResponse> GetSupportedFormats(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // |CreateRingBuffer| is sent by clients to select a stream format based on information that
    // the driver provides in |GetSupportedFormats| what is supported by the client, and any other
    // requirement. The |ring_buffer| channel is used to control the audio buffer, if a previous
    // ring buffer channel had been established and was still active, the driver must close that
    // (ring buffer) channel and make every attempt to gracefully quiesce any on-going streaming
    // operations in the process.
    static ::fidl::internal::StatusAndError CreateRingBuffer(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<CreateRingBufferRequest> params);

    // Get the gain state via a hanging get. The driver will reply to the first |WatchGainState|
    // sent by the client. The driver will not respond to subsequent client |WatchGainState| calls
    // until the gain state changes from what was most recently reported.
    static ::fidl::DecodeResult<WatchGainStateResponse> WatchGainState(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Client update of the gain state.
    static ::fidl::internal::StatusAndError SetGain(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetGainRequest> params);

    // Get the plug detect state via a hanging get. The driver will reply to the first
    // |WatchPlugState| sent by the client. The driver will not respond to subsequent client
    // |WatchPlugState| calls until the plug state changes from what was most recently reported.
    static ::fidl::DecodeResult<WatchPlugStateResponse> WatchPlugState(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = StreamConfig;
    using _Base = ::fidl::CompleterBase;

    class GetPropertiesCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::hardware::audio::StreamProperties properties);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::audio::StreamProperties properties);
      void Reply(::fidl::DecodedMessage<GetPropertiesResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetPropertiesCompleter = ::fidl::Completer<GetPropertiesCompleterBase>;

    virtual void GetProperties(GetPropertiesCompleter::Sync _completer) = 0;

    class GetSupportedFormatsCompleterBase : public _Base {
     public:
      void Reply(::fidl::VectorView<::llcpp::fuchsia::hardware::audio::SupportedFormats> supported_formats);
      void Reply(::fidl::BytePart _buffer, ::fidl::VectorView<::llcpp::fuchsia::hardware::audio::SupportedFormats> supported_formats);
      void Reply(::fidl::DecodedMessage<GetSupportedFormatsResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetSupportedFormatsCompleter = ::fidl::Completer<GetSupportedFormatsCompleterBase>;

    virtual void GetSupportedFormats(GetSupportedFormatsCompleter::Sync _completer) = 0;

    using CreateRingBufferCompleter = ::fidl::Completer<>;

    virtual void CreateRingBuffer(::llcpp::fuchsia::hardware::audio::Format format, ::zx::channel ring_buffer, CreateRingBufferCompleter::Sync _completer) = 0;

    class WatchGainStateCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::hardware::audio::GainState gain_state);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::audio::GainState gain_state);
      void Reply(::fidl::DecodedMessage<WatchGainStateResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using WatchGainStateCompleter = ::fidl::Completer<WatchGainStateCompleterBase>;

    virtual void WatchGainState(WatchGainStateCompleter::Sync _completer) = 0;

    using SetGainCompleter = ::fidl::Completer<>;

    virtual void SetGain(::llcpp::fuchsia::hardware::audio::GainState target_state, SetGainCompleter::Sync _completer) = 0;

    class WatchPlugStateCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::hardware::audio::PlugState plug_state);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::audio::PlugState plug_state);
      void Reply(::fidl::DecodedMessage<WatchPlugStateResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using WatchPlugStateCompleter = ::fidl::Completer<WatchPlugStateCompleterBase>;

    virtual void WatchPlugState(WatchPlugStateCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void GetPropertiesRequest(const ::fidl::DecodedMessage<StreamConfig::GetPropertiesRequest>& _msg);
    static void GetPropertiesResponse(const ::fidl::DecodedMessage<StreamConfig::GetPropertiesResponse>& _msg);
    static void GetSupportedFormatsRequest(const ::fidl::DecodedMessage<StreamConfig::GetSupportedFormatsRequest>& _msg);
    static void GetSupportedFormatsResponse(const ::fidl::DecodedMessage<StreamConfig::GetSupportedFormatsResponse>& _msg);
    static void CreateRingBufferRequest(const ::fidl::DecodedMessage<StreamConfig::CreateRingBufferRequest>& _msg);
    static void WatchGainStateRequest(const ::fidl::DecodedMessage<StreamConfig::WatchGainStateRequest>& _msg);
    static void WatchGainStateResponse(const ::fidl::DecodedMessage<StreamConfig::WatchGainStateResponse>& _msg);
    static void SetGainRequest(const ::fidl::DecodedMessage<StreamConfig::SetGainRequest>& _msg);
    static void WatchPlugStateRequest(const ::fidl::DecodedMessage<StreamConfig::WatchPlugStateRequest>& _msg);
    static void WatchPlugStateResponse(const ::fidl::DecodedMessage<StreamConfig::WatchPlugStateResponse>& _msg);
  };
};

}  // namespace audio
}  // namespace hardware
}  // namespace fuchsia
}  // namespace llcpp

namespace fidl {

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::audio::RingBufferPositionInfo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::audio::RingBufferPositionInfo>);
static_assert(offsetof(::llcpp::fuchsia::hardware::audio::RingBufferPositionInfo, timestamp) == 0);
static_assert(offsetof(::llcpp::fuchsia::hardware::audio::RingBufferPositionInfo, position) == 8);
static_assert(sizeof(::llcpp::fuchsia::hardware::audio::RingBufferPositionInfo) == ::llcpp::fuchsia::hardware::audio::RingBufferPositionInfo::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::audio::PlugState> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::audio::PlugState>);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::audio::RingBufferProperties> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::audio::RingBufferProperties>);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::audio::Device::GetChannelResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::audio::Device::GetChannelResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::audio::Device::GetChannelResponse)
    == ::llcpp::fuchsia::hardware::audio::Device::GetChannelResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::audio::Device::GetChannelResponse, channel) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::audio::PcmSupportedFormats> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::audio::PcmSupportedFormats>);
static_assert(offsetof(::llcpp::fuchsia::hardware::audio::PcmSupportedFormats, number_of_channels) == 0);
static_assert(offsetof(::llcpp::fuchsia::hardware::audio::PcmSupportedFormats, sample_formats) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::audio::PcmSupportedFormats, bytes_per_sample) == 32);
static_assert(offsetof(::llcpp::fuchsia::hardware::audio::PcmSupportedFormats, valid_bits_per_sample) == 48);
static_assert(offsetof(::llcpp::fuchsia::hardware::audio::PcmSupportedFormats, frame_rates) == 64);
static_assert(sizeof(::llcpp::fuchsia::hardware::audio::PcmSupportedFormats) == ::llcpp::fuchsia::hardware::audio::PcmSupportedFormats::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::audio::SupportedFormats> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::audio::SupportedFormats>);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::audio::PcmFormat> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::audio::PcmFormat>);
static_assert(offsetof(::llcpp::fuchsia::hardware::audio::PcmFormat, number_of_channels) == 0);
static_assert(offsetof(::llcpp::fuchsia::hardware::audio::PcmFormat, channels_to_use_bitmask) == 8);
static_assert(offsetof(::llcpp::fuchsia::hardware::audio::PcmFormat, sample_format) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::audio::PcmFormat, bytes_per_sample) == 17);
static_assert(offsetof(::llcpp::fuchsia::hardware::audio::PcmFormat, valid_bits_per_sample) == 18);
static_assert(offsetof(::llcpp::fuchsia::hardware::audio::PcmFormat, frame_rate) == 20);
static_assert(sizeof(::llcpp::fuchsia::hardware::audio::PcmFormat) == ::llcpp::fuchsia::hardware::audio::PcmFormat::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::audio::Format> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::audio::Format>);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::audio::RingBuffer_GetVmo_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::audio::RingBuffer_GetVmo_Response>);
static_assert(offsetof(::llcpp::fuchsia::hardware::audio::RingBuffer_GetVmo_Response, num_frames) == 0);
static_assert(offsetof(::llcpp::fuchsia::hardware::audio::RingBuffer_GetVmo_Response, ring_buffer) == 4);
static_assert(sizeof(::llcpp::fuchsia::hardware::audio::RingBuffer_GetVmo_Response) == ::llcpp::fuchsia::hardware::audio::RingBuffer_GetVmo_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::audio::StreamProperties> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::audio::StreamProperties>);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::audio::RingBuffer_GetVmo_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::audio::RingBuffer_GetVmo_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::audio::RingBuffer::GetPropertiesResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::audio::RingBuffer::GetPropertiesResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::audio::RingBuffer::GetPropertiesResponse)
    == ::llcpp::fuchsia::hardware::audio::RingBuffer::GetPropertiesResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::audio::RingBuffer::GetPropertiesResponse, properties) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::audio::RingBuffer::WatchClockRecoveryPositionInfoResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::audio::RingBuffer::WatchClockRecoveryPositionInfoResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::audio::RingBuffer::WatchClockRecoveryPositionInfoResponse)
    == ::llcpp::fuchsia::hardware::audio::RingBuffer::WatchClockRecoveryPositionInfoResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::audio::RingBuffer::WatchClockRecoveryPositionInfoResponse, position_info) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::audio::RingBuffer::GetVmoRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::audio::RingBuffer::GetVmoRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::audio::RingBuffer::GetVmoRequest)
    == ::llcpp::fuchsia::hardware::audio::RingBuffer::GetVmoRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::audio::RingBuffer::GetVmoRequest, min_frames) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::audio::RingBuffer::GetVmoRequest, clock_recovery_notifications_per_ring) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::audio::RingBuffer::GetVmoResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::audio::RingBuffer::GetVmoResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::audio::RingBuffer::GetVmoResponse)
    == ::llcpp::fuchsia::hardware::audio::RingBuffer::GetVmoResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::audio::RingBuffer::GetVmoResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::audio::RingBuffer::StartResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::audio::RingBuffer::StartResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::audio::RingBuffer::StartResponse)
    == ::llcpp::fuchsia::hardware::audio::RingBuffer::StartResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::audio::RingBuffer::StartResponse, start_time) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::audio::GainState> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::audio::GainState>);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::audio::StreamConfig::GetPropertiesResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::audio::StreamConfig::GetPropertiesResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::audio::StreamConfig::GetPropertiesResponse)
    == ::llcpp::fuchsia::hardware::audio::StreamConfig::GetPropertiesResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::audio::StreamConfig::GetPropertiesResponse, properties) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::audio::StreamConfig::GetSupportedFormatsResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::audio::StreamConfig::GetSupportedFormatsResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::audio::StreamConfig::GetSupportedFormatsResponse)
    == ::llcpp::fuchsia::hardware::audio::StreamConfig::GetSupportedFormatsResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::audio::StreamConfig::GetSupportedFormatsResponse, supported_formats) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::audio::StreamConfig::CreateRingBufferRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::audio::StreamConfig::CreateRingBufferRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::audio::StreamConfig::CreateRingBufferRequest)
    == ::llcpp::fuchsia::hardware::audio::StreamConfig::CreateRingBufferRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::audio::StreamConfig::CreateRingBufferRequest, format) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::audio::StreamConfig::CreateRingBufferRequest, ring_buffer) == 32);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::audio::StreamConfig::WatchGainStateResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::audio::StreamConfig::WatchGainStateResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::audio::StreamConfig::WatchGainStateResponse)
    == ::llcpp::fuchsia::hardware::audio::StreamConfig::WatchGainStateResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::audio::StreamConfig::WatchGainStateResponse, gain_state) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::audio::StreamConfig::SetGainRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::audio::StreamConfig::SetGainRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::audio::StreamConfig::SetGainRequest)
    == ::llcpp::fuchsia::hardware::audio::StreamConfig::SetGainRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::audio::StreamConfig::SetGainRequest, target_state) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::audio::StreamConfig::WatchPlugStateResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::audio::StreamConfig::WatchPlugStateResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::audio::StreamConfig::WatchPlugStateResponse)
    == ::llcpp::fuchsia::hardware::audio::StreamConfig::WatchPlugStateResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::audio::StreamConfig::WatchPlugStateResponse, plug_state) == 16);

}  // namespace fidl

// WARNING: This file is machine generated by fidlgen.

#include <fuchsia/hardware/display/llcpp/fidl.h>
#include <memory>

namespace llcpp {

namespace fuchsia {
namespace hardware {
namespace display {

namespace {

[[maybe_unused]]
constexpr uint64_t kProvider_OpenVirtconController_Ordinal = 0x7522c7b300000000lu;
[[maybe_unused]]
constexpr uint64_t kProvider_OpenVirtconController_GenOrdinal = 0x7163a23d838e6fb6lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ProviderOpenVirtconControllerRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ProviderOpenVirtconControllerResponseTable;
[[maybe_unused]]
constexpr uint64_t kProvider_OpenController_Ordinal = 0x69d407d00000000lu;
[[maybe_unused]]
constexpr uint64_t kProvider_OpenController_GenOrdinal = 0x54b5aa00a47ab0b3lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ProviderOpenControllerRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ProviderOpenControllerResponseTable;

}  // namespace
template <>
Provider::ResultOf::OpenVirtconController_Impl<Provider::OpenVirtconControllerResponse>::OpenVirtconController_Impl(zx::unowned_channel _client_end, ::zx::channel device, ::zx::channel controller) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OpenVirtconControllerRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, OpenVirtconControllerRequest::PrimarySize);
  auto& _request = *reinterpret_cast<OpenVirtconControllerRequest*>(_write_bytes);
  _request.device = std::move(device);
  _request.controller = std::move(controller);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(OpenVirtconControllerRequest));
  ::fidl::DecodedMessage<OpenVirtconControllerRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Provider::InPlace::OpenVirtconController(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Provider::ResultOf::OpenVirtconController Provider::SyncClient::OpenVirtconController(::zx::channel device, ::zx::channel controller) {
  return ResultOf::OpenVirtconController(zx::unowned_channel(this->channel_), std::move(device), std::move(controller));
}

Provider::ResultOf::OpenVirtconController Provider::Call::OpenVirtconController(zx::unowned_channel _client_end, ::zx::channel device, ::zx::channel controller) {
  return ResultOf::OpenVirtconController(std::move(_client_end), std::move(device), std::move(controller));
}

template <>
Provider::UnownedResultOf::OpenVirtconController_Impl<Provider::OpenVirtconControllerResponse>::OpenVirtconController_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel device, ::zx::channel controller, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < OpenVirtconControllerRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<OpenVirtconControllerResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, OpenVirtconControllerRequest::PrimarySize);
  auto& _request = *reinterpret_cast<OpenVirtconControllerRequest*>(_request_buffer.data());
  _request.device = std::move(device);
  _request.controller = std::move(controller);
  _request_buffer.set_actual(sizeof(OpenVirtconControllerRequest));
  ::fidl::DecodedMessage<OpenVirtconControllerRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Provider::InPlace::OpenVirtconController(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Provider::UnownedResultOf::OpenVirtconController Provider::SyncClient::OpenVirtconController(::fidl::BytePart _request_buffer, ::zx::channel device, ::zx::channel controller, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::OpenVirtconController(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(device), std::move(controller), std::move(_response_buffer));
}

Provider::UnownedResultOf::OpenVirtconController Provider::Call::OpenVirtconController(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel device, ::zx::channel controller, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::OpenVirtconController(std::move(_client_end), std::move(_request_buffer), std::move(device), std::move(controller), std::move(_response_buffer));
}

::fidl::DecodeResult<Provider::OpenVirtconControllerResponse> Provider::InPlace::OpenVirtconController(zx::unowned_channel _client_end, ::fidl::DecodedMessage<OpenVirtconControllerRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kProvider_OpenVirtconController_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Provider::OpenVirtconControllerResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<OpenVirtconControllerRequest, OpenVirtconControllerResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Provider::OpenVirtconControllerResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Provider::ResultOf::OpenController_Impl<Provider::OpenControllerResponse>::OpenController_Impl(zx::unowned_channel _client_end, ::zx::channel device, ::zx::channel controller) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OpenControllerRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, OpenControllerRequest::PrimarySize);
  auto& _request = *reinterpret_cast<OpenControllerRequest*>(_write_bytes);
  _request.device = std::move(device);
  _request.controller = std::move(controller);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(OpenControllerRequest));
  ::fidl::DecodedMessage<OpenControllerRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Provider::InPlace::OpenController(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Provider::ResultOf::OpenController Provider::SyncClient::OpenController(::zx::channel device, ::zx::channel controller) {
  return ResultOf::OpenController(zx::unowned_channel(this->channel_), std::move(device), std::move(controller));
}

Provider::ResultOf::OpenController Provider::Call::OpenController(zx::unowned_channel _client_end, ::zx::channel device, ::zx::channel controller) {
  return ResultOf::OpenController(std::move(_client_end), std::move(device), std::move(controller));
}

template <>
Provider::UnownedResultOf::OpenController_Impl<Provider::OpenControllerResponse>::OpenController_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel device, ::zx::channel controller, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < OpenControllerRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<OpenControllerResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, OpenControllerRequest::PrimarySize);
  auto& _request = *reinterpret_cast<OpenControllerRequest*>(_request_buffer.data());
  _request.device = std::move(device);
  _request.controller = std::move(controller);
  _request_buffer.set_actual(sizeof(OpenControllerRequest));
  ::fidl::DecodedMessage<OpenControllerRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Provider::InPlace::OpenController(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Provider::UnownedResultOf::OpenController Provider::SyncClient::OpenController(::fidl::BytePart _request_buffer, ::zx::channel device, ::zx::channel controller, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::OpenController(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(device), std::move(controller), std::move(_response_buffer));
}

Provider::UnownedResultOf::OpenController Provider::Call::OpenController(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel device, ::zx::channel controller, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::OpenController(std::move(_client_end), std::move(_request_buffer), std::move(device), std::move(controller), std::move(_response_buffer));
}

::fidl::DecodeResult<Provider::OpenControllerResponse> Provider::InPlace::OpenController(zx::unowned_channel _client_end, ::fidl::DecodedMessage<OpenControllerRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kProvider_OpenController_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Provider::OpenControllerResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<OpenControllerRequest, OpenControllerResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Provider::OpenControllerResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool Provider::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kProvider_OpenVirtconController_Ordinal:
    case kProvider_OpenVirtconController_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<OpenVirtconControllerRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->OpenVirtconController(std::move(message->device), std::move(message->controller),
        Interface::OpenVirtconControllerCompleter::Sync(txn));
      return true;
    }
    case kProvider_OpenController_Ordinal:
    case kProvider_OpenController_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<OpenControllerRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->OpenController(std::move(message->device), std::move(message->controller),
        Interface::OpenControllerCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Provider::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void Provider::Interface::OpenVirtconControllerCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OpenVirtconControllerResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<OpenVirtconControllerResponse*>(_write_bytes);
  _response._hdr.ordinal = kProvider_OpenVirtconController_Ordinal;
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(OpenVirtconControllerResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<OpenVirtconControllerResponse>(std::move(_response_bytes)));
}

void Provider::Interface::OpenVirtconControllerCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < OpenVirtconControllerResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<OpenVirtconControllerResponse*>(_buffer.data());
  _response._hdr.ordinal = kProvider_OpenVirtconController_Ordinal;
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(OpenVirtconControllerResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<OpenVirtconControllerResponse>(std::move(_buffer)));
}

void Provider::Interface::OpenVirtconControllerCompleterBase::Reply(::fidl::DecodedMessage<OpenVirtconControllerResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kProvider_OpenVirtconController_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Provider::Interface::OpenControllerCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OpenControllerResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<OpenControllerResponse*>(_write_bytes);
  _response._hdr.ordinal = kProvider_OpenController_Ordinal;
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(OpenControllerResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<OpenControllerResponse>(std::move(_response_bytes)));
}

void Provider::Interface::OpenControllerCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < OpenControllerResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<OpenControllerResponse*>(_buffer.data());
  _response._hdr.ordinal = kProvider_OpenController_Ordinal;
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(OpenControllerResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<OpenControllerResponse>(std::move(_buffer)));
}

void Provider::Interface::OpenControllerCompleterBase::Reply(::fidl::DecodedMessage<OpenControllerResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kProvider_OpenController_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


::llcpp::fuchsia::hardware::display::Controller_StartCapture_Result::Controller_StartCapture_Result() {
  tag_ = Tag::Invalid;
}

::llcpp::fuchsia::hardware::display::Controller_StartCapture_Result::~Controller_StartCapture_Result() {
  Destroy();
}

void ::llcpp::fuchsia::hardware::display::Controller_StartCapture_Result::Destroy() {
  switch (which()) {
  case Tag::kResponse:
    response_.~Controller_StartCapture_Response();
    break;
  default:
    break;
  }
  tag_ = Tag::Invalid;
}

void ::llcpp::fuchsia::hardware::display::Controller_StartCapture_Result::MoveImpl_(Controller_StartCapture_Result&& other) {
  switch (other.which()) {
  case Tag::kResponse:
    mutable_response() = std::move(other.mutable_response());
    break;
  case Tag::kErr:
    mutable_err() = std::move(other.mutable_err());
    break;
  default:
    break;
  }
  other.Destroy();
}

void ::llcpp::fuchsia::hardware::display::Controller_StartCapture_Result::SizeAndOffsetAssertionHelper() {
  static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller_StartCapture_Result, response_) == 4);
  static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller_StartCapture_Result, err_) == 4);
  static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller_StartCapture_Result) == ::llcpp::fuchsia::hardware::display::Controller_StartCapture_Result::PrimarySize);
}


Controller_StartCapture_Response& ::llcpp::fuchsia::hardware::display::Controller_StartCapture_Result::mutable_response() {
  if (which() != Tag::kResponse) {
    Destroy();
    new (&response_) Controller_StartCapture_Response;
  }
  tag_ = Tag::kResponse;
  return response_;
}

int32_t& ::llcpp::fuchsia::hardware::display::Controller_StartCapture_Result::mutable_err() {
  if (which() != Tag::kErr) {
    Destroy();
    new (&err_) int32_t;
  }
  tag_ = Tag::kErr;
  return err_;
}


::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Result::Controller_ReleaseCapture_Result() {
  tag_ = Tag::Invalid;
}

::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Result::~Controller_ReleaseCapture_Result() {
  Destroy();
}

void ::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Result::Destroy() {
  switch (which()) {
  case Tag::kResponse:
    response_.~Controller_ReleaseCapture_Response();
    break;
  default:
    break;
  }
  tag_ = Tag::Invalid;
}

void ::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Result::MoveImpl_(Controller_ReleaseCapture_Result&& other) {
  switch (other.which()) {
  case Tag::kResponse:
    mutable_response() = std::move(other.mutable_response());
    break;
  case Tag::kErr:
    mutable_err() = std::move(other.mutable_err());
    break;
  default:
    break;
  }
  other.Destroy();
}

void ::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Result::SizeAndOffsetAssertionHelper() {
  static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Result, response_) == 4);
  static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Result, err_) == 4);
  static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Result) == ::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Result::PrimarySize);
}


Controller_ReleaseCapture_Response& ::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Result::mutable_response() {
  if (which() != Tag::kResponse) {
    Destroy();
    new (&response_) Controller_ReleaseCapture_Response;
  }
  tag_ = Tag::kResponse;
  return response_;
}

int32_t& ::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Result::mutable_err() {
  if (which() != Tag::kErr) {
    Destroy();
    new (&err_) int32_t;
  }
  tag_ = Tag::kErr;
  return err_;
}


::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Result::Controller_ImportImageForCapture_Result() {
  tag_ = Tag::Invalid;
}

::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Result::~Controller_ImportImageForCapture_Result() {
  Destroy();
}

void ::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Result::Destroy() {
  switch (which()) {
  case Tag::kResponse:
    response_.~Controller_ImportImageForCapture_Response();
    break;
  default:
    break;
  }
  tag_ = Tag::Invalid;
}

void ::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Result::MoveImpl_(Controller_ImportImageForCapture_Result&& other) {
  switch (other.which()) {
  case Tag::kResponse:
    mutable_response() = std::move(other.mutable_response());
    break;
  case Tag::kErr:
    mutable_err() = std::move(other.mutable_err());
    break;
  default:
    break;
  }
  other.Destroy();
}

void ::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Result::SizeAndOffsetAssertionHelper() {
  static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Result, response_) == 8);
  static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Result, err_) == 8);
  static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Result) == ::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Result::PrimarySize);
}


Controller_ImportImageForCapture_Response& ::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Result::mutable_response() {
  if (which() != Tag::kResponse) {
    Destroy();
    new (&response_) Controller_ImportImageForCapture_Response;
  }
  tag_ = Tag::kResponse;
  return response_;
}

int32_t& ::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Result::mutable_err() {
  if (which() != Tag::kErr) {
    Destroy();
    new (&err_) int32_t;
  }
  tag_ = Tag::kErr;
  return err_;
}


namespace {

[[maybe_unused]]
constexpr uint64_t kController_DisplaysChanged_Ordinal = 0x30f5452200000000lu;
[[maybe_unused]]
constexpr uint64_t kController_DisplaysChanged_GenOrdinal = 0x848efe931ddb1c6lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerDisplaysChangedEventTable;
[[maybe_unused]]
constexpr uint64_t kController_ImportVmoImage_Ordinal = 0x420a4b7000000000lu;
[[maybe_unused]]
constexpr uint64_t kController_ImportVmoImage_GenOrdinal = 0x7cab4d73f9f1893clu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerImportVmoImageRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerImportVmoImageResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_ImportImage_Ordinal = 0x18d6e53b00000000lu;
[[maybe_unused]]
constexpr uint64_t kController_ImportImage_GenOrdinal = 0x1be9cd6562de6db5lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerImportImageRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerImportImageResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_ReleaseImage_Ordinal = 0x3abc075800000000lu;
[[maybe_unused]]
constexpr uint64_t kController_ReleaseImage_GenOrdinal = 0x63a7d0a6b107bd11lu;
[[maybe_unused]]
constexpr uint64_t kController_ImportEvent_Ordinal = 0x7d2447aa00000000lu;
[[maybe_unused]]
constexpr uint64_t kController_ImportEvent_GenOrdinal = 0x402289f13944e6d7lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerImportEventRequestTable;
[[maybe_unused]]
constexpr uint64_t kController_ReleaseEvent_Ordinal = 0x4379630400000000lu;
[[maybe_unused]]
constexpr uint64_t kController_ReleaseEvent_GenOrdinal = 0x657e4eab9a8e23a1lu;
[[maybe_unused]]
constexpr uint64_t kController_CreateLayer_Ordinal = 0x7f56932400000000lu;
[[maybe_unused]]
constexpr uint64_t kController_CreateLayer_GenOrdinal = 0x468d06aadd139295lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerCreateLayerResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_DestroyLayer_Ordinal = 0x2abc04b100000000lu;
[[maybe_unused]]
constexpr uint64_t kController_DestroyLayer_GenOrdinal = 0x6b42dce004859fe5lu;
[[maybe_unused]]
constexpr uint64_t kController_SetDisplayMode_Ordinal = 0x584c92ab00000000lu;
[[maybe_unused]]
constexpr uint64_t kController_SetDisplayMode_GenOrdinal = 0x55a035e7a881c48dlu;
[[maybe_unused]]
constexpr uint64_t kController_SetDisplayColorConversion_Ordinal = 0x71cb370500000000lu;
[[maybe_unused]]
constexpr uint64_t kController_SetDisplayColorConversion_GenOrdinal = 0x3d3548d04caf79b7lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetDisplayColorConversionRequestTable;
[[maybe_unused]]
constexpr uint64_t kController_SetDisplayLayers_Ordinal = 0x9bebf8600000000lu;
[[maybe_unused]]
constexpr uint64_t kController_SetDisplayLayers_GenOrdinal = 0x47e92da1f9702675lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetDisplayLayersRequestTable;
[[maybe_unused]]
constexpr uint64_t kController_SetLayerPrimaryConfig_Ordinal = 0x3673de6000000000lu;
[[maybe_unused]]
constexpr uint64_t kController_SetLayerPrimaryConfig_GenOrdinal = 0x10bc9fc5d61f5c94lu;
[[maybe_unused]]
constexpr uint64_t kController_SetLayerPrimaryPosition_Ordinal = 0x6bd4fbc600000000lu;
[[maybe_unused]]
constexpr uint64_t kController_SetLayerPrimaryPosition_GenOrdinal = 0x735faf29ee889cdclu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetLayerPrimaryPositionRequestTable;
[[maybe_unused]]
constexpr uint64_t kController_SetLayerPrimaryAlpha_Ordinal = 0x5a79ec9200000000lu;
[[maybe_unused]]
constexpr uint64_t kController_SetLayerPrimaryAlpha_GenOrdinal = 0x1b81604b1a9b6576lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetLayerPrimaryAlphaRequestTable;
[[maybe_unused]]
constexpr uint64_t kController_SetLayerCursorConfig_Ordinal = 0x74020b200000000lu;
[[maybe_unused]]
constexpr uint64_t kController_SetLayerCursorConfig_GenOrdinal = 0x2fddfd240f9e7764lu;
[[maybe_unused]]
constexpr uint64_t kController_SetLayerCursorPosition_Ordinal = 0x2f36e7b000000000lu;
[[maybe_unused]]
constexpr uint64_t kController_SetLayerCursorPosition_GenOrdinal = 0x147c1526ac3ad9c5lu;
[[maybe_unused]]
constexpr uint64_t kController_SetLayerColorConfig_Ordinal = 0x21cc7c8800000000lu;
[[maybe_unused]]
constexpr uint64_t kController_SetLayerColorConfig_GenOrdinal = 0x19cb6da071d515calu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetLayerColorConfigRequestTable;
[[maybe_unused]]
constexpr uint64_t kController_SetLayerImage_Ordinal = 0x1ecab8800000000lu;
[[maybe_unused]]
constexpr uint64_t kController_SetLayerImage_GenOrdinal = 0x7c71f66253182fb9lu;
[[maybe_unused]]
constexpr uint64_t kController_CheckConfig_Ordinal = 0x160ce58b00000000lu;
[[maybe_unused]]
constexpr uint64_t kController_CheckConfig_GenOrdinal = 0x586ca589eaf66e11lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerCheckConfigRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerCheckConfigResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_ApplyConfig_Ordinal = 0x572081a200000000lu;
[[maybe_unused]]
constexpr uint64_t kController_ApplyConfig_GenOrdinal = 0x65b30a10604984f7lu;
[[maybe_unused]]
constexpr uint64_t kController_EnableVsync_Ordinal = 0x2be2db1300000000lu;
[[maybe_unused]]
constexpr uint64_t kController_EnableVsync_GenOrdinal = 0x5d517bdbc05d434elu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerEnableVsyncRequestTable;
[[maybe_unused]]
constexpr uint64_t kController_Vsync_Ordinal = 0x71fcce9000000000lu;
[[maybe_unused]]
constexpr uint64_t kController_Vsync_GenOrdinal = 0x5813c85bf6f9d5f5lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerVsyncEventTable;
[[maybe_unused]]
constexpr uint64_t kController_SetVirtconMode_Ordinal = 0x49c4520700000000lu;
[[maybe_unused]]
constexpr uint64_t kController_SetVirtconMode_GenOrdinal = 0x7c8d1b102e72182clu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetVirtconModeRequestTable;
[[maybe_unused]]
constexpr uint64_t kController_ClientOwnershipChange_Ordinal = 0x4360b92e00000000lu;
[[maybe_unused]]
constexpr uint64_t kController_ClientOwnershipChange_GenOrdinal = 0x41b1af32fb2f7362lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerClientOwnershipChangeEventTable;
[[maybe_unused]]
constexpr uint64_t kController_ComputeLinearImageStride_Ordinal = 0x6ac90cda00000000lu;
[[maybe_unused]]
constexpr uint64_t kController_ComputeLinearImageStride_GenOrdinal = 0x1ed33802ba2d797clu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerComputeLinearImageStrideResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_AllocateVmo_Ordinal = 0x6fb5bafa00000000lu;
[[maybe_unused]]
constexpr uint64_t kController_AllocateVmo_GenOrdinal = 0x589658048f8d398blu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerAllocateVmoResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_ImportBufferCollection_Ordinal = 0x605b9d0d00000000lu;
[[maybe_unused]]
constexpr uint64_t kController_ImportBufferCollection_GenOrdinal = 0x1cdf9cc2e60832d1lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerImportBufferCollectionRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerImportBufferCollectionResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_ReleaseBufferCollection_Ordinal = 0x52f8b58400000000lu;
[[maybe_unused]]
constexpr uint64_t kController_ReleaseBufferCollection_GenOrdinal = 0x4527c480391b6c83lu;
[[maybe_unused]]
constexpr uint64_t kController_SetBufferCollectionConstraints_Ordinal = 0x78b51dd00000000lu;
[[maybe_unused]]
constexpr uint64_t kController_SetBufferCollectionConstraints_GenOrdinal = 0x3b78d75d2d21b451lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetBufferCollectionConstraintsResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_GetSingleBufferFramebuffer_Ordinal = 0x2ecce54500000000lu;
[[maybe_unused]]
constexpr uint64_t kController_GetSingleBufferFramebuffer_GenOrdinal = 0x65cd908c2c03b49dlu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerGetSingleBufferFramebufferResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_ImportImageForCapture_Ordinal = 0x3150d1a200000000lu;
[[maybe_unused]]
constexpr uint64_t kController_ImportImageForCapture_GenOrdinal = 0x2a595fbc2df7f9eblu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerImportImageForCaptureRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerImportImageForCaptureResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_StartCapture_Ordinal = 0x5436d93300000000lu;
[[maybe_unused]]
constexpr uint64_t kController_StartCapture_GenOrdinal = 0x7d4ccf55f0259266lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerStartCaptureResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_ReleaseCapture_Ordinal = 0x7f1785f000000000lu;
[[maybe_unused]]
constexpr uint64_t kController_ReleaseCapture_GenOrdinal = 0x3c5dbe1d114a5752lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerReleaseCaptureResponseTable;

}  // namespace
template <>
Controller::ResultOf::ImportVmoImage_Impl<Controller::ImportVmoImageResponse>::ImportVmoImage_Impl(zx::unowned_channel _client_end, ImageConfig image_config, ::zx::vmo vmo, int32_t offset) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ImportVmoImageRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ImportVmoImageRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ImportVmoImageRequest*>(_write_bytes);
  _request.image_config = std::move(image_config);
  _request.vmo = std::move(vmo);
  _request.offset = std::move(offset);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ImportVmoImageRequest));
  ::fidl::DecodedMessage<ImportVmoImageRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::ImportVmoImage(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Controller::ResultOf::ImportVmoImage Controller::SyncClient::ImportVmoImage(ImageConfig image_config, ::zx::vmo vmo, int32_t offset) {
  return ResultOf::ImportVmoImage(zx::unowned_channel(this->channel_), std::move(image_config), std::move(vmo), std::move(offset));
}

Controller::ResultOf::ImportVmoImage Controller::Call::ImportVmoImage(zx::unowned_channel _client_end, ImageConfig image_config, ::zx::vmo vmo, int32_t offset) {
  return ResultOf::ImportVmoImage(std::move(_client_end), std::move(image_config), std::move(vmo), std::move(offset));
}

template <>
Controller::UnownedResultOf::ImportVmoImage_Impl<Controller::ImportVmoImageResponse>::ImportVmoImage_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ImageConfig image_config, ::zx::vmo vmo, int32_t offset, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < ImportVmoImageRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<ImportVmoImageResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, ImportVmoImageRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ImportVmoImageRequest*>(_request_buffer.data());
  _request.image_config = std::move(image_config);
  _request.vmo = std::move(vmo);
  _request.offset = std::move(offset);
  _request_buffer.set_actual(sizeof(ImportVmoImageRequest));
  ::fidl::DecodedMessage<ImportVmoImageRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::ImportVmoImage(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Controller::UnownedResultOf::ImportVmoImage Controller::SyncClient::ImportVmoImage(::fidl::BytePart _request_buffer, ImageConfig image_config, ::zx::vmo vmo, int32_t offset, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ImportVmoImage(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(image_config), std::move(vmo), std::move(offset), std::move(_response_buffer));
}

Controller::UnownedResultOf::ImportVmoImage Controller::Call::ImportVmoImage(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ImageConfig image_config, ::zx::vmo vmo, int32_t offset, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ImportVmoImage(std::move(_client_end), std::move(_request_buffer), std::move(image_config), std::move(vmo), std::move(offset), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::ImportVmoImageResponse> Controller::InPlace::ImportVmoImage(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ImportVmoImageRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_ImportVmoImage_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::ImportVmoImageResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ImportVmoImageRequest, ImportVmoImageResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::ImportVmoImageResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::ImportImage_Impl<Controller::ImportImageResponse>::ImportImage_Impl(zx::unowned_channel _client_end, ImageConfig image_config, uint64_t collection_id, uint32_t index) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ImportImageRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ImportImageRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ImportImageRequest*>(_write_bytes);
  _request.image_config = std::move(image_config);
  _request.collection_id = std::move(collection_id);
  _request.index = std::move(index);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ImportImageRequest));
  ::fidl::DecodedMessage<ImportImageRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::ImportImage(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Controller::ResultOf::ImportImage Controller::SyncClient::ImportImage(ImageConfig image_config, uint64_t collection_id, uint32_t index) {
  return ResultOf::ImportImage(zx::unowned_channel(this->channel_), std::move(image_config), std::move(collection_id), std::move(index));
}

Controller::ResultOf::ImportImage Controller::Call::ImportImage(zx::unowned_channel _client_end, ImageConfig image_config, uint64_t collection_id, uint32_t index) {
  return ResultOf::ImportImage(std::move(_client_end), std::move(image_config), std::move(collection_id), std::move(index));
}

template <>
Controller::UnownedResultOf::ImportImage_Impl<Controller::ImportImageResponse>::ImportImage_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ImageConfig image_config, uint64_t collection_id, uint32_t index, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < ImportImageRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<ImportImageResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, ImportImageRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ImportImageRequest*>(_request_buffer.data());
  _request.image_config = std::move(image_config);
  _request.collection_id = std::move(collection_id);
  _request.index = std::move(index);
  _request_buffer.set_actual(sizeof(ImportImageRequest));
  ::fidl::DecodedMessage<ImportImageRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::ImportImage(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Controller::UnownedResultOf::ImportImage Controller::SyncClient::ImportImage(::fidl::BytePart _request_buffer, ImageConfig image_config, uint64_t collection_id, uint32_t index, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ImportImage(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(image_config), std::move(collection_id), std::move(index), std::move(_response_buffer));
}

Controller::UnownedResultOf::ImportImage Controller::Call::ImportImage(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ImageConfig image_config, uint64_t collection_id, uint32_t index, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ImportImage(std::move(_client_end), std::move(_request_buffer), std::move(image_config), std::move(collection_id), std::move(index), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::ImportImageResponse> Controller::InPlace::ImportImage(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ImportImageRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_ImportImage_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::ImportImageResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ImportImageRequest, ImportImageResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::ImportImageResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


Controller::ResultOf::ReleaseImage_Impl::ReleaseImage_Impl(zx::unowned_channel _client_end, uint64_t image_id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReleaseImageRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ReleaseImageRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReleaseImageRequest*>(_write_bytes);
  _request.image_id = std::move(image_id);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ReleaseImageRequest));
  ::fidl::DecodedMessage<ReleaseImageRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Controller::InPlace::ReleaseImage(std::move(_client_end), std::move(_decoded_request)));
}

Controller::ResultOf::ReleaseImage Controller::SyncClient::ReleaseImage(uint64_t image_id) {
  return ResultOf::ReleaseImage(zx::unowned_channel(this->channel_), std::move(image_id));
}

Controller::ResultOf::ReleaseImage Controller::Call::ReleaseImage(zx::unowned_channel _client_end, uint64_t image_id) {
  return ResultOf::ReleaseImage(std::move(_client_end), std::move(image_id));
}


Controller::UnownedResultOf::ReleaseImage_Impl::ReleaseImage_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t image_id) {
  if (_request_buffer.capacity() < ReleaseImageRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, ReleaseImageRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReleaseImageRequest*>(_request_buffer.data());
  _request.image_id = std::move(image_id);
  _request_buffer.set_actual(sizeof(ReleaseImageRequest));
  ::fidl::DecodedMessage<ReleaseImageRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Controller::InPlace::ReleaseImage(std::move(_client_end), std::move(_decoded_request)));
}

Controller::UnownedResultOf::ReleaseImage Controller::SyncClient::ReleaseImage(::fidl::BytePart _request_buffer, uint64_t image_id) {
  return UnownedResultOf::ReleaseImage(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(image_id));
}

Controller::UnownedResultOf::ReleaseImage Controller::Call::ReleaseImage(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t image_id) {
  return UnownedResultOf::ReleaseImage(std::move(_client_end), std::move(_request_buffer), std::move(image_id));
}

::fidl::internal::StatusAndError Controller::InPlace::ReleaseImage(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReleaseImageRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_ReleaseImage_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Controller::ResultOf::ImportEvent_Impl::ImportEvent_Impl(zx::unowned_channel _client_end, ::zx::event event, uint64_t id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ImportEventRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ImportEventRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ImportEventRequest*>(_write_bytes);
  _request.event = std::move(event);
  _request.id = std::move(id);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ImportEventRequest));
  ::fidl::DecodedMessage<ImportEventRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Controller::InPlace::ImportEvent(std::move(_client_end), std::move(_decoded_request)));
}

Controller::ResultOf::ImportEvent Controller::SyncClient::ImportEvent(::zx::event event, uint64_t id) {
  return ResultOf::ImportEvent(zx::unowned_channel(this->channel_), std::move(event), std::move(id));
}

Controller::ResultOf::ImportEvent Controller::Call::ImportEvent(zx::unowned_channel _client_end, ::zx::event event, uint64_t id) {
  return ResultOf::ImportEvent(std::move(_client_end), std::move(event), std::move(id));
}


Controller::UnownedResultOf::ImportEvent_Impl::ImportEvent_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::event event, uint64_t id) {
  if (_request_buffer.capacity() < ImportEventRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, ImportEventRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ImportEventRequest*>(_request_buffer.data());
  _request.event = std::move(event);
  _request.id = std::move(id);
  _request_buffer.set_actual(sizeof(ImportEventRequest));
  ::fidl::DecodedMessage<ImportEventRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Controller::InPlace::ImportEvent(std::move(_client_end), std::move(_decoded_request)));
}

Controller::UnownedResultOf::ImportEvent Controller::SyncClient::ImportEvent(::fidl::BytePart _request_buffer, ::zx::event event, uint64_t id) {
  return UnownedResultOf::ImportEvent(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(event), std::move(id));
}

Controller::UnownedResultOf::ImportEvent Controller::Call::ImportEvent(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::event event, uint64_t id) {
  return UnownedResultOf::ImportEvent(std::move(_client_end), std::move(_request_buffer), std::move(event), std::move(id));
}

::fidl::internal::StatusAndError Controller::InPlace::ImportEvent(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ImportEventRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_ImportEvent_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Controller::ResultOf::ReleaseEvent_Impl::ReleaseEvent_Impl(zx::unowned_channel _client_end, uint64_t id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReleaseEventRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ReleaseEventRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReleaseEventRequest*>(_write_bytes);
  _request.id = std::move(id);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ReleaseEventRequest));
  ::fidl::DecodedMessage<ReleaseEventRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Controller::InPlace::ReleaseEvent(std::move(_client_end), std::move(_decoded_request)));
}

Controller::ResultOf::ReleaseEvent Controller::SyncClient::ReleaseEvent(uint64_t id) {
  return ResultOf::ReleaseEvent(zx::unowned_channel(this->channel_), std::move(id));
}

Controller::ResultOf::ReleaseEvent Controller::Call::ReleaseEvent(zx::unowned_channel _client_end, uint64_t id) {
  return ResultOf::ReleaseEvent(std::move(_client_end), std::move(id));
}


Controller::UnownedResultOf::ReleaseEvent_Impl::ReleaseEvent_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t id) {
  if (_request_buffer.capacity() < ReleaseEventRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, ReleaseEventRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReleaseEventRequest*>(_request_buffer.data());
  _request.id = std::move(id);
  _request_buffer.set_actual(sizeof(ReleaseEventRequest));
  ::fidl::DecodedMessage<ReleaseEventRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Controller::InPlace::ReleaseEvent(std::move(_client_end), std::move(_decoded_request)));
}

Controller::UnownedResultOf::ReleaseEvent Controller::SyncClient::ReleaseEvent(::fidl::BytePart _request_buffer, uint64_t id) {
  return UnownedResultOf::ReleaseEvent(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(id));
}

Controller::UnownedResultOf::ReleaseEvent Controller::Call::ReleaseEvent(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t id) {
  return UnownedResultOf::ReleaseEvent(std::move(_client_end), std::move(_request_buffer), std::move(id));
}

::fidl::internal::StatusAndError Controller::InPlace::ReleaseEvent(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReleaseEventRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_ReleaseEvent_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
Controller::ResultOf::CreateLayer_Impl<Controller::CreateLayerResponse>::CreateLayer_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CreateLayerRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CreateLayerRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CreateLayerRequest));
  ::fidl::DecodedMessage<CreateLayerRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::CreateLayer(std::move(_client_end), Super::response_buffer()));
}

Controller::ResultOf::CreateLayer Controller::SyncClient::CreateLayer() {
  return ResultOf::CreateLayer(zx::unowned_channel(this->channel_));
}

Controller::ResultOf::CreateLayer Controller::Call::CreateLayer(zx::unowned_channel _client_end) {
  return ResultOf::CreateLayer(std::move(_client_end));
}

template <>
Controller::UnownedResultOf::CreateLayer_Impl<Controller::CreateLayerResponse>::CreateLayer_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(CreateLayerRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, CreateLayerRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(CreateLayerRequest));
  ::fidl::DecodedMessage<CreateLayerRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::CreateLayer(std::move(_client_end), std::move(_response_buffer)));
}

Controller::UnownedResultOf::CreateLayer Controller::SyncClient::CreateLayer(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::CreateLayer(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Controller::UnownedResultOf::CreateLayer Controller::Call::CreateLayer(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::CreateLayer(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::CreateLayerResponse> Controller::InPlace::CreateLayer(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(CreateLayerRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<CreateLayerRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_CreateLayer_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::CreateLayerResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<CreateLayerRequest, CreateLayerResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::CreateLayerResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


Controller::ResultOf::DestroyLayer_Impl::DestroyLayer_Impl(zx::unowned_channel _client_end, uint64_t layer_id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DestroyLayerRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, DestroyLayerRequest::PrimarySize);
  auto& _request = *reinterpret_cast<DestroyLayerRequest*>(_write_bytes);
  _request.layer_id = std::move(layer_id);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(DestroyLayerRequest));
  ::fidl::DecodedMessage<DestroyLayerRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Controller::InPlace::DestroyLayer(std::move(_client_end), std::move(_decoded_request)));
}

Controller::ResultOf::DestroyLayer Controller::SyncClient::DestroyLayer(uint64_t layer_id) {
  return ResultOf::DestroyLayer(zx::unowned_channel(this->channel_), std::move(layer_id));
}

Controller::ResultOf::DestroyLayer Controller::Call::DestroyLayer(zx::unowned_channel _client_end, uint64_t layer_id) {
  return ResultOf::DestroyLayer(std::move(_client_end), std::move(layer_id));
}


Controller::UnownedResultOf::DestroyLayer_Impl::DestroyLayer_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id) {
  if (_request_buffer.capacity() < DestroyLayerRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, DestroyLayerRequest::PrimarySize);
  auto& _request = *reinterpret_cast<DestroyLayerRequest*>(_request_buffer.data());
  _request.layer_id = std::move(layer_id);
  _request_buffer.set_actual(sizeof(DestroyLayerRequest));
  ::fidl::DecodedMessage<DestroyLayerRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Controller::InPlace::DestroyLayer(std::move(_client_end), std::move(_decoded_request)));
}

Controller::UnownedResultOf::DestroyLayer Controller::SyncClient::DestroyLayer(::fidl::BytePart _request_buffer, uint64_t layer_id) {
  return UnownedResultOf::DestroyLayer(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(layer_id));
}

Controller::UnownedResultOf::DestroyLayer Controller::Call::DestroyLayer(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id) {
  return UnownedResultOf::DestroyLayer(std::move(_client_end), std::move(_request_buffer), std::move(layer_id));
}

::fidl::internal::StatusAndError Controller::InPlace::DestroyLayer(zx::unowned_channel _client_end, ::fidl::DecodedMessage<DestroyLayerRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_DestroyLayer_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Controller::ResultOf::SetDisplayMode_Impl::SetDisplayMode_Impl(zx::unowned_channel _client_end, uint64_t display_id, Mode mode) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetDisplayModeRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetDisplayModeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetDisplayModeRequest*>(_write_bytes);
  _request.display_id = std::move(display_id);
  _request.mode = std::move(mode);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetDisplayModeRequest));
  ::fidl::DecodedMessage<SetDisplayModeRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Controller::InPlace::SetDisplayMode(std::move(_client_end), std::move(_decoded_request)));
}

Controller::ResultOf::SetDisplayMode Controller::SyncClient::SetDisplayMode(uint64_t display_id, Mode mode) {
  return ResultOf::SetDisplayMode(zx::unowned_channel(this->channel_), std::move(display_id), std::move(mode));
}

Controller::ResultOf::SetDisplayMode Controller::Call::SetDisplayMode(zx::unowned_channel _client_end, uint64_t display_id, Mode mode) {
  return ResultOf::SetDisplayMode(std::move(_client_end), std::move(display_id), std::move(mode));
}


Controller::UnownedResultOf::SetDisplayMode_Impl::SetDisplayMode_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t display_id, Mode mode) {
  if (_request_buffer.capacity() < SetDisplayModeRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, SetDisplayModeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetDisplayModeRequest*>(_request_buffer.data());
  _request.display_id = std::move(display_id);
  _request.mode = std::move(mode);
  _request_buffer.set_actual(sizeof(SetDisplayModeRequest));
  ::fidl::DecodedMessage<SetDisplayModeRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Controller::InPlace::SetDisplayMode(std::move(_client_end), std::move(_decoded_request)));
}

Controller::UnownedResultOf::SetDisplayMode Controller::SyncClient::SetDisplayMode(::fidl::BytePart _request_buffer, uint64_t display_id, Mode mode) {
  return UnownedResultOf::SetDisplayMode(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(display_id), std::move(mode));
}

Controller::UnownedResultOf::SetDisplayMode Controller::Call::SetDisplayMode(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t display_id, Mode mode) {
  return UnownedResultOf::SetDisplayMode(std::move(_client_end), std::move(_request_buffer), std::move(display_id), std::move(mode));
}

::fidl::internal::StatusAndError Controller::InPlace::SetDisplayMode(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetDisplayModeRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_SetDisplayMode_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Controller::ResultOf::SetDisplayColorConversion_Impl::SetDisplayColorConversion_Impl(zx::unowned_channel _client_end, uint64_t display_id, ::fidl::Array<float, 3> preoffsets, ::fidl::Array<float, 9> coefficients, ::fidl::Array<float, 3> postoffsets) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetDisplayColorConversionRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetDisplayColorConversionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetDisplayColorConversionRequest*>(_write_bytes);
  _request.display_id = std::move(display_id);
  _request.preoffsets = std::move(preoffsets);
  _request.coefficients = std::move(coefficients);
  _request.postoffsets = std::move(postoffsets);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetDisplayColorConversionRequest));
  ::fidl::DecodedMessage<SetDisplayColorConversionRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Controller::InPlace::SetDisplayColorConversion(std::move(_client_end), std::move(_decoded_request)));
}

Controller::ResultOf::SetDisplayColorConversion Controller::SyncClient::SetDisplayColorConversion(uint64_t display_id, ::fidl::Array<float, 3> preoffsets, ::fidl::Array<float, 9> coefficients, ::fidl::Array<float, 3> postoffsets) {
  return ResultOf::SetDisplayColorConversion(zx::unowned_channel(this->channel_), std::move(display_id), std::move(preoffsets), std::move(coefficients), std::move(postoffsets));
}

Controller::ResultOf::SetDisplayColorConversion Controller::Call::SetDisplayColorConversion(zx::unowned_channel _client_end, uint64_t display_id, ::fidl::Array<float, 3> preoffsets, ::fidl::Array<float, 9> coefficients, ::fidl::Array<float, 3> postoffsets) {
  return ResultOf::SetDisplayColorConversion(std::move(_client_end), std::move(display_id), std::move(preoffsets), std::move(coefficients), std::move(postoffsets));
}


Controller::UnownedResultOf::SetDisplayColorConversion_Impl::SetDisplayColorConversion_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t display_id, ::fidl::Array<float, 3> preoffsets, ::fidl::Array<float, 9> coefficients, ::fidl::Array<float, 3> postoffsets) {
  if (_request_buffer.capacity() < SetDisplayColorConversionRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, SetDisplayColorConversionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetDisplayColorConversionRequest*>(_request_buffer.data());
  _request.display_id = std::move(display_id);
  _request.preoffsets = std::move(preoffsets);
  _request.coefficients = std::move(coefficients);
  _request.postoffsets = std::move(postoffsets);
  _request_buffer.set_actual(sizeof(SetDisplayColorConversionRequest));
  ::fidl::DecodedMessage<SetDisplayColorConversionRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Controller::InPlace::SetDisplayColorConversion(std::move(_client_end), std::move(_decoded_request)));
}

Controller::UnownedResultOf::SetDisplayColorConversion Controller::SyncClient::SetDisplayColorConversion(::fidl::BytePart _request_buffer, uint64_t display_id, ::fidl::Array<float, 3> preoffsets, ::fidl::Array<float, 9> coefficients, ::fidl::Array<float, 3> postoffsets) {
  return UnownedResultOf::SetDisplayColorConversion(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(display_id), std::move(preoffsets), std::move(coefficients), std::move(postoffsets));
}

Controller::UnownedResultOf::SetDisplayColorConversion Controller::Call::SetDisplayColorConversion(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t display_id, ::fidl::Array<float, 3> preoffsets, ::fidl::Array<float, 9> coefficients, ::fidl::Array<float, 3> postoffsets) {
  return UnownedResultOf::SetDisplayColorConversion(std::move(_client_end), std::move(_request_buffer), std::move(display_id), std::move(preoffsets), std::move(coefficients), std::move(postoffsets));
}

::fidl::internal::StatusAndError Controller::InPlace::SetDisplayColorConversion(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetDisplayColorConversionRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_SetDisplayColorConversion_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Controller::ResultOf::SetDisplayLayers_Impl::SetDisplayLayers_Impl(zx::unowned_channel _client_end, uint64_t display_id, ::fidl::VectorView<uint64_t> layer_ids) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetDisplayLayersRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  SetDisplayLayersRequest _request = {};
  _request.display_id = std::move(display_id);
  _request.layer_ids = std::move(layer_ids);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<SetDisplayLayersRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      Controller::InPlace::SetDisplayLayers(std::move(_client_end), std::move(_decoded_request)));
}

Controller::ResultOf::SetDisplayLayers Controller::SyncClient::SetDisplayLayers(uint64_t display_id, ::fidl::VectorView<uint64_t> layer_ids) {
  return ResultOf::SetDisplayLayers(zx::unowned_channel(this->channel_), std::move(display_id), std::move(layer_ids));
}

Controller::ResultOf::SetDisplayLayers Controller::Call::SetDisplayLayers(zx::unowned_channel _client_end, uint64_t display_id, ::fidl::VectorView<uint64_t> layer_ids) {
  return ResultOf::SetDisplayLayers(std::move(_client_end), std::move(display_id), std::move(layer_ids));
}


Controller::UnownedResultOf::SetDisplayLayers_Impl::SetDisplayLayers_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t display_id, ::fidl::VectorView<uint64_t> layer_ids) {
  if (_request_buffer.capacity() < SetDisplayLayersRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  SetDisplayLayersRequest _request = {};
  _request.display_id = std::move(display_id);
  _request.layer_ids = std::move(layer_ids);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<SetDisplayLayersRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      Controller::InPlace::SetDisplayLayers(std::move(_client_end), std::move(_decoded_request)));
}

Controller::UnownedResultOf::SetDisplayLayers Controller::SyncClient::SetDisplayLayers(::fidl::BytePart _request_buffer, uint64_t display_id, ::fidl::VectorView<uint64_t> layer_ids) {
  return UnownedResultOf::SetDisplayLayers(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(display_id), std::move(layer_ids));
}

Controller::UnownedResultOf::SetDisplayLayers Controller::Call::SetDisplayLayers(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t display_id, ::fidl::VectorView<uint64_t> layer_ids) {
  return UnownedResultOf::SetDisplayLayers(std::move(_client_end), std::move(_request_buffer), std::move(display_id), std::move(layer_ids));
}

::fidl::internal::StatusAndError Controller::InPlace::SetDisplayLayers(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetDisplayLayersRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_SetDisplayLayers_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Controller::ResultOf::SetLayerPrimaryConfig_Impl::SetLayerPrimaryConfig_Impl(zx::unowned_channel _client_end, uint64_t layer_id, ImageConfig image_config) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetLayerPrimaryConfigRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetLayerPrimaryConfigRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetLayerPrimaryConfigRequest*>(_write_bytes);
  _request.layer_id = std::move(layer_id);
  _request.image_config = std::move(image_config);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetLayerPrimaryConfigRequest));
  ::fidl::DecodedMessage<SetLayerPrimaryConfigRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Controller::InPlace::SetLayerPrimaryConfig(std::move(_client_end), std::move(_decoded_request)));
}

Controller::ResultOf::SetLayerPrimaryConfig Controller::SyncClient::SetLayerPrimaryConfig(uint64_t layer_id, ImageConfig image_config) {
  return ResultOf::SetLayerPrimaryConfig(zx::unowned_channel(this->channel_), std::move(layer_id), std::move(image_config));
}

Controller::ResultOf::SetLayerPrimaryConfig Controller::Call::SetLayerPrimaryConfig(zx::unowned_channel _client_end, uint64_t layer_id, ImageConfig image_config) {
  return ResultOf::SetLayerPrimaryConfig(std::move(_client_end), std::move(layer_id), std::move(image_config));
}


Controller::UnownedResultOf::SetLayerPrimaryConfig_Impl::SetLayerPrimaryConfig_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, ImageConfig image_config) {
  if (_request_buffer.capacity() < SetLayerPrimaryConfigRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, SetLayerPrimaryConfigRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetLayerPrimaryConfigRequest*>(_request_buffer.data());
  _request.layer_id = std::move(layer_id);
  _request.image_config = std::move(image_config);
  _request_buffer.set_actual(sizeof(SetLayerPrimaryConfigRequest));
  ::fidl::DecodedMessage<SetLayerPrimaryConfigRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Controller::InPlace::SetLayerPrimaryConfig(std::move(_client_end), std::move(_decoded_request)));
}

Controller::UnownedResultOf::SetLayerPrimaryConfig Controller::SyncClient::SetLayerPrimaryConfig(::fidl::BytePart _request_buffer, uint64_t layer_id, ImageConfig image_config) {
  return UnownedResultOf::SetLayerPrimaryConfig(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(layer_id), std::move(image_config));
}

Controller::UnownedResultOf::SetLayerPrimaryConfig Controller::Call::SetLayerPrimaryConfig(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, ImageConfig image_config) {
  return UnownedResultOf::SetLayerPrimaryConfig(std::move(_client_end), std::move(_request_buffer), std::move(layer_id), std::move(image_config));
}

::fidl::internal::StatusAndError Controller::InPlace::SetLayerPrimaryConfig(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetLayerPrimaryConfigRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_SetLayerPrimaryConfig_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Controller::ResultOf::SetLayerPrimaryPosition_Impl::SetLayerPrimaryPosition_Impl(zx::unowned_channel _client_end, uint64_t layer_id, Transform transform, Frame src_frame, Frame dest_frame) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetLayerPrimaryPositionRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetLayerPrimaryPositionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetLayerPrimaryPositionRequest*>(_write_bytes);
  _request.layer_id = std::move(layer_id);
  _request.transform = std::move(transform);
  _request.src_frame = std::move(src_frame);
  _request.dest_frame = std::move(dest_frame);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetLayerPrimaryPositionRequest));
  ::fidl::DecodedMessage<SetLayerPrimaryPositionRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Controller::InPlace::SetLayerPrimaryPosition(std::move(_client_end), std::move(_decoded_request)));
}

Controller::ResultOf::SetLayerPrimaryPosition Controller::SyncClient::SetLayerPrimaryPosition(uint64_t layer_id, Transform transform, Frame src_frame, Frame dest_frame) {
  return ResultOf::SetLayerPrimaryPosition(zx::unowned_channel(this->channel_), std::move(layer_id), std::move(transform), std::move(src_frame), std::move(dest_frame));
}

Controller::ResultOf::SetLayerPrimaryPosition Controller::Call::SetLayerPrimaryPosition(zx::unowned_channel _client_end, uint64_t layer_id, Transform transform, Frame src_frame, Frame dest_frame) {
  return ResultOf::SetLayerPrimaryPosition(std::move(_client_end), std::move(layer_id), std::move(transform), std::move(src_frame), std::move(dest_frame));
}


Controller::UnownedResultOf::SetLayerPrimaryPosition_Impl::SetLayerPrimaryPosition_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, Transform transform, Frame src_frame, Frame dest_frame) {
  if (_request_buffer.capacity() < SetLayerPrimaryPositionRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, SetLayerPrimaryPositionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetLayerPrimaryPositionRequest*>(_request_buffer.data());
  _request.layer_id = std::move(layer_id);
  _request.transform = std::move(transform);
  _request.src_frame = std::move(src_frame);
  _request.dest_frame = std::move(dest_frame);
  _request_buffer.set_actual(sizeof(SetLayerPrimaryPositionRequest));
  ::fidl::DecodedMessage<SetLayerPrimaryPositionRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Controller::InPlace::SetLayerPrimaryPosition(std::move(_client_end), std::move(_decoded_request)));
}

Controller::UnownedResultOf::SetLayerPrimaryPosition Controller::SyncClient::SetLayerPrimaryPosition(::fidl::BytePart _request_buffer, uint64_t layer_id, Transform transform, Frame src_frame, Frame dest_frame) {
  return UnownedResultOf::SetLayerPrimaryPosition(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(layer_id), std::move(transform), std::move(src_frame), std::move(dest_frame));
}

Controller::UnownedResultOf::SetLayerPrimaryPosition Controller::Call::SetLayerPrimaryPosition(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, Transform transform, Frame src_frame, Frame dest_frame) {
  return UnownedResultOf::SetLayerPrimaryPosition(std::move(_client_end), std::move(_request_buffer), std::move(layer_id), std::move(transform), std::move(src_frame), std::move(dest_frame));
}

::fidl::internal::StatusAndError Controller::InPlace::SetLayerPrimaryPosition(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetLayerPrimaryPositionRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_SetLayerPrimaryPosition_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Controller::ResultOf::SetLayerPrimaryAlpha_Impl::SetLayerPrimaryAlpha_Impl(zx::unowned_channel _client_end, uint64_t layer_id, AlphaMode mode, float val) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetLayerPrimaryAlphaRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetLayerPrimaryAlphaRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetLayerPrimaryAlphaRequest*>(_write_bytes);
  _request.layer_id = std::move(layer_id);
  _request.mode = std::move(mode);
  _request.val = std::move(val);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetLayerPrimaryAlphaRequest));
  ::fidl::DecodedMessage<SetLayerPrimaryAlphaRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Controller::InPlace::SetLayerPrimaryAlpha(std::move(_client_end), std::move(_decoded_request)));
}

Controller::ResultOf::SetLayerPrimaryAlpha Controller::SyncClient::SetLayerPrimaryAlpha(uint64_t layer_id, AlphaMode mode, float val) {
  return ResultOf::SetLayerPrimaryAlpha(zx::unowned_channel(this->channel_), std::move(layer_id), std::move(mode), std::move(val));
}

Controller::ResultOf::SetLayerPrimaryAlpha Controller::Call::SetLayerPrimaryAlpha(zx::unowned_channel _client_end, uint64_t layer_id, AlphaMode mode, float val) {
  return ResultOf::SetLayerPrimaryAlpha(std::move(_client_end), std::move(layer_id), std::move(mode), std::move(val));
}


Controller::UnownedResultOf::SetLayerPrimaryAlpha_Impl::SetLayerPrimaryAlpha_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, AlphaMode mode, float val) {
  if (_request_buffer.capacity() < SetLayerPrimaryAlphaRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, SetLayerPrimaryAlphaRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetLayerPrimaryAlphaRequest*>(_request_buffer.data());
  _request.layer_id = std::move(layer_id);
  _request.mode = std::move(mode);
  _request.val = std::move(val);
  _request_buffer.set_actual(sizeof(SetLayerPrimaryAlphaRequest));
  ::fidl::DecodedMessage<SetLayerPrimaryAlphaRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Controller::InPlace::SetLayerPrimaryAlpha(std::move(_client_end), std::move(_decoded_request)));
}

Controller::UnownedResultOf::SetLayerPrimaryAlpha Controller::SyncClient::SetLayerPrimaryAlpha(::fidl::BytePart _request_buffer, uint64_t layer_id, AlphaMode mode, float val) {
  return UnownedResultOf::SetLayerPrimaryAlpha(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(layer_id), std::move(mode), std::move(val));
}

Controller::UnownedResultOf::SetLayerPrimaryAlpha Controller::Call::SetLayerPrimaryAlpha(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, AlphaMode mode, float val) {
  return UnownedResultOf::SetLayerPrimaryAlpha(std::move(_client_end), std::move(_request_buffer), std::move(layer_id), std::move(mode), std::move(val));
}

::fidl::internal::StatusAndError Controller::InPlace::SetLayerPrimaryAlpha(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetLayerPrimaryAlphaRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_SetLayerPrimaryAlpha_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Controller::ResultOf::SetLayerCursorConfig_Impl::SetLayerCursorConfig_Impl(zx::unowned_channel _client_end, uint64_t layer_id, ImageConfig image_config) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetLayerCursorConfigRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetLayerCursorConfigRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetLayerCursorConfigRequest*>(_write_bytes);
  _request.layer_id = std::move(layer_id);
  _request.image_config = std::move(image_config);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetLayerCursorConfigRequest));
  ::fidl::DecodedMessage<SetLayerCursorConfigRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Controller::InPlace::SetLayerCursorConfig(std::move(_client_end), std::move(_decoded_request)));
}

Controller::ResultOf::SetLayerCursorConfig Controller::SyncClient::SetLayerCursorConfig(uint64_t layer_id, ImageConfig image_config) {
  return ResultOf::SetLayerCursorConfig(zx::unowned_channel(this->channel_), std::move(layer_id), std::move(image_config));
}

Controller::ResultOf::SetLayerCursorConfig Controller::Call::SetLayerCursorConfig(zx::unowned_channel _client_end, uint64_t layer_id, ImageConfig image_config) {
  return ResultOf::SetLayerCursorConfig(std::move(_client_end), std::move(layer_id), std::move(image_config));
}


Controller::UnownedResultOf::SetLayerCursorConfig_Impl::SetLayerCursorConfig_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, ImageConfig image_config) {
  if (_request_buffer.capacity() < SetLayerCursorConfigRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, SetLayerCursorConfigRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetLayerCursorConfigRequest*>(_request_buffer.data());
  _request.layer_id = std::move(layer_id);
  _request.image_config = std::move(image_config);
  _request_buffer.set_actual(sizeof(SetLayerCursorConfigRequest));
  ::fidl::DecodedMessage<SetLayerCursorConfigRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Controller::InPlace::SetLayerCursorConfig(std::move(_client_end), std::move(_decoded_request)));
}

Controller::UnownedResultOf::SetLayerCursorConfig Controller::SyncClient::SetLayerCursorConfig(::fidl::BytePart _request_buffer, uint64_t layer_id, ImageConfig image_config) {
  return UnownedResultOf::SetLayerCursorConfig(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(layer_id), std::move(image_config));
}

Controller::UnownedResultOf::SetLayerCursorConfig Controller::Call::SetLayerCursorConfig(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, ImageConfig image_config) {
  return UnownedResultOf::SetLayerCursorConfig(std::move(_client_end), std::move(_request_buffer), std::move(layer_id), std::move(image_config));
}

::fidl::internal::StatusAndError Controller::InPlace::SetLayerCursorConfig(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetLayerCursorConfigRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_SetLayerCursorConfig_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Controller::ResultOf::SetLayerCursorPosition_Impl::SetLayerCursorPosition_Impl(zx::unowned_channel _client_end, uint64_t layer_id, int32_t x, int32_t y) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetLayerCursorPositionRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetLayerCursorPositionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetLayerCursorPositionRequest*>(_write_bytes);
  _request.layer_id = std::move(layer_id);
  _request.x = std::move(x);
  _request.y = std::move(y);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetLayerCursorPositionRequest));
  ::fidl::DecodedMessage<SetLayerCursorPositionRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Controller::InPlace::SetLayerCursorPosition(std::move(_client_end), std::move(_decoded_request)));
}

Controller::ResultOf::SetLayerCursorPosition Controller::SyncClient::SetLayerCursorPosition(uint64_t layer_id, int32_t x, int32_t y) {
  return ResultOf::SetLayerCursorPosition(zx::unowned_channel(this->channel_), std::move(layer_id), std::move(x), std::move(y));
}

Controller::ResultOf::SetLayerCursorPosition Controller::Call::SetLayerCursorPosition(zx::unowned_channel _client_end, uint64_t layer_id, int32_t x, int32_t y) {
  return ResultOf::SetLayerCursorPosition(std::move(_client_end), std::move(layer_id), std::move(x), std::move(y));
}


Controller::UnownedResultOf::SetLayerCursorPosition_Impl::SetLayerCursorPosition_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, int32_t x, int32_t y) {
  if (_request_buffer.capacity() < SetLayerCursorPositionRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, SetLayerCursorPositionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetLayerCursorPositionRequest*>(_request_buffer.data());
  _request.layer_id = std::move(layer_id);
  _request.x = std::move(x);
  _request.y = std::move(y);
  _request_buffer.set_actual(sizeof(SetLayerCursorPositionRequest));
  ::fidl::DecodedMessage<SetLayerCursorPositionRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Controller::InPlace::SetLayerCursorPosition(std::move(_client_end), std::move(_decoded_request)));
}

Controller::UnownedResultOf::SetLayerCursorPosition Controller::SyncClient::SetLayerCursorPosition(::fidl::BytePart _request_buffer, uint64_t layer_id, int32_t x, int32_t y) {
  return UnownedResultOf::SetLayerCursorPosition(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(layer_id), std::move(x), std::move(y));
}

Controller::UnownedResultOf::SetLayerCursorPosition Controller::Call::SetLayerCursorPosition(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, int32_t x, int32_t y) {
  return UnownedResultOf::SetLayerCursorPosition(std::move(_client_end), std::move(_request_buffer), std::move(layer_id), std::move(x), std::move(y));
}

::fidl::internal::StatusAndError Controller::InPlace::SetLayerCursorPosition(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetLayerCursorPositionRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_SetLayerCursorPosition_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Controller::ResultOf::SetLayerColorConfig_Impl::SetLayerColorConfig_Impl(zx::unowned_channel _client_end, uint64_t layer_id, uint32_t pixel_format, ::fidl::VectorView<uint8_t> color_bytes) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetLayerColorConfigRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  SetLayerColorConfigRequest _request = {};
  _request.layer_id = std::move(layer_id);
  _request.pixel_format = std::move(pixel_format);
  _request.color_bytes = std::move(color_bytes);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<SetLayerColorConfigRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      Controller::InPlace::SetLayerColorConfig(std::move(_client_end), std::move(_decoded_request)));
}

Controller::ResultOf::SetLayerColorConfig Controller::SyncClient::SetLayerColorConfig(uint64_t layer_id, uint32_t pixel_format, ::fidl::VectorView<uint8_t> color_bytes) {
  return ResultOf::SetLayerColorConfig(zx::unowned_channel(this->channel_), std::move(layer_id), std::move(pixel_format), std::move(color_bytes));
}

Controller::ResultOf::SetLayerColorConfig Controller::Call::SetLayerColorConfig(zx::unowned_channel _client_end, uint64_t layer_id, uint32_t pixel_format, ::fidl::VectorView<uint8_t> color_bytes) {
  return ResultOf::SetLayerColorConfig(std::move(_client_end), std::move(layer_id), std::move(pixel_format), std::move(color_bytes));
}


Controller::UnownedResultOf::SetLayerColorConfig_Impl::SetLayerColorConfig_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, uint32_t pixel_format, ::fidl::VectorView<uint8_t> color_bytes) {
  if (_request_buffer.capacity() < SetLayerColorConfigRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  SetLayerColorConfigRequest _request = {};
  _request.layer_id = std::move(layer_id);
  _request.pixel_format = std::move(pixel_format);
  _request.color_bytes = std::move(color_bytes);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<SetLayerColorConfigRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      Controller::InPlace::SetLayerColorConfig(std::move(_client_end), std::move(_decoded_request)));
}

Controller::UnownedResultOf::SetLayerColorConfig Controller::SyncClient::SetLayerColorConfig(::fidl::BytePart _request_buffer, uint64_t layer_id, uint32_t pixel_format, ::fidl::VectorView<uint8_t> color_bytes) {
  return UnownedResultOf::SetLayerColorConfig(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(layer_id), std::move(pixel_format), std::move(color_bytes));
}

Controller::UnownedResultOf::SetLayerColorConfig Controller::Call::SetLayerColorConfig(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, uint32_t pixel_format, ::fidl::VectorView<uint8_t> color_bytes) {
  return UnownedResultOf::SetLayerColorConfig(std::move(_client_end), std::move(_request_buffer), std::move(layer_id), std::move(pixel_format), std::move(color_bytes));
}

::fidl::internal::StatusAndError Controller::InPlace::SetLayerColorConfig(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetLayerColorConfigRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_SetLayerColorConfig_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Controller::ResultOf::SetLayerImage_Impl::SetLayerImage_Impl(zx::unowned_channel _client_end, uint64_t layer_id, uint64_t image_id, uint64_t wait_event_id, uint64_t signal_event_id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetLayerImageRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetLayerImageRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetLayerImageRequest*>(_write_bytes);
  _request.layer_id = std::move(layer_id);
  _request.image_id = std::move(image_id);
  _request.wait_event_id = std::move(wait_event_id);
  _request.signal_event_id = std::move(signal_event_id);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetLayerImageRequest));
  ::fidl::DecodedMessage<SetLayerImageRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Controller::InPlace::SetLayerImage(std::move(_client_end), std::move(_decoded_request)));
}

Controller::ResultOf::SetLayerImage Controller::SyncClient::SetLayerImage(uint64_t layer_id, uint64_t image_id, uint64_t wait_event_id, uint64_t signal_event_id) {
  return ResultOf::SetLayerImage(zx::unowned_channel(this->channel_), std::move(layer_id), std::move(image_id), std::move(wait_event_id), std::move(signal_event_id));
}

Controller::ResultOf::SetLayerImage Controller::Call::SetLayerImage(zx::unowned_channel _client_end, uint64_t layer_id, uint64_t image_id, uint64_t wait_event_id, uint64_t signal_event_id) {
  return ResultOf::SetLayerImage(std::move(_client_end), std::move(layer_id), std::move(image_id), std::move(wait_event_id), std::move(signal_event_id));
}


Controller::UnownedResultOf::SetLayerImage_Impl::SetLayerImage_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, uint64_t image_id, uint64_t wait_event_id, uint64_t signal_event_id) {
  if (_request_buffer.capacity() < SetLayerImageRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, SetLayerImageRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetLayerImageRequest*>(_request_buffer.data());
  _request.layer_id = std::move(layer_id);
  _request.image_id = std::move(image_id);
  _request.wait_event_id = std::move(wait_event_id);
  _request.signal_event_id = std::move(signal_event_id);
  _request_buffer.set_actual(sizeof(SetLayerImageRequest));
  ::fidl::DecodedMessage<SetLayerImageRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Controller::InPlace::SetLayerImage(std::move(_client_end), std::move(_decoded_request)));
}

Controller::UnownedResultOf::SetLayerImage Controller::SyncClient::SetLayerImage(::fidl::BytePart _request_buffer, uint64_t layer_id, uint64_t image_id, uint64_t wait_event_id, uint64_t signal_event_id) {
  return UnownedResultOf::SetLayerImage(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(layer_id), std::move(image_id), std::move(wait_event_id), std::move(signal_event_id));
}

Controller::UnownedResultOf::SetLayerImage Controller::Call::SetLayerImage(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, uint64_t image_id, uint64_t wait_event_id, uint64_t signal_event_id) {
  return UnownedResultOf::SetLayerImage(std::move(_client_end), std::move(_request_buffer), std::move(layer_id), std::move(image_id), std::move(wait_event_id), std::move(signal_event_id));
}

::fidl::internal::StatusAndError Controller::InPlace::SetLayerImage(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetLayerImageRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_SetLayerImage_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
Controller::ResultOf::CheckConfig_Impl<Controller::CheckConfigResponse>::CheckConfig_Impl(zx::unowned_channel _client_end, bool discard) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CheckConfigRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CheckConfigRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CheckConfigRequest*>(_write_bytes);
  _request.discard = std::move(discard);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CheckConfigRequest));
  ::fidl::DecodedMessage<CheckConfigRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::CheckConfig(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Controller::ResultOf::CheckConfig Controller::SyncClient::CheckConfig(bool discard) {
  return ResultOf::CheckConfig(zx::unowned_channel(this->channel_), std::move(discard));
}

Controller::ResultOf::CheckConfig Controller::Call::CheckConfig(zx::unowned_channel _client_end, bool discard) {
  return ResultOf::CheckConfig(std::move(_client_end), std::move(discard));
}

template <>
Controller::UnownedResultOf::CheckConfig_Impl<Controller::CheckConfigResponse>::CheckConfig_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, bool discard, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < CheckConfigRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<CheckConfigResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, CheckConfigRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CheckConfigRequest*>(_request_buffer.data());
  _request.discard = std::move(discard);
  _request_buffer.set_actual(sizeof(CheckConfigRequest));
  ::fidl::DecodedMessage<CheckConfigRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::CheckConfig(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Controller::UnownedResultOf::CheckConfig Controller::SyncClient::CheckConfig(::fidl::BytePart _request_buffer, bool discard, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::CheckConfig(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(discard), std::move(_response_buffer));
}

Controller::UnownedResultOf::CheckConfig Controller::Call::CheckConfig(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, bool discard, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::CheckConfig(std::move(_client_end), std::move(_request_buffer), std::move(discard), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::CheckConfigResponse> Controller::InPlace::CheckConfig(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CheckConfigRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_CheckConfig_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::CheckConfigResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<CheckConfigRequest, CheckConfigResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::CheckConfigResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


Controller::ResultOf::ApplyConfig_Impl::ApplyConfig_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ApplyConfigRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ApplyConfigRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ApplyConfigRequest));
  ::fidl::DecodedMessage<ApplyConfigRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Controller::InPlace::ApplyConfig(std::move(_client_end)));
}

Controller::ResultOf::ApplyConfig Controller::SyncClient::ApplyConfig() {
  return ResultOf::ApplyConfig(zx::unowned_channel(this->channel_));
}

Controller::ResultOf::ApplyConfig Controller::Call::ApplyConfig(zx::unowned_channel _client_end) {
  return ResultOf::ApplyConfig(std::move(_client_end));
}

::fidl::internal::StatusAndError Controller::InPlace::ApplyConfig(zx::unowned_channel _client_end) {
  constexpr uint32_t _write_num_bytes = sizeof(ApplyConfigRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<ApplyConfigRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_ApplyConfig_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Controller::ResultOf::EnableVsync_Impl::EnableVsync_Impl(zx::unowned_channel _client_end, bool enable) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<EnableVsyncRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, EnableVsyncRequest::PrimarySize);
  auto& _request = *reinterpret_cast<EnableVsyncRequest*>(_write_bytes);
  _request.enable = std::move(enable);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(EnableVsyncRequest));
  ::fidl::DecodedMessage<EnableVsyncRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Controller::InPlace::EnableVsync(std::move(_client_end), std::move(_decoded_request)));
}

Controller::ResultOf::EnableVsync Controller::SyncClient::EnableVsync(bool enable) {
  return ResultOf::EnableVsync(zx::unowned_channel(this->channel_), std::move(enable));
}

Controller::ResultOf::EnableVsync Controller::Call::EnableVsync(zx::unowned_channel _client_end, bool enable) {
  return ResultOf::EnableVsync(std::move(_client_end), std::move(enable));
}


Controller::UnownedResultOf::EnableVsync_Impl::EnableVsync_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, bool enable) {
  if (_request_buffer.capacity() < EnableVsyncRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, EnableVsyncRequest::PrimarySize);
  auto& _request = *reinterpret_cast<EnableVsyncRequest*>(_request_buffer.data());
  _request.enable = std::move(enable);
  _request_buffer.set_actual(sizeof(EnableVsyncRequest));
  ::fidl::DecodedMessage<EnableVsyncRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Controller::InPlace::EnableVsync(std::move(_client_end), std::move(_decoded_request)));
}

Controller::UnownedResultOf::EnableVsync Controller::SyncClient::EnableVsync(::fidl::BytePart _request_buffer, bool enable) {
  return UnownedResultOf::EnableVsync(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(enable));
}

Controller::UnownedResultOf::EnableVsync Controller::Call::EnableVsync(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, bool enable) {
  return UnownedResultOf::EnableVsync(std::move(_client_end), std::move(_request_buffer), std::move(enable));
}

::fidl::internal::StatusAndError Controller::InPlace::EnableVsync(zx::unowned_channel _client_end, ::fidl::DecodedMessage<EnableVsyncRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_EnableVsync_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Controller::ResultOf::SetVirtconMode_Impl::SetVirtconMode_Impl(zx::unowned_channel _client_end, uint8_t mode) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetVirtconModeRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetVirtconModeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetVirtconModeRequest*>(_write_bytes);
  _request.mode = std::move(mode);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetVirtconModeRequest));
  ::fidl::DecodedMessage<SetVirtconModeRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Controller::InPlace::SetVirtconMode(std::move(_client_end), std::move(_decoded_request)));
}

Controller::ResultOf::SetVirtconMode Controller::SyncClient::SetVirtconMode(uint8_t mode) {
  return ResultOf::SetVirtconMode(zx::unowned_channel(this->channel_), std::move(mode));
}

Controller::ResultOf::SetVirtconMode Controller::Call::SetVirtconMode(zx::unowned_channel _client_end, uint8_t mode) {
  return ResultOf::SetVirtconMode(std::move(_client_end), std::move(mode));
}


Controller::UnownedResultOf::SetVirtconMode_Impl::SetVirtconMode_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint8_t mode) {
  if (_request_buffer.capacity() < SetVirtconModeRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, SetVirtconModeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetVirtconModeRequest*>(_request_buffer.data());
  _request.mode = std::move(mode);
  _request_buffer.set_actual(sizeof(SetVirtconModeRequest));
  ::fidl::DecodedMessage<SetVirtconModeRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Controller::InPlace::SetVirtconMode(std::move(_client_end), std::move(_decoded_request)));
}

Controller::UnownedResultOf::SetVirtconMode Controller::SyncClient::SetVirtconMode(::fidl::BytePart _request_buffer, uint8_t mode) {
  return UnownedResultOf::SetVirtconMode(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(mode));
}

Controller::UnownedResultOf::SetVirtconMode Controller::Call::SetVirtconMode(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint8_t mode) {
  return UnownedResultOf::SetVirtconMode(std::move(_client_end), std::move(_request_buffer), std::move(mode));
}

::fidl::internal::StatusAndError Controller::InPlace::SetVirtconMode(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetVirtconModeRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_SetVirtconMode_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
Controller::ResultOf::ComputeLinearImageStride_Impl<Controller::ComputeLinearImageStrideResponse>::ComputeLinearImageStride_Impl(zx::unowned_channel _client_end, uint32_t width, uint32_t pixel_format) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ComputeLinearImageStrideRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ComputeLinearImageStrideRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ComputeLinearImageStrideRequest*>(_write_bytes);
  _request.width = std::move(width);
  _request.pixel_format = std::move(pixel_format);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ComputeLinearImageStrideRequest));
  ::fidl::DecodedMessage<ComputeLinearImageStrideRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::ComputeLinearImageStride(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Controller::ResultOf::ComputeLinearImageStride Controller::SyncClient::ComputeLinearImageStride(uint32_t width, uint32_t pixel_format) {
  return ResultOf::ComputeLinearImageStride(zx::unowned_channel(this->channel_), std::move(width), std::move(pixel_format));
}

Controller::ResultOf::ComputeLinearImageStride Controller::Call::ComputeLinearImageStride(zx::unowned_channel _client_end, uint32_t width, uint32_t pixel_format) {
  return ResultOf::ComputeLinearImageStride(std::move(_client_end), std::move(width), std::move(pixel_format));
}

template <>
Controller::UnownedResultOf::ComputeLinearImageStride_Impl<Controller::ComputeLinearImageStrideResponse>::ComputeLinearImageStride_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t width, uint32_t pixel_format, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < ComputeLinearImageStrideRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<ComputeLinearImageStrideResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, ComputeLinearImageStrideRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ComputeLinearImageStrideRequest*>(_request_buffer.data());
  _request.width = std::move(width);
  _request.pixel_format = std::move(pixel_format);
  _request_buffer.set_actual(sizeof(ComputeLinearImageStrideRequest));
  ::fidl::DecodedMessage<ComputeLinearImageStrideRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::ComputeLinearImageStride(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Controller::UnownedResultOf::ComputeLinearImageStride Controller::SyncClient::ComputeLinearImageStride(::fidl::BytePart _request_buffer, uint32_t width, uint32_t pixel_format, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ComputeLinearImageStride(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(width), std::move(pixel_format), std::move(_response_buffer));
}

Controller::UnownedResultOf::ComputeLinearImageStride Controller::Call::ComputeLinearImageStride(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t width, uint32_t pixel_format, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ComputeLinearImageStride(std::move(_client_end), std::move(_request_buffer), std::move(width), std::move(pixel_format), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::ComputeLinearImageStrideResponse> Controller::InPlace::ComputeLinearImageStride(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ComputeLinearImageStrideRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_ComputeLinearImageStride_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::ComputeLinearImageStrideResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ComputeLinearImageStrideRequest, ComputeLinearImageStrideResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::ComputeLinearImageStrideResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::AllocateVmo_Impl<Controller::AllocateVmoResponse>::AllocateVmo_Impl(zx::unowned_channel _client_end, uint64_t size) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<AllocateVmoRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, AllocateVmoRequest::PrimarySize);
  auto& _request = *reinterpret_cast<AllocateVmoRequest*>(_write_bytes);
  _request.size = std::move(size);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(AllocateVmoRequest));
  ::fidl::DecodedMessage<AllocateVmoRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::AllocateVmo(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Controller::ResultOf::AllocateVmo Controller::SyncClient::AllocateVmo(uint64_t size) {
  return ResultOf::AllocateVmo(zx::unowned_channel(this->channel_), std::move(size));
}

Controller::ResultOf::AllocateVmo Controller::Call::AllocateVmo(zx::unowned_channel _client_end, uint64_t size) {
  return ResultOf::AllocateVmo(std::move(_client_end), std::move(size));
}

template <>
Controller::UnownedResultOf::AllocateVmo_Impl<Controller::AllocateVmoResponse>::AllocateVmo_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t size, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < AllocateVmoRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<AllocateVmoResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, AllocateVmoRequest::PrimarySize);
  auto& _request = *reinterpret_cast<AllocateVmoRequest*>(_request_buffer.data());
  _request.size = std::move(size);
  _request_buffer.set_actual(sizeof(AllocateVmoRequest));
  ::fidl::DecodedMessage<AllocateVmoRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::AllocateVmo(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Controller::UnownedResultOf::AllocateVmo Controller::SyncClient::AllocateVmo(::fidl::BytePart _request_buffer, uint64_t size, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::AllocateVmo(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(size), std::move(_response_buffer));
}

Controller::UnownedResultOf::AllocateVmo Controller::Call::AllocateVmo(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t size, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::AllocateVmo(std::move(_client_end), std::move(_request_buffer), std::move(size), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::AllocateVmoResponse> Controller::InPlace::AllocateVmo(zx::unowned_channel _client_end, ::fidl::DecodedMessage<AllocateVmoRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_AllocateVmo_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::AllocateVmoResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<AllocateVmoRequest, AllocateVmoResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::AllocateVmoResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::ImportBufferCollection_Impl<Controller::ImportBufferCollectionResponse>::ImportBufferCollection_Impl(zx::unowned_channel _client_end, uint64_t collection_id, ::zx::channel collection_token) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ImportBufferCollectionRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ImportBufferCollectionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ImportBufferCollectionRequest*>(_write_bytes);
  _request.collection_id = std::move(collection_id);
  _request.collection_token = std::move(collection_token);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ImportBufferCollectionRequest));
  ::fidl::DecodedMessage<ImportBufferCollectionRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::ImportBufferCollection(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Controller::ResultOf::ImportBufferCollection Controller::SyncClient::ImportBufferCollection(uint64_t collection_id, ::zx::channel collection_token) {
  return ResultOf::ImportBufferCollection(zx::unowned_channel(this->channel_), std::move(collection_id), std::move(collection_token));
}

Controller::ResultOf::ImportBufferCollection Controller::Call::ImportBufferCollection(zx::unowned_channel _client_end, uint64_t collection_id, ::zx::channel collection_token) {
  return ResultOf::ImportBufferCollection(std::move(_client_end), std::move(collection_id), std::move(collection_token));
}

template <>
Controller::UnownedResultOf::ImportBufferCollection_Impl<Controller::ImportBufferCollectionResponse>::ImportBufferCollection_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t collection_id, ::zx::channel collection_token, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < ImportBufferCollectionRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<ImportBufferCollectionResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, ImportBufferCollectionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ImportBufferCollectionRequest*>(_request_buffer.data());
  _request.collection_id = std::move(collection_id);
  _request.collection_token = std::move(collection_token);
  _request_buffer.set_actual(sizeof(ImportBufferCollectionRequest));
  ::fidl::DecodedMessage<ImportBufferCollectionRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::ImportBufferCollection(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Controller::UnownedResultOf::ImportBufferCollection Controller::SyncClient::ImportBufferCollection(::fidl::BytePart _request_buffer, uint64_t collection_id, ::zx::channel collection_token, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ImportBufferCollection(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(collection_id), std::move(collection_token), std::move(_response_buffer));
}

Controller::UnownedResultOf::ImportBufferCollection Controller::Call::ImportBufferCollection(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t collection_id, ::zx::channel collection_token, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ImportBufferCollection(std::move(_client_end), std::move(_request_buffer), std::move(collection_id), std::move(collection_token), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::ImportBufferCollectionResponse> Controller::InPlace::ImportBufferCollection(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ImportBufferCollectionRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_ImportBufferCollection_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::ImportBufferCollectionResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ImportBufferCollectionRequest, ImportBufferCollectionResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::ImportBufferCollectionResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


Controller::ResultOf::ReleaseBufferCollection_Impl::ReleaseBufferCollection_Impl(zx::unowned_channel _client_end, uint64_t collection_id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReleaseBufferCollectionRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ReleaseBufferCollectionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReleaseBufferCollectionRequest*>(_write_bytes);
  _request.collection_id = std::move(collection_id);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ReleaseBufferCollectionRequest));
  ::fidl::DecodedMessage<ReleaseBufferCollectionRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Controller::InPlace::ReleaseBufferCollection(std::move(_client_end), std::move(_decoded_request)));
}

Controller::ResultOf::ReleaseBufferCollection Controller::SyncClient::ReleaseBufferCollection(uint64_t collection_id) {
  return ResultOf::ReleaseBufferCollection(zx::unowned_channel(this->channel_), std::move(collection_id));
}

Controller::ResultOf::ReleaseBufferCollection Controller::Call::ReleaseBufferCollection(zx::unowned_channel _client_end, uint64_t collection_id) {
  return ResultOf::ReleaseBufferCollection(std::move(_client_end), std::move(collection_id));
}


Controller::UnownedResultOf::ReleaseBufferCollection_Impl::ReleaseBufferCollection_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t collection_id) {
  if (_request_buffer.capacity() < ReleaseBufferCollectionRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, ReleaseBufferCollectionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReleaseBufferCollectionRequest*>(_request_buffer.data());
  _request.collection_id = std::move(collection_id);
  _request_buffer.set_actual(sizeof(ReleaseBufferCollectionRequest));
  ::fidl::DecodedMessage<ReleaseBufferCollectionRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Controller::InPlace::ReleaseBufferCollection(std::move(_client_end), std::move(_decoded_request)));
}

Controller::UnownedResultOf::ReleaseBufferCollection Controller::SyncClient::ReleaseBufferCollection(::fidl::BytePart _request_buffer, uint64_t collection_id) {
  return UnownedResultOf::ReleaseBufferCollection(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(collection_id));
}

Controller::UnownedResultOf::ReleaseBufferCollection Controller::Call::ReleaseBufferCollection(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t collection_id) {
  return UnownedResultOf::ReleaseBufferCollection(std::move(_client_end), std::move(_request_buffer), std::move(collection_id));
}

::fidl::internal::StatusAndError Controller::InPlace::ReleaseBufferCollection(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReleaseBufferCollectionRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_ReleaseBufferCollection_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
Controller::ResultOf::SetBufferCollectionConstraints_Impl<Controller::SetBufferCollectionConstraintsResponse>::SetBufferCollectionConstraints_Impl(zx::unowned_channel _client_end, uint64_t collection_id, ImageConfig config) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetBufferCollectionConstraintsRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetBufferCollectionConstraintsRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetBufferCollectionConstraintsRequest*>(_write_bytes);
  _request.collection_id = std::move(collection_id);
  _request.config = std::move(config);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetBufferCollectionConstraintsRequest));
  ::fidl::DecodedMessage<SetBufferCollectionConstraintsRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::SetBufferCollectionConstraints(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Controller::ResultOf::SetBufferCollectionConstraints Controller::SyncClient::SetBufferCollectionConstraints(uint64_t collection_id, ImageConfig config) {
  return ResultOf::SetBufferCollectionConstraints(zx::unowned_channel(this->channel_), std::move(collection_id), std::move(config));
}

Controller::ResultOf::SetBufferCollectionConstraints Controller::Call::SetBufferCollectionConstraints(zx::unowned_channel _client_end, uint64_t collection_id, ImageConfig config) {
  return ResultOf::SetBufferCollectionConstraints(std::move(_client_end), std::move(collection_id), std::move(config));
}

template <>
Controller::UnownedResultOf::SetBufferCollectionConstraints_Impl<Controller::SetBufferCollectionConstraintsResponse>::SetBufferCollectionConstraints_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t collection_id, ImageConfig config, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < SetBufferCollectionConstraintsRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<SetBufferCollectionConstraintsResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, SetBufferCollectionConstraintsRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetBufferCollectionConstraintsRequest*>(_request_buffer.data());
  _request.collection_id = std::move(collection_id);
  _request.config = std::move(config);
  _request_buffer.set_actual(sizeof(SetBufferCollectionConstraintsRequest));
  ::fidl::DecodedMessage<SetBufferCollectionConstraintsRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::SetBufferCollectionConstraints(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Controller::UnownedResultOf::SetBufferCollectionConstraints Controller::SyncClient::SetBufferCollectionConstraints(::fidl::BytePart _request_buffer, uint64_t collection_id, ImageConfig config, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetBufferCollectionConstraints(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(collection_id), std::move(config), std::move(_response_buffer));
}

Controller::UnownedResultOf::SetBufferCollectionConstraints Controller::Call::SetBufferCollectionConstraints(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t collection_id, ImageConfig config, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetBufferCollectionConstraints(std::move(_client_end), std::move(_request_buffer), std::move(collection_id), std::move(config), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::SetBufferCollectionConstraintsResponse> Controller::InPlace::SetBufferCollectionConstraints(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetBufferCollectionConstraintsRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_SetBufferCollectionConstraints_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::SetBufferCollectionConstraintsResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SetBufferCollectionConstraintsRequest, SetBufferCollectionConstraintsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::SetBufferCollectionConstraintsResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::GetSingleBufferFramebuffer_Impl<Controller::GetSingleBufferFramebufferResponse>::GetSingleBufferFramebuffer_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetSingleBufferFramebufferRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetSingleBufferFramebufferRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetSingleBufferFramebufferRequest));
  ::fidl::DecodedMessage<GetSingleBufferFramebufferRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::GetSingleBufferFramebuffer(std::move(_client_end), Super::response_buffer()));
}

Controller::ResultOf::GetSingleBufferFramebuffer Controller::SyncClient::GetSingleBufferFramebuffer() {
  return ResultOf::GetSingleBufferFramebuffer(zx::unowned_channel(this->channel_));
}

Controller::ResultOf::GetSingleBufferFramebuffer Controller::Call::GetSingleBufferFramebuffer(zx::unowned_channel _client_end) {
  return ResultOf::GetSingleBufferFramebuffer(std::move(_client_end));
}

template <>
Controller::UnownedResultOf::GetSingleBufferFramebuffer_Impl<Controller::GetSingleBufferFramebufferResponse>::GetSingleBufferFramebuffer_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetSingleBufferFramebufferRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetSingleBufferFramebufferRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetSingleBufferFramebufferRequest));
  ::fidl::DecodedMessage<GetSingleBufferFramebufferRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::GetSingleBufferFramebuffer(std::move(_client_end), std::move(_response_buffer)));
}

Controller::UnownedResultOf::GetSingleBufferFramebuffer Controller::SyncClient::GetSingleBufferFramebuffer(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetSingleBufferFramebuffer(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Controller::UnownedResultOf::GetSingleBufferFramebuffer Controller::Call::GetSingleBufferFramebuffer(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetSingleBufferFramebuffer(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::GetSingleBufferFramebufferResponse> Controller::InPlace::GetSingleBufferFramebuffer(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetSingleBufferFramebufferRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetSingleBufferFramebufferRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_GetSingleBufferFramebuffer_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetSingleBufferFramebufferResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetSingleBufferFramebufferRequest, GetSingleBufferFramebufferResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetSingleBufferFramebufferResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::ImportImageForCapture_Impl<Controller::ImportImageForCaptureResponse>::ImportImageForCapture_Impl(zx::unowned_channel _client_end, ImageConfig image_config, uint64_t collection_id, uint32_t index) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ImportImageForCaptureRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ImportImageForCaptureRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ImportImageForCaptureRequest*>(_write_bytes);
  _request.image_config = std::move(image_config);
  _request.collection_id = std::move(collection_id);
  _request.index = std::move(index);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ImportImageForCaptureRequest));
  ::fidl::DecodedMessage<ImportImageForCaptureRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::ImportImageForCapture(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Controller::ResultOf::ImportImageForCapture Controller::SyncClient::ImportImageForCapture(ImageConfig image_config, uint64_t collection_id, uint32_t index) {
  return ResultOf::ImportImageForCapture(zx::unowned_channel(this->channel_), std::move(image_config), std::move(collection_id), std::move(index));
}

Controller::ResultOf::ImportImageForCapture Controller::Call::ImportImageForCapture(zx::unowned_channel _client_end, ImageConfig image_config, uint64_t collection_id, uint32_t index) {
  return ResultOf::ImportImageForCapture(std::move(_client_end), std::move(image_config), std::move(collection_id), std::move(index));
}

template <>
Controller::UnownedResultOf::ImportImageForCapture_Impl<Controller::ImportImageForCaptureResponse>::ImportImageForCapture_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ImageConfig image_config, uint64_t collection_id, uint32_t index, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < ImportImageForCaptureRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<ImportImageForCaptureResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, ImportImageForCaptureRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ImportImageForCaptureRequest*>(_request_buffer.data());
  _request.image_config = std::move(image_config);
  _request.collection_id = std::move(collection_id);
  _request.index = std::move(index);
  _request_buffer.set_actual(sizeof(ImportImageForCaptureRequest));
  ::fidl::DecodedMessage<ImportImageForCaptureRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::ImportImageForCapture(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Controller::UnownedResultOf::ImportImageForCapture Controller::SyncClient::ImportImageForCapture(::fidl::BytePart _request_buffer, ImageConfig image_config, uint64_t collection_id, uint32_t index, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ImportImageForCapture(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(image_config), std::move(collection_id), std::move(index), std::move(_response_buffer));
}

Controller::UnownedResultOf::ImportImageForCapture Controller::Call::ImportImageForCapture(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ImageConfig image_config, uint64_t collection_id, uint32_t index, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ImportImageForCapture(std::move(_client_end), std::move(_request_buffer), std::move(image_config), std::move(collection_id), std::move(index), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::ImportImageForCaptureResponse> Controller::InPlace::ImportImageForCapture(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ImportImageForCaptureRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_ImportImageForCapture_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::ImportImageForCaptureResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ImportImageForCaptureRequest, ImportImageForCaptureResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::ImportImageForCaptureResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::StartCapture_Impl<Controller::StartCaptureResponse>::StartCapture_Impl(zx::unowned_channel _client_end, uint64_t signal_event_id, uint64_t image_id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<StartCaptureRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, StartCaptureRequest::PrimarySize);
  auto& _request = *reinterpret_cast<StartCaptureRequest*>(_write_bytes);
  _request.signal_event_id = std::move(signal_event_id);
  _request.image_id = std::move(image_id);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(StartCaptureRequest));
  ::fidl::DecodedMessage<StartCaptureRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::StartCapture(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Controller::ResultOf::StartCapture Controller::SyncClient::StartCapture(uint64_t signal_event_id, uint64_t image_id) {
  return ResultOf::StartCapture(zx::unowned_channel(this->channel_), std::move(signal_event_id), std::move(image_id));
}

Controller::ResultOf::StartCapture Controller::Call::StartCapture(zx::unowned_channel _client_end, uint64_t signal_event_id, uint64_t image_id) {
  return ResultOf::StartCapture(std::move(_client_end), std::move(signal_event_id), std::move(image_id));
}

template <>
Controller::UnownedResultOf::StartCapture_Impl<Controller::StartCaptureResponse>::StartCapture_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t signal_event_id, uint64_t image_id, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < StartCaptureRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<StartCaptureResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, StartCaptureRequest::PrimarySize);
  auto& _request = *reinterpret_cast<StartCaptureRequest*>(_request_buffer.data());
  _request.signal_event_id = std::move(signal_event_id);
  _request.image_id = std::move(image_id);
  _request_buffer.set_actual(sizeof(StartCaptureRequest));
  ::fidl::DecodedMessage<StartCaptureRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::StartCapture(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Controller::UnownedResultOf::StartCapture Controller::SyncClient::StartCapture(::fidl::BytePart _request_buffer, uint64_t signal_event_id, uint64_t image_id, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::StartCapture(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(signal_event_id), std::move(image_id), std::move(_response_buffer));
}

Controller::UnownedResultOf::StartCapture Controller::Call::StartCapture(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t signal_event_id, uint64_t image_id, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::StartCapture(std::move(_client_end), std::move(_request_buffer), std::move(signal_event_id), std::move(image_id), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::StartCaptureResponse> Controller::InPlace::StartCapture(zx::unowned_channel _client_end, ::fidl::DecodedMessage<StartCaptureRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_StartCapture_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::StartCaptureResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<StartCaptureRequest, StartCaptureResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::StartCaptureResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::ReleaseCapture_Impl<Controller::ReleaseCaptureResponse>::ReleaseCapture_Impl(zx::unowned_channel _client_end, uint64_t image_id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReleaseCaptureRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ReleaseCaptureRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReleaseCaptureRequest*>(_write_bytes);
  _request.image_id = std::move(image_id);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ReleaseCaptureRequest));
  ::fidl::DecodedMessage<ReleaseCaptureRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::ReleaseCapture(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Controller::ResultOf::ReleaseCapture Controller::SyncClient::ReleaseCapture(uint64_t image_id) {
  return ResultOf::ReleaseCapture(zx::unowned_channel(this->channel_), std::move(image_id));
}

Controller::ResultOf::ReleaseCapture Controller::Call::ReleaseCapture(zx::unowned_channel _client_end, uint64_t image_id) {
  return ResultOf::ReleaseCapture(std::move(_client_end), std::move(image_id));
}

template <>
Controller::UnownedResultOf::ReleaseCapture_Impl<Controller::ReleaseCaptureResponse>::ReleaseCapture_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t image_id, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < ReleaseCaptureRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<ReleaseCaptureResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, ReleaseCaptureRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReleaseCaptureRequest*>(_request_buffer.data());
  _request.image_id = std::move(image_id);
  _request_buffer.set_actual(sizeof(ReleaseCaptureRequest));
  ::fidl::DecodedMessage<ReleaseCaptureRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::ReleaseCapture(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Controller::UnownedResultOf::ReleaseCapture Controller::SyncClient::ReleaseCapture(::fidl::BytePart _request_buffer, uint64_t image_id, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ReleaseCapture(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(image_id), std::move(_response_buffer));
}

Controller::UnownedResultOf::ReleaseCapture Controller::Call::ReleaseCapture(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t image_id, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ReleaseCapture(std::move(_client_end), std::move(_request_buffer), std::move(image_id), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::ReleaseCaptureResponse> Controller::InPlace::ReleaseCapture(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReleaseCaptureRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_ReleaseCapture_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::ReleaseCaptureResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ReleaseCaptureRequest, ReleaseCaptureResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::ReleaseCaptureResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

zx_status_t Controller::SyncClient::HandleEvents(Controller::EventHandlers handlers) {
  return Controller::Call::HandleEvents(zx::unowned_channel(channel_), std::move(handlers));
}

zx_status_t Controller::Call::HandleEvents(zx::unowned_channel client_end,
                                            Controller::EventHandlers handlers) {
  zx_status_t status = client_end->wait_one(ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED,
                                            zx::time::infinite(),
                                            nullptr);
  if (status != ZX_OK) {
    return status;
  }
  constexpr uint32_t kReadAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::internal::ClampedMessageSize<DisplaysChangedResponse, ::fidl::MessageDirection::kReceiving>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<DisplaysChangedResponse, ::fidl::MessageDirection::kReceiving>();
    }
    if (::fidl::internal::ClampedMessageSize<VsyncResponse, ::fidl::MessageDirection::kReceiving>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<VsyncResponse, ::fidl::MessageDirection::kReceiving>();
    }
    if (::fidl::internal::ClampedMessageSize<ClientOwnershipChangeResponse, ::fidl::MessageDirection::kReceiving>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<ClientOwnershipChangeResponse, ::fidl::MessageDirection::kReceiving>();
    }
    return x;
  })();
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (DisplaysChangedResponse::MaxNumHandles >= x) {
      x = DisplaysChangedResponse::MaxNumHandles;
    }
    if (VsyncResponse::MaxNumHandles >= x) {
      x = VsyncResponse::MaxNumHandles;
    }
    if (ClientOwnershipChangeResponse::MaxNumHandles >= x) {
      x = ClientOwnershipChangeResponse::MaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  std::unique_ptr<uint8_t[]> read_bytes_unique_ptr(new uint8_t[kReadAllocSize]);
  uint8_t* read_bytes = read_bytes_unique_ptr.get();
  zx_handle_t read_handles[kHandleAllocSize];
  uint32_t actual_bytes;
  uint32_t actual_handles;
  status = client_end->read(ZX_CHANNEL_READ_MAY_DISCARD,
                            read_bytes, read_handles,
                            kReadAllocSize, kHandleAllocSize,
                            &actual_bytes, &actual_handles);
  if (status == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new event,
    // whose size exceeds the maximum of known events in the current protocol.
    return handlers.unknown();
  }
  if (status != ZX_OK) {
    return status;
  }
  if (actual_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(read_handles, actual_handles);
    return ZX_ERR_INVALID_ARGS;
  }
  auto msg = fidl_msg_t {
    .bytes = read_bytes,
    .handles = read_handles,
    .num_bytes = actual_bytes,
    .num_handles = actual_handles
  };
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg.bytes);
  switch (hdr->ordinal) {
    case kController_DisplaysChanged_Ordinal:
    case kController_DisplaysChanged_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<DisplaysChangedResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      auto message = result.message.message();
      return handlers.displays_changed(std::move(message->added), std::move(message->removed));
    }
    case kController_Vsync_Ordinal:
    case kController_Vsync_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<VsyncResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      auto message = result.message.message();
      return handlers.vsync(std::move(message->display_id), std::move(message->timestamp), std::move(message->images));
    }
    case kController_ClientOwnershipChange_Ordinal:
    case kController_ClientOwnershipChange_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ClientOwnershipChangeResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      auto message = result.message.message();
      return handlers.client_ownership_change(std::move(message->has_ownership));
    }
    default:
      zx_handle_close_many(read_handles, actual_handles);
      return handlers.unknown();
  }
}

bool Controller::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kController_ImportVmoImage_Ordinal:
    case kController_ImportVmoImage_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ImportVmoImageRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->ImportVmoImage(std::move(message->image_config), std::move(message->vmo), std::move(message->offset),
        Interface::ImportVmoImageCompleter::Sync(txn));
      return true;
    }
    case kController_ImportImage_Ordinal:
    case kController_ImportImage_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ImportImageRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->ImportImage(std::move(message->image_config), std::move(message->collection_id), std::move(message->index),
        Interface::ImportImageCompleter::Sync(txn));
      return true;
    }
    case kController_ReleaseImage_Ordinal:
    case kController_ReleaseImage_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ReleaseImageRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->ReleaseImage(std::move(message->image_id),
        Interface::ReleaseImageCompleter::Sync(txn));
      return true;
    }
    case kController_ImportEvent_Ordinal:
    case kController_ImportEvent_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ImportEventRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->ImportEvent(std::move(message->event), std::move(message->id),
        Interface::ImportEventCompleter::Sync(txn));
      return true;
    }
    case kController_ReleaseEvent_Ordinal:
    case kController_ReleaseEvent_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ReleaseEventRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->ReleaseEvent(std::move(message->id),
        Interface::ReleaseEventCompleter::Sync(txn));
      return true;
    }
    case kController_CreateLayer_Ordinal:
    case kController_CreateLayer_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<CreateLayerRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->CreateLayer(
        Interface::CreateLayerCompleter::Sync(txn));
      return true;
    }
    case kController_DestroyLayer_Ordinal:
    case kController_DestroyLayer_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<DestroyLayerRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->DestroyLayer(std::move(message->layer_id),
        Interface::DestroyLayerCompleter::Sync(txn));
      return true;
    }
    case kController_SetDisplayMode_Ordinal:
    case kController_SetDisplayMode_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetDisplayModeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetDisplayMode(std::move(message->display_id), std::move(message->mode),
        Interface::SetDisplayModeCompleter::Sync(txn));
      return true;
    }
    case kController_SetDisplayColorConversion_Ordinal:
    case kController_SetDisplayColorConversion_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetDisplayColorConversionRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetDisplayColorConversion(std::move(message->display_id), std::move(message->preoffsets), std::move(message->coefficients), std::move(message->postoffsets),
        Interface::SetDisplayColorConversionCompleter::Sync(txn));
      return true;
    }
    case kController_SetDisplayLayers_Ordinal:
    case kController_SetDisplayLayers_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetDisplayLayersRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetDisplayLayers(std::move(message->display_id), std::move(message->layer_ids),
        Interface::SetDisplayLayersCompleter::Sync(txn));
      return true;
    }
    case kController_SetLayerPrimaryConfig_Ordinal:
    case kController_SetLayerPrimaryConfig_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetLayerPrimaryConfigRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetLayerPrimaryConfig(std::move(message->layer_id), std::move(message->image_config),
        Interface::SetLayerPrimaryConfigCompleter::Sync(txn));
      return true;
    }
    case kController_SetLayerPrimaryPosition_Ordinal:
    case kController_SetLayerPrimaryPosition_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetLayerPrimaryPositionRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetLayerPrimaryPosition(std::move(message->layer_id), std::move(message->transform), std::move(message->src_frame), std::move(message->dest_frame),
        Interface::SetLayerPrimaryPositionCompleter::Sync(txn));
      return true;
    }
    case kController_SetLayerPrimaryAlpha_Ordinal:
    case kController_SetLayerPrimaryAlpha_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetLayerPrimaryAlphaRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetLayerPrimaryAlpha(std::move(message->layer_id), std::move(message->mode), std::move(message->val),
        Interface::SetLayerPrimaryAlphaCompleter::Sync(txn));
      return true;
    }
    case kController_SetLayerCursorConfig_Ordinal:
    case kController_SetLayerCursorConfig_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetLayerCursorConfigRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetLayerCursorConfig(std::move(message->layer_id), std::move(message->image_config),
        Interface::SetLayerCursorConfigCompleter::Sync(txn));
      return true;
    }
    case kController_SetLayerCursorPosition_Ordinal:
    case kController_SetLayerCursorPosition_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetLayerCursorPositionRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetLayerCursorPosition(std::move(message->layer_id), std::move(message->x), std::move(message->y),
        Interface::SetLayerCursorPositionCompleter::Sync(txn));
      return true;
    }
    case kController_SetLayerColorConfig_Ordinal:
    case kController_SetLayerColorConfig_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetLayerColorConfigRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetLayerColorConfig(std::move(message->layer_id), std::move(message->pixel_format), std::move(message->color_bytes),
        Interface::SetLayerColorConfigCompleter::Sync(txn));
      return true;
    }
    case kController_SetLayerImage_Ordinal:
    case kController_SetLayerImage_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetLayerImageRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetLayerImage(std::move(message->layer_id), std::move(message->image_id), std::move(message->wait_event_id), std::move(message->signal_event_id),
        Interface::SetLayerImageCompleter::Sync(txn));
      return true;
    }
    case kController_CheckConfig_Ordinal:
    case kController_CheckConfig_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<CheckConfigRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->CheckConfig(std::move(message->discard),
        Interface::CheckConfigCompleter::Sync(txn));
      return true;
    }
    case kController_ApplyConfig_Ordinal:
    case kController_ApplyConfig_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ApplyConfigRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->ApplyConfig(
        Interface::ApplyConfigCompleter::Sync(txn));
      return true;
    }
    case kController_EnableVsync_Ordinal:
    case kController_EnableVsync_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<EnableVsyncRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->EnableVsync(std::move(message->enable),
        Interface::EnableVsyncCompleter::Sync(txn));
      return true;
    }
    case kController_SetVirtconMode_Ordinal:
    case kController_SetVirtconMode_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetVirtconModeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetVirtconMode(std::move(message->mode),
        Interface::SetVirtconModeCompleter::Sync(txn));
      return true;
    }
    case kController_ComputeLinearImageStride_Ordinal:
    case kController_ComputeLinearImageStride_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ComputeLinearImageStrideRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->ComputeLinearImageStride(std::move(message->width), std::move(message->pixel_format),
        Interface::ComputeLinearImageStrideCompleter::Sync(txn));
      return true;
    }
    case kController_AllocateVmo_Ordinal:
    case kController_AllocateVmo_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<AllocateVmoRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->AllocateVmo(std::move(message->size),
        Interface::AllocateVmoCompleter::Sync(txn));
      return true;
    }
    case kController_ImportBufferCollection_Ordinal:
    case kController_ImportBufferCollection_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ImportBufferCollectionRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->ImportBufferCollection(std::move(message->collection_id), std::move(message->collection_token),
        Interface::ImportBufferCollectionCompleter::Sync(txn));
      return true;
    }
    case kController_ReleaseBufferCollection_Ordinal:
    case kController_ReleaseBufferCollection_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ReleaseBufferCollectionRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->ReleaseBufferCollection(std::move(message->collection_id),
        Interface::ReleaseBufferCollectionCompleter::Sync(txn));
      return true;
    }
    case kController_SetBufferCollectionConstraints_Ordinal:
    case kController_SetBufferCollectionConstraints_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetBufferCollectionConstraintsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetBufferCollectionConstraints(std::move(message->collection_id), std::move(message->config),
        Interface::SetBufferCollectionConstraintsCompleter::Sync(txn));
      return true;
    }
    case kController_GetSingleBufferFramebuffer_Ordinal:
    case kController_GetSingleBufferFramebuffer_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetSingleBufferFramebufferRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetSingleBufferFramebuffer(
        Interface::GetSingleBufferFramebufferCompleter::Sync(txn));
      return true;
    }
    case kController_ImportImageForCapture_Ordinal:
    case kController_ImportImageForCapture_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ImportImageForCaptureRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->ImportImageForCapture(std::move(message->image_config), std::move(message->collection_id), std::move(message->index),
        Interface::ImportImageForCaptureCompleter::Sync(txn));
      return true;
    }
    case kController_StartCapture_Ordinal:
    case kController_StartCapture_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<StartCaptureRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->StartCapture(std::move(message->signal_event_id), std::move(message->image_id),
        Interface::StartCaptureCompleter::Sync(txn));
      return true;
    }
    case kController_ReleaseCapture_Ordinal:
    case kController_ReleaseCapture_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ReleaseCaptureRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->ReleaseCapture(std::move(message->image_id),
        Interface::ReleaseCaptureCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Controller::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


zx_status_t Controller::SendDisplaysChangedEvent(::zx::unowned_channel _chan, ::fidl::VectorView<Info> added, ::fidl::VectorView<uint64_t> removed) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DisplaysChangedResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  DisplaysChangedResponse _response = {};
  _response._hdr = {};
  _response._hdr.ordinal = kController_DisplaysChanged_Ordinal;
  _response.added = std::move(added);
  _response.removed = std::move(removed);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t Controller::SendDisplaysChangedEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, ::fidl::VectorView<Info> added, ::fidl::VectorView<uint64_t> removed) {
  if (_buffer.capacity() < DisplaysChangedResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  DisplaysChangedResponse _response = {};
  _response._hdr = {};
  _response._hdr.ordinal = kController_DisplaysChanged_Ordinal;
  _response.added = std::move(added);
  _response.removed = std::move(removed);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
	return _linearize_result.status;
  }
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t Controller::SendDisplaysChangedEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<DisplaysChangedResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_DisplaysChanged_Ordinal;
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(params));
}


void Controller::Interface::ImportVmoImageCompleterBase::Reply(int32_t res, uint64_t image_id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ImportVmoImageResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<ImportVmoImageResponse*>(_write_bytes);
  _response._hdr.ordinal = kController_ImportVmoImage_Ordinal;
  _response.res = std::move(res);
  _response.image_id = std::move(image_id);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(ImportVmoImageResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ImportVmoImageResponse>(std::move(_response_bytes)));
}

void Controller::Interface::ImportVmoImageCompleterBase::Reply(::fidl::BytePart _buffer, int32_t res, uint64_t image_id) {
  if (_buffer.capacity() < ImportVmoImageResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<ImportVmoImageResponse*>(_buffer.data());
  _response._hdr.ordinal = kController_ImportVmoImage_Ordinal;
  _response.res = std::move(res);
  _response.image_id = std::move(image_id);
  _buffer.set_actual(sizeof(ImportVmoImageResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ImportVmoImageResponse>(std::move(_buffer)));
}

void Controller::Interface::ImportVmoImageCompleterBase::Reply(::fidl::DecodedMessage<ImportVmoImageResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_ImportVmoImage_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::ImportImageCompleterBase::Reply(int32_t res, uint64_t image_id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ImportImageResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<ImportImageResponse*>(_write_bytes);
  _response._hdr.ordinal = kController_ImportImage_Ordinal;
  _response.res = std::move(res);
  _response.image_id = std::move(image_id);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(ImportImageResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ImportImageResponse>(std::move(_response_bytes)));
}

void Controller::Interface::ImportImageCompleterBase::Reply(::fidl::BytePart _buffer, int32_t res, uint64_t image_id) {
  if (_buffer.capacity() < ImportImageResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<ImportImageResponse*>(_buffer.data());
  _response._hdr.ordinal = kController_ImportImage_Ordinal;
  _response.res = std::move(res);
  _response.image_id = std::move(image_id);
  _buffer.set_actual(sizeof(ImportImageResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ImportImageResponse>(std::move(_buffer)));
}

void Controller::Interface::ImportImageCompleterBase::Reply(::fidl::DecodedMessage<ImportImageResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_ImportImage_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::CreateLayerCompleterBase::Reply(int32_t res, uint64_t layer_id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CreateLayerResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<CreateLayerResponse*>(_write_bytes);
  _response._hdr.ordinal = kController_CreateLayer_Ordinal;
  _response.res = std::move(res);
  _response.layer_id = std::move(layer_id);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(CreateLayerResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CreateLayerResponse>(std::move(_response_bytes)));
}

void Controller::Interface::CreateLayerCompleterBase::Reply(::fidl::BytePart _buffer, int32_t res, uint64_t layer_id) {
  if (_buffer.capacity() < CreateLayerResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<CreateLayerResponse*>(_buffer.data());
  _response._hdr.ordinal = kController_CreateLayer_Ordinal;
  _response.res = std::move(res);
  _response.layer_id = std::move(layer_id);
  _buffer.set_actual(sizeof(CreateLayerResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CreateLayerResponse>(std::move(_buffer)));
}

void Controller::Interface::CreateLayerCompleterBase::Reply(::fidl::DecodedMessage<CreateLayerResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_CreateLayer_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::CheckConfigCompleterBase::Reply(ConfigResult res, ::fidl::VectorView<ClientCompositionOp> ops) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CheckConfigResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  CheckConfigResponse _response = {};
  _response._hdr.ordinal = kController_CheckConfig_Ordinal;
  _response.res = std::move(res);
  _response.ops = std::move(ops);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Controller::Interface::CheckConfigCompleterBase::Reply(::fidl::BytePart _buffer, ConfigResult res, ::fidl::VectorView<ClientCompositionOp> ops) {
  if (_buffer.capacity() < CheckConfigResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CheckConfigResponse _response = {};
  _response._hdr.ordinal = kController_CheckConfig_Ordinal;
  _response.res = std::move(res);
  _response.ops = std::move(ops);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Controller::Interface::CheckConfigCompleterBase::Reply(::fidl::DecodedMessage<CheckConfigResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_CheckConfig_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


zx_status_t Controller::SendVsyncEvent(::zx::unowned_channel _chan, uint64_t display_id, uint64_t timestamp, ::fidl::VectorView<uint64_t> images) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<VsyncResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  VsyncResponse _response = {};
  _response._hdr = {};
  _response._hdr.ordinal = kController_Vsync_Ordinal;
  _response.display_id = std::move(display_id);
  _response.timestamp = std::move(timestamp);
  _response.images = std::move(images);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t Controller::SendVsyncEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, uint64_t display_id, uint64_t timestamp, ::fidl::VectorView<uint64_t> images) {
  if (_buffer.capacity() < VsyncResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  VsyncResponse _response = {};
  _response._hdr = {};
  _response._hdr.ordinal = kController_Vsync_Ordinal;
  _response.display_id = std::move(display_id);
  _response.timestamp = std::move(timestamp);
  _response.images = std::move(images);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
	return _linearize_result.status;
  }
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t Controller::SendVsyncEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<VsyncResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_Vsync_Ordinal;
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(params));
}


zx_status_t Controller::SendClientOwnershipChangeEvent(::zx::unowned_channel _chan, bool has_ownership) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ClientOwnershipChangeResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<ClientOwnershipChangeResponse*>(_write_bytes);
  _response._hdr = {};
  _response._hdr.ordinal = kController_ClientOwnershipChange_Ordinal;
  _response.has_ownership = std::move(has_ownership);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(ClientOwnershipChangeResponse));
  return ::fidl::Write(zx::unowned_channel(_chan), ::fidl::DecodedMessage<ClientOwnershipChangeResponse>(std::move(_response_bytes)));
}

zx_status_t Controller::SendClientOwnershipChangeEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, bool has_ownership) {
  if (_buffer.capacity() < ClientOwnershipChangeResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  auto& _response = *reinterpret_cast<ClientOwnershipChangeResponse*>(_buffer.data());
  _response._hdr = {};
  _response._hdr.ordinal = kController_ClientOwnershipChange_Ordinal;
  _response.has_ownership = std::move(has_ownership);
  _buffer.set_actual(sizeof(ClientOwnershipChangeResponse));
  return ::fidl::Write(zx::unowned_channel(_chan), ::fidl::DecodedMessage<ClientOwnershipChangeResponse>(std::move(_buffer)));
}

zx_status_t Controller::SendClientOwnershipChangeEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<ClientOwnershipChangeResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_ClientOwnershipChange_Ordinal;
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(params));
}


void Controller::Interface::ComputeLinearImageStrideCompleterBase::Reply(uint32_t stride) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ComputeLinearImageStrideResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<ComputeLinearImageStrideResponse*>(_write_bytes);
  _response._hdr.ordinal = kController_ComputeLinearImageStride_Ordinal;
  _response.stride = std::move(stride);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(ComputeLinearImageStrideResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ComputeLinearImageStrideResponse>(std::move(_response_bytes)));
}

void Controller::Interface::ComputeLinearImageStrideCompleterBase::Reply(::fidl::BytePart _buffer, uint32_t stride) {
  if (_buffer.capacity() < ComputeLinearImageStrideResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<ComputeLinearImageStrideResponse*>(_buffer.data());
  _response._hdr.ordinal = kController_ComputeLinearImageStride_Ordinal;
  _response.stride = std::move(stride);
  _buffer.set_actual(sizeof(ComputeLinearImageStrideResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ComputeLinearImageStrideResponse>(std::move(_buffer)));
}

void Controller::Interface::ComputeLinearImageStrideCompleterBase::Reply(::fidl::DecodedMessage<ComputeLinearImageStrideResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_ComputeLinearImageStride_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::AllocateVmoCompleterBase::Reply(int32_t res, ::zx::vmo vmo) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<AllocateVmoResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<AllocateVmoResponse*>(_write_bytes);
  _response._hdr.ordinal = kController_AllocateVmo_Ordinal;
  _response.res = std::move(res);
  _response.vmo = std::move(vmo);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(AllocateVmoResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<AllocateVmoResponse>(std::move(_response_bytes)));
}

void Controller::Interface::AllocateVmoCompleterBase::Reply(::fidl::BytePart _buffer, int32_t res, ::zx::vmo vmo) {
  if (_buffer.capacity() < AllocateVmoResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<AllocateVmoResponse*>(_buffer.data());
  _response._hdr.ordinal = kController_AllocateVmo_Ordinal;
  _response.res = std::move(res);
  _response.vmo = std::move(vmo);
  _buffer.set_actual(sizeof(AllocateVmoResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<AllocateVmoResponse>(std::move(_buffer)));
}

void Controller::Interface::AllocateVmoCompleterBase::Reply(::fidl::DecodedMessage<AllocateVmoResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_AllocateVmo_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::ImportBufferCollectionCompleterBase::Reply(int32_t res) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ImportBufferCollectionResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<ImportBufferCollectionResponse*>(_write_bytes);
  _response._hdr.ordinal = kController_ImportBufferCollection_Ordinal;
  _response.res = std::move(res);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(ImportBufferCollectionResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ImportBufferCollectionResponse>(std::move(_response_bytes)));
}

void Controller::Interface::ImportBufferCollectionCompleterBase::Reply(::fidl::BytePart _buffer, int32_t res) {
  if (_buffer.capacity() < ImportBufferCollectionResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<ImportBufferCollectionResponse*>(_buffer.data());
  _response._hdr.ordinal = kController_ImportBufferCollection_Ordinal;
  _response.res = std::move(res);
  _buffer.set_actual(sizeof(ImportBufferCollectionResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ImportBufferCollectionResponse>(std::move(_buffer)));
}

void Controller::Interface::ImportBufferCollectionCompleterBase::Reply(::fidl::DecodedMessage<ImportBufferCollectionResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_ImportBufferCollection_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::SetBufferCollectionConstraintsCompleterBase::Reply(int32_t res) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetBufferCollectionConstraintsResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SetBufferCollectionConstraintsResponse*>(_write_bytes);
  _response._hdr.ordinal = kController_SetBufferCollectionConstraints_Ordinal;
  _response.res = std::move(res);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetBufferCollectionConstraintsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetBufferCollectionConstraintsResponse>(std::move(_response_bytes)));
}

void Controller::Interface::SetBufferCollectionConstraintsCompleterBase::Reply(::fidl::BytePart _buffer, int32_t res) {
  if (_buffer.capacity() < SetBufferCollectionConstraintsResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SetBufferCollectionConstraintsResponse*>(_buffer.data());
  _response._hdr.ordinal = kController_SetBufferCollectionConstraints_Ordinal;
  _response.res = std::move(res);
  _buffer.set_actual(sizeof(SetBufferCollectionConstraintsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetBufferCollectionConstraintsResponse>(std::move(_buffer)));
}

void Controller::Interface::SetBufferCollectionConstraintsCompleterBase::Reply(::fidl::DecodedMessage<SetBufferCollectionConstraintsResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_SetBufferCollectionConstraints_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::GetSingleBufferFramebufferCompleterBase::Reply(int32_t res, ::zx::vmo vmo, uint32_t stride) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetSingleBufferFramebufferResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetSingleBufferFramebufferResponse*>(_write_bytes);
  _response._hdr.ordinal = kController_GetSingleBufferFramebuffer_Ordinal;
  _response.res = std::move(res);
  _response.vmo = std::move(vmo);
  _response.stride = std::move(stride);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetSingleBufferFramebufferResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetSingleBufferFramebufferResponse>(std::move(_response_bytes)));
}

void Controller::Interface::GetSingleBufferFramebufferCompleterBase::Reply(::fidl::BytePart _buffer, int32_t res, ::zx::vmo vmo, uint32_t stride) {
  if (_buffer.capacity() < GetSingleBufferFramebufferResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetSingleBufferFramebufferResponse*>(_buffer.data());
  _response._hdr.ordinal = kController_GetSingleBufferFramebuffer_Ordinal;
  _response.res = std::move(res);
  _response.vmo = std::move(vmo);
  _response.stride = std::move(stride);
  _buffer.set_actual(sizeof(GetSingleBufferFramebufferResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetSingleBufferFramebufferResponse>(std::move(_buffer)));
}

void Controller::Interface::GetSingleBufferFramebufferCompleterBase::Reply(::fidl::DecodedMessage<GetSingleBufferFramebufferResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_GetSingleBufferFramebuffer_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::ImportImageForCaptureCompleterBase::Reply(Controller_ImportImageForCapture_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ImportImageForCaptureResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<ImportImageForCaptureResponse*>(_write_bytes);
  _response._hdr.ordinal = kController_ImportImageForCapture_Ordinal;
  _response.result = std::move(result);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(ImportImageForCaptureResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ImportImageForCaptureResponse>(std::move(_response_bytes)));
}

void Controller::Interface::ImportImageForCaptureCompleterBase::Reply(::fidl::BytePart _buffer, Controller_ImportImageForCapture_Result result) {
  if (_buffer.capacity() < ImportImageForCaptureResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<ImportImageForCaptureResponse*>(_buffer.data());
  _response._hdr.ordinal = kController_ImportImageForCapture_Ordinal;
  _response.result = std::move(result);
  _buffer.set_actual(sizeof(ImportImageForCaptureResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ImportImageForCaptureResponse>(std::move(_buffer)));
}

void Controller::Interface::ImportImageForCaptureCompleterBase::Reply(::fidl::DecodedMessage<ImportImageForCaptureResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_ImportImageForCapture_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::StartCaptureCompleterBase::Reply(Controller_StartCapture_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<StartCaptureResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<StartCaptureResponse*>(_write_bytes);
  _response._hdr.ordinal = kController_StartCapture_Ordinal;
  _response.result = std::move(result);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(StartCaptureResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<StartCaptureResponse>(std::move(_response_bytes)));
}

void Controller::Interface::StartCaptureCompleterBase::Reply(::fidl::BytePart _buffer, Controller_StartCapture_Result result) {
  if (_buffer.capacity() < StartCaptureResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<StartCaptureResponse*>(_buffer.data());
  _response._hdr.ordinal = kController_StartCapture_Ordinal;
  _response.result = std::move(result);
  _buffer.set_actual(sizeof(StartCaptureResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<StartCaptureResponse>(std::move(_buffer)));
}

void Controller::Interface::StartCaptureCompleterBase::Reply(::fidl::DecodedMessage<StartCaptureResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_StartCapture_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::ReleaseCaptureCompleterBase::Reply(Controller_ReleaseCapture_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReleaseCaptureResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<ReleaseCaptureResponse*>(_write_bytes);
  _response._hdr.ordinal = kController_ReleaseCapture_Ordinal;
  _response.result = std::move(result);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(ReleaseCaptureResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ReleaseCaptureResponse>(std::move(_response_bytes)));
}

void Controller::Interface::ReleaseCaptureCompleterBase::Reply(::fidl::BytePart _buffer, Controller_ReleaseCapture_Result result) {
  if (_buffer.capacity() < ReleaseCaptureResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<ReleaseCaptureResponse*>(_buffer.data());
  _response._hdr.ordinal = kController_ReleaseCapture_Ordinal;
  _response.result = std::move(result);
  _buffer.set_actual(sizeof(ReleaseCaptureResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ReleaseCaptureResponse>(std::move(_buffer)));
}

void Controller::Interface::ReleaseCaptureCompleterBase::Reply(::fidl::DecodedMessage<ReleaseCaptureResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_ReleaseCapture_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


}  // namespace display
}  // namespace hardware
}  // namespace fuchsia
}  // namespace llcpp

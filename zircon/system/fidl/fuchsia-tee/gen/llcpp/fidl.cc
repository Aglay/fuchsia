// WARNING: This file is machine generated by fidlgen.

#include <fuchsia/tee/llcpp/fidl.h>
#include <memory>

namespace llcpp {

namespace fuchsia {
namespace tee {

::llcpp::fuchsia::tee::OsRevision::Builder OsRevision::Build() {
  return OsRevision::Builder();
}

auto ::llcpp::fuchsia::tee::OsRevision::Builder::set_major(uint32_t* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[1 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 1) {
    max_ordinal_ = 1;
  }
  return std::move(*this);
}

auto ::llcpp::fuchsia::tee::OsRevision::Builder::set_minor(uint32_t* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[2 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 2) {
    max_ordinal_ = 2;
  }
  return std::move(*this);
}

::llcpp::fuchsia::tee::OsInfo::Builder OsInfo::Build() {
  return OsInfo::Builder();
}

auto ::llcpp::fuchsia::tee::OsInfo::Builder::set_uuid(::llcpp::fuchsia::tee::Uuid* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[1 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 1) {
    max_ordinal_ = 1;
  }
  return std::move(*this);
}

auto ::llcpp::fuchsia::tee::OsInfo::Builder::set_revision(::llcpp::fuchsia::tee::OsRevision* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[2 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 2) {
    max_ordinal_ = 2;
  }
  return std::move(*this);
}

auto ::llcpp::fuchsia::tee::OsInfo::Builder::set_is_global_platform_compliant(bool* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[3 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 3) {
    max_ordinal_ = 3;
  }
  return std::move(*this);
}

::llcpp::fuchsia::tee::Value::Builder Value::Build() {
  return Value::Builder();
}

auto ::llcpp::fuchsia::tee::Value::Builder::set_direction(::llcpp::fuchsia::tee::Direction* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[1 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 1) {
    max_ordinal_ = 1;
  }
  return std::move(*this);
}

auto ::llcpp::fuchsia::tee::Value::Builder::set_a(uint64_t* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[2 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 2) {
    max_ordinal_ = 2;
  }
  return std::move(*this);
}

auto ::llcpp::fuchsia::tee::Value::Builder::set_b(uint64_t* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[3 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 3) {
    max_ordinal_ = 3;
  }
  return std::move(*this);
}

auto ::llcpp::fuchsia::tee::Value::Builder::set_c(uint64_t* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[4 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 4) {
    max_ordinal_ = 4;
  }
  return std::move(*this);
}

::llcpp::fuchsia::tee::Buffer::Builder Buffer::Build() {
  return Buffer::Builder();
}

auto ::llcpp::fuchsia::tee::Buffer::Builder::set_direction(::llcpp::fuchsia::tee::Direction* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[1 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 1) {
    max_ordinal_ = 1;
  }
  return std::move(*this);
}

auto ::llcpp::fuchsia::tee::Buffer::Builder::set_vmo(::zx::vmo* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[2 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 2) {
    max_ordinal_ = 2;
  }
  return std::move(*this);
}

auto ::llcpp::fuchsia::tee::Buffer::Builder::set_offset(uint64_t* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[3 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 3) {
    max_ordinal_ = 3;
  }
  return std::move(*this);
}

auto ::llcpp::fuchsia::tee::Buffer::Builder::set_size(uint64_t* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[4 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 4) {
    max_ordinal_ = 4;
  }
  return std::move(*this);
}
auto ::llcpp::fuchsia::tee::Parameter::which() const -> Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case Ordinal::kNone:
  case Ordinal::kBuffer:
  case Ordinal::kValue:
    return static_cast<Tag>(ordinal_);
  default:
    return Tag::kUnknown;
  }
}

void ::llcpp::fuchsia::tee::Parameter::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(Parameter) == sizeof(fidl_xunion_t));
  static_assert(offsetof(Parameter, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(Parameter, envelope_) == offsetof(fidl_xunion_t, envelope));
}

::llcpp::fuchsia::tee::OpResult::Builder OpResult::Build() {
  return OpResult::Builder();
}

auto ::llcpp::fuchsia::tee::OpResult::Builder::set_return_code(uint64_t* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[1 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 1) {
    max_ordinal_ = 1;
  }
  return std::move(*this);
}

auto ::llcpp::fuchsia::tee::OpResult::Builder::set_return_origin(::llcpp::fuchsia::tee::ReturnOrigin* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[2 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 2) {
    max_ordinal_ = 2;
  }
  return std::move(*this);
}

auto ::llcpp::fuchsia::tee::OpResult::Builder::set_parameter_set(::fidl::VectorView<::llcpp::fuchsia::tee::Parameter>* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[3 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 3) {
    max_ordinal_ = 3;
  }
  return std::move(*this);
}

namespace {

[[maybe_unused]]
constexpr uint64_t kDevice_GetOsInfo_Ordinal = 0x6d1d83f300000000lu;
[[maybe_unused]]
constexpr uint64_t kDevice_GetOsInfo_GenOrdinal = 0x9b65a9e69ce2ff0lu;
extern "C" const fidl_type_t fuchsia_tee_DeviceGetOsInfoRequestTable;
extern "C" const fidl_type_t fuchsia_tee_DeviceGetOsInfoResponseTable;
extern "C" const fidl_type_t v1_fuchsia_tee_DeviceGetOsInfoResponseTable;
[[maybe_unused]]
constexpr uint64_t kDevice_OpenSession_Ordinal = 0x3c7d253d00000000lu;
[[maybe_unused]]
constexpr uint64_t kDevice_OpenSession_GenOrdinal = 0x611e642d24d5d425lu;
extern "C" const fidl_type_t fuchsia_tee_DeviceOpenSessionRequestTable;
extern "C" const fidl_type_t fuchsia_tee_DeviceOpenSessionResponseTable;
extern "C" const fidl_type_t v1_fuchsia_tee_DeviceOpenSessionResponseTable;
[[maybe_unused]]
constexpr uint64_t kDevice_InvokeCommand_Ordinal = 0x202511b100000000lu;
[[maybe_unused]]
constexpr uint64_t kDevice_InvokeCommand_GenOrdinal = 0x6cba9f107e725868lu;
extern "C" const fidl_type_t fuchsia_tee_DeviceInvokeCommandRequestTable;
extern "C" const fidl_type_t fuchsia_tee_DeviceInvokeCommandResponseTable;
extern "C" const fidl_type_t v1_fuchsia_tee_DeviceInvokeCommandResponseTable;
[[maybe_unused]]
constexpr uint64_t kDevice_CloseSession_Ordinal = 0x53bbaea700000000lu;
[[maybe_unused]]
constexpr uint64_t kDevice_CloseSession_GenOrdinal = 0x7c21cc4c0084d8aflu;
extern "C" const fidl_type_t fuchsia_tee_DeviceCloseSessionRequestTable;
extern "C" const fidl_type_t fuchsia_tee_DeviceCloseSessionResponseTable;
extern "C" const fidl_type_t v1_fuchsia_tee_DeviceCloseSessionResponseTable;

}  // namespace
template <>
Device::ResultOf::GetOsInfo_Impl<Device::GetOsInfoResponse>::GetOsInfo_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetOsInfoRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetOsInfoRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetOsInfoRequest));
  ::fidl::DecodedMessage<GetOsInfoRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Device::InPlace::GetOsInfo(std::move(_client_end), Super::response_buffer()));
}

Device::ResultOf::GetOsInfo Device::SyncClient::GetOsInfo() {
    return ResultOf::GetOsInfo(::zx::unowned_channel(this->channel_));
}

Device::ResultOf::GetOsInfo Device::Call::GetOsInfo(::zx::unowned_channel _client_end) {
  return ResultOf::GetOsInfo(std::move(_client_end));
}

template <>
Device::UnownedResultOf::GetOsInfo_Impl<Device::GetOsInfoResponse>::GetOsInfo_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetOsInfoRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetOsInfoRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetOsInfoRequest));
  ::fidl::DecodedMessage<GetOsInfoRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Device::InPlace::GetOsInfo(std::move(_client_end), std::move(_response_buffer)));
}

Device::UnownedResultOf::GetOsInfo Device::SyncClient::GetOsInfo(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetOsInfo(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Device::UnownedResultOf::GetOsInfo Device::Call::GetOsInfo(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetOsInfo(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::GetOsInfoResponse> Device::InPlace::GetOsInfo(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetOsInfoRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetOsInfoRequest> params(std::move(_request_buffer));
  Device::SetTransactionHeaderFor::GetOsInfoRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::GetOsInfoResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetOsInfoRequest, GetOsInfoResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::GetOsInfoResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Device::ResultOf::OpenSession_Impl<Device::OpenSessionResponse>::OpenSession_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::tee::Uuid trusted_app, ::fidl::VectorView<::llcpp::fuchsia::tee::Parameter> parameter_set) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OpenSessionRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  OpenSessionRequest _request = {};
  _request.trusted_app = std::move(trusted_app);
  _request.parameter_set = std::move(parameter_set);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<OpenSessionRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Device::InPlace::OpenSession(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Device::ResultOf::OpenSession Device::SyncClient::OpenSession(::llcpp::fuchsia::tee::Uuid trusted_app, ::fidl::VectorView<::llcpp::fuchsia::tee::Parameter> parameter_set) {
    return ResultOf::OpenSession(::zx::unowned_channel(this->channel_), std::move(trusted_app), std::move(parameter_set));
}

Device::ResultOf::OpenSession Device::Call::OpenSession(::zx::unowned_channel _client_end, ::llcpp::fuchsia::tee::Uuid trusted_app, ::fidl::VectorView<::llcpp::fuchsia::tee::Parameter> parameter_set) {
  return ResultOf::OpenSession(std::move(_client_end), std::move(trusted_app), std::move(parameter_set));
}

template <>
Device::UnownedResultOf::OpenSession_Impl<Device::OpenSessionResponse>::OpenSession_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::tee::Uuid trusted_app, ::fidl::VectorView<::llcpp::fuchsia::tee::Parameter> parameter_set, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < OpenSessionRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<OpenSessionResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  OpenSessionRequest _request = {};
  _request.trusted_app = std::move(trusted_app);
  _request.parameter_set = std::move(parameter_set);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<OpenSessionRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Device::InPlace::OpenSession(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Device::UnownedResultOf::OpenSession Device::SyncClient::OpenSession(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::tee::Uuid trusted_app, ::fidl::VectorView<::llcpp::fuchsia::tee::Parameter> parameter_set, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::OpenSession(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(trusted_app), std::move(parameter_set), std::move(_response_buffer));
}

Device::UnownedResultOf::OpenSession Device::Call::OpenSession(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::tee::Uuid trusted_app, ::fidl::VectorView<::llcpp::fuchsia::tee::Parameter> parameter_set, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::OpenSession(std::move(_client_end), std::move(_request_buffer), std::move(trusted_app), std::move(parameter_set), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::OpenSessionResponse> Device::InPlace::OpenSession(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<OpenSessionRequest> params, ::fidl::BytePart response_buffer) {
  Device::SetTransactionHeaderFor::OpenSessionRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::OpenSessionResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<OpenSessionRequest, OpenSessionResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::OpenSessionResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Device::ResultOf::InvokeCommand_Impl<Device::InvokeCommandResponse>::InvokeCommand_Impl(::zx::unowned_channel _client_end, uint32_t session_id, uint32_t command_id, ::fidl::VectorView<::llcpp::fuchsia::tee::Parameter> parameter_set) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<InvokeCommandRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  InvokeCommandRequest _request = {};
  _request.session_id = std::move(session_id);
  _request.command_id = std::move(command_id);
  _request.parameter_set = std::move(parameter_set);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<InvokeCommandRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Device::InPlace::InvokeCommand(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Device::ResultOf::InvokeCommand Device::SyncClient::InvokeCommand(uint32_t session_id, uint32_t command_id, ::fidl::VectorView<::llcpp::fuchsia::tee::Parameter> parameter_set) {
    return ResultOf::InvokeCommand(::zx::unowned_channel(this->channel_), std::move(session_id), std::move(command_id), std::move(parameter_set));
}

Device::ResultOf::InvokeCommand Device::Call::InvokeCommand(::zx::unowned_channel _client_end, uint32_t session_id, uint32_t command_id, ::fidl::VectorView<::llcpp::fuchsia::tee::Parameter> parameter_set) {
  return ResultOf::InvokeCommand(std::move(_client_end), std::move(session_id), std::move(command_id), std::move(parameter_set));
}

template <>
Device::UnownedResultOf::InvokeCommand_Impl<Device::InvokeCommandResponse>::InvokeCommand_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t session_id, uint32_t command_id, ::fidl::VectorView<::llcpp::fuchsia::tee::Parameter> parameter_set, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < InvokeCommandRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<InvokeCommandResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  InvokeCommandRequest _request = {};
  _request.session_id = std::move(session_id);
  _request.command_id = std::move(command_id);
  _request.parameter_set = std::move(parameter_set);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<InvokeCommandRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Device::InPlace::InvokeCommand(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Device::UnownedResultOf::InvokeCommand Device::SyncClient::InvokeCommand(::fidl::BytePart _request_buffer, uint32_t session_id, uint32_t command_id, ::fidl::VectorView<::llcpp::fuchsia::tee::Parameter> parameter_set, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::InvokeCommand(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(session_id), std::move(command_id), std::move(parameter_set), std::move(_response_buffer));
}

Device::UnownedResultOf::InvokeCommand Device::Call::InvokeCommand(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t session_id, uint32_t command_id, ::fidl::VectorView<::llcpp::fuchsia::tee::Parameter> parameter_set, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::InvokeCommand(std::move(_client_end), std::move(_request_buffer), std::move(session_id), std::move(command_id), std::move(parameter_set), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::InvokeCommandResponse> Device::InPlace::InvokeCommand(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<InvokeCommandRequest> params, ::fidl::BytePart response_buffer) {
  Device::SetTransactionHeaderFor::InvokeCommandRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::InvokeCommandResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<InvokeCommandRequest, InvokeCommandResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::InvokeCommandResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Device::ResultOf::CloseSession_Impl<Device::CloseSessionResponse>::CloseSession_Impl(::zx::unowned_channel _client_end, uint32_t session_id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseSessionRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CloseSessionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CloseSessionRequest*>(_write_bytes);
  _request.session_id = std::move(session_id);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseSessionRequest));
  ::fidl::DecodedMessage<CloseSessionRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Device::InPlace::CloseSession(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Device::ResultOf::CloseSession Device::SyncClient::CloseSession(uint32_t session_id) {
    return ResultOf::CloseSession(::zx::unowned_channel(this->channel_), std::move(session_id));
}

Device::ResultOf::CloseSession Device::Call::CloseSession(::zx::unowned_channel _client_end, uint32_t session_id) {
  return ResultOf::CloseSession(std::move(_client_end), std::move(session_id));
}

template <>
Device::UnownedResultOf::CloseSession_Impl<Device::CloseSessionResponse>::CloseSession_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t session_id, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < CloseSessionRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<CloseSessionResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, CloseSessionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CloseSessionRequest*>(_request_buffer.data());
  _request.session_id = std::move(session_id);
  _request_buffer.set_actual(sizeof(CloseSessionRequest));
  ::fidl::DecodedMessage<CloseSessionRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Device::InPlace::CloseSession(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Device::UnownedResultOf::CloseSession Device::SyncClient::CloseSession(::fidl::BytePart _request_buffer, uint32_t session_id, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::CloseSession(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(session_id), std::move(_response_buffer));
}

Device::UnownedResultOf::CloseSession Device::Call::CloseSession(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t session_id, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::CloseSession(std::move(_client_end), std::move(_request_buffer), std::move(session_id), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::CloseSessionResponse> Device::InPlace::CloseSession(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<CloseSessionRequest> params, ::fidl::BytePart response_buffer) {
  Device::SetTransactionHeaderFor::CloseSessionRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::CloseSessionResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<CloseSessionRequest, CloseSessionResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::CloseSessionResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool Device::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kDevice_GetOsInfo_Ordinal:
    case kDevice_GetOsInfo_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetOsInfoRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetOsInfo(
          Interface::GetOsInfoCompleter::Sync(txn));
      return true;
    }
    case kDevice_OpenSession_Ordinal:
    case kDevice_OpenSession_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<OpenSessionRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->OpenSession(std::move(message->trusted_app), std::move(message->parameter_set),
          Interface::OpenSessionCompleter::Sync(txn));
      return true;
    }
    case kDevice_InvokeCommand_Ordinal:
    case kDevice_InvokeCommand_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<InvokeCommandRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->InvokeCommand(std::move(message->session_id), std::move(message->command_id), std::move(message->parameter_set),
          Interface::InvokeCommandCompleter::Sync(txn));
      return true;
    }
    case kDevice_CloseSession_Ordinal:
    case kDevice_CloseSession_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<CloseSessionRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->CloseSession(std::move(message->session_id),
          Interface::CloseSessionCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Device::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void Device::Interface::GetOsInfoCompleterBase::Reply(::llcpp::fuchsia::tee::OsInfo info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetOsInfoResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  GetOsInfoResponse _response = {};
  Device::SetTransactionHeaderFor::GetOsInfoResponse(
      ::fidl::DecodedMessage<GetOsInfoResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetOsInfoResponse::PrimarySize,
              GetOsInfoResponse::PrimarySize)));
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Device::Interface::GetOsInfoCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::tee::OsInfo info) {
  if (_buffer.capacity() < GetOsInfoResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetOsInfoResponse _response = {};
  Device::SetTransactionHeaderFor::GetOsInfoResponse(
      ::fidl::DecodedMessage<GetOsInfoResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetOsInfoResponse::PrimarySize,
              GetOsInfoResponse::PrimarySize)));
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Device::Interface::GetOsInfoCompleterBase::Reply(::fidl::DecodedMessage<GetOsInfoResponse> params) {
  Device::SetTransactionHeaderFor::GetOsInfoResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Device::Interface::OpenSessionCompleterBase::Reply(uint32_t session_id, ::llcpp::fuchsia::tee::OpResult op_result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OpenSessionResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  OpenSessionResponse _response = {};
  Device::SetTransactionHeaderFor::OpenSessionResponse(
      ::fidl::DecodedMessage<OpenSessionResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OpenSessionResponse::PrimarySize,
              OpenSessionResponse::PrimarySize)));
  _response.session_id = std::move(session_id);
  _response.op_result = std::move(op_result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Device::Interface::OpenSessionCompleterBase::Reply(::fidl::BytePart _buffer, uint32_t session_id, ::llcpp::fuchsia::tee::OpResult op_result) {
  if (_buffer.capacity() < OpenSessionResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  OpenSessionResponse _response = {};
  Device::SetTransactionHeaderFor::OpenSessionResponse(
      ::fidl::DecodedMessage<OpenSessionResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OpenSessionResponse::PrimarySize,
              OpenSessionResponse::PrimarySize)));
  _response.session_id = std::move(session_id);
  _response.op_result = std::move(op_result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Device::Interface::OpenSessionCompleterBase::Reply(::fidl::DecodedMessage<OpenSessionResponse> params) {
  Device::SetTransactionHeaderFor::OpenSessionResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Device::Interface::InvokeCommandCompleterBase::Reply(::llcpp::fuchsia::tee::OpResult op_result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<InvokeCommandResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  InvokeCommandResponse _response = {};
  Device::SetTransactionHeaderFor::InvokeCommandResponse(
      ::fidl::DecodedMessage<InvokeCommandResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              InvokeCommandResponse::PrimarySize,
              InvokeCommandResponse::PrimarySize)));
  _response.op_result = std::move(op_result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Device::Interface::InvokeCommandCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::tee::OpResult op_result) {
  if (_buffer.capacity() < InvokeCommandResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  InvokeCommandResponse _response = {};
  Device::SetTransactionHeaderFor::InvokeCommandResponse(
      ::fidl::DecodedMessage<InvokeCommandResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              InvokeCommandResponse::PrimarySize,
              InvokeCommandResponse::PrimarySize)));
  _response.op_result = std::move(op_result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Device::Interface::InvokeCommandCompleterBase::Reply(::fidl::DecodedMessage<InvokeCommandResponse> params) {
  Device::SetTransactionHeaderFor::InvokeCommandResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Device::Interface::CloseSessionCompleterBase::Reply() {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseSessionResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<CloseSessionResponse*>(_write_bytes);
  Device::SetTransactionHeaderFor::CloseSessionResponse(
      ::fidl::DecodedMessage<CloseSessionResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              CloseSessionResponse::PrimarySize,
              CloseSessionResponse::PrimarySize)));
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseSessionResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CloseSessionResponse>(std::move(_response_bytes)));
}



void Device::SetTransactionHeaderFor::GetOsInfoRequest(const ::fidl::DecodedMessage<Device::GetOsInfoRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_GetOsInfo_GenOrdinal);
}
void Device::SetTransactionHeaderFor::GetOsInfoResponse(const ::fidl::DecodedMessage<Device::GetOsInfoResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_GetOsInfo_GenOrdinal);
}

void Device::SetTransactionHeaderFor::OpenSessionRequest(const ::fidl::DecodedMessage<Device::OpenSessionRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_OpenSession_GenOrdinal);
}
void Device::SetTransactionHeaderFor::OpenSessionResponse(const ::fidl::DecodedMessage<Device::OpenSessionResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_OpenSession_GenOrdinal);
}

void Device::SetTransactionHeaderFor::InvokeCommandRequest(const ::fidl::DecodedMessage<Device::InvokeCommandRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_InvokeCommand_GenOrdinal);
}
void Device::SetTransactionHeaderFor::InvokeCommandResponse(const ::fidl::DecodedMessage<Device::InvokeCommandResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_InvokeCommand_GenOrdinal);
}

void Device::SetTransactionHeaderFor::CloseSessionRequest(const ::fidl::DecodedMessage<Device::CloseSessionRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_CloseSession_GenOrdinal);
}
void Device::SetTransactionHeaderFor::CloseSessionResponse(const ::fidl::DecodedMessage<Device::CloseSessionResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_CloseSession_GenOrdinal);
}

}  // namespace tee
}  // namespace fuchsia
}  // namespace llcpp

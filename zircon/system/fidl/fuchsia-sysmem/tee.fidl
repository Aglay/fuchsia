// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

library fuchsia.sysmem;

using zx;

/// TEE - Trusted Execution Environment.
///
/// REE - Rich Execution Environment.
///
/// Enables sysmem to communicate with the TEE's REE-side driver to get any
/// secure heaps configured via the TEE, and set any physical secure heaps
/// configured via sysmem.
///
/// The protocol description uses "TEE" as shorthand for "The TEE or a process
/// in communication with the TEE".  The server end can be a low-layer TEE
/// driver, or a higher-layer driver concerned with secure memory aspects of the
/// TEE, or even a non-driver service process that can communicate with the TEE
/// (can be ok assuming overall avoidance of up-call deadlocks).
///
/// Presently, dynamically-allocated secure heaps are configured via sysmem, as
/// it starts quite early during boot and can successfully reserve contiguous
/// physical memory.  Presently, fixed-location secure heaps are configured via
/// TEE, as the plumbing goes from the bootloader to the TEE.  However, this
/// protocol intentionally doesn't care which heaps are dynamically-allocated
/// and which are fixed-location.
///
// Needs Layout = "Simple" because used with "FIDL Simple C Bindings" (by
// sysmem; the server end uses llcpp).
[Layout = "Simple"]
protocol Tee {
    /// Gets the physical address and length of any secure heap whose physical
    /// range is configured via the TEE.
    ///
    /// Presently, these will be fixed physical addresses and lengths, with the
    /// location plumbed via the TEE.
    ///
    /// This is preferred over RegisterHeap() when there isn't any special
    /// heap-specific per-VMO setup or teardown required.
    ///
    /// The physical range must be secured/protected by the TEE before the TEE
    /// responds to this request with success.
    GetPhysicalSecureHeaps() -> (PhysicalSecureHeaps heaps) error zx.status;

    /// This request from sysmem to the TEE lets the TEE know the physical
    /// memory address and length of any secure heap whose location is
    /// configured/established via sysmem.
    ///
    /// Presently, these physical ranges will be dynamically-allocated by sysmem
    /// early during boot.
    ///
    /// The heap ID is included in case that's relevant to a particular TEE, for
    /// more informative log messages, and for consistency with
    /// GetPhysicalSecureHeaps().
    ///
    /// The TEE must configure all the provided ranges as secure before
    /// responding to this message with success.
    SetPhysicalSecureHeaps(PhysicalSecureHeaps heaps) -> () error zx.status;

    /// This message from sysmem to TEE lets the TEE know that sysmem is done
    /// with this channel.  The error code shall be interpreted similarly to an
    /// epitaph.  It's not officially an epitaph because those can only be sent
    /// from server to client.  The client shall not send any more messages
    /// after this message.  The client shall close the channel shortly.  The
    /// server may close the channel shortly (with or without an epitaph).
    ///
    /// A value of ZX_OK (0) indicates to the server that this channel has
    /// successfully served its purpose.  Any other value, or a client channel
    /// close without this message first, indicates to the server that the
    /// channel closed unexpectedly, potentially without having served its
    /// purpose.
    Epitaph(zx.status status);
};

struct PhysicalSecureHeap {
    /// This must be a HeapType that is secure/protected, else the TEE won't be
    /// involved.
    HeapType heap;
    /// Must be at least PAGE_SIZE aligned.
    uint64 physical_address;
    /// Must be at least PAGE_SIZE aligned.
    uint64 size_bytes;
};

const uint32 MAX_HEAPS_COUNT = 32;

struct PhysicalSecureHeaps {
    /// Must be <= MAX_HEAPS_COUNT.
    uint32 heaps_count;
    /// Only the first heaps_count are meaningful.  The rest are ignored.
    array<PhysicalSecureHeap>:MAX_HEAPS_COUNT heaps;
};

// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/cpp/vector_view.h>
#include <lib/fidl/cpp/string_view.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/fit/function.h>
#include <lib/zx/channel.h>
#include <lib/zx/vmo.h>
#include <zircon/fidl.h>

namespace fuchsia {
namespace sysmem {

struct VmoBuffer;
class BufferCollectionToken;
class Heap;
class DriverConnector;
class Allocator;
enum class PixelFormatType : uint32_t {
  INVALID = 0u,
  R8G8B8A8 = 1u,
  BGRA32 = 101u,
  I420 = 102u,
  M420 = 103u,
  NV12 = 104u,
  YUY2 = 105u,
  MJPEG = 106u,
  YV12 = 107u,
};


struct ImagePlane;
enum class HeapType : uint64_t {
  SYSTEM_RAM = 0u,
  AMLOGIC_SECURE = 1152921504606912512u,
  GOLDFISH_DEVICE_LOCAL = 1152921504606978048u,
};


struct BufferMemoryConstraints;
struct FormatModifier;
struct PixelFormat;
enum class ColorSpaceType : uint32_t {
  INVALID = 0u,
  SRGB = 1u,
  REC601_NTSC = 2u,
  REC601_NTSC_FULL_RANGE = 3u,
  REC601_PAL = 4u,
  REC601_PAL_FULL_RANGE = 5u,
  REC709 = 6u,
  REC2020 = 7u,
  REC2100 = 8u,
};


struct ColorSpace;
struct ImageSpec;
struct BufferSpec;
struct ImageFormat_2;
struct ImageFormatConstraints;
struct ImageFormat;
struct BufferFormat;
struct BufferCollectionInfo;
enum class CoherencyDomain : uint32_t {
  CPU = 0u,
  RAM = 1u,
  INACCESSIBLE = 2u,
};


struct BufferMemorySettings;
struct SingleBufferSettings;
struct SingleBufferInfo;
struct BufferCollectionInfo_2;
class BufferCollectionEvents;
struct BufferUsage;
struct BufferCollectionConstraints;
class BufferCollection;

constexpr uint32_t vulkanUsageTransientAttachment = 64u;

constexpr uint32_t vulkanUsageTransferSrc = 1u;

constexpr uint32_t vulkanUsageTransferDst = 2u;

constexpr uint32_t vulkanUsageStorage = 8u;

constexpr uint32_t vulkanUsageStencilAttachment = 32u;

constexpr uint32_t vulkanUsageSampled = 4u;

constexpr uint32_t vulkanUsageInputAttachment = 128u;

constexpr uint32_t vulkanUsageColorAttachment = 16u;

constexpr uint32_t videoUsageHwProtected = 4u;

constexpr uint32_t videoUsageHwEncoder = 2u;

constexpr uint32_t videoUsageHwDecoder = 1u;

constexpr uint32_t displayUsageLayer = 1u;

constexpr uint32_t displayUsageCursor = 2u;

constexpr uint32_t cpuUsageWriteOften = 8u;

constexpr uint32_t cpuUsageWrite = 4u;

constexpr uint32_t cpuUsageReadOften = 2u;

constexpr uint32_t cpuUsageRead = 1u;

extern "C" const fidl_type_t fuchsia_sysmem_VmoBufferTable;

struct VmoBuffer {
  static constexpr const fidl_type_t* Type = &fuchsia_sysmem_VmoBufferTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  ::zx::vmo vmo{};

  uint64_t vmo_usable_start{};
};

extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionTokenDuplicateRequestTable;

class BufferCollectionToken final {
 public:

  struct DuplicateRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t rights_attenuation_mask;
    ::zx::channel token_request;

    static constexpr const fidl_type_t* Type = &fuchsia_sysmem_BufferCollectionTokenDuplicateRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };

  using SyncResponse = ::fidl::AnyZeroArgMessage;
  using SyncRequest = ::fidl::AnyZeroArgMessage;

  using CloseRequest = ::fidl::AnyZeroArgMessage;


  class SyncClient final {
   public:
    SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}

    ~SyncClient() {}

    zx_status_t Duplicate(uint32_t rights_attenuation_mask, ::zx::channel token_request);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Duplicate(::fidl::BytePart _request_buffer, uint32_t rights_attenuation_mask, ::zx::channel token_request);

    // Messages are encoded and decoded in-place.
    zx_status_t Duplicate(::fidl::DecodedMessage<DuplicateRequest> params);

    zx_status_t Sync();

    zx_status_t Close();

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
   public:

    static zx_status_t Duplicate(zx::unowned_channel _client_end, uint32_t rights_attenuation_mask, ::zx::channel token_request);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Duplicate(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t rights_attenuation_mask, ::zx::channel token_request);

    // Messages are encoded and decoded in-place.
    static zx_status_t Duplicate(zx::unowned_channel _client_end, ::fidl::DecodedMessage<DuplicateRequest> params);

    static zx_status_t Sync(zx::unowned_channel _client_end);

    static zx_status_t Close(zx::unowned_channel _client_end);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = BufferCollectionToken;
    using _Base = ::fidl::CompleterBase;

    using DuplicateCompleter = ::fidl::Completer<>;

    virtual void Duplicate(uint32_t rights_attenuation_mask, ::zx::channel token_request, DuplicateCompleter::Sync _completer) = 0;

    class SyncCompleterBase : public _Base {
     public:
      void Reply();

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SyncCompleter = ::fidl::Completer<SyncCompleterBase>;

    virtual void Sync(SyncCompleter::Sync _completer) = 0;

    using CloseCompleter = ::fidl::Completer<>;

    virtual void Close(CloseCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

};

extern "C" const fidl_type_t fuchsia_sysmem_HeapAllocateVmoResponseTable;
extern "C" const fidl_type_t fuchsia_sysmem_HeapCreateResourceRequestTable;
extern "C" const fidl_type_t fuchsia_sysmem_HeapCreateResourceResponseTable;

// Manages resources on a specific sysmem heap.
//
// Needs Layout = "Simple" because used with "FIDL Simple C Bindings".
class Heap final {
 public:

  struct AllocateVmoResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::zx::vmo vmo;

    static constexpr const fidl_type_t* Type = &fuchsia_sysmem_HeapAllocateVmoResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct AllocateVmoRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t size;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = AllocateVmoResponse;
  };

  struct CreateResourceResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    uint64_t id;

    static constexpr const fidl_type_t* Type = &fuchsia_sysmem_HeapCreateResourceResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct CreateResourceRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::vmo vmo;

    static constexpr const fidl_type_t* Type = &fuchsia_sysmem_HeapCreateResourceRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = CreateResourceResponse;
  };

  using DestroyResourceResponse = ::fidl::AnyZeroArgMessage;
  struct DestroyResourceRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t id;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };


  class SyncClient final {
   public:
    SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}

    ~SyncClient() {}

    // Request a new memory allocation of |size| on heap.
    // For heaps which don't permit CPU access to the buffer data, this
    // will create a VMO with an official size, but which never has any
    // physical pages.  For such heaps, the VMO is effectively used as
    // an opaque buffer identifier.
    //
    // Heaps should defer allocation of any associated resources until
    // CreateResource(), because the caller of AllocateVmo() may simply
    // delete the returned VMO with no further notification to the heap.
    // In contrast, after CreateResource(), the caller guarantees that
    // DestroyResource() or heap channel closure will occur.
    //
    // The caller guarantees that CreateResource() will be called prior
    // to the returned VMO or any associated child VMO being used.
    zx_status_t AllocateVmo(uint64_t size, int32_t* out_s, ::zx::vmo* out_vmo);

    // Request a new memory allocation of |size| on heap.
    // For heaps which don't permit CPU access to the buffer data, this
    // will create a VMO with an official size, but which never has any
    // physical pages.  For such heaps, the VMO is effectively used as
    // an opaque buffer identifier.
    //
    // Heaps should defer allocation of any associated resources until
    // CreateResource(), because the caller of AllocateVmo() may simply
    // delete the returned VMO with no further notification to the heap.
    // In contrast, after CreateResource(), the caller guarantees that
    // DestroyResource() or heap channel closure will occur.
    //
    // The caller guarantees that CreateResource() will be called prior
    // to the returned VMO or any associated child VMO being used.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<AllocateVmoResponse> AllocateVmo(::fidl::BytePart _request_buffer, uint64_t size, ::fidl::BytePart _response_buffer, int32_t* out_s, ::zx::vmo* out_vmo);

    // Request a new memory allocation of |size| on heap.
    // For heaps which don't permit CPU access to the buffer data, this
    // will create a VMO with an official size, but which never has any
    // physical pages.  For such heaps, the VMO is effectively used as
    // an opaque buffer identifier.
    //
    // Heaps should defer allocation of any associated resources until
    // CreateResource(), because the caller of AllocateVmo() may simply
    // delete the returned VMO with no further notification to the heap.
    // In contrast, after CreateResource(), the caller guarantees that
    // DestroyResource() or heap channel closure will occur.
    //
    // The caller guarantees that CreateResource() will be called prior
    // to the returned VMO or any associated child VMO being used.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<AllocateVmoResponse> AllocateVmo(::fidl::DecodedMessage<AllocateVmoRequest> params, ::fidl::BytePart response_buffer);

    // Create resources and associate heap-specific resources with the
    // passed-in VMO. Resources can be hardware specific and their
    // lifetime don't have to be tied to |vmo|. |vmo| must be a VMO
    // (or a direct or indirect child of a VMO) acquired through a call
    // to AllocateVmo method above.  If the passed-in vmo is a child VMO,
    // it's size must match the size of the parent VMO created by
    // AllocateVmo().  For heaps that permit CPU access, the passed-in
    // VMO must not have a copy-on-write relationship with the parent
    // VMO, but rather a pass-through relationship. Successful return
    // status indicate that Heap has established a mapping between
    // VMO and hardware specific resources.
    //
    // The returned id must be passed to DestroyResource() later when
    // resources associated with VMO are no longer needed, unless the
    // heap channel closes first.
    //
    // The heap must not own/keep a handle to VMO, or any derived child
    // VMO, or any VMAR mapping to VMO, as any of those would keep VMO
    // alive beyond all sysmem participant usages of the vmo; instead
    // the heap can get the vmo's koid for the heap's mapping.
    zx_status_t CreateResource(::zx::vmo vmo, int32_t* out_s, uint64_t* out_id);

    // Create resources and associate heap-specific resources with the
    // passed-in VMO. Resources can be hardware specific and their
    // lifetime don't have to be tied to |vmo|. |vmo| must be a VMO
    // (or a direct or indirect child of a VMO) acquired through a call
    // to AllocateVmo method above.  If the passed-in vmo is a child VMO,
    // it's size must match the size of the parent VMO created by
    // AllocateVmo().  For heaps that permit CPU access, the passed-in
    // VMO must not have a copy-on-write relationship with the parent
    // VMO, but rather a pass-through relationship. Successful return
    // status indicate that Heap has established a mapping between
    // VMO and hardware specific resources.
    //
    // The returned id must be passed to DestroyResource() later when
    // resources associated with VMO are no longer needed, unless the
    // heap channel closes first.
    //
    // The heap must not own/keep a handle to VMO, or any derived child
    // VMO, or any VMAR mapping to VMO, as any of those would keep VMO
    // alive beyond all sysmem participant usages of the vmo; instead
    // the heap can get the vmo's koid for the heap's mapping.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<CreateResourceResponse> CreateResource(::fidl::BytePart _request_buffer, ::zx::vmo vmo, ::fidl::BytePart _response_buffer, int32_t* out_s, uint64_t* out_id);

    // Create resources and associate heap-specific resources with the
    // passed-in VMO. Resources can be hardware specific and their
    // lifetime don't have to be tied to |vmo|. |vmo| must be a VMO
    // (or a direct or indirect child of a VMO) acquired through a call
    // to AllocateVmo method above.  If the passed-in vmo is a child VMO,
    // it's size must match the size of the parent VMO created by
    // AllocateVmo().  For heaps that permit CPU access, the passed-in
    // VMO must not have a copy-on-write relationship with the parent
    // VMO, but rather a pass-through relationship. Successful return
    // status indicate that Heap has established a mapping between
    // VMO and hardware specific resources.
    //
    // The returned id must be passed to DestroyResource() later when
    // resources associated with VMO are no longer needed, unless the
    // heap channel closes first.
    //
    // The heap must not own/keep a handle to VMO, or any derived child
    // VMO, or any VMAR mapping to VMO, as any of those would keep VMO
    // alive beyond all sysmem participant usages of the vmo; instead
    // the heap can get the vmo's koid for the heap's mapping.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<CreateResourceResponse> CreateResource(::fidl::DecodedMessage<CreateResourceRequest> params, ::fidl::BytePart response_buffer);

    // Destroy previously created resources.
    zx_status_t DestroyResource(uint64_t id);

    // Destroy previously created resources.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<DestroyResourceResponse> DestroyResource(::fidl::BytePart _request_buffer, uint64_t id);

    // Destroy previously created resources.
    // Messages are encoded and decoded in-place.
    zx_status_t DestroyResource(::fidl::DecodedMessage<DestroyResourceRequest> params);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
   public:

    // Request a new memory allocation of |size| on heap.
    // For heaps which don't permit CPU access to the buffer data, this
    // will create a VMO with an official size, but which never has any
    // physical pages.  For such heaps, the VMO is effectively used as
    // an opaque buffer identifier.
    //
    // Heaps should defer allocation of any associated resources until
    // CreateResource(), because the caller of AllocateVmo() may simply
    // delete the returned VMO with no further notification to the heap.
    // In contrast, after CreateResource(), the caller guarantees that
    // DestroyResource() or heap channel closure will occur.
    //
    // The caller guarantees that CreateResource() will be called prior
    // to the returned VMO or any associated child VMO being used.
    static zx_status_t AllocateVmo(zx::unowned_channel _client_end, uint64_t size, int32_t* out_s, ::zx::vmo* out_vmo);

    // Request a new memory allocation of |size| on heap.
    // For heaps which don't permit CPU access to the buffer data, this
    // will create a VMO with an official size, but which never has any
    // physical pages.  For such heaps, the VMO is effectively used as
    // an opaque buffer identifier.
    //
    // Heaps should defer allocation of any associated resources until
    // CreateResource(), because the caller of AllocateVmo() may simply
    // delete the returned VMO with no further notification to the heap.
    // In contrast, after CreateResource(), the caller guarantees that
    // DestroyResource() or heap channel closure will occur.
    //
    // The caller guarantees that CreateResource() will be called prior
    // to the returned VMO or any associated child VMO being used.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<AllocateVmoResponse> AllocateVmo(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t size, ::fidl::BytePart _response_buffer, int32_t* out_s, ::zx::vmo* out_vmo);

    // Request a new memory allocation of |size| on heap.
    // For heaps which don't permit CPU access to the buffer data, this
    // will create a VMO with an official size, but which never has any
    // physical pages.  For such heaps, the VMO is effectively used as
    // an opaque buffer identifier.
    //
    // Heaps should defer allocation of any associated resources until
    // CreateResource(), because the caller of AllocateVmo() may simply
    // delete the returned VMO with no further notification to the heap.
    // In contrast, after CreateResource(), the caller guarantees that
    // DestroyResource() or heap channel closure will occur.
    //
    // The caller guarantees that CreateResource() will be called prior
    // to the returned VMO or any associated child VMO being used.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<AllocateVmoResponse> AllocateVmo(zx::unowned_channel _client_end, ::fidl::DecodedMessage<AllocateVmoRequest> params, ::fidl::BytePart response_buffer);

    // Create resources and associate heap-specific resources with the
    // passed-in VMO. Resources can be hardware specific and their
    // lifetime don't have to be tied to |vmo|. |vmo| must be a VMO
    // (or a direct or indirect child of a VMO) acquired through a call
    // to AllocateVmo method above.  If the passed-in vmo is a child VMO,
    // it's size must match the size of the parent VMO created by
    // AllocateVmo().  For heaps that permit CPU access, the passed-in
    // VMO must not have a copy-on-write relationship with the parent
    // VMO, but rather a pass-through relationship. Successful return
    // status indicate that Heap has established a mapping between
    // VMO and hardware specific resources.
    //
    // The returned id must be passed to DestroyResource() later when
    // resources associated with VMO are no longer needed, unless the
    // heap channel closes first.
    //
    // The heap must not own/keep a handle to VMO, or any derived child
    // VMO, or any VMAR mapping to VMO, as any of those would keep VMO
    // alive beyond all sysmem participant usages of the vmo; instead
    // the heap can get the vmo's koid for the heap's mapping.
    static zx_status_t CreateResource(zx::unowned_channel _client_end, ::zx::vmo vmo, int32_t* out_s, uint64_t* out_id);

    // Create resources and associate heap-specific resources with the
    // passed-in VMO. Resources can be hardware specific and their
    // lifetime don't have to be tied to |vmo|. |vmo| must be a VMO
    // (or a direct or indirect child of a VMO) acquired through a call
    // to AllocateVmo method above.  If the passed-in vmo is a child VMO,
    // it's size must match the size of the parent VMO created by
    // AllocateVmo().  For heaps that permit CPU access, the passed-in
    // VMO must not have a copy-on-write relationship with the parent
    // VMO, but rather a pass-through relationship. Successful return
    // status indicate that Heap has established a mapping between
    // VMO and hardware specific resources.
    //
    // The returned id must be passed to DestroyResource() later when
    // resources associated with VMO are no longer needed, unless the
    // heap channel closes first.
    //
    // The heap must not own/keep a handle to VMO, or any derived child
    // VMO, or any VMAR mapping to VMO, as any of those would keep VMO
    // alive beyond all sysmem participant usages of the vmo; instead
    // the heap can get the vmo's koid for the heap's mapping.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<CreateResourceResponse> CreateResource(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::vmo vmo, ::fidl::BytePart _response_buffer, int32_t* out_s, uint64_t* out_id);

    // Create resources and associate heap-specific resources with the
    // passed-in VMO. Resources can be hardware specific and their
    // lifetime don't have to be tied to |vmo|. |vmo| must be a VMO
    // (or a direct or indirect child of a VMO) acquired through a call
    // to AllocateVmo method above.  If the passed-in vmo is a child VMO,
    // it's size must match the size of the parent VMO created by
    // AllocateVmo().  For heaps that permit CPU access, the passed-in
    // VMO must not have a copy-on-write relationship with the parent
    // VMO, but rather a pass-through relationship. Successful return
    // status indicate that Heap has established a mapping between
    // VMO and hardware specific resources.
    //
    // The returned id must be passed to DestroyResource() later when
    // resources associated with VMO are no longer needed, unless the
    // heap channel closes first.
    //
    // The heap must not own/keep a handle to VMO, or any derived child
    // VMO, or any VMAR mapping to VMO, as any of those would keep VMO
    // alive beyond all sysmem participant usages of the vmo; instead
    // the heap can get the vmo's koid for the heap's mapping.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<CreateResourceResponse> CreateResource(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CreateResourceRequest> params, ::fidl::BytePart response_buffer);

    // Destroy previously created resources.
    static zx_status_t DestroyResource(zx::unowned_channel _client_end, uint64_t id);

    // Destroy previously created resources.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<DestroyResourceResponse> DestroyResource(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t id);

    // Destroy previously created resources.
    // Messages are encoded and decoded in-place.
    static zx_status_t DestroyResource(zx::unowned_channel _client_end, ::fidl::DecodedMessage<DestroyResourceRequest> params);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Heap;
    using _Base = ::fidl::CompleterBase;

    class AllocateVmoCompleterBase : public _Base {
     public:
      void Reply(int32_t s, ::zx::vmo vmo);
      void Reply(::fidl::BytePart _buffer, int32_t s, ::zx::vmo vmo);
      void Reply(::fidl::DecodedMessage<AllocateVmoResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using AllocateVmoCompleter = ::fidl::Completer<AllocateVmoCompleterBase>;

    virtual void AllocateVmo(uint64_t size, AllocateVmoCompleter::Sync _completer) = 0;

    class CreateResourceCompleterBase : public _Base {
     public:
      void Reply(int32_t s, uint64_t id);
      void Reply(::fidl::BytePart _buffer, int32_t s, uint64_t id);
      void Reply(::fidl::DecodedMessage<CreateResourceResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using CreateResourceCompleter = ::fidl::Completer<CreateResourceCompleterBase>;

    virtual void CreateResource(::zx::vmo vmo, CreateResourceCompleter::Sync _completer) = 0;

    class DestroyResourceCompleterBase : public _Base {
     public:
      void Reply();

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using DestroyResourceCompleter = ::fidl::Completer<DestroyResourceCompleterBase>;

    virtual void DestroyResource(uint64_t id, DestroyResourceCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

};

extern "C" const fidl_type_t fuchsia_sysmem_DriverConnectorConnectRequestTable;
extern "C" const fidl_type_t fuchsia_sysmem_DriverConnectorGetProtectedMemoryInfoResponseTable;

class DriverConnector final {
 public:

  struct ConnectRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::channel allocator_request;

    static constexpr const fidl_type_t* Type = &fuchsia_sysmem_DriverConnectorConnectRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };

  struct GetProtectedMemoryInfoResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    uint64_t base_address;
    uint64_t size;

    static constexpr const fidl_type_t* Type = &fuchsia_sysmem_DriverConnectorGetProtectedMemoryInfoResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using GetProtectedMemoryInfoRequest = ::fidl::AnyZeroArgMessage;


  class SyncClient final {
   public:
    SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}

    ~SyncClient() {}

    zx_status_t Connect(::zx::channel allocator_request);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Connect(::fidl::BytePart _request_buffer, ::zx::channel allocator_request);

    // Messages are encoded and decoded in-place.
    zx_status_t Connect(::fidl::DecodedMessage<ConnectRequest> params);

    zx_status_t GetProtectedMemoryInfo(int32_t* out_status, uint64_t* out_base_address, uint64_t* out_size);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<GetProtectedMemoryInfoResponse> GetProtectedMemoryInfo(::fidl::BytePart _response_buffer, int32_t* out_status, uint64_t* out_base_address, uint64_t* out_size);

    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<GetProtectedMemoryInfoResponse> GetProtectedMemoryInfo(::fidl::BytePart response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
   public:

    static zx_status_t Connect(zx::unowned_channel _client_end, ::zx::channel allocator_request);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Connect(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel allocator_request);

    // Messages are encoded and decoded in-place.
    static zx_status_t Connect(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ConnectRequest> params);

    static zx_status_t GetProtectedMemoryInfo(zx::unowned_channel _client_end, int32_t* out_status, uint64_t* out_base_address, uint64_t* out_size);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<GetProtectedMemoryInfoResponse> GetProtectedMemoryInfo(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_status, uint64_t* out_base_address, uint64_t* out_size);

    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<GetProtectedMemoryInfoResponse> GetProtectedMemoryInfo(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = DriverConnector;
    using _Base = ::fidl::CompleterBase;

    using ConnectCompleter = ::fidl::Completer<>;

    virtual void Connect(::zx::channel allocator_request, ConnectCompleter::Sync _completer) = 0;

    class GetProtectedMemoryInfoCompleterBase : public _Base {
     public:
      void Reply(int32_t status, uint64_t base_address, uint64_t size);
      void Reply(::fidl::BytePart _buffer, int32_t status, uint64_t base_address, uint64_t size);
      void Reply(::fidl::DecodedMessage<GetProtectedMemoryInfoResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetProtectedMemoryInfoCompleter = ::fidl::Completer<GetProtectedMemoryInfoCompleterBase>;

    virtual void GetProtectedMemoryInfo(GetProtectedMemoryInfoCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

};

extern "C" const fidl_type_t fuchsia_sysmem_AllocatorAllocateNonSharedCollectionRequestTable;
extern "C" const fidl_type_t fuchsia_sysmem_AllocatorAllocateSharedCollectionRequestTable;
extern "C" const fidl_type_t fuchsia_sysmem_AllocatorBindSharedCollectionRequestTable;

class Allocator final {
 public:

  struct AllocateNonSharedCollectionRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::channel collection;

    static constexpr const fidl_type_t* Type = &fuchsia_sysmem_AllocatorAllocateNonSharedCollectionRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };

  struct AllocateSharedCollectionRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::channel token_request;

    static constexpr const fidl_type_t* Type = &fuchsia_sysmem_AllocatorAllocateSharedCollectionRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };

  struct BindSharedCollectionRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::channel token;
    ::zx::channel buffer_collection_request;

    static constexpr const fidl_type_t* Type = &fuchsia_sysmem_AllocatorBindSharedCollectionRequestTable;
    static constexpr uint32_t MaxNumHandles = 2;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };


  class SyncClient final {
   public:
    SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}

    ~SyncClient() {}

    zx_status_t AllocateNonSharedCollection(::zx::channel collection);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t AllocateNonSharedCollection(::fidl::BytePart _request_buffer, ::zx::channel collection);

    // Messages are encoded and decoded in-place.
    zx_status_t AllocateNonSharedCollection(::fidl::DecodedMessage<AllocateNonSharedCollectionRequest> params);

    zx_status_t AllocateSharedCollection(::zx::channel token_request);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t AllocateSharedCollection(::fidl::BytePart _request_buffer, ::zx::channel token_request);

    // Messages are encoded and decoded in-place.
    zx_status_t AllocateSharedCollection(::fidl::DecodedMessage<AllocateSharedCollectionRequest> params);

    zx_status_t BindSharedCollection(::zx::channel token, ::zx::channel buffer_collection_request);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t BindSharedCollection(::fidl::BytePart _request_buffer, ::zx::channel token, ::zx::channel buffer_collection_request);

    // Messages are encoded and decoded in-place.
    zx_status_t BindSharedCollection(::fidl::DecodedMessage<BindSharedCollectionRequest> params);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
   public:

    static zx_status_t AllocateNonSharedCollection(zx::unowned_channel _client_end, ::zx::channel collection);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t AllocateNonSharedCollection(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel collection);

    // Messages are encoded and decoded in-place.
    static zx_status_t AllocateNonSharedCollection(zx::unowned_channel _client_end, ::fidl::DecodedMessage<AllocateNonSharedCollectionRequest> params);

    static zx_status_t AllocateSharedCollection(zx::unowned_channel _client_end, ::zx::channel token_request);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t AllocateSharedCollection(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel token_request);

    // Messages are encoded and decoded in-place.
    static zx_status_t AllocateSharedCollection(zx::unowned_channel _client_end, ::fidl::DecodedMessage<AllocateSharedCollectionRequest> params);

    static zx_status_t BindSharedCollection(zx::unowned_channel _client_end, ::zx::channel token, ::zx::channel buffer_collection_request);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t BindSharedCollection(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel token, ::zx::channel buffer_collection_request);

    // Messages are encoded and decoded in-place.
    static zx_status_t BindSharedCollection(zx::unowned_channel _client_end, ::fidl::DecodedMessage<BindSharedCollectionRequest> params);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Allocator;
    using _Base = ::fidl::CompleterBase;

    using AllocateNonSharedCollectionCompleter = ::fidl::Completer<>;

    virtual void AllocateNonSharedCollection(::zx::channel collection, AllocateNonSharedCollectionCompleter::Sync _completer) = 0;

    using AllocateSharedCollectionCompleter = ::fidl::Completer<>;

    virtual void AllocateSharedCollection(::zx::channel token_request, AllocateSharedCollectionCompleter::Sync _completer) = 0;

    using BindSharedCollectionCompleter = ::fidl::Completer<>;

    virtual void BindSharedCollection(::zx::channel token, ::zx::channel buffer_collection_request, BindSharedCollectionCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

};



struct ImagePlane {
  static constexpr const fidl_type_t* Type = nullptr;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  uint32_t byte_offset{};

  uint32_t bytes_per_row{};
};

extern "C" const fidl_type_t fuchsia_sysmem_BufferMemoryConstraintsTable;

struct BufferMemoryConstraints {
  static constexpr const fidl_type_t* Type = &fuchsia_sysmem_BufferMemoryConstraintsTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 280;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  uint32_t min_size_bytes{};

  uint32_t max_size_bytes{};

  bool physically_contiguous_required{};

  // If true, at least one participant requires secure memory.
  //
  // When aggregating BufferCollectionConstraints, these values boolean-OR.
  bool secure_required{};

  // By default, participants must ensure the CPU can read or write data to
  // the buffer without cache operations. If they support using the RAM
  // domain, data must be available in RAM (with CPU cache state such that
  // the RAM data won't get corrupted by a dirty CPU cache line writing
  // incorrect data to RAM), and a consumer reading using the CPU must
  // invalidate CPU cache before reading (the producer doesn't guarantee
  // zero stale "clean" cache lines)
  bool ram_domain_supported{};

  bool cpu_domain_supported{};

  bool inaccessible_domain_supported{};

  // Optional heap constraints. Participants that don't care which heap
  // memory is allocated on should leave this field 0.
  uint32_t heap_permitted_count{};

  ::fidl::Array<HeapType, 32> heap_permitted{};
};



struct FormatModifier {
  static constexpr const fidl_type_t* Type = nullptr;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  // The upper 8 bits are a vendor code as allocated in FormatModifierVendor
  // enum.  The lower 56 bits are vendor-defined.
  //
  // This field and the values that go in this field are defined this way for
  // compatibility reasons.
  uint64_t value{};
};

extern "C" const fidl_type_t fuchsia_sysmem_PixelFormatTable;

struct PixelFormat {
  static constexpr const fidl_type_t* Type = &fuchsia_sysmem_PixelFormatTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  PixelFormatType type{};

  // This bool effectively makes format_modifier optional, to satisfy
  // 'Layout = "Simple"', to satisify "FIDL Simple C Bindings".
  bool has_format_modifier{};

  FormatModifier format_modifier{};
};

constexpr uint64_t FORMAT_MODIFIER_VENDOR_VIVANTE = 432345564227567616u;

constexpr uint64_t FORMAT_MODIFIER_VENDOR_SAMSUNG = 288230376151711744u;

constexpr uint64_t FORMAT_MODIFIER_VENDOR_QCOM = 360287970189639680u;

constexpr uint64_t FORMAT_MODIFIER_VENDOR_NVIDIA = 216172782113783808u;

constexpr uint64_t FORMAT_MODIFIER_VENDOR_NONE = 0u;

constexpr uint64_t FORMAT_MODIFIER_VENDOR_INTEL = 72057594037927936u;

constexpr uint64_t FORMAT_MODIFIER_VENDOR_BROADCOM = 504403158265495552u;

constexpr uint64_t FORMAT_MODIFIER_VENDOR_ARM = 576460752303423488u;

constexpr uint64_t FORMAT_MODIFIER_VENDOR_AMD = 144115188075855872u;

constexpr uint64_t FORMAT_MODIFIER_VALUE_RESERVED = 72057594037927935u;

constexpr uint64_t FORMAT_MODIFIER_INVALID = FORMAT_MODIFIER_VALUE_RESERVED;

constexpr uint64_t FORMAT_MODIFIER_NONE = 0u;

constexpr uint64_t FORMAT_MODIFIER_LINEAR = 0u;

constexpr uint64_t FORMAT_MODIFIER_INTEL_I915_Y_TILED = 72057594037927938u;

constexpr uint64_t FORMAT_MODIFIER_INTEL_I915_YF_TILED = 72057594037927939u;

constexpr uint64_t FORMAT_MODIFIER_INTEL_I915_X_TILED = 72057594037927937u;

constexpr uint64_t FORMAT_MODIFIER_ARM_AFBC_32x8 = 576460752303423490u;

constexpr uint64_t FORMAT_MODIFIER_ARM_AFBC_16x16 = 576460752303423489u;



struct ColorSpace {
  static constexpr const fidl_type_t* Type = nullptr;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  ColorSpaceType type{};
};

extern "C" const fidl_type_t fuchsia_sysmem_ImageSpecTable;

struct ImageSpec {
  static constexpr const fidl_type_t* Type = &fuchsia_sysmem_ImageSpecTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 40;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  uint32_t min_width{};

  uint32_t min_height{};

  uint32_t layers{};

  PixelFormat pixel_format{};

  ColorSpace color_space{};
};

extern "C" const fidl_type_t fuchsia_sysmem_BufferSpecTable;

struct BufferSpec {
  enum class Tag : fidl_union_tag_t {
    kImage = 0,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  BufferSpec();
  ~BufferSpec();

  BufferSpec(BufferSpec&& other) {
    tag_ = Tag::Invalid;
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
  }

  BufferSpec& operator=(BufferSpec&& other) {
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
    return *this;
  }

  bool has_invalid_tag() const { return tag_ == Tag::Invalid; }

  bool is_image() const { return tag_ == Tag::kImage; }

  ImageSpec& mutable_image();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ImageSpec>::value && std::is_copy_assignable<T>::value>
  set_image(const T& v) {
    mutable_image() = v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ImageSpec>::value && std::is_move_assignable<T>::value>
  set_image(T&& v) {
    mutable_image() = std::move(v);
  }

  ImageSpec const & image() const { return image_; }

  Tag which() const { return tag_; }

  static constexpr const fidl_type_t* Type = &fuchsia_sysmem_BufferSpecTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 48;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

 private:
  void Destroy();
  void MoveImpl_(BufferSpec&& other);
  static void SizeAndOffsetAssertionHelper();
  Tag tag_;
  union {
    ImageSpec image_;
  };
};

extern "C" const fidl_type_t fuchsia_sysmem_ImageFormat_2Table;

// Describes how an image is represented.
struct ImageFormat_2 {
  static constexpr const fidl_type_t* Type = &fuchsia_sysmem_ImageFormat_2Table;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 56;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  // Pixel format.
  PixelFormat pixel_format{};

  // Row width in pixels that exist in the buffer.  Must be >= display_width.
  // Can be < the width implied by stride_bytes.
  uint32_t coded_width{};

  // Number of rows.  Must be >= display_height.
  uint32_t coded_height{};

  uint32_t bytes_per_row{};

  // Row width in pixels that are to be displayed.  This can be <=
  // coded_width.  Any cropping occurs on the right of the image (not left).
  uint32_t display_width{};

  // Number of rows to be displayed.  This can be <= coded_height, with any
  // cropping on the bottom (not top).
  uint32_t display_height{};

  // Number of layers within a multi-layered image.
  uint32_t layers{};

  // Color space.
  ColorSpace color_space{};

  bool has_pixel_aspect_ratio{};

  uint32_t pixel_aspect_ratio_width{};

  uint32_t pixel_aspect_ratio_height{};
};

extern "C" const fidl_type_t fuchsia_sysmem_ImageFormatConstraintsTable;

// Describes constraints on layout of image data in buffers.
struct ImageFormatConstraints {
  static constexpr const fidl_type_t* Type = &fuchsia_sysmem_ImageFormatConstraintsTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 232;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  // The PixelFormat for which the following constraints apply.  A
  // participant may have more than one PixelFormat that's supported, in
  // which case that participant can use a list of ImageFormatConstraints
  // with an entry per PixelFormat.  It's not uncommon for the other fields
  // of ImageFormatConstraints to vary by PixelFormat - for example for a
  // linear format to support smaller max size than a tiled format.
  PixelFormat pixel_format{};

  // Empty is an error.  Redundant entries are an error.  Arbitrary ordering
  // is not an error.
  uint32_t color_spaces_count{};

  ::fidl::Array<ColorSpace, 32> color_space{};

  // Minimum permitted width in pixels.
  //
  // For example a video decoder participant may set this field to the
  // minimum coded_width that might potentially be specified by a stream.  In
  // contrast, required_min_coded_width would be set to the current
  // coded_width specified by the stream.  While min_coded_width aggregates
  // by taking the max, required_min_coded_width aggregates by taking the
  // min.
  //
  // See also required_min_coded_width.
  uint32_t min_coded_width{};

  // Maximum width in pixels.  For example Scenic may set this field
  // (directly or via sub-participants) to the maximum width that can be
  // composited.
  uint32_t max_coded_width{};

  // Minimum height in pixels.  For example a video decoder participant may
  // set this field to the coded_height specified by a stream.
  uint32_t min_coded_height{};

  // Maximum height in pixels.  For example Scenic may set this field
  // (directly or via sub-participants) to the maximum height that can be
  // composited.
  uint32_t max_coded_height{};

  // Must be >= the value implied by min_coded_width for plane 0.
  uint32_t min_bytes_per_row{};

  // Must be >= the value implied by max_coded_width for plane 0.
  uint32_t max_bytes_per_row{};

  // The max image area in pixels is limited indirectly via
  // BufferSettings.size_bytes, and can also be enforced directly via this
  // field.
  uint32_t max_coded_width_times_coded_height{};

  // Number of layers within a multi-layered image.
  // Defaults to 1 if not specified.
  uint32_t layers{};

  // coded_width % width_divisor must be 0.
  uint32_t coded_width_divisor{};

  // coded_height % height_divisor must be 0.
  uint32_t coded_height_divisor{};

  // bytes_per_row % bytes_per_row_divisor must be 0.
  uint32_t bytes_per_row_divisor{};

  // vmo_usable_start % start_offset_divisor must be 0.
  uint32_t start_offset_divisor{};

  // display_width % display_width_divisor must be 0.
  uint32_t display_width_divisor{};

  // display_height % display_height_divisor must be 0.
  uint32_t display_height_divisor{};

  // required_ dimension bounds.
  //
  // In contrast to the corresponding fields without "required_" at the
  // start, these fields (when set to non-zero values) express a requirement
  // that the resulting aggregated non-required_ fields specify a space that
  // fully contain the space expressed by each participant's required_
  // fields.
  //
  // For example, a producer video decoder is perfectly happy for the
  // consumer to be willing to accept anything, and the video decoder doesn't
  // really want to constrain the potential space of dimensions that might be
  // seen in a stream and may be acceptable to the consumer, but the video
  // decoder needs to ensure that the resulting dimension ranges contain
  // at least the current dimensions decoded from the stream.
  //
  // Similarly, an initiator with a particular dynamic-dimension scenario in
  // mind may wish to require up front that participants agree to handle at
  // least the range of dimensions expected by the initiator in that
  // scenario (else fail earlier rather than later, maybe trying again with
  // smaller required_ space).
  //
  // It's much more common for a producer or initiator to set these fields
  // than for a consumer to set these fields.
  //
  // While the non-required_ fields aggregate by taking the intersection, the
  // required_ fields aggregate by taking the union.
  uint32_t required_min_coded_width{};

  uint32_t required_max_coded_width{};

  uint32_t required_min_coded_height{};

  uint32_t required_max_coded_height{};

  uint32_t required_min_bytes_per_row{};

  uint32_t required_max_bytes_per_row{};
};

extern "C" const fidl_type_t fuchsia_sysmem_ImageFormatTable;

struct ImageFormat {
  static constexpr const fidl_type_t* Type = &fuchsia_sysmem_ImageFormatTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 72;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  uint32_t width{};

  uint32_t height{};

  uint32_t layers{};

  PixelFormat pixel_format{};

  ColorSpace color_space{};

  ::fidl::Array<ImagePlane, 4> planes{};
};

extern "C" const fidl_type_t fuchsia_sysmem_BufferFormatTable;

struct BufferFormat {
  enum class Tag : fidl_union_tag_t {
    kImage = 0,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  BufferFormat();
  ~BufferFormat();

  BufferFormat(BufferFormat&& other) {
    tag_ = Tag::Invalid;
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
  }

  BufferFormat& operator=(BufferFormat&& other) {
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
    return *this;
  }

  bool has_invalid_tag() const { return tag_ == Tag::Invalid; }

  bool is_image() const { return tag_ == Tag::kImage; }

  ImageFormat& mutable_image();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ImageFormat>::value && std::is_copy_assignable<T>::value>
  set_image(const T& v) {
    mutable_image() = v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ImageFormat>::value && std::is_move_assignable<T>::value>
  set_image(T&& v) {
    mutable_image() = std::move(v);
  }

  ImageFormat const & image() const { return image_; }

  Tag which() const { return tag_; }

  static constexpr const fidl_type_t* Type = &fuchsia_sysmem_BufferFormatTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 80;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

 private:
  void Destroy();
  void MoveImpl_(BufferFormat&& other);
  static void SizeAndOffsetAssertionHelper();
  Tag tag_;
  union {
    ImageFormat image_;
  };
};

extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionInfoTable;

struct BufferCollectionInfo {
  static constexpr const fidl_type_t* Type = &fuchsia_sysmem_BufferCollectionInfoTable;
  static constexpr uint32_t MaxNumHandles = 64;
  static constexpr uint32_t PrimarySize = 352;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  uint32_t buffer_count{};

  BufferFormat format{};

  ::fidl::Array<::zx::vmo, 64> vmos{};

  uint64_t vmo_size{};
};

extern "C" const fidl_type_t fuchsia_sysmem_BufferMemorySettingsTable;

struct BufferMemorySettings {
  static constexpr const fidl_type_t* Type = &fuchsia_sysmem_BufferMemorySettingsTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  uint32_t size_bytes{};

  bool is_physically_contiguous{};

  bool is_secure{};

  CoherencyDomain coherency_domain{};

  // The specific heap from which buffers are allocated.
  // See above in this file for heap identifier values.
  HeapType heap{};
};

extern "C" const fidl_type_t fuchsia_sysmem_SingleBufferSettingsTable;

struct SingleBufferSettings {
  static constexpr const fidl_type_t* Type = &fuchsia_sysmem_SingleBufferSettingsTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 264;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  BufferMemorySettings buffer_settings{};

  // Buffers holding data that is not uncompressed image data will not have
  // this field set.  Buffers holding data that is uncompressed image data
  // _may_ have this field set.
  //
  // At least for now, changing the PixelFormat requires re-allocating
  // buffers.
  bool has_image_format_constraints{};

  ImageFormatConstraints image_format_constraints{};
};

extern "C" const fidl_type_t fuchsia_sysmem_SingleBufferInfoTable;

struct SingleBufferInfo {
  static constexpr const fidl_type_t* Type = &fuchsia_sysmem_SingleBufferInfoTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 280;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  SingleBufferSettings settings{};

  VmoBuffer buffer{};
};

extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionInfo_2Table;

struct BufferCollectionInfo_2 {
  static constexpr const fidl_type_t* Type = &fuchsia_sysmem_BufferCollectionInfo_2Table;
  static constexpr uint32_t MaxNumHandles = 64;
  static constexpr uint32_t PrimarySize = 1296;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  uint32_t buffer_count{};

  SingleBufferSettings settings{};

  ::fidl::Array<VmoBuffer, 64> buffers{};
};

extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionEventsOnBuffersAllocatedRequestTable;
extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionEventsOnAllocateSingleBufferDoneRequestTable;

class BufferCollectionEvents final {
 public:

  using OnDuplicatedTokensKnownByServerRequest = ::fidl::AnyZeroArgMessage;

  struct OnBuffersAllocatedRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    BufferCollectionInfo_2 buffer_collection_info;

    static constexpr const fidl_type_t* Type = &fuchsia_sysmem_BufferCollectionEventsOnBuffersAllocatedRequestTable;
    static constexpr uint32_t MaxNumHandles = 64;
    static constexpr uint32_t PrimarySize = 1320;
    static constexpr uint32_t MaxOutOfLine = 0;
  };

  struct OnAllocateSingleBufferDoneRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    SingleBufferInfo buffer_info;

    static constexpr const fidl_type_t* Type = &fuchsia_sysmem_BufferCollectionEventsOnAllocateSingleBufferDoneRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 304;
    static constexpr uint32_t MaxOutOfLine = 0;
  };


  class SyncClient final {
   public:
    SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}

    ~SyncClient() {}

    zx_status_t OnDuplicatedTokensKnownByServer();

    zx_status_t OnBuffersAllocated(int32_t status, BufferCollectionInfo_2 buffer_collection_info);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t OnBuffersAllocated(::fidl::BytePart _request_buffer, int32_t status, BufferCollectionInfo_2 buffer_collection_info);

    // Messages are encoded and decoded in-place.
    zx_status_t OnBuffersAllocated(::fidl::DecodedMessage<OnBuffersAllocatedRequest> params);

    zx_status_t OnAllocateSingleBufferDone(int32_t status, SingleBufferInfo buffer_info);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t OnAllocateSingleBufferDone(::fidl::BytePart _request_buffer, int32_t status, SingleBufferInfo buffer_info);

    // Messages are encoded and decoded in-place.
    zx_status_t OnAllocateSingleBufferDone(::fidl::DecodedMessage<OnAllocateSingleBufferDoneRequest> params);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
   public:

    static zx_status_t OnDuplicatedTokensKnownByServer(zx::unowned_channel _client_end);

    static zx_status_t OnBuffersAllocated(zx::unowned_channel _client_end, int32_t status, BufferCollectionInfo_2 buffer_collection_info);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t OnBuffersAllocated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int32_t status, BufferCollectionInfo_2 buffer_collection_info);

    // Messages are encoded and decoded in-place.
    static zx_status_t OnBuffersAllocated(zx::unowned_channel _client_end, ::fidl::DecodedMessage<OnBuffersAllocatedRequest> params);

    static zx_status_t OnAllocateSingleBufferDone(zx::unowned_channel _client_end, int32_t status, SingleBufferInfo buffer_info);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t OnAllocateSingleBufferDone(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int32_t status, SingleBufferInfo buffer_info);

    // Messages are encoded and decoded in-place.
    static zx_status_t OnAllocateSingleBufferDone(zx::unowned_channel _client_end, ::fidl::DecodedMessage<OnAllocateSingleBufferDoneRequest> params);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = BufferCollectionEvents;
    using _Base = ::fidl::CompleterBase;

    using OnDuplicatedTokensKnownByServerCompleter = ::fidl::Completer<>;

    virtual void OnDuplicatedTokensKnownByServer(OnDuplicatedTokensKnownByServerCompleter::Sync _completer) = 0;

    using OnBuffersAllocatedCompleter = ::fidl::Completer<>;

    virtual void OnBuffersAllocated(int32_t status, BufferCollectionInfo_2 buffer_collection_info, OnBuffersAllocatedCompleter::Sync _completer) = 0;

    using OnAllocateSingleBufferDoneCompleter = ::fidl::Completer<>;

    virtual void OnAllocateSingleBufferDone(int32_t status, SingleBufferInfo buffer_info, OnAllocateSingleBufferDoneCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

};



struct BufferUsage {
  static constexpr const fidl_type_t* Type = nullptr;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  uint32_t cpu{};

  uint32_t vulkan{};

  uint32_t display{};

  uint32_t video{};
};

extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionConstraintsTable;

// Constraints on BufferCollection parameters.  These constraints can be
// specified per-participant.  The sysmem service implements aggregation of
// constraints from multiple participants.
struct BufferCollectionConstraints {
  static constexpr const fidl_type_t* Type = &fuchsia_sysmem_BufferCollectionConstraintsTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 7752;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  // The usage is only meant as a hint to help sysmem choose a more optimal
  // PixelFormat or similar when multiple compatible options exist.
  //
  // When aggregating BufferCollectionConstraints, these values bitwise-OR.
  //
  // At least one usage bit must be specified unless the whole
  // BufferCollectionConstraints is logically null due to !has_constraints.
  BufferUsage usage{};

  // Per-participant minimum number of buffers that are needed for camping
  // purposes.  A participant should specify a number for min_buffer_count
  // that's >= the maximum number of buffers that the participant may
  // concurrently camp on for any non-transient period of time.
  //
  // For example, a video decoder would specify (at least) the maximum number
  // of reference frames + 1 frame currently being decoded into.
  //
  // A participant must not camp on more buffers than specified here (except
  // very transiently) else processing may get stuck.
  //
  // When aggregating BufferCollectionConstraints, these values add.
  //
  // In testing scenarios, camping on more buffers than this for any
  // significant duration may (ideally will) be flagged as a failure.  In
  // testing scenarios, the participant may not be provided with more buffers
  // than this concurrently.
  uint32_t min_buffer_count_for_camping{};

  // Per-participant minimum number of buffers that are needed for slack
  // reasons, for better overlap of processing / better performance.
  //
  // When aggregating BufferCollectionConstraints, these values add.
  //
  // A participant should typically specify 0 or 1 here - typically 0 is
  // appropriate if min_buffer_count_for_camping is already enough to keep
  // the participant busy 100% of the time when the participant is slightly
  // behind, while 1 can be appropriate if 1 more buffer than strictly needed
  // for min-camping reasons gives enough slack to stay busy 100% of the time
  // (when slightly behind, vs. lower % without the extra buffer).
  //
  // In testing scenarios, this field may be forced to 0, and all
  // participants are expected to continue to work without getting stuck.  If
  // a buffer is needed for forward progress reasons, that buffer should be
  // accounted for in min_buffer_count_for_camping.
  uint32_t min_buffer_count_for_dedicated_slack{};

  // Similar to min_buffer_count_for_dedicated_slack, except when aggregating
  // these values max (instead of add).  The value here is not shared with
  // any participant's min_buffer_count_for_dedicated_slack.
  //
  // A participant can specify > 0 here if a participant would like to ensure
  // there's some slack overall, but doesn't need that slack to be dedicated.
  //
  // The choice whether to use min_buffer_count_for_dedicated_slack or
  // min_buffer_count_for_shared_slack (or both) will typically be about the
  // degree to which the extra slack improves performance.
  //
  // In testing scenarios, this field may be forced to 0, and all
  // participants are expected to continue to work without getting stuck.  If
  // a buffer is needed for forward progress reasons, that buffer should be
  // accounted for in min_buffer_count_for_camping.
  uint32_t min_buffer_count_for_shared_slack{};

  uint32_t min_buffer_count{};

  uint32_t max_buffer_count{};

  // Constraints on BufferCollectionSettings.buffer_settings.
  //
  // A participant that intends to specify image_format_constraints_count > 1
  // will typically specify the minimum buffer size implicitly via
  // image_format_constraints, and possibly specify only the max buffer size
  // via buffer_memory_constraints.
  bool has_buffer_memory_constraints{};

  BufferMemoryConstraints buffer_memory_constraints{};

  // Optional constraints on the image format parameters of an image stored
  // in a buffer of the BufferCollection.  This includes pixel format and
  // image layout.  These constraints are per-pixel-format, so more than one
  // is permitted.
  //
  // When aggregating, only pixel formats that are specified by all
  // particpants with non-zero image_format_constraints_count (and non-Null)
  // BufferCollectionConstraints) are retained.
  uint32_t image_format_constraints_count{};

  ::fidl::Array<ImageFormatConstraints, 32> image_format_constraints{};
};

extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionSetEventSinkRequestTable;
extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionSetConstraintsRequestTable;
extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionWaitForBuffersAllocatedResponseTable;
extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionCheckBuffersAllocatedResponseTable;
extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionWaitForSingleBufferAllocatedResponseTable;

class BufferCollection final {
 public:

  struct SetEventSinkRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::channel events;

    static constexpr const fidl_type_t* Type = &fuchsia_sysmem_BufferCollectionSetEventSinkRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };

  using SyncResponse = ::fidl::AnyZeroArgMessage;
  using SyncRequest = ::fidl::AnyZeroArgMessage;

  struct SetConstraintsRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    bool has_constraints;
    BufferCollectionConstraints constraints;

    static constexpr const fidl_type_t* Type = &fuchsia_sysmem_BufferCollectionSetConstraintsRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 7776;
    static constexpr uint32_t MaxOutOfLine = 0;
  };

  struct WaitForBuffersAllocatedResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    BufferCollectionInfo_2 buffer_collection_info;

    static constexpr const fidl_type_t* Type = &fuchsia_sysmem_BufferCollectionWaitForBuffersAllocatedResponseTable;
    static constexpr uint32_t MaxNumHandles = 64;
    static constexpr uint32_t PrimarySize = 1320;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using WaitForBuffersAllocatedRequest = ::fidl::AnyZeroArgMessage;

  struct CheckBuffersAllocatedResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;

    static constexpr const fidl_type_t* Type = &fuchsia_sysmem_BufferCollectionCheckBuffersAllocatedResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using CheckBuffersAllocatedRequest = ::fidl::AnyZeroArgMessage;

  struct CloseSingleBufferRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t buffer_index;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };

  struct AllocateSingleBufferRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t buffer_index;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };

  struct WaitForSingleBufferAllocatedResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    SingleBufferInfo buffer_info;

    static constexpr const fidl_type_t* Type = &fuchsia_sysmem_BufferCollectionWaitForSingleBufferAllocatedResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 304;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct WaitForSingleBufferAllocatedRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t buffer_index;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = WaitForSingleBufferAllocatedResponse;
  };

  struct CheckSingleBufferAllocatedRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t buffer_index;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };

  using CloseRequest = ::fidl::AnyZeroArgMessage;


  class SyncClient final {
   public:
    SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}

    ~SyncClient() {}

    zx_status_t SetEventSink(::zx::channel events);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t SetEventSink(::fidl::BytePart _request_buffer, ::zx::channel events);

    // Messages are encoded and decoded in-place.
    zx_status_t SetEventSink(::fidl::DecodedMessage<SetEventSinkRequest> params);

    zx_status_t Sync();

    zx_status_t SetConstraints(bool has_constraints, BufferCollectionConstraints constraints);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t SetConstraints(::fidl::BytePart _request_buffer, bool has_constraints, BufferCollectionConstraints constraints);

    // Messages are encoded and decoded in-place.
    zx_status_t SetConstraints(::fidl::DecodedMessage<SetConstraintsRequest> params);

    zx_status_t WaitForBuffersAllocated(int32_t* out_status, BufferCollectionInfo_2* out_buffer_collection_info);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<WaitForBuffersAllocatedResponse> WaitForBuffersAllocated(::fidl::BytePart _response_buffer, int32_t* out_status, BufferCollectionInfo_2* out_buffer_collection_info);

    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<WaitForBuffersAllocatedResponse> WaitForBuffersAllocated(::fidl::BytePart response_buffer);

    zx_status_t CheckBuffersAllocated(int32_t* out_status);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<CheckBuffersAllocatedResponse> CheckBuffersAllocated(::fidl::BytePart _response_buffer, int32_t* out_status);

    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<CheckBuffersAllocatedResponse> CheckBuffersAllocated(::fidl::BytePart response_buffer);

    zx_status_t CloseSingleBuffer(uint64_t buffer_index);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t CloseSingleBuffer(::fidl::BytePart _request_buffer, uint64_t buffer_index);

    // Messages are encoded and decoded in-place.
    zx_status_t CloseSingleBuffer(::fidl::DecodedMessage<CloseSingleBufferRequest> params);

    zx_status_t AllocateSingleBuffer(uint64_t buffer_index);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t AllocateSingleBuffer(::fidl::BytePart _request_buffer, uint64_t buffer_index);

    // Messages are encoded and decoded in-place.
    zx_status_t AllocateSingleBuffer(::fidl::DecodedMessage<AllocateSingleBufferRequest> params);

    zx_status_t WaitForSingleBufferAllocated(uint64_t buffer_index, int32_t* out_status, SingleBufferInfo* out_buffer_info);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<WaitForSingleBufferAllocatedResponse> WaitForSingleBufferAllocated(::fidl::BytePart _request_buffer, uint64_t buffer_index, ::fidl::BytePart _response_buffer, int32_t* out_status, SingleBufferInfo* out_buffer_info);

    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<WaitForSingleBufferAllocatedResponse> WaitForSingleBufferAllocated(::fidl::DecodedMessage<WaitForSingleBufferAllocatedRequest> params, ::fidl::BytePart response_buffer);

    zx_status_t CheckSingleBufferAllocated(uint64_t buffer_index);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t CheckSingleBufferAllocated(::fidl::BytePart _request_buffer, uint64_t buffer_index);

    // Messages are encoded and decoded in-place.
    zx_status_t CheckSingleBufferAllocated(::fidl::DecodedMessage<CheckSingleBufferAllocatedRequest> params);

    zx_status_t Close();

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
   public:

    static zx_status_t SetEventSink(zx::unowned_channel _client_end, ::zx::channel events);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t SetEventSink(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel events);

    // Messages are encoded and decoded in-place.
    static zx_status_t SetEventSink(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetEventSinkRequest> params);

    static zx_status_t Sync(zx::unowned_channel _client_end);

    static zx_status_t SetConstraints(zx::unowned_channel _client_end, bool has_constraints, BufferCollectionConstraints constraints);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t SetConstraints(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, bool has_constraints, BufferCollectionConstraints constraints);

    // Messages are encoded and decoded in-place.
    static zx_status_t SetConstraints(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetConstraintsRequest> params);

    static zx_status_t WaitForBuffersAllocated(zx::unowned_channel _client_end, int32_t* out_status, BufferCollectionInfo_2* out_buffer_collection_info);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<WaitForBuffersAllocatedResponse> WaitForBuffersAllocated(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_status, BufferCollectionInfo_2* out_buffer_collection_info);

    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<WaitForBuffersAllocatedResponse> WaitForBuffersAllocated(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    static zx_status_t CheckBuffersAllocated(zx::unowned_channel _client_end, int32_t* out_status);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<CheckBuffersAllocatedResponse> CheckBuffersAllocated(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_status);

    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<CheckBuffersAllocatedResponse> CheckBuffersAllocated(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    static zx_status_t CloseSingleBuffer(zx::unowned_channel _client_end, uint64_t buffer_index);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t CloseSingleBuffer(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t buffer_index);

    // Messages are encoded and decoded in-place.
    static zx_status_t CloseSingleBuffer(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CloseSingleBufferRequest> params);

    static zx_status_t AllocateSingleBuffer(zx::unowned_channel _client_end, uint64_t buffer_index);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t AllocateSingleBuffer(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t buffer_index);

    // Messages are encoded and decoded in-place.
    static zx_status_t AllocateSingleBuffer(zx::unowned_channel _client_end, ::fidl::DecodedMessage<AllocateSingleBufferRequest> params);

    static zx_status_t WaitForSingleBufferAllocated(zx::unowned_channel _client_end, uint64_t buffer_index, int32_t* out_status, SingleBufferInfo* out_buffer_info);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<WaitForSingleBufferAllocatedResponse> WaitForSingleBufferAllocated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t buffer_index, ::fidl::BytePart _response_buffer, int32_t* out_status, SingleBufferInfo* out_buffer_info);

    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<WaitForSingleBufferAllocatedResponse> WaitForSingleBufferAllocated(zx::unowned_channel _client_end, ::fidl::DecodedMessage<WaitForSingleBufferAllocatedRequest> params, ::fidl::BytePart response_buffer);

    static zx_status_t CheckSingleBufferAllocated(zx::unowned_channel _client_end, uint64_t buffer_index);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t CheckSingleBufferAllocated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t buffer_index);

    // Messages are encoded and decoded in-place.
    static zx_status_t CheckSingleBufferAllocated(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CheckSingleBufferAllocatedRequest> params);

    static zx_status_t Close(zx::unowned_channel _client_end);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = BufferCollection;
    using _Base = ::fidl::CompleterBase;

    using SetEventSinkCompleter = ::fidl::Completer<>;

    virtual void SetEventSink(::zx::channel events, SetEventSinkCompleter::Sync _completer) = 0;

    class SyncCompleterBase : public _Base {
     public:
      void Reply();

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SyncCompleter = ::fidl::Completer<SyncCompleterBase>;

    virtual void Sync(SyncCompleter::Sync _completer) = 0;

    using SetConstraintsCompleter = ::fidl::Completer<>;

    virtual void SetConstraints(bool has_constraints, BufferCollectionConstraints constraints, SetConstraintsCompleter::Sync _completer) = 0;

    class WaitForBuffersAllocatedCompleterBase : public _Base {
     public:
      void Reply(int32_t status, BufferCollectionInfo_2 buffer_collection_info);
      void Reply(::fidl::BytePart _buffer, int32_t status, BufferCollectionInfo_2 buffer_collection_info);
      void Reply(::fidl::DecodedMessage<WaitForBuffersAllocatedResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using WaitForBuffersAllocatedCompleter = ::fidl::Completer<WaitForBuffersAllocatedCompleterBase>;

    virtual void WaitForBuffersAllocated(WaitForBuffersAllocatedCompleter::Sync _completer) = 0;

    class CheckBuffersAllocatedCompleterBase : public _Base {
     public:
      void Reply(int32_t status);
      void Reply(::fidl::BytePart _buffer, int32_t status);
      void Reply(::fidl::DecodedMessage<CheckBuffersAllocatedResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using CheckBuffersAllocatedCompleter = ::fidl::Completer<CheckBuffersAllocatedCompleterBase>;

    virtual void CheckBuffersAllocated(CheckBuffersAllocatedCompleter::Sync _completer) = 0;

    using CloseSingleBufferCompleter = ::fidl::Completer<>;

    virtual void CloseSingleBuffer(uint64_t buffer_index, CloseSingleBufferCompleter::Sync _completer) = 0;

    using AllocateSingleBufferCompleter = ::fidl::Completer<>;

    virtual void AllocateSingleBuffer(uint64_t buffer_index, AllocateSingleBufferCompleter::Sync _completer) = 0;

    class WaitForSingleBufferAllocatedCompleterBase : public _Base {
     public:
      void Reply(int32_t status, SingleBufferInfo buffer_info);
      void Reply(::fidl::BytePart _buffer, int32_t status, SingleBufferInfo buffer_info);
      void Reply(::fidl::DecodedMessage<WaitForSingleBufferAllocatedResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using WaitForSingleBufferAllocatedCompleter = ::fidl::Completer<WaitForSingleBufferAllocatedCompleterBase>;

    virtual void WaitForSingleBufferAllocated(uint64_t buffer_index, WaitForSingleBufferAllocatedCompleter::Sync _completer) = 0;

    using CheckSingleBufferAllocatedCompleter = ::fidl::Completer<>;

    virtual void CheckSingleBufferAllocated(uint64_t buffer_index, CheckSingleBufferAllocatedCompleter::Sync _completer) = 0;

    using CloseCompleter = ::fidl::Completer<>;

    virtual void Close(CloseCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

};

}  // namespace sysmem
}  // namespace fuchsia

namespace fidl {

template <>
struct IsFidlType<::fuchsia::sysmem::VmoBuffer> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fuchsia::sysmem::VmoBuffer>);
static_assert(offsetof(::fuchsia::sysmem::VmoBuffer, vmo) == 0);
static_assert(offsetof(::fuchsia::sysmem::VmoBuffer, vmo_usable_start) == 8);
static_assert(sizeof(::fuchsia::sysmem::VmoBuffer) == ::fuchsia::sysmem::VmoBuffer::PrimarySize);

template <>
struct IsFidlType<::fuchsia::sysmem::BufferCollectionToken::DuplicateRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::sysmem::BufferCollectionToken::DuplicateRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::sysmem::BufferCollectionToken::DuplicateRequest)
    == ::fuchsia::sysmem::BufferCollectionToken::DuplicateRequest::PrimarySize);
static_assert(offsetof(::fuchsia::sysmem::BufferCollectionToken::DuplicateRequest, rights_attenuation_mask) == 16);
static_assert(offsetof(::fuchsia::sysmem::BufferCollectionToken::DuplicateRequest, token_request) == 20);

template <>
struct IsFidlType<::fuchsia::sysmem::Heap::AllocateVmoRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::sysmem::Heap::AllocateVmoRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::sysmem::Heap::AllocateVmoRequest)
    == ::fuchsia::sysmem::Heap::AllocateVmoRequest::PrimarySize);
static_assert(offsetof(::fuchsia::sysmem::Heap::AllocateVmoRequest, size) == 16);

template <>
struct IsFidlType<::fuchsia::sysmem::Heap::AllocateVmoResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::sysmem::Heap::AllocateVmoResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::sysmem::Heap::AllocateVmoResponse)
    == ::fuchsia::sysmem::Heap::AllocateVmoResponse::PrimarySize);
static_assert(offsetof(::fuchsia::sysmem::Heap::AllocateVmoResponse, s) == 16);
static_assert(offsetof(::fuchsia::sysmem::Heap::AllocateVmoResponse, vmo) == 20);

template <>
struct IsFidlType<::fuchsia::sysmem::Heap::CreateResourceRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::sysmem::Heap::CreateResourceRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::sysmem::Heap::CreateResourceRequest)
    == ::fuchsia::sysmem::Heap::CreateResourceRequest::PrimarySize);
static_assert(offsetof(::fuchsia::sysmem::Heap::CreateResourceRequest, vmo) == 16);

template <>
struct IsFidlType<::fuchsia::sysmem::Heap::CreateResourceResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::sysmem::Heap::CreateResourceResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::sysmem::Heap::CreateResourceResponse)
    == ::fuchsia::sysmem::Heap::CreateResourceResponse::PrimarySize);
static_assert(offsetof(::fuchsia::sysmem::Heap::CreateResourceResponse, s) == 16);
static_assert(offsetof(::fuchsia::sysmem::Heap::CreateResourceResponse, id) == 24);

template <>
struct IsFidlType<::fuchsia::sysmem::Heap::DestroyResourceRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::sysmem::Heap::DestroyResourceRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::sysmem::Heap::DestroyResourceRequest)
    == ::fuchsia::sysmem::Heap::DestroyResourceRequest::PrimarySize);
static_assert(offsetof(::fuchsia::sysmem::Heap::DestroyResourceRequest, id) == 16);

template <>
struct IsFidlType<::fuchsia::sysmem::DriverConnector::ConnectRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::sysmem::DriverConnector::ConnectRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::sysmem::DriverConnector::ConnectRequest)
    == ::fuchsia::sysmem::DriverConnector::ConnectRequest::PrimarySize);
static_assert(offsetof(::fuchsia::sysmem::DriverConnector::ConnectRequest, allocator_request) == 16);

template <>
struct IsFidlType<::fuchsia::sysmem::DriverConnector::GetProtectedMemoryInfoResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::sysmem::DriverConnector::GetProtectedMemoryInfoResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::sysmem::DriverConnector::GetProtectedMemoryInfoResponse)
    == ::fuchsia::sysmem::DriverConnector::GetProtectedMemoryInfoResponse::PrimarySize);
static_assert(offsetof(::fuchsia::sysmem::DriverConnector::GetProtectedMemoryInfoResponse, status) == 16);
static_assert(offsetof(::fuchsia::sysmem::DriverConnector::GetProtectedMemoryInfoResponse, base_address) == 24);
static_assert(offsetof(::fuchsia::sysmem::DriverConnector::GetProtectedMemoryInfoResponse, size) == 32);

template <>
struct IsFidlType<::fuchsia::sysmem::Allocator::AllocateNonSharedCollectionRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::sysmem::Allocator::AllocateNonSharedCollectionRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::sysmem::Allocator::AllocateNonSharedCollectionRequest)
    == ::fuchsia::sysmem::Allocator::AllocateNonSharedCollectionRequest::PrimarySize);
static_assert(offsetof(::fuchsia::sysmem::Allocator::AllocateNonSharedCollectionRequest, collection) == 16);

template <>
struct IsFidlType<::fuchsia::sysmem::Allocator::AllocateSharedCollectionRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::sysmem::Allocator::AllocateSharedCollectionRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::sysmem::Allocator::AllocateSharedCollectionRequest)
    == ::fuchsia::sysmem::Allocator::AllocateSharedCollectionRequest::PrimarySize);
static_assert(offsetof(::fuchsia::sysmem::Allocator::AllocateSharedCollectionRequest, token_request) == 16);

template <>
struct IsFidlType<::fuchsia::sysmem::Allocator::BindSharedCollectionRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::sysmem::Allocator::BindSharedCollectionRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::sysmem::Allocator::BindSharedCollectionRequest)
    == ::fuchsia::sysmem::Allocator::BindSharedCollectionRequest::PrimarySize);
static_assert(offsetof(::fuchsia::sysmem::Allocator::BindSharedCollectionRequest, token) == 16);
static_assert(offsetof(::fuchsia::sysmem::Allocator::BindSharedCollectionRequest, buffer_collection_request) == 20);

template <>
struct IsFidlType<::fuchsia::sysmem::ImagePlane> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fuchsia::sysmem::ImagePlane>);
static_assert(offsetof(::fuchsia::sysmem::ImagePlane, byte_offset) == 0);
static_assert(offsetof(::fuchsia::sysmem::ImagePlane, bytes_per_row) == 4);
static_assert(sizeof(::fuchsia::sysmem::ImagePlane) == ::fuchsia::sysmem::ImagePlane::PrimarySize);

template <>
struct IsFidlType<::fuchsia::sysmem::BufferMemoryConstraints> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fuchsia::sysmem::BufferMemoryConstraints>);
static_assert(offsetof(::fuchsia::sysmem::BufferMemoryConstraints, min_size_bytes) == 0);
static_assert(offsetof(::fuchsia::sysmem::BufferMemoryConstraints, max_size_bytes) == 4);
static_assert(offsetof(::fuchsia::sysmem::BufferMemoryConstraints, physically_contiguous_required) == 8);
static_assert(offsetof(::fuchsia::sysmem::BufferMemoryConstraints, secure_required) == 9);
static_assert(offsetof(::fuchsia::sysmem::BufferMemoryConstraints, ram_domain_supported) == 10);
static_assert(offsetof(::fuchsia::sysmem::BufferMemoryConstraints, cpu_domain_supported) == 11);
static_assert(offsetof(::fuchsia::sysmem::BufferMemoryConstraints, inaccessible_domain_supported) == 12);
static_assert(offsetof(::fuchsia::sysmem::BufferMemoryConstraints, heap_permitted_count) == 16);
static_assert(offsetof(::fuchsia::sysmem::BufferMemoryConstraints, heap_permitted) == 24);
static_assert(sizeof(::fuchsia::sysmem::BufferMemoryConstraints) == ::fuchsia::sysmem::BufferMemoryConstraints::PrimarySize);

template <>
struct IsFidlType<::fuchsia::sysmem::FormatModifier> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fuchsia::sysmem::FormatModifier>);
static_assert(offsetof(::fuchsia::sysmem::FormatModifier, value) == 0);
static_assert(sizeof(::fuchsia::sysmem::FormatModifier) == ::fuchsia::sysmem::FormatModifier::PrimarySize);

template <>
struct IsFidlType<::fuchsia::sysmem::PixelFormat> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fuchsia::sysmem::PixelFormat>);
static_assert(offsetof(::fuchsia::sysmem::PixelFormat, type) == 0);
static_assert(offsetof(::fuchsia::sysmem::PixelFormat, has_format_modifier) == 4);
static_assert(offsetof(::fuchsia::sysmem::PixelFormat, format_modifier) == 8);
static_assert(sizeof(::fuchsia::sysmem::PixelFormat) == ::fuchsia::sysmem::PixelFormat::PrimarySize);

template <>
struct IsFidlType<::fuchsia::sysmem::ColorSpace> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fuchsia::sysmem::ColorSpace>);
static_assert(offsetof(::fuchsia::sysmem::ColorSpace, type) == 0);
static_assert(sizeof(::fuchsia::sysmem::ColorSpace) == ::fuchsia::sysmem::ColorSpace::PrimarySize);

template <>
struct IsFidlType<::fuchsia::sysmem::ImageSpec> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fuchsia::sysmem::ImageSpec>);
static_assert(offsetof(::fuchsia::sysmem::ImageSpec, min_width) == 0);
static_assert(offsetof(::fuchsia::sysmem::ImageSpec, min_height) == 4);
static_assert(offsetof(::fuchsia::sysmem::ImageSpec, layers) == 8);
static_assert(offsetof(::fuchsia::sysmem::ImageSpec, pixel_format) == 16);
static_assert(offsetof(::fuchsia::sysmem::ImageSpec, color_space) == 32);
static_assert(sizeof(::fuchsia::sysmem::ImageSpec) == ::fuchsia::sysmem::ImageSpec::PrimarySize);

template <>
struct IsFidlType<::fuchsia::sysmem::BufferSpec> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fuchsia::sysmem::BufferSpec>);

template <>
struct IsFidlType<::fuchsia::sysmem::ImageFormat_2> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fuchsia::sysmem::ImageFormat_2>);
static_assert(offsetof(::fuchsia::sysmem::ImageFormat_2, pixel_format) == 0);
static_assert(offsetof(::fuchsia::sysmem::ImageFormat_2, coded_width) == 16);
static_assert(offsetof(::fuchsia::sysmem::ImageFormat_2, coded_height) == 20);
static_assert(offsetof(::fuchsia::sysmem::ImageFormat_2, bytes_per_row) == 24);
static_assert(offsetof(::fuchsia::sysmem::ImageFormat_2, display_width) == 28);
static_assert(offsetof(::fuchsia::sysmem::ImageFormat_2, display_height) == 32);
static_assert(offsetof(::fuchsia::sysmem::ImageFormat_2, layers) == 36);
static_assert(offsetof(::fuchsia::sysmem::ImageFormat_2, color_space) == 40);
static_assert(offsetof(::fuchsia::sysmem::ImageFormat_2, has_pixel_aspect_ratio) == 44);
static_assert(offsetof(::fuchsia::sysmem::ImageFormat_2, pixel_aspect_ratio_width) == 48);
static_assert(offsetof(::fuchsia::sysmem::ImageFormat_2, pixel_aspect_ratio_height) == 52);
static_assert(sizeof(::fuchsia::sysmem::ImageFormat_2) == ::fuchsia::sysmem::ImageFormat_2::PrimarySize);

template <>
struct IsFidlType<::fuchsia::sysmem::ImageFormatConstraints> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fuchsia::sysmem::ImageFormatConstraints>);
static_assert(offsetof(::fuchsia::sysmem::ImageFormatConstraints, pixel_format) == 0);
static_assert(offsetof(::fuchsia::sysmem::ImageFormatConstraints, color_spaces_count) == 16);
static_assert(offsetof(::fuchsia::sysmem::ImageFormatConstraints, color_space) == 20);
static_assert(offsetof(::fuchsia::sysmem::ImageFormatConstraints, min_coded_width) == 148);
static_assert(offsetof(::fuchsia::sysmem::ImageFormatConstraints, max_coded_width) == 152);
static_assert(offsetof(::fuchsia::sysmem::ImageFormatConstraints, min_coded_height) == 156);
static_assert(offsetof(::fuchsia::sysmem::ImageFormatConstraints, max_coded_height) == 160);
static_assert(offsetof(::fuchsia::sysmem::ImageFormatConstraints, min_bytes_per_row) == 164);
static_assert(offsetof(::fuchsia::sysmem::ImageFormatConstraints, max_bytes_per_row) == 168);
static_assert(offsetof(::fuchsia::sysmem::ImageFormatConstraints, max_coded_width_times_coded_height) == 172);
static_assert(offsetof(::fuchsia::sysmem::ImageFormatConstraints, layers) == 176);
static_assert(offsetof(::fuchsia::sysmem::ImageFormatConstraints, coded_width_divisor) == 180);
static_assert(offsetof(::fuchsia::sysmem::ImageFormatConstraints, coded_height_divisor) == 184);
static_assert(offsetof(::fuchsia::sysmem::ImageFormatConstraints, bytes_per_row_divisor) == 188);
static_assert(offsetof(::fuchsia::sysmem::ImageFormatConstraints, start_offset_divisor) == 192);
static_assert(offsetof(::fuchsia::sysmem::ImageFormatConstraints, display_width_divisor) == 196);
static_assert(offsetof(::fuchsia::sysmem::ImageFormatConstraints, display_height_divisor) == 200);
static_assert(offsetof(::fuchsia::sysmem::ImageFormatConstraints, required_min_coded_width) == 204);
static_assert(offsetof(::fuchsia::sysmem::ImageFormatConstraints, required_max_coded_width) == 208);
static_assert(offsetof(::fuchsia::sysmem::ImageFormatConstraints, required_min_coded_height) == 212);
static_assert(offsetof(::fuchsia::sysmem::ImageFormatConstraints, required_max_coded_height) == 216);
static_assert(offsetof(::fuchsia::sysmem::ImageFormatConstraints, required_min_bytes_per_row) == 220);
static_assert(offsetof(::fuchsia::sysmem::ImageFormatConstraints, required_max_bytes_per_row) == 224);
static_assert(sizeof(::fuchsia::sysmem::ImageFormatConstraints) == ::fuchsia::sysmem::ImageFormatConstraints::PrimarySize);

template <>
struct IsFidlType<::fuchsia::sysmem::ImageFormat> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fuchsia::sysmem::ImageFormat>);
static_assert(offsetof(::fuchsia::sysmem::ImageFormat, width) == 0);
static_assert(offsetof(::fuchsia::sysmem::ImageFormat, height) == 4);
static_assert(offsetof(::fuchsia::sysmem::ImageFormat, layers) == 8);
static_assert(offsetof(::fuchsia::sysmem::ImageFormat, pixel_format) == 16);
static_assert(offsetof(::fuchsia::sysmem::ImageFormat, color_space) == 32);
static_assert(offsetof(::fuchsia::sysmem::ImageFormat, planes) == 36);
static_assert(sizeof(::fuchsia::sysmem::ImageFormat) == ::fuchsia::sysmem::ImageFormat::PrimarySize);

template <>
struct IsFidlType<::fuchsia::sysmem::BufferFormat> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fuchsia::sysmem::BufferFormat>);

template <>
struct IsFidlType<::fuchsia::sysmem::BufferCollectionInfo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fuchsia::sysmem::BufferCollectionInfo>);
static_assert(offsetof(::fuchsia::sysmem::BufferCollectionInfo, buffer_count) == 0);
static_assert(offsetof(::fuchsia::sysmem::BufferCollectionInfo, format) == 8);
static_assert(offsetof(::fuchsia::sysmem::BufferCollectionInfo, vmos) == 88);
static_assert(offsetof(::fuchsia::sysmem::BufferCollectionInfo, vmo_size) == 344);
static_assert(sizeof(::fuchsia::sysmem::BufferCollectionInfo) == ::fuchsia::sysmem::BufferCollectionInfo::PrimarySize);

template <>
struct IsFidlType<::fuchsia::sysmem::BufferMemorySettings> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fuchsia::sysmem::BufferMemorySettings>);
static_assert(offsetof(::fuchsia::sysmem::BufferMemorySettings, size_bytes) == 0);
static_assert(offsetof(::fuchsia::sysmem::BufferMemorySettings, is_physically_contiguous) == 4);
static_assert(offsetof(::fuchsia::sysmem::BufferMemorySettings, is_secure) == 5);
static_assert(offsetof(::fuchsia::sysmem::BufferMemorySettings, coherency_domain) == 8);
static_assert(offsetof(::fuchsia::sysmem::BufferMemorySettings, heap) == 16);
static_assert(sizeof(::fuchsia::sysmem::BufferMemorySettings) == ::fuchsia::sysmem::BufferMemorySettings::PrimarySize);

template <>
struct IsFidlType<::fuchsia::sysmem::SingleBufferSettings> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fuchsia::sysmem::SingleBufferSettings>);
static_assert(offsetof(::fuchsia::sysmem::SingleBufferSettings, buffer_settings) == 0);
static_assert(offsetof(::fuchsia::sysmem::SingleBufferSettings, has_image_format_constraints) == 24);
static_assert(offsetof(::fuchsia::sysmem::SingleBufferSettings, image_format_constraints) == 32);
static_assert(sizeof(::fuchsia::sysmem::SingleBufferSettings) == ::fuchsia::sysmem::SingleBufferSettings::PrimarySize);

template <>
struct IsFidlType<::fuchsia::sysmem::SingleBufferInfo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fuchsia::sysmem::SingleBufferInfo>);
static_assert(offsetof(::fuchsia::sysmem::SingleBufferInfo, settings) == 0);
static_assert(offsetof(::fuchsia::sysmem::SingleBufferInfo, buffer) == 264);
static_assert(sizeof(::fuchsia::sysmem::SingleBufferInfo) == ::fuchsia::sysmem::SingleBufferInfo::PrimarySize);

template <>
struct IsFidlType<::fuchsia::sysmem::BufferCollectionInfo_2> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fuchsia::sysmem::BufferCollectionInfo_2>);
static_assert(offsetof(::fuchsia::sysmem::BufferCollectionInfo_2, buffer_count) == 0);
static_assert(offsetof(::fuchsia::sysmem::BufferCollectionInfo_2, settings) == 8);
static_assert(offsetof(::fuchsia::sysmem::BufferCollectionInfo_2, buffers) == 272);
static_assert(sizeof(::fuchsia::sysmem::BufferCollectionInfo_2) == ::fuchsia::sysmem::BufferCollectionInfo_2::PrimarySize);

template <>
struct IsFidlType<::fuchsia::sysmem::BufferCollectionEvents::OnBuffersAllocatedRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::sysmem::BufferCollectionEvents::OnBuffersAllocatedRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::sysmem::BufferCollectionEvents::OnBuffersAllocatedRequest)
    == ::fuchsia::sysmem::BufferCollectionEvents::OnBuffersAllocatedRequest::PrimarySize);
static_assert(offsetof(::fuchsia::sysmem::BufferCollectionEvents::OnBuffersAllocatedRequest, status) == 16);
static_assert(offsetof(::fuchsia::sysmem::BufferCollectionEvents::OnBuffersAllocatedRequest, buffer_collection_info) == 24);

template <>
struct IsFidlType<::fuchsia::sysmem::BufferCollectionEvents::OnAllocateSingleBufferDoneRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::sysmem::BufferCollectionEvents::OnAllocateSingleBufferDoneRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::sysmem::BufferCollectionEvents::OnAllocateSingleBufferDoneRequest)
    == ::fuchsia::sysmem::BufferCollectionEvents::OnAllocateSingleBufferDoneRequest::PrimarySize);
static_assert(offsetof(::fuchsia::sysmem::BufferCollectionEvents::OnAllocateSingleBufferDoneRequest, status) == 16);
static_assert(offsetof(::fuchsia::sysmem::BufferCollectionEvents::OnAllocateSingleBufferDoneRequest, buffer_info) == 24);

template <>
struct IsFidlType<::fuchsia::sysmem::BufferUsage> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fuchsia::sysmem::BufferUsage>);
static_assert(offsetof(::fuchsia::sysmem::BufferUsage, cpu) == 0);
static_assert(offsetof(::fuchsia::sysmem::BufferUsage, vulkan) == 4);
static_assert(offsetof(::fuchsia::sysmem::BufferUsage, display) == 8);
static_assert(offsetof(::fuchsia::sysmem::BufferUsage, video) == 12);
static_assert(sizeof(::fuchsia::sysmem::BufferUsage) == ::fuchsia::sysmem::BufferUsage::PrimarySize);

template <>
struct IsFidlType<::fuchsia::sysmem::BufferCollectionConstraints> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fuchsia::sysmem::BufferCollectionConstraints>);
static_assert(offsetof(::fuchsia::sysmem::BufferCollectionConstraints, usage) == 0);
static_assert(offsetof(::fuchsia::sysmem::BufferCollectionConstraints, min_buffer_count_for_camping) == 16);
static_assert(offsetof(::fuchsia::sysmem::BufferCollectionConstraints, min_buffer_count_for_dedicated_slack) == 20);
static_assert(offsetof(::fuchsia::sysmem::BufferCollectionConstraints, min_buffer_count_for_shared_slack) == 24);
static_assert(offsetof(::fuchsia::sysmem::BufferCollectionConstraints, min_buffer_count) == 28);
static_assert(offsetof(::fuchsia::sysmem::BufferCollectionConstraints, max_buffer_count) == 32);
static_assert(offsetof(::fuchsia::sysmem::BufferCollectionConstraints, has_buffer_memory_constraints) == 36);
static_assert(offsetof(::fuchsia::sysmem::BufferCollectionConstraints, buffer_memory_constraints) == 40);
static_assert(offsetof(::fuchsia::sysmem::BufferCollectionConstraints, image_format_constraints_count) == 320);
static_assert(offsetof(::fuchsia::sysmem::BufferCollectionConstraints, image_format_constraints) == 328);
static_assert(sizeof(::fuchsia::sysmem::BufferCollectionConstraints) == ::fuchsia::sysmem::BufferCollectionConstraints::PrimarySize);

template <>
struct IsFidlType<::fuchsia::sysmem::BufferCollection::SetEventSinkRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::sysmem::BufferCollection::SetEventSinkRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::sysmem::BufferCollection::SetEventSinkRequest)
    == ::fuchsia::sysmem::BufferCollection::SetEventSinkRequest::PrimarySize);
static_assert(offsetof(::fuchsia::sysmem::BufferCollection::SetEventSinkRequest, events) == 16);

template <>
struct IsFidlType<::fuchsia::sysmem::BufferCollection::SetConstraintsRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::sysmem::BufferCollection::SetConstraintsRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::sysmem::BufferCollection::SetConstraintsRequest)
    == ::fuchsia::sysmem::BufferCollection::SetConstraintsRequest::PrimarySize);
static_assert(offsetof(::fuchsia::sysmem::BufferCollection::SetConstraintsRequest, has_constraints) == 16);
static_assert(offsetof(::fuchsia::sysmem::BufferCollection::SetConstraintsRequest, constraints) == 24);

template <>
struct IsFidlType<::fuchsia::sysmem::BufferCollection::WaitForBuffersAllocatedResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::sysmem::BufferCollection::WaitForBuffersAllocatedResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::sysmem::BufferCollection::WaitForBuffersAllocatedResponse)
    == ::fuchsia::sysmem::BufferCollection::WaitForBuffersAllocatedResponse::PrimarySize);
static_assert(offsetof(::fuchsia::sysmem::BufferCollection::WaitForBuffersAllocatedResponse, status) == 16);
static_assert(offsetof(::fuchsia::sysmem::BufferCollection::WaitForBuffersAllocatedResponse, buffer_collection_info) == 24);

template <>
struct IsFidlType<::fuchsia::sysmem::BufferCollection::CheckBuffersAllocatedResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::sysmem::BufferCollection::CheckBuffersAllocatedResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::sysmem::BufferCollection::CheckBuffersAllocatedResponse)
    == ::fuchsia::sysmem::BufferCollection::CheckBuffersAllocatedResponse::PrimarySize);
static_assert(offsetof(::fuchsia::sysmem::BufferCollection::CheckBuffersAllocatedResponse, status) == 16);

template <>
struct IsFidlType<::fuchsia::sysmem::BufferCollection::CloseSingleBufferRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::sysmem::BufferCollection::CloseSingleBufferRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::sysmem::BufferCollection::CloseSingleBufferRequest)
    == ::fuchsia::sysmem::BufferCollection::CloseSingleBufferRequest::PrimarySize);
static_assert(offsetof(::fuchsia::sysmem::BufferCollection::CloseSingleBufferRequest, buffer_index) == 16);

template <>
struct IsFidlType<::fuchsia::sysmem::BufferCollection::AllocateSingleBufferRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::sysmem::BufferCollection::AllocateSingleBufferRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::sysmem::BufferCollection::AllocateSingleBufferRequest)
    == ::fuchsia::sysmem::BufferCollection::AllocateSingleBufferRequest::PrimarySize);
static_assert(offsetof(::fuchsia::sysmem::BufferCollection::AllocateSingleBufferRequest, buffer_index) == 16);

template <>
struct IsFidlType<::fuchsia::sysmem::BufferCollection::WaitForSingleBufferAllocatedRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::sysmem::BufferCollection::WaitForSingleBufferAllocatedRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::sysmem::BufferCollection::WaitForSingleBufferAllocatedRequest)
    == ::fuchsia::sysmem::BufferCollection::WaitForSingleBufferAllocatedRequest::PrimarySize);
static_assert(offsetof(::fuchsia::sysmem::BufferCollection::WaitForSingleBufferAllocatedRequest, buffer_index) == 16);

template <>
struct IsFidlType<::fuchsia::sysmem::BufferCollection::WaitForSingleBufferAllocatedResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::sysmem::BufferCollection::WaitForSingleBufferAllocatedResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::sysmem::BufferCollection::WaitForSingleBufferAllocatedResponse)
    == ::fuchsia::sysmem::BufferCollection::WaitForSingleBufferAllocatedResponse::PrimarySize);
static_assert(offsetof(::fuchsia::sysmem::BufferCollection::WaitForSingleBufferAllocatedResponse, status) == 16);
static_assert(offsetof(::fuchsia::sysmem::BufferCollection::WaitForSingleBufferAllocatedResponse, buffer_info) == 24);

template <>
struct IsFidlType<::fuchsia::sysmem::BufferCollection::CheckSingleBufferAllocatedRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::sysmem::BufferCollection::CheckSingleBufferAllocatedRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::sysmem::BufferCollection::CheckSingleBufferAllocatedRequest)
    == ::fuchsia::sysmem::BufferCollection::CheckSingleBufferAllocatedRequest::PrimarySize);
static_assert(offsetof(::fuchsia::sysmem::BufferCollection::CheckSingleBufferAllocatedRequest, buffer_index) == 16);

}  // namespace fidl

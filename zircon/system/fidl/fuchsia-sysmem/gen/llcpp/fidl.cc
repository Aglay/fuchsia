// WARNING: This file is machine generated by fidlgen.

#include <fuchsia/sysmem/llcpp/fidl.h>
#include <memory>

namespace llcpp {

namespace fuchsia {
namespace sysmem {

namespace {

[[maybe_unused]]
constexpr uint64_t kBufferCollectionToken_Duplicate_Ordinal = 0x5e37401300000000lu;
extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionTokenDuplicateRequestTable;
[[maybe_unused]]
constexpr uint64_t kBufferCollectionToken_Sync_Ordinal = 0x3218cf6000000000lu;
[[maybe_unused]]
constexpr uint64_t kBufferCollectionToken_Close_Ordinal = 0x21ba753500000000lu;

}  // namespace

BufferCollectionToken::ResultOf::Duplicate_Impl::Duplicate_Impl(zx::unowned_channel _client_end, uint32_t rights_attenuation_mask, ::zx::channel token_request) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DuplicateRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, DuplicateRequest::PrimarySize);
  auto& _request = *reinterpret_cast<DuplicateRequest*>(_write_bytes);
  _request.rights_attenuation_mask = std::move(rights_attenuation_mask);
  _request.token_request = std::move(token_request);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(DuplicateRequest));
  ::fidl::DecodedMessage<DuplicateRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      BufferCollectionToken::InPlace::Duplicate(std::move(_client_end), std::move(_decoded_request)));
}

BufferCollectionToken::ResultOf::Duplicate BufferCollectionToken::SyncClient::Duplicate(uint32_t rights_attenuation_mask, ::zx::channel token_request) {
  return ResultOf::Duplicate(zx::unowned_channel(this->channel_), std::move(rights_attenuation_mask), std::move(token_request));
}

BufferCollectionToken::ResultOf::Duplicate BufferCollectionToken::Call::Duplicate(zx::unowned_channel _client_end, uint32_t rights_attenuation_mask, ::zx::channel token_request) {
  return ResultOf::Duplicate(std::move(_client_end), std::move(rights_attenuation_mask), std::move(token_request));
}


BufferCollectionToken::UnownedResultOf::Duplicate_Impl::Duplicate_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t rights_attenuation_mask, ::zx::channel token_request) {
  if (_request_buffer.capacity() < DuplicateRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, DuplicateRequest::PrimarySize);
  auto& _request = *reinterpret_cast<DuplicateRequest*>(_request_buffer.data());
  _request.rights_attenuation_mask = std::move(rights_attenuation_mask);
  _request.token_request = std::move(token_request);
  _request_buffer.set_actual(sizeof(DuplicateRequest));
  ::fidl::DecodedMessage<DuplicateRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      BufferCollectionToken::InPlace::Duplicate(std::move(_client_end), std::move(_decoded_request)));
}

BufferCollectionToken::UnownedResultOf::Duplicate BufferCollectionToken::SyncClient::Duplicate(::fidl::BytePart _request_buffer, uint32_t rights_attenuation_mask, ::zx::channel token_request) {
  return UnownedResultOf::Duplicate(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(rights_attenuation_mask), std::move(token_request));
}

BufferCollectionToken::UnownedResultOf::Duplicate BufferCollectionToken::Call::Duplicate(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t rights_attenuation_mask, ::zx::channel token_request) {
  return UnownedResultOf::Duplicate(std::move(_client_end), std::move(_request_buffer), std::move(rights_attenuation_mask), std::move(token_request));
}

::fidl::internal::StatusAndError BufferCollectionToken::InPlace::Duplicate(zx::unowned_channel _client_end, ::fidl::DecodedMessage<DuplicateRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kBufferCollectionToken_Duplicate_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
BufferCollectionToken::ResultOf::Sync_Impl<BufferCollectionToken::SyncResponse>::Sync_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SyncRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      BufferCollectionToken::InPlace::Sync(std::move(_client_end), Super::response_buffer()));
}

BufferCollectionToken::ResultOf::Sync BufferCollectionToken::SyncClient::Sync() {
  return ResultOf::Sync(zx::unowned_channel(this->channel_));
}

BufferCollectionToken::ResultOf::Sync BufferCollectionToken::Call::Sync(zx::unowned_channel _client_end) {
  return ResultOf::Sync(std::move(_client_end));
}

::fidl::DecodeResult<BufferCollectionToken::SyncResponse> BufferCollectionToken::InPlace::Sync(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(SyncRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<SyncRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kBufferCollectionToken_Sync_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<BufferCollectionToken::SyncResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SyncRequest, SyncResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<BufferCollectionToken::SyncResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


BufferCollectionToken::ResultOf::Close_Impl::Close_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CloseRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseRequest));
  ::fidl::DecodedMessage<CloseRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      BufferCollectionToken::InPlace::Close(std::move(_client_end)));
}

BufferCollectionToken::ResultOf::Close BufferCollectionToken::SyncClient::Close() {
  return ResultOf::Close(zx::unowned_channel(this->channel_));
}

BufferCollectionToken::ResultOf::Close BufferCollectionToken::Call::Close(zx::unowned_channel _client_end) {
  return ResultOf::Close(std::move(_client_end));
}

::fidl::internal::StatusAndError BufferCollectionToken::InPlace::Close(zx::unowned_channel _client_end) {
  constexpr uint32_t _write_num_bytes = sizeof(CloseRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<CloseRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kBufferCollectionToken_Close_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


bool BufferCollectionToken::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kBufferCollectionToken_Duplicate_Ordinal:
    {
      auto result = ::fidl::DecodeAs<DuplicateRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Duplicate(std::move(message->rights_attenuation_mask), std::move(message->token_request),
        Interface::DuplicateCompleter::Sync(txn));
      return true;
    }
    case kBufferCollectionToken_Sync_Ordinal:
    {
      auto result = ::fidl::DecodeAs<SyncRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Sync(
        Interface::SyncCompleter::Sync(txn));
      return true;
    }
    case kBufferCollectionToken_Close_Ordinal:
    {
      auto result = ::fidl::DecodeAs<CloseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Close(
        Interface::CloseCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool BufferCollectionToken::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void BufferCollectionToken::Interface::SyncCompleterBase::Reply() {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SyncResponse*>(_write_bytes);
  _response._hdr.ordinal = kBufferCollectionToken_Sync_Ordinal;
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SyncResponse>(std::move(_response_bytes)));
}


namespace {

[[maybe_unused]]
constexpr uint64_t kHeap_AllocateVmo_Ordinal = 0xbb99f8d00000000lu;
extern "C" const fidl_type_t fuchsia_sysmem_HeapAllocateVmoResponseTable;
[[maybe_unused]]
constexpr uint64_t kHeap_CreateResource_Ordinal = 0x35a990c200000000lu;
extern "C" const fidl_type_t fuchsia_sysmem_HeapCreateResourceRequestTable;
extern "C" const fidl_type_t fuchsia_sysmem_HeapCreateResourceResponseTable;
[[maybe_unused]]
constexpr uint64_t kHeap_DestroyResource_Ordinal = 0x27df37a100000000lu;

}  // namespace
template <>
Heap::ResultOf::AllocateVmo_Impl<Heap::AllocateVmoResponse>::AllocateVmo_Impl(zx::unowned_channel _client_end, uint64_t size) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<AllocateVmoRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, AllocateVmoRequest::PrimarySize);
  auto& _request = *reinterpret_cast<AllocateVmoRequest*>(_write_bytes);
  _request.size = std::move(size);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(AllocateVmoRequest));
  ::fidl::DecodedMessage<AllocateVmoRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Heap::InPlace::AllocateVmo(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Heap::ResultOf::AllocateVmo Heap::SyncClient::AllocateVmo(uint64_t size) {
  return ResultOf::AllocateVmo(zx::unowned_channel(this->channel_), std::move(size));
}

Heap::ResultOf::AllocateVmo Heap::Call::AllocateVmo(zx::unowned_channel _client_end, uint64_t size) {
  return ResultOf::AllocateVmo(std::move(_client_end), std::move(size));
}

template <>
Heap::UnownedResultOf::AllocateVmo_Impl<Heap::AllocateVmoResponse>::AllocateVmo_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t size, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < AllocateVmoRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<AllocateVmoResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, AllocateVmoRequest::PrimarySize);
  auto& _request = *reinterpret_cast<AllocateVmoRequest*>(_request_buffer.data());
  _request.size = std::move(size);
  _request_buffer.set_actual(sizeof(AllocateVmoRequest));
  ::fidl::DecodedMessage<AllocateVmoRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Heap::InPlace::AllocateVmo(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Heap::UnownedResultOf::AllocateVmo Heap::SyncClient::AllocateVmo(::fidl::BytePart _request_buffer, uint64_t size, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::AllocateVmo(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(size), std::move(_response_buffer));
}

Heap::UnownedResultOf::AllocateVmo Heap::Call::AllocateVmo(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t size, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::AllocateVmo(std::move(_client_end), std::move(_request_buffer), std::move(size), std::move(_response_buffer));
}

::fidl::DecodeResult<Heap::AllocateVmoResponse> Heap::InPlace::AllocateVmo(zx::unowned_channel _client_end, ::fidl::DecodedMessage<AllocateVmoRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kHeap_AllocateVmo_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Heap::AllocateVmoResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<AllocateVmoRequest, AllocateVmoResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Heap::AllocateVmoResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Heap::ResultOf::CreateResource_Impl<Heap::CreateResourceResponse>::CreateResource_Impl(zx::unowned_channel _client_end, ::zx::vmo vmo) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CreateResourceRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CreateResourceRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CreateResourceRequest*>(_write_bytes);
  _request.vmo = std::move(vmo);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CreateResourceRequest));
  ::fidl::DecodedMessage<CreateResourceRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Heap::InPlace::CreateResource(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Heap::ResultOf::CreateResource Heap::SyncClient::CreateResource(::zx::vmo vmo) {
  return ResultOf::CreateResource(zx::unowned_channel(this->channel_), std::move(vmo));
}

Heap::ResultOf::CreateResource Heap::Call::CreateResource(zx::unowned_channel _client_end, ::zx::vmo vmo) {
  return ResultOf::CreateResource(std::move(_client_end), std::move(vmo));
}

template <>
Heap::UnownedResultOf::CreateResource_Impl<Heap::CreateResourceResponse>::CreateResource_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::vmo vmo, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < CreateResourceRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<CreateResourceResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, CreateResourceRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CreateResourceRequest*>(_request_buffer.data());
  _request.vmo = std::move(vmo);
  _request_buffer.set_actual(sizeof(CreateResourceRequest));
  ::fidl::DecodedMessage<CreateResourceRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Heap::InPlace::CreateResource(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Heap::UnownedResultOf::CreateResource Heap::SyncClient::CreateResource(::fidl::BytePart _request_buffer, ::zx::vmo vmo, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::CreateResource(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(vmo), std::move(_response_buffer));
}

Heap::UnownedResultOf::CreateResource Heap::Call::CreateResource(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::vmo vmo, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::CreateResource(std::move(_client_end), std::move(_request_buffer), std::move(vmo), std::move(_response_buffer));
}

::fidl::DecodeResult<Heap::CreateResourceResponse> Heap::InPlace::CreateResource(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CreateResourceRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kHeap_CreateResource_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Heap::CreateResourceResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<CreateResourceRequest, CreateResourceResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Heap::CreateResourceResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Heap::ResultOf::DestroyResource_Impl<Heap::DestroyResourceResponse>::DestroyResource_Impl(zx::unowned_channel _client_end, uint64_t id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DestroyResourceRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, DestroyResourceRequest::PrimarySize);
  auto& _request = *reinterpret_cast<DestroyResourceRequest*>(_write_bytes);
  _request.id = std::move(id);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(DestroyResourceRequest));
  ::fidl::DecodedMessage<DestroyResourceRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Heap::InPlace::DestroyResource(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Heap::ResultOf::DestroyResource Heap::SyncClient::DestroyResource(uint64_t id) {
  return ResultOf::DestroyResource(zx::unowned_channel(this->channel_), std::move(id));
}

Heap::ResultOf::DestroyResource Heap::Call::DestroyResource(zx::unowned_channel _client_end, uint64_t id) {
  return ResultOf::DestroyResource(std::move(_client_end), std::move(id));
}

template <>
Heap::UnownedResultOf::DestroyResource_Impl<Heap::DestroyResourceResponse>::DestroyResource_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t id, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < DestroyResourceRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<DestroyResourceResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, DestroyResourceRequest::PrimarySize);
  auto& _request = *reinterpret_cast<DestroyResourceRequest*>(_request_buffer.data());
  _request.id = std::move(id);
  _request_buffer.set_actual(sizeof(DestroyResourceRequest));
  ::fidl::DecodedMessage<DestroyResourceRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Heap::InPlace::DestroyResource(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Heap::UnownedResultOf::DestroyResource Heap::SyncClient::DestroyResource(::fidl::BytePart _request_buffer, uint64_t id, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::DestroyResource(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(id), std::move(_response_buffer));
}

Heap::UnownedResultOf::DestroyResource Heap::Call::DestroyResource(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t id, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::DestroyResource(std::move(_client_end), std::move(_request_buffer), std::move(id), std::move(_response_buffer));
}

::fidl::DecodeResult<Heap::DestroyResourceResponse> Heap::InPlace::DestroyResource(zx::unowned_channel _client_end, ::fidl::DecodedMessage<DestroyResourceRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kHeap_DestroyResource_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Heap::DestroyResourceResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<DestroyResourceRequest, DestroyResourceResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Heap::DestroyResourceResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool Heap::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kHeap_AllocateVmo_Ordinal:
    {
      auto result = ::fidl::DecodeAs<AllocateVmoRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->AllocateVmo(std::move(message->size),
        Interface::AllocateVmoCompleter::Sync(txn));
      return true;
    }
    case kHeap_CreateResource_Ordinal:
    {
      auto result = ::fidl::DecodeAs<CreateResourceRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->CreateResource(std::move(message->vmo),
        Interface::CreateResourceCompleter::Sync(txn));
      return true;
    }
    case kHeap_DestroyResource_Ordinal:
    {
      auto result = ::fidl::DecodeAs<DestroyResourceRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->DestroyResource(std::move(message->id),
        Interface::DestroyResourceCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Heap::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void Heap::Interface::AllocateVmoCompleterBase::Reply(int32_t s, ::zx::vmo vmo) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<AllocateVmoResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<AllocateVmoResponse*>(_write_bytes);
  _response._hdr.ordinal = kHeap_AllocateVmo_Ordinal;
  _response.s = std::move(s);
  _response.vmo = std::move(vmo);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(AllocateVmoResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<AllocateVmoResponse>(std::move(_response_bytes)));
}

void Heap::Interface::AllocateVmoCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, ::zx::vmo vmo) {
  if (_buffer.capacity() < AllocateVmoResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<AllocateVmoResponse*>(_buffer.data());
  _response._hdr.ordinal = kHeap_AllocateVmo_Ordinal;
  _response.s = std::move(s);
  _response.vmo = std::move(vmo);
  _buffer.set_actual(sizeof(AllocateVmoResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<AllocateVmoResponse>(std::move(_buffer)));
}

void Heap::Interface::AllocateVmoCompleterBase::Reply(::fidl::DecodedMessage<AllocateVmoResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kHeap_AllocateVmo_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Heap::Interface::CreateResourceCompleterBase::Reply(int32_t s, uint64_t id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CreateResourceResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<CreateResourceResponse*>(_write_bytes);
  _response._hdr.ordinal = kHeap_CreateResource_Ordinal;
  _response.s = std::move(s);
  _response.id = std::move(id);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(CreateResourceResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CreateResourceResponse>(std::move(_response_bytes)));
}

void Heap::Interface::CreateResourceCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, uint64_t id) {
  if (_buffer.capacity() < CreateResourceResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<CreateResourceResponse*>(_buffer.data());
  _response._hdr.ordinal = kHeap_CreateResource_Ordinal;
  _response.s = std::move(s);
  _response.id = std::move(id);
  _buffer.set_actual(sizeof(CreateResourceResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CreateResourceResponse>(std::move(_buffer)));
}

void Heap::Interface::CreateResourceCompleterBase::Reply(::fidl::DecodedMessage<CreateResourceResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kHeap_CreateResource_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Heap::Interface::DestroyResourceCompleterBase::Reply() {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DestroyResourceResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<DestroyResourceResponse*>(_write_bytes);
  _response._hdr.ordinal = kHeap_DestroyResource_Ordinal;
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(DestroyResourceResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<DestroyResourceResponse>(std::move(_response_bytes)));
}


namespace {

[[maybe_unused]]
constexpr uint64_t kDriverConnector_Connect_Ordinal = 0x3082e03400000000lu;
extern "C" const fidl_type_t fuchsia_sysmem_DriverConnectorConnectRequestTable;
[[maybe_unused]]
constexpr uint64_t kDriverConnector_GetProtectedMemoryInfo_Ordinal = 0x10d8a27100000000lu;
extern "C" const fidl_type_t fuchsia_sysmem_DriverConnectorGetProtectedMemoryInfoResponseTable;

}  // namespace

DriverConnector::ResultOf::Connect_Impl::Connect_Impl(zx::unowned_channel _client_end, ::zx::channel allocator_request) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ConnectRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ConnectRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ConnectRequest*>(_write_bytes);
  _request.allocator_request = std::move(allocator_request);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ConnectRequest));
  ::fidl::DecodedMessage<ConnectRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      DriverConnector::InPlace::Connect(std::move(_client_end), std::move(_decoded_request)));
}

DriverConnector::ResultOf::Connect DriverConnector::SyncClient::Connect(::zx::channel allocator_request) {
  return ResultOf::Connect(zx::unowned_channel(this->channel_), std::move(allocator_request));
}

DriverConnector::ResultOf::Connect DriverConnector::Call::Connect(zx::unowned_channel _client_end, ::zx::channel allocator_request) {
  return ResultOf::Connect(std::move(_client_end), std::move(allocator_request));
}


DriverConnector::UnownedResultOf::Connect_Impl::Connect_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel allocator_request) {
  if (_request_buffer.capacity() < ConnectRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, ConnectRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ConnectRequest*>(_request_buffer.data());
  _request.allocator_request = std::move(allocator_request);
  _request_buffer.set_actual(sizeof(ConnectRequest));
  ::fidl::DecodedMessage<ConnectRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      DriverConnector::InPlace::Connect(std::move(_client_end), std::move(_decoded_request)));
}

DriverConnector::UnownedResultOf::Connect DriverConnector::SyncClient::Connect(::fidl::BytePart _request_buffer, ::zx::channel allocator_request) {
  return UnownedResultOf::Connect(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(allocator_request));
}

DriverConnector::UnownedResultOf::Connect DriverConnector::Call::Connect(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel allocator_request) {
  return UnownedResultOf::Connect(std::move(_client_end), std::move(_request_buffer), std::move(allocator_request));
}

::fidl::internal::StatusAndError DriverConnector::InPlace::Connect(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ConnectRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDriverConnector_Connect_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
DriverConnector::ResultOf::GetProtectedMemoryInfo_Impl<DriverConnector::GetProtectedMemoryInfoResponse>::GetProtectedMemoryInfo_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetProtectedMemoryInfoRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetProtectedMemoryInfoRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetProtectedMemoryInfoRequest));
  ::fidl::DecodedMessage<GetProtectedMemoryInfoRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      DriverConnector::InPlace::GetProtectedMemoryInfo(std::move(_client_end), Super::response_buffer()));
}

DriverConnector::ResultOf::GetProtectedMemoryInfo DriverConnector::SyncClient::GetProtectedMemoryInfo() {
  return ResultOf::GetProtectedMemoryInfo(zx::unowned_channel(this->channel_));
}

DriverConnector::ResultOf::GetProtectedMemoryInfo DriverConnector::Call::GetProtectedMemoryInfo(zx::unowned_channel _client_end) {
  return ResultOf::GetProtectedMemoryInfo(std::move(_client_end));
}

template <>
DriverConnector::UnownedResultOf::GetProtectedMemoryInfo_Impl<DriverConnector::GetProtectedMemoryInfoResponse>::GetProtectedMemoryInfo_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetProtectedMemoryInfoRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetProtectedMemoryInfoRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetProtectedMemoryInfoRequest));
  ::fidl::DecodedMessage<GetProtectedMemoryInfoRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      DriverConnector::InPlace::GetProtectedMemoryInfo(std::move(_client_end), std::move(_response_buffer)));
}

DriverConnector::UnownedResultOf::GetProtectedMemoryInfo DriverConnector::SyncClient::GetProtectedMemoryInfo(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetProtectedMemoryInfo(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

DriverConnector::UnownedResultOf::GetProtectedMemoryInfo DriverConnector::Call::GetProtectedMemoryInfo(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetProtectedMemoryInfo(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<DriverConnector::GetProtectedMemoryInfoResponse> DriverConnector::InPlace::GetProtectedMemoryInfo(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetProtectedMemoryInfoRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetProtectedMemoryInfoRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDriverConnector_GetProtectedMemoryInfo_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DriverConnector::GetProtectedMemoryInfoResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetProtectedMemoryInfoRequest, GetProtectedMemoryInfoResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DriverConnector::GetProtectedMemoryInfoResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool DriverConnector::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kDriverConnector_Connect_Ordinal:
    {
      auto result = ::fidl::DecodeAs<ConnectRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Connect(std::move(message->allocator_request),
        Interface::ConnectCompleter::Sync(txn));
      return true;
    }
    case kDriverConnector_GetProtectedMemoryInfo_Ordinal:
    {
      auto result = ::fidl::DecodeAs<GetProtectedMemoryInfoRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetProtectedMemoryInfo(
        Interface::GetProtectedMemoryInfoCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool DriverConnector::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void DriverConnector::Interface::GetProtectedMemoryInfoCompleterBase::Reply(int32_t status, uint64_t base_address, uint64_t size) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetProtectedMemoryInfoResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetProtectedMemoryInfoResponse*>(_write_bytes);
  _response._hdr.ordinal = kDriverConnector_GetProtectedMemoryInfo_Ordinal;
  _response.status = std::move(status);
  _response.base_address = std::move(base_address);
  _response.size = std::move(size);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetProtectedMemoryInfoResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetProtectedMemoryInfoResponse>(std::move(_response_bytes)));
}

void DriverConnector::Interface::GetProtectedMemoryInfoCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status, uint64_t base_address, uint64_t size) {
  if (_buffer.capacity() < GetProtectedMemoryInfoResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetProtectedMemoryInfoResponse*>(_buffer.data());
  _response._hdr.ordinal = kDriverConnector_GetProtectedMemoryInfo_Ordinal;
  _response.status = std::move(status);
  _response.base_address = std::move(base_address);
  _response.size = std::move(size);
  _buffer.set_actual(sizeof(GetProtectedMemoryInfoResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetProtectedMemoryInfoResponse>(std::move(_buffer)));
}

void DriverConnector::Interface::GetProtectedMemoryInfoCompleterBase::Reply(::fidl::DecodedMessage<GetProtectedMemoryInfoResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDriverConnector_GetProtectedMemoryInfo_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


namespace {

[[maybe_unused]]
constexpr uint64_t kAllocator_AllocateNonSharedCollection_Ordinal = 0x21b157d700000000lu;
extern "C" const fidl_type_t fuchsia_sysmem_AllocatorAllocateNonSharedCollectionRequestTable;
[[maybe_unused]]
constexpr uint64_t kAllocator_AllocateSharedCollection_Ordinal = 0x36a4dbc400000000lu;
extern "C" const fidl_type_t fuchsia_sysmem_AllocatorAllocateSharedCollectionRequestTable;
[[maybe_unused]]
constexpr uint64_t kAllocator_BindSharedCollection_Ordinal = 0x1d68697500000000lu;
extern "C" const fidl_type_t fuchsia_sysmem_AllocatorBindSharedCollectionRequestTable;

}  // namespace

Allocator::ResultOf::AllocateNonSharedCollection_Impl::AllocateNonSharedCollection_Impl(zx::unowned_channel _client_end, ::zx::channel collection) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<AllocateNonSharedCollectionRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, AllocateNonSharedCollectionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<AllocateNonSharedCollectionRequest*>(_write_bytes);
  _request.collection = std::move(collection);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(AllocateNonSharedCollectionRequest));
  ::fidl::DecodedMessage<AllocateNonSharedCollectionRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Allocator::InPlace::AllocateNonSharedCollection(std::move(_client_end), std::move(_decoded_request)));
}

Allocator::ResultOf::AllocateNonSharedCollection Allocator::SyncClient::AllocateNonSharedCollection(::zx::channel collection) {
  return ResultOf::AllocateNonSharedCollection(zx::unowned_channel(this->channel_), std::move(collection));
}

Allocator::ResultOf::AllocateNonSharedCollection Allocator::Call::AllocateNonSharedCollection(zx::unowned_channel _client_end, ::zx::channel collection) {
  return ResultOf::AllocateNonSharedCollection(std::move(_client_end), std::move(collection));
}


Allocator::UnownedResultOf::AllocateNonSharedCollection_Impl::AllocateNonSharedCollection_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel collection) {
  if (_request_buffer.capacity() < AllocateNonSharedCollectionRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, AllocateNonSharedCollectionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<AllocateNonSharedCollectionRequest*>(_request_buffer.data());
  _request.collection = std::move(collection);
  _request_buffer.set_actual(sizeof(AllocateNonSharedCollectionRequest));
  ::fidl::DecodedMessage<AllocateNonSharedCollectionRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Allocator::InPlace::AllocateNonSharedCollection(std::move(_client_end), std::move(_decoded_request)));
}

Allocator::UnownedResultOf::AllocateNonSharedCollection Allocator::SyncClient::AllocateNonSharedCollection(::fidl::BytePart _request_buffer, ::zx::channel collection) {
  return UnownedResultOf::AllocateNonSharedCollection(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(collection));
}

Allocator::UnownedResultOf::AllocateNonSharedCollection Allocator::Call::AllocateNonSharedCollection(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel collection) {
  return UnownedResultOf::AllocateNonSharedCollection(std::move(_client_end), std::move(_request_buffer), std::move(collection));
}

::fidl::internal::StatusAndError Allocator::InPlace::AllocateNonSharedCollection(zx::unowned_channel _client_end, ::fidl::DecodedMessage<AllocateNonSharedCollectionRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kAllocator_AllocateNonSharedCollection_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Allocator::ResultOf::AllocateSharedCollection_Impl::AllocateSharedCollection_Impl(zx::unowned_channel _client_end, ::zx::channel token_request) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<AllocateSharedCollectionRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, AllocateSharedCollectionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<AllocateSharedCollectionRequest*>(_write_bytes);
  _request.token_request = std::move(token_request);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(AllocateSharedCollectionRequest));
  ::fidl::DecodedMessage<AllocateSharedCollectionRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Allocator::InPlace::AllocateSharedCollection(std::move(_client_end), std::move(_decoded_request)));
}

Allocator::ResultOf::AllocateSharedCollection Allocator::SyncClient::AllocateSharedCollection(::zx::channel token_request) {
  return ResultOf::AllocateSharedCollection(zx::unowned_channel(this->channel_), std::move(token_request));
}

Allocator::ResultOf::AllocateSharedCollection Allocator::Call::AllocateSharedCollection(zx::unowned_channel _client_end, ::zx::channel token_request) {
  return ResultOf::AllocateSharedCollection(std::move(_client_end), std::move(token_request));
}


Allocator::UnownedResultOf::AllocateSharedCollection_Impl::AllocateSharedCollection_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel token_request) {
  if (_request_buffer.capacity() < AllocateSharedCollectionRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, AllocateSharedCollectionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<AllocateSharedCollectionRequest*>(_request_buffer.data());
  _request.token_request = std::move(token_request);
  _request_buffer.set_actual(sizeof(AllocateSharedCollectionRequest));
  ::fidl::DecodedMessage<AllocateSharedCollectionRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Allocator::InPlace::AllocateSharedCollection(std::move(_client_end), std::move(_decoded_request)));
}

Allocator::UnownedResultOf::AllocateSharedCollection Allocator::SyncClient::AllocateSharedCollection(::fidl::BytePart _request_buffer, ::zx::channel token_request) {
  return UnownedResultOf::AllocateSharedCollection(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(token_request));
}

Allocator::UnownedResultOf::AllocateSharedCollection Allocator::Call::AllocateSharedCollection(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel token_request) {
  return UnownedResultOf::AllocateSharedCollection(std::move(_client_end), std::move(_request_buffer), std::move(token_request));
}

::fidl::internal::StatusAndError Allocator::InPlace::AllocateSharedCollection(zx::unowned_channel _client_end, ::fidl::DecodedMessage<AllocateSharedCollectionRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kAllocator_AllocateSharedCollection_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Allocator::ResultOf::BindSharedCollection_Impl::BindSharedCollection_Impl(zx::unowned_channel _client_end, ::zx::channel token, ::zx::channel buffer_collection_request) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<BindSharedCollectionRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, BindSharedCollectionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<BindSharedCollectionRequest*>(_write_bytes);
  _request.token = std::move(token);
  _request.buffer_collection_request = std::move(buffer_collection_request);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(BindSharedCollectionRequest));
  ::fidl::DecodedMessage<BindSharedCollectionRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Allocator::InPlace::BindSharedCollection(std::move(_client_end), std::move(_decoded_request)));
}

Allocator::ResultOf::BindSharedCollection Allocator::SyncClient::BindSharedCollection(::zx::channel token, ::zx::channel buffer_collection_request) {
  return ResultOf::BindSharedCollection(zx::unowned_channel(this->channel_), std::move(token), std::move(buffer_collection_request));
}

Allocator::ResultOf::BindSharedCollection Allocator::Call::BindSharedCollection(zx::unowned_channel _client_end, ::zx::channel token, ::zx::channel buffer_collection_request) {
  return ResultOf::BindSharedCollection(std::move(_client_end), std::move(token), std::move(buffer_collection_request));
}


Allocator::UnownedResultOf::BindSharedCollection_Impl::BindSharedCollection_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel token, ::zx::channel buffer_collection_request) {
  if (_request_buffer.capacity() < BindSharedCollectionRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, BindSharedCollectionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<BindSharedCollectionRequest*>(_request_buffer.data());
  _request.token = std::move(token);
  _request.buffer_collection_request = std::move(buffer_collection_request);
  _request_buffer.set_actual(sizeof(BindSharedCollectionRequest));
  ::fidl::DecodedMessage<BindSharedCollectionRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Allocator::InPlace::BindSharedCollection(std::move(_client_end), std::move(_decoded_request)));
}

Allocator::UnownedResultOf::BindSharedCollection Allocator::SyncClient::BindSharedCollection(::fidl::BytePart _request_buffer, ::zx::channel token, ::zx::channel buffer_collection_request) {
  return UnownedResultOf::BindSharedCollection(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(token), std::move(buffer_collection_request));
}

Allocator::UnownedResultOf::BindSharedCollection Allocator::Call::BindSharedCollection(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel token, ::zx::channel buffer_collection_request) {
  return UnownedResultOf::BindSharedCollection(std::move(_client_end), std::move(_request_buffer), std::move(token), std::move(buffer_collection_request));
}

::fidl::internal::StatusAndError Allocator::InPlace::BindSharedCollection(zx::unowned_channel _client_end, ::fidl::DecodedMessage<BindSharedCollectionRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kAllocator_BindSharedCollection_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


bool Allocator::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kAllocator_AllocateNonSharedCollection_Ordinal:
    {
      auto result = ::fidl::DecodeAs<AllocateNonSharedCollectionRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->AllocateNonSharedCollection(std::move(message->collection),
        Interface::AllocateNonSharedCollectionCompleter::Sync(txn));
      return true;
    }
    case kAllocator_AllocateSharedCollection_Ordinal:
    {
      auto result = ::fidl::DecodeAs<AllocateSharedCollectionRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->AllocateSharedCollection(std::move(message->token_request),
        Interface::AllocateSharedCollectionCompleter::Sync(txn));
      return true;
    }
    case kAllocator_BindSharedCollection_Ordinal:
    {
      auto result = ::fidl::DecodeAs<BindSharedCollectionRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->BindSharedCollection(std::move(message->token), std::move(message->buffer_collection_request),
        Interface::BindSharedCollectionCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Allocator::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


::llcpp::fuchsia::sysmem::SecureMem_SetPhysicalSecureHeaps_Result::SecureMem_SetPhysicalSecureHeaps_Result() {
  tag_ = Tag::Invalid;
}

::llcpp::fuchsia::sysmem::SecureMem_SetPhysicalSecureHeaps_Result::~SecureMem_SetPhysicalSecureHeaps_Result() {
  Destroy();
}

void ::llcpp::fuchsia::sysmem::SecureMem_SetPhysicalSecureHeaps_Result::Destroy() {
  switch (which()) {
  case Tag::kResponse:
    response_.~SecureMem_SetPhysicalSecureHeaps_Response();
    break;
  default:
    break;
  }
  tag_ = Tag::Invalid;
}

void ::llcpp::fuchsia::sysmem::SecureMem_SetPhysicalSecureHeaps_Result::MoveImpl_(SecureMem_SetPhysicalSecureHeaps_Result&& other) {
  switch (other.which()) {
  case Tag::kResponse:
    mutable_response() = std::move(other.mutable_response());
    break;
  case Tag::kErr:
    mutable_err() = std::move(other.mutable_err());
    break;
  default:
    break;
  }
  other.Destroy();
}

void ::llcpp::fuchsia::sysmem::SecureMem_SetPhysicalSecureHeaps_Result::SizeAndOffsetAssertionHelper() {
  static_assert(offsetof(::llcpp::fuchsia::sysmem::SecureMem_SetPhysicalSecureHeaps_Result, response_) == 4);
  static_assert(offsetof(::llcpp::fuchsia::sysmem::SecureMem_SetPhysicalSecureHeaps_Result, err_) == 4);
  static_assert(sizeof(::llcpp::fuchsia::sysmem::SecureMem_SetPhysicalSecureHeaps_Result) == ::llcpp::fuchsia::sysmem::SecureMem_SetPhysicalSecureHeaps_Result::PrimarySize);
}


SecureMem_SetPhysicalSecureHeaps_Response& ::llcpp::fuchsia::sysmem::SecureMem_SetPhysicalSecureHeaps_Result::mutable_response() {
  if (which() != Tag::kResponse) {
    Destroy();
    new (&response_) SecureMem_SetPhysicalSecureHeaps_Response;
  }
  tag_ = Tag::kResponse;
  return response_;
}

int32_t& ::llcpp::fuchsia::sysmem::SecureMem_SetPhysicalSecureHeaps_Result::mutable_err() {
  if (which() != Tag::kErr) {
    Destroy();
    new (&err_) int32_t;
  }
  tag_ = Tag::kErr;
  return err_;
}


::llcpp::fuchsia::sysmem::SecureMem_GetPhysicalSecureHeaps_Result::SecureMem_GetPhysicalSecureHeaps_Result() {
  tag_ = Tag::Invalid;
}

::llcpp::fuchsia::sysmem::SecureMem_GetPhysicalSecureHeaps_Result::~SecureMem_GetPhysicalSecureHeaps_Result() {
  Destroy();
}

void ::llcpp::fuchsia::sysmem::SecureMem_GetPhysicalSecureHeaps_Result::Destroy() {
  switch (which()) {
  case Tag::kResponse:
    response_.~SecureMem_GetPhysicalSecureHeaps_Response();
    break;
  default:
    break;
  }
  tag_ = Tag::Invalid;
}

void ::llcpp::fuchsia::sysmem::SecureMem_GetPhysicalSecureHeaps_Result::MoveImpl_(SecureMem_GetPhysicalSecureHeaps_Result&& other) {
  switch (other.which()) {
  case Tag::kResponse:
    mutable_response() = std::move(other.mutable_response());
    break;
  case Tag::kErr:
    mutable_err() = std::move(other.mutable_err());
    break;
  default:
    break;
  }
  other.Destroy();
}

void ::llcpp::fuchsia::sysmem::SecureMem_GetPhysicalSecureHeaps_Result::SizeAndOffsetAssertionHelper() {
  static_assert(offsetof(::llcpp::fuchsia::sysmem::SecureMem_GetPhysicalSecureHeaps_Result, response_) == 8);
  static_assert(offsetof(::llcpp::fuchsia::sysmem::SecureMem_GetPhysicalSecureHeaps_Result, err_) == 8);
  static_assert(sizeof(::llcpp::fuchsia::sysmem::SecureMem_GetPhysicalSecureHeaps_Result) == ::llcpp::fuchsia::sysmem::SecureMem_GetPhysicalSecureHeaps_Result::PrimarySize);
}


SecureMem_GetPhysicalSecureHeaps_Response& ::llcpp::fuchsia::sysmem::SecureMem_GetPhysicalSecureHeaps_Result::mutable_response() {
  if (which() != Tag::kResponse) {
    Destroy();
    new (&response_) SecureMem_GetPhysicalSecureHeaps_Response;
  }
  tag_ = Tag::kResponse;
  return response_;
}

int32_t& ::llcpp::fuchsia::sysmem::SecureMem_GetPhysicalSecureHeaps_Result::mutable_err() {
  if (which() != Tag::kErr) {
    Destroy();
    new (&err_) int32_t;
  }
  tag_ = Tag::kErr;
  return err_;
}


namespace {

[[maybe_unused]]
constexpr uint64_t kSecureMem_GetPhysicalSecureHeaps_Ordinal = 0x60f3c45a00000000lu;
extern "C" const fidl_type_t fuchsia_sysmem_SecureMemGetPhysicalSecureHeapsResponseTable;
[[maybe_unused]]
constexpr uint64_t kSecureMem_SetPhysicalSecureHeaps_Ordinal = 0x14b0c0000000000lu;
extern "C" const fidl_type_t fuchsia_sysmem_SecureMemSetPhysicalSecureHeapsRequestTable;
extern "C" const fidl_type_t fuchsia_sysmem_SecureMemSetPhysicalSecureHeapsResponseTable;

}  // namespace
template <>
SecureMem::ResultOf::GetPhysicalSecureHeaps_Impl<SecureMem::GetPhysicalSecureHeapsResponse>::GetPhysicalSecureHeaps_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetPhysicalSecureHeapsRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetPhysicalSecureHeapsRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetPhysicalSecureHeapsRequest));
  ::fidl::DecodedMessage<GetPhysicalSecureHeapsRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      SecureMem::InPlace::GetPhysicalSecureHeaps(std::move(_client_end), Super::response_buffer()));
}

SecureMem::ResultOf::GetPhysicalSecureHeaps SecureMem::SyncClient::GetPhysicalSecureHeaps() {
  return ResultOf::GetPhysicalSecureHeaps(zx::unowned_channel(this->channel_));
}

SecureMem::ResultOf::GetPhysicalSecureHeaps SecureMem::Call::GetPhysicalSecureHeaps(zx::unowned_channel _client_end) {
  return ResultOf::GetPhysicalSecureHeaps(std::move(_client_end));
}

template <>
SecureMem::UnownedResultOf::GetPhysicalSecureHeaps_Impl<SecureMem::GetPhysicalSecureHeapsResponse>::GetPhysicalSecureHeaps_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetPhysicalSecureHeapsRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetPhysicalSecureHeapsRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetPhysicalSecureHeapsRequest));
  ::fidl::DecodedMessage<GetPhysicalSecureHeapsRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      SecureMem::InPlace::GetPhysicalSecureHeaps(std::move(_client_end), std::move(_response_buffer)));
}

SecureMem::UnownedResultOf::GetPhysicalSecureHeaps SecureMem::SyncClient::GetPhysicalSecureHeaps(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetPhysicalSecureHeaps(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

SecureMem::UnownedResultOf::GetPhysicalSecureHeaps SecureMem::Call::GetPhysicalSecureHeaps(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetPhysicalSecureHeaps(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<SecureMem::GetPhysicalSecureHeapsResponse> SecureMem::InPlace::GetPhysicalSecureHeaps(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetPhysicalSecureHeapsRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetPhysicalSecureHeapsRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kSecureMem_GetPhysicalSecureHeaps_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SecureMem::GetPhysicalSecureHeapsResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetPhysicalSecureHeapsRequest, GetPhysicalSecureHeapsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SecureMem::GetPhysicalSecureHeapsResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
SecureMem::ResultOf::SetPhysicalSecureHeaps_Impl<SecureMem::SetPhysicalSecureHeapsResponse>::SetPhysicalSecureHeaps_Impl(zx::unowned_channel _client_end, PhysicalSecureHeaps heaps) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetPhysicalSecureHeapsRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetPhysicalSecureHeapsRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetPhysicalSecureHeapsRequest*>(_write_bytes);
  _request.heaps = std::move(heaps);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetPhysicalSecureHeapsRequest));
  ::fidl::DecodedMessage<SetPhysicalSecureHeapsRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      SecureMem::InPlace::SetPhysicalSecureHeaps(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

SecureMem::ResultOf::SetPhysicalSecureHeaps SecureMem::SyncClient::SetPhysicalSecureHeaps(PhysicalSecureHeaps heaps) {
  return ResultOf::SetPhysicalSecureHeaps(zx::unowned_channel(this->channel_), std::move(heaps));
}

SecureMem::ResultOf::SetPhysicalSecureHeaps SecureMem::Call::SetPhysicalSecureHeaps(zx::unowned_channel _client_end, PhysicalSecureHeaps heaps) {
  return ResultOf::SetPhysicalSecureHeaps(std::move(_client_end), std::move(heaps));
}

template <>
SecureMem::UnownedResultOf::SetPhysicalSecureHeaps_Impl<SecureMem::SetPhysicalSecureHeapsResponse>::SetPhysicalSecureHeaps_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, PhysicalSecureHeaps heaps, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < SetPhysicalSecureHeapsRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<SetPhysicalSecureHeapsResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, SetPhysicalSecureHeapsRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetPhysicalSecureHeapsRequest*>(_request_buffer.data());
  _request.heaps = std::move(heaps);
  _request_buffer.set_actual(sizeof(SetPhysicalSecureHeapsRequest));
  ::fidl::DecodedMessage<SetPhysicalSecureHeapsRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      SecureMem::InPlace::SetPhysicalSecureHeaps(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

SecureMem::UnownedResultOf::SetPhysicalSecureHeaps SecureMem::SyncClient::SetPhysicalSecureHeaps(::fidl::BytePart _request_buffer, PhysicalSecureHeaps heaps, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetPhysicalSecureHeaps(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(heaps), std::move(_response_buffer));
}

SecureMem::UnownedResultOf::SetPhysicalSecureHeaps SecureMem::Call::SetPhysicalSecureHeaps(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, PhysicalSecureHeaps heaps, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetPhysicalSecureHeaps(std::move(_client_end), std::move(_request_buffer), std::move(heaps), std::move(_response_buffer));
}

::fidl::DecodeResult<SecureMem::SetPhysicalSecureHeapsResponse> SecureMem::InPlace::SetPhysicalSecureHeaps(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetPhysicalSecureHeapsRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kSecureMem_SetPhysicalSecureHeaps_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SecureMem::SetPhysicalSecureHeapsResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SetPhysicalSecureHeapsRequest, SetPhysicalSecureHeapsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SecureMem::SetPhysicalSecureHeapsResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool SecureMem::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kSecureMem_GetPhysicalSecureHeaps_Ordinal:
    {
      auto result = ::fidl::DecodeAs<GetPhysicalSecureHeapsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetPhysicalSecureHeaps(
        Interface::GetPhysicalSecureHeapsCompleter::Sync(txn));
      return true;
    }
    case kSecureMem_SetPhysicalSecureHeaps_Ordinal:
    {
      auto result = ::fidl::DecodeAs<SetPhysicalSecureHeapsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetPhysicalSecureHeaps(std::move(message->heaps),
        Interface::SetPhysicalSecureHeapsCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool SecureMem::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void SecureMem::Interface::GetPhysicalSecureHeapsCompleterBase::Reply(SecureMem_GetPhysicalSecureHeaps_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetPhysicalSecureHeapsResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  auto& _response = *reinterpret_cast<GetPhysicalSecureHeapsResponse*>(_write_bytes);
  _response._hdr.ordinal = kSecureMem_GetPhysicalSecureHeaps_Ordinal;
  _response.result = std::move(result);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetPhysicalSecureHeapsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetPhysicalSecureHeapsResponse>(std::move(_response_bytes)));
}

void SecureMem::Interface::GetPhysicalSecureHeapsCompleterBase::Reply(::fidl::BytePart _buffer, SecureMem_GetPhysicalSecureHeaps_Result result) {
  if (_buffer.capacity() < GetPhysicalSecureHeapsResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetPhysicalSecureHeapsResponse*>(_buffer.data());
  _response._hdr.ordinal = kSecureMem_GetPhysicalSecureHeaps_Ordinal;
  _response.result = std::move(result);
  _buffer.set_actual(sizeof(GetPhysicalSecureHeapsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetPhysicalSecureHeapsResponse>(std::move(_buffer)));
}

void SecureMem::Interface::GetPhysicalSecureHeapsCompleterBase::Reply(::fidl::DecodedMessage<GetPhysicalSecureHeapsResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kSecureMem_GetPhysicalSecureHeaps_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void SecureMem::Interface::SetPhysicalSecureHeapsCompleterBase::Reply(SecureMem_SetPhysicalSecureHeaps_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetPhysicalSecureHeapsResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SetPhysicalSecureHeapsResponse*>(_write_bytes);
  _response._hdr.ordinal = kSecureMem_SetPhysicalSecureHeaps_Ordinal;
  _response.result = std::move(result);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetPhysicalSecureHeapsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetPhysicalSecureHeapsResponse>(std::move(_response_bytes)));
}

void SecureMem::Interface::SetPhysicalSecureHeapsCompleterBase::Reply(::fidl::BytePart _buffer, SecureMem_SetPhysicalSecureHeaps_Result result) {
  if (_buffer.capacity() < SetPhysicalSecureHeapsResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SetPhysicalSecureHeapsResponse*>(_buffer.data());
  _response._hdr.ordinal = kSecureMem_SetPhysicalSecureHeaps_Ordinal;
  _response.result = std::move(result);
  _buffer.set_actual(sizeof(SetPhysicalSecureHeapsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetPhysicalSecureHeapsResponse>(std::move(_buffer)));
}

void SecureMem::Interface::SetPhysicalSecureHeapsCompleterBase::Reply(::fidl::DecodedMessage<SetPhysicalSecureHeapsResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kSecureMem_SetPhysicalSecureHeaps_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


::llcpp::fuchsia::sysmem::BufferSpec::BufferSpec() {
  tag_ = Tag::Invalid;
}

::llcpp::fuchsia::sysmem::BufferSpec::~BufferSpec() {
  Destroy();
}

void ::llcpp::fuchsia::sysmem::BufferSpec::Destroy() {
  switch (which()) {
  case Tag::kImage:
    image_.~ImageSpec();
    break;
  default:
    break;
  }
  tag_ = Tag::Invalid;
}

void ::llcpp::fuchsia::sysmem::BufferSpec::MoveImpl_(BufferSpec&& other) {
  switch (other.which()) {
  case Tag::kImage:
    mutable_image() = std::move(other.mutable_image());
    break;
  default:
    break;
  }
  other.Destroy();
}

void ::llcpp::fuchsia::sysmem::BufferSpec::SizeAndOffsetAssertionHelper() {
  static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferSpec, image_) == 8);
  static_assert(sizeof(::llcpp::fuchsia::sysmem::BufferSpec) == ::llcpp::fuchsia::sysmem::BufferSpec::PrimarySize);
}


ImageSpec& ::llcpp::fuchsia::sysmem::BufferSpec::mutable_image() {
  if (which() != Tag::kImage) {
    Destroy();
    new (&image_) ImageSpec;
  }
  tag_ = Tag::kImage;
  return image_;
}


::llcpp::fuchsia::sysmem::BufferFormat::BufferFormat() {
  tag_ = Tag::Invalid;
}

::llcpp::fuchsia::sysmem::BufferFormat::~BufferFormat() {
  Destroy();
}

void ::llcpp::fuchsia::sysmem::BufferFormat::Destroy() {
  switch (which()) {
  case Tag::kImage:
    image_.~ImageFormat();
    break;
  default:
    break;
  }
  tag_ = Tag::Invalid;
}

void ::llcpp::fuchsia::sysmem::BufferFormat::MoveImpl_(BufferFormat&& other) {
  switch (other.which()) {
  case Tag::kImage:
    mutable_image() = std::move(other.mutable_image());
    break;
  default:
    break;
  }
  other.Destroy();
}

void ::llcpp::fuchsia::sysmem::BufferFormat::SizeAndOffsetAssertionHelper() {
  static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferFormat, image_) == 8);
  static_assert(sizeof(::llcpp::fuchsia::sysmem::BufferFormat) == ::llcpp::fuchsia::sysmem::BufferFormat::PrimarySize);
}


ImageFormat& ::llcpp::fuchsia::sysmem::BufferFormat::mutable_image() {
  if (which() != Tag::kImage) {
    Destroy();
    new (&image_) ImageFormat;
  }
  tag_ = Tag::kImage;
  return image_;
}


namespace {

[[maybe_unused]]
constexpr uint64_t kBufferCollectionEvents_OnDuplicatedTokensKnownByServer_Ordinal = 0x1f54cf3600000000lu;
[[maybe_unused]]
constexpr uint64_t kBufferCollectionEvents_OnBuffersAllocated_Ordinal = 0x6830ec5f00000000lu;
extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionEventsOnBuffersAllocatedRequestTable;
[[maybe_unused]]
constexpr uint64_t kBufferCollectionEvents_OnAllocateSingleBufferDone_Ordinal = 0x6cb2333900000000lu;
extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionEventsOnAllocateSingleBufferDoneRequestTable;

}  // namespace

BufferCollectionEvents::ResultOf::OnDuplicatedTokensKnownByServer_Impl::OnDuplicatedTokensKnownByServer_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OnDuplicatedTokensKnownByServerRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, OnDuplicatedTokensKnownByServerRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(OnDuplicatedTokensKnownByServerRequest));
  ::fidl::DecodedMessage<OnDuplicatedTokensKnownByServerRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      BufferCollectionEvents::InPlace::OnDuplicatedTokensKnownByServer(std::move(_client_end)));
}

BufferCollectionEvents::ResultOf::OnDuplicatedTokensKnownByServer BufferCollectionEvents::SyncClient::OnDuplicatedTokensKnownByServer() {
  return ResultOf::OnDuplicatedTokensKnownByServer(zx::unowned_channel(this->channel_));
}

BufferCollectionEvents::ResultOf::OnDuplicatedTokensKnownByServer BufferCollectionEvents::Call::OnDuplicatedTokensKnownByServer(zx::unowned_channel _client_end) {
  return ResultOf::OnDuplicatedTokensKnownByServer(std::move(_client_end));
}

::fidl::internal::StatusAndError BufferCollectionEvents::InPlace::OnDuplicatedTokensKnownByServer(zx::unowned_channel _client_end) {
  constexpr uint32_t _write_num_bytes = sizeof(OnDuplicatedTokensKnownByServerRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<OnDuplicatedTokensKnownByServerRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kBufferCollectionEvents_OnDuplicatedTokensKnownByServer_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


BufferCollectionEvents::ResultOf::OnBuffersAllocated_Impl::OnBuffersAllocated_Impl(zx::unowned_channel _client_end, int32_t status, BufferCollectionInfo_2 buffer_collection_info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OnBuffersAllocatedRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, OnBuffersAllocatedRequest::PrimarySize);
  auto& _request = *reinterpret_cast<OnBuffersAllocatedRequest*>(_write_bytes);
  _request.status = std::move(status);
  _request.buffer_collection_info = std::move(buffer_collection_info);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(OnBuffersAllocatedRequest));
  ::fidl::DecodedMessage<OnBuffersAllocatedRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      BufferCollectionEvents::InPlace::OnBuffersAllocated(std::move(_client_end), std::move(_decoded_request)));
}

BufferCollectionEvents::ResultOf::OnBuffersAllocated BufferCollectionEvents::SyncClient::OnBuffersAllocated(int32_t status, BufferCollectionInfo_2 buffer_collection_info) {
  return ResultOf::OnBuffersAllocated(zx::unowned_channel(this->channel_), std::move(status), std::move(buffer_collection_info));
}

BufferCollectionEvents::ResultOf::OnBuffersAllocated BufferCollectionEvents::Call::OnBuffersAllocated(zx::unowned_channel _client_end, int32_t status, BufferCollectionInfo_2 buffer_collection_info) {
  return ResultOf::OnBuffersAllocated(std::move(_client_end), std::move(status), std::move(buffer_collection_info));
}


BufferCollectionEvents::UnownedResultOf::OnBuffersAllocated_Impl::OnBuffersAllocated_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int32_t status, BufferCollectionInfo_2 buffer_collection_info) {
  if (_request_buffer.capacity() < OnBuffersAllocatedRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, OnBuffersAllocatedRequest::PrimarySize);
  auto& _request = *reinterpret_cast<OnBuffersAllocatedRequest*>(_request_buffer.data());
  _request.status = std::move(status);
  _request.buffer_collection_info = std::move(buffer_collection_info);
  _request_buffer.set_actual(sizeof(OnBuffersAllocatedRequest));
  ::fidl::DecodedMessage<OnBuffersAllocatedRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      BufferCollectionEvents::InPlace::OnBuffersAllocated(std::move(_client_end), std::move(_decoded_request)));
}

BufferCollectionEvents::UnownedResultOf::OnBuffersAllocated BufferCollectionEvents::SyncClient::OnBuffersAllocated(::fidl::BytePart _request_buffer, int32_t status, BufferCollectionInfo_2 buffer_collection_info) {
  return UnownedResultOf::OnBuffersAllocated(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(status), std::move(buffer_collection_info));
}

BufferCollectionEvents::UnownedResultOf::OnBuffersAllocated BufferCollectionEvents::Call::OnBuffersAllocated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int32_t status, BufferCollectionInfo_2 buffer_collection_info) {
  return UnownedResultOf::OnBuffersAllocated(std::move(_client_end), std::move(_request_buffer), std::move(status), std::move(buffer_collection_info));
}

::fidl::internal::StatusAndError BufferCollectionEvents::InPlace::OnBuffersAllocated(zx::unowned_channel _client_end, ::fidl::DecodedMessage<OnBuffersAllocatedRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kBufferCollectionEvents_OnBuffersAllocated_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


BufferCollectionEvents::ResultOf::OnAllocateSingleBufferDone_Impl::OnAllocateSingleBufferDone_Impl(zx::unowned_channel _client_end, int32_t status, SingleBufferInfo buffer_info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OnAllocateSingleBufferDoneRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, OnAllocateSingleBufferDoneRequest::PrimarySize);
  auto& _request = *reinterpret_cast<OnAllocateSingleBufferDoneRequest*>(_write_bytes);
  _request.status = std::move(status);
  _request.buffer_info = std::move(buffer_info);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(OnAllocateSingleBufferDoneRequest));
  ::fidl::DecodedMessage<OnAllocateSingleBufferDoneRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      BufferCollectionEvents::InPlace::OnAllocateSingleBufferDone(std::move(_client_end), std::move(_decoded_request)));
}

BufferCollectionEvents::ResultOf::OnAllocateSingleBufferDone BufferCollectionEvents::SyncClient::OnAllocateSingleBufferDone(int32_t status, SingleBufferInfo buffer_info) {
  return ResultOf::OnAllocateSingleBufferDone(zx::unowned_channel(this->channel_), std::move(status), std::move(buffer_info));
}

BufferCollectionEvents::ResultOf::OnAllocateSingleBufferDone BufferCollectionEvents::Call::OnAllocateSingleBufferDone(zx::unowned_channel _client_end, int32_t status, SingleBufferInfo buffer_info) {
  return ResultOf::OnAllocateSingleBufferDone(std::move(_client_end), std::move(status), std::move(buffer_info));
}


BufferCollectionEvents::UnownedResultOf::OnAllocateSingleBufferDone_Impl::OnAllocateSingleBufferDone_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int32_t status, SingleBufferInfo buffer_info) {
  if (_request_buffer.capacity() < OnAllocateSingleBufferDoneRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, OnAllocateSingleBufferDoneRequest::PrimarySize);
  auto& _request = *reinterpret_cast<OnAllocateSingleBufferDoneRequest*>(_request_buffer.data());
  _request.status = std::move(status);
  _request.buffer_info = std::move(buffer_info);
  _request_buffer.set_actual(sizeof(OnAllocateSingleBufferDoneRequest));
  ::fidl::DecodedMessage<OnAllocateSingleBufferDoneRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      BufferCollectionEvents::InPlace::OnAllocateSingleBufferDone(std::move(_client_end), std::move(_decoded_request)));
}

BufferCollectionEvents::UnownedResultOf::OnAllocateSingleBufferDone BufferCollectionEvents::SyncClient::OnAllocateSingleBufferDone(::fidl::BytePart _request_buffer, int32_t status, SingleBufferInfo buffer_info) {
  return UnownedResultOf::OnAllocateSingleBufferDone(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(status), std::move(buffer_info));
}

BufferCollectionEvents::UnownedResultOf::OnAllocateSingleBufferDone BufferCollectionEvents::Call::OnAllocateSingleBufferDone(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int32_t status, SingleBufferInfo buffer_info) {
  return UnownedResultOf::OnAllocateSingleBufferDone(std::move(_client_end), std::move(_request_buffer), std::move(status), std::move(buffer_info));
}

::fidl::internal::StatusAndError BufferCollectionEvents::InPlace::OnAllocateSingleBufferDone(zx::unowned_channel _client_end, ::fidl::DecodedMessage<OnAllocateSingleBufferDoneRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kBufferCollectionEvents_OnAllocateSingleBufferDone_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


bool BufferCollectionEvents::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kBufferCollectionEvents_OnDuplicatedTokensKnownByServer_Ordinal:
    {
      auto result = ::fidl::DecodeAs<OnDuplicatedTokensKnownByServerRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->OnDuplicatedTokensKnownByServer(
        Interface::OnDuplicatedTokensKnownByServerCompleter::Sync(txn));
      return true;
    }
    case kBufferCollectionEvents_OnBuffersAllocated_Ordinal:
    {
      auto result = ::fidl::DecodeAs<OnBuffersAllocatedRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->OnBuffersAllocated(std::move(message->status), std::move(message->buffer_collection_info),
        Interface::OnBuffersAllocatedCompleter::Sync(txn));
      return true;
    }
    case kBufferCollectionEvents_OnAllocateSingleBufferDone_Ordinal:
    {
      auto result = ::fidl::DecodeAs<OnAllocateSingleBufferDoneRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->OnAllocateSingleBufferDone(std::move(message->status), std::move(message->buffer_info),
        Interface::OnAllocateSingleBufferDoneCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool BufferCollectionEvents::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


namespace {

[[maybe_unused]]
constexpr uint64_t kBufferCollection_SetEventSink_Ordinal = 0x154ba43000000000lu;
extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionSetEventSinkRequestTable;
[[maybe_unused]]
constexpr uint64_t kBufferCollection_Sync_Ordinal = 0x15ba322100000000lu;
[[maybe_unused]]
constexpr uint64_t kBufferCollection_SetConstraints_Ordinal = 0x541b637e00000000lu;
extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionSetConstraintsRequestTable;
[[maybe_unused]]
constexpr uint64_t kBufferCollection_WaitForBuffersAllocated_Ordinal = 0x1b36cfa800000000lu;
extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionWaitForBuffersAllocatedResponseTable;
[[maybe_unused]]
constexpr uint64_t kBufferCollection_CheckBuffersAllocated_Ordinal = 0x95520ce00000000lu;
extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionCheckBuffersAllocatedResponseTable;
[[maybe_unused]]
constexpr uint64_t kBufferCollection_CloseSingleBuffer_Ordinal = 0x1802fa4800000000lu;
[[maybe_unused]]
constexpr uint64_t kBufferCollection_AllocateSingleBuffer_Ordinal = 0x1ba0786400000000lu;
[[maybe_unused]]
constexpr uint64_t kBufferCollection_WaitForSingleBufferAllocated_Ordinal = 0x36e6672300000000lu;
extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionWaitForSingleBufferAllocatedResponseTable;
[[maybe_unused]]
constexpr uint64_t kBufferCollection_CheckSingleBufferAllocated_Ordinal = 0x1301391c00000000lu;
[[maybe_unused]]
constexpr uint64_t kBufferCollection_Close_Ordinal = 0x607c571800000000lu;

}  // namespace

BufferCollection::ResultOf::SetEventSink_Impl::SetEventSink_Impl(zx::unowned_channel _client_end, ::zx::channel events) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetEventSinkRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetEventSinkRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetEventSinkRequest*>(_write_bytes);
  _request.events = std::move(events);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetEventSinkRequest));
  ::fidl::DecodedMessage<SetEventSinkRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      BufferCollection::InPlace::SetEventSink(std::move(_client_end), std::move(_decoded_request)));
}

BufferCollection::ResultOf::SetEventSink BufferCollection::SyncClient::SetEventSink(::zx::channel events) {
  return ResultOf::SetEventSink(zx::unowned_channel(this->channel_), std::move(events));
}

BufferCollection::ResultOf::SetEventSink BufferCollection::Call::SetEventSink(zx::unowned_channel _client_end, ::zx::channel events) {
  return ResultOf::SetEventSink(std::move(_client_end), std::move(events));
}


BufferCollection::UnownedResultOf::SetEventSink_Impl::SetEventSink_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel events) {
  if (_request_buffer.capacity() < SetEventSinkRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, SetEventSinkRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetEventSinkRequest*>(_request_buffer.data());
  _request.events = std::move(events);
  _request_buffer.set_actual(sizeof(SetEventSinkRequest));
  ::fidl::DecodedMessage<SetEventSinkRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      BufferCollection::InPlace::SetEventSink(std::move(_client_end), std::move(_decoded_request)));
}

BufferCollection::UnownedResultOf::SetEventSink BufferCollection::SyncClient::SetEventSink(::fidl::BytePart _request_buffer, ::zx::channel events) {
  return UnownedResultOf::SetEventSink(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(events));
}

BufferCollection::UnownedResultOf::SetEventSink BufferCollection::Call::SetEventSink(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel events) {
  return UnownedResultOf::SetEventSink(std::move(_client_end), std::move(_request_buffer), std::move(events));
}

::fidl::internal::StatusAndError BufferCollection::InPlace::SetEventSink(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetEventSinkRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kBufferCollection_SetEventSink_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
BufferCollection::ResultOf::Sync_Impl<BufferCollection::SyncResponse>::Sync_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SyncRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      BufferCollection::InPlace::Sync(std::move(_client_end), Super::response_buffer()));
}

BufferCollection::ResultOf::Sync BufferCollection::SyncClient::Sync() {
  return ResultOf::Sync(zx::unowned_channel(this->channel_));
}

BufferCollection::ResultOf::Sync BufferCollection::Call::Sync(zx::unowned_channel _client_end) {
  return ResultOf::Sync(std::move(_client_end));
}

::fidl::DecodeResult<BufferCollection::SyncResponse> BufferCollection::InPlace::Sync(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(SyncRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<SyncRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kBufferCollection_Sync_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<BufferCollection::SyncResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SyncRequest, SyncResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<BufferCollection::SyncResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


BufferCollection::ResultOf::SetConstraints_Impl::SetConstraints_Impl(zx::unowned_channel _client_end, bool has_constraints, BufferCollectionConstraints constraints) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetConstraintsRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetConstraintsRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetConstraintsRequest*>(_write_bytes);
  _request.has_constraints = std::move(has_constraints);
  _request.constraints = std::move(constraints);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetConstraintsRequest));
  ::fidl::DecodedMessage<SetConstraintsRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      BufferCollection::InPlace::SetConstraints(std::move(_client_end), std::move(_decoded_request)));
}

BufferCollection::ResultOf::SetConstraints BufferCollection::SyncClient::SetConstraints(bool has_constraints, BufferCollectionConstraints constraints) {
  return ResultOf::SetConstraints(zx::unowned_channel(this->channel_), std::move(has_constraints), std::move(constraints));
}

BufferCollection::ResultOf::SetConstraints BufferCollection::Call::SetConstraints(zx::unowned_channel _client_end, bool has_constraints, BufferCollectionConstraints constraints) {
  return ResultOf::SetConstraints(std::move(_client_end), std::move(has_constraints), std::move(constraints));
}


BufferCollection::UnownedResultOf::SetConstraints_Impl::SetConstraints_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, bool has_constraints, BufferCollectionConstraints constraints) {
  if (_request_buffer.capacity() < SetConstraintsRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, SetConstraintsRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetConstraintsRequest*>(_request_buffer.data());
  _request.has_constraints = std::move(has_constraints);
  _request.constraints = std::move(constraints);
  _request_buffer.set_actual(sizeof(SetConstraintsRequest));
  ::fidl::DecodedMessage<SetConstraintsRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      BufferCollection::InPlace::SetConstraints(std::move(_client_end), std::move(_decoded_request)));
}

BufferCollection::UnownedResultOf::SetConstraints BufferCollection::SyncClient::SetConstraints(::fidl::BytePart _request_buffer, bool has_constraints, BufferCollectionConstraints constraints) {
  return UnownedResultOf::SetConstraints(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(has_constraints), std::move(constraints));
}

BufferCollection::UnownedResultOf::SetConstraints BufferCollection::Call::SetConstraints(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, bool has_constraints, BufferCollectionConstraints constraints) {
  return UnownedResultOf::SetConstraints(std::move(_client_end), std::move(_request_buffer), std::move(has_constraints), std::move(constraints));
}

::fidl::internal::StatusAndError BufferCollection::InPlace::SetConstraints(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetConstraintsRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kBufferCollection_SetConstraints_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
BufferCollection::ResultOf::WaitForBuffersAllocated_Impl<BufferCollection::WaitForBuffersAllocatedResponse>::WaitForBuffersAllocated_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WaitForBuffersAllocatedRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, WaitForBuffersAllocatedRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(WaitForBuffersAllocatedRequest));
  ::fidl::DecodedMessage<WaitForBuffersAllocatedRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      BufferCollection::InPlace::WaitForBuffersAllocated(std::move(_client_end), Super::response_buffer()));
}

BufferCollection::ResultOf::WaitForBuffersAllocated BufferCollection::SyncClient::WaitForBuffersAllocated() {
  return ResultOf::WaitForBuffersAllocated(zx::unowned_channel(this->channel_));
}

BufferCollection::ResultOf::WaitForBuffersAllocated BufferCollection::Call::WaitForBuffersAllocated(zx::unowned_channel _client_end) {
  return ResultOf::WaitForBuffersAllocated(std::move(_client_end));
}

template <>
BufferCollection::UnownedResultOf::WaitForBuffersAllocated_Impl<BufferCollection::WaitForBuffersAllocatedResponse>::WaitForBuffersAllocated_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(WaitForBuffersAllocatedRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, WaitForBuffersAllocatedRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(WaitForBuffersAllocatedRequest));
  ::fidl::DecodedMessage<WaitForBuffersAllocatedRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      BufferCollection::InPlace::WaitForBuffersAllocated(std::move(_client_end), std::move(_response_buffer)));
}

BufferCollection::UnownedResultOf::WaitForBuffersAllocated BufferCollection::SyncClient::WaitForBuffersAllocated(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WaitForBuffersAllocated(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

BufferCollection::UnownedResultOf::WaitForBuffersAllocated BufferCollection::Call::WaitForBuffersAllocated(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WaitForBuffersAllocated(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<BufferCollection::WaitForBuffersAllocatedResponse> BufferCollection::InPlace::WaitForBuffersAllocated(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(WaitForBuffersAllocatedRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<WaitForBuffersAllocatedRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kBufferCollection_WaitForBuffersAllocated_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<BufferCollection::WaitForBuffersAllocatedResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<WaitForBuffersAllocatedRequest, WaitForBuffersAllocatedResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<BufferCollection::WaitForBuffersAllocatedResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
BufferCollection::ResultOf::CheckBuffersAllocated_Impl<BufferCollection::CheckBuffersAllocatedResponse>::CheckBuffersAllocated_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CheckBuffersAllocatedRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CheckBuffersAllocatedRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CheckBuffersAllocatedRequest));
  ::fidl::DecodedMessage<CheckBuffersAllocatedRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      BufferCollection::InPlace::CheckBuffersAllocated(std::move(_client_end), Super::response_buffer()));
}

BufferCollection::ResultOf::CheckBuffersAllocated BufferCollection::SyncClient::CheckBuffersAllocated() {
  return ResultOf::CheckBuffersAllocated(zx::unowned_channel(this->channel_));
}

BufferCollection::ResultOf::CheckBuffersAllocated BufferCollection::Call::CheckBuffersAllocated(zx::unowned_channel _client_end) {
  return ResultOf::CheckBuffersAllocated(std::move(_client_end));
}

template <>
BufferCollection::UnownedResultOf::CheckBuffersAllocated_Impl<BufferCollection::CheckBuffersAllocatedResponse>::CheckBuffersAllocated_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(CheckBuffersAllocatedRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, CheckBuffersAllocatedRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(CheckBuffersAllocatedRequest));
  ::fidl::DecodedMessage<CheckBuffersAllocatedRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      BufferCollection::InPlace::CheckBuffersAllocated(std::move(_client_end), std::move(_response_buffer)));
}

BufferCollection::UnownedResultOf::CheckBuffersAllocated BufferCollection::SyncClient::CheckBuffersAllocated(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::CheckBuffersAllocated(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

BufferCollection::UnownedResultOf::CheckBuffersAllocated BufferCollection::Call::CheckBuffersAllocated(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::CheckBuffersAllocated(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<BufferCollection::CheckBuffersAllocatedResponse> BufferCollection::InPlace::CheckBuffersAllocated(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(CheckBuffersAllocatedRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<CheckBuffersAllocatedRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kBufferCollection_CheckBuffersAllocated_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<BufferCollection::CheckBuffersAllocatedResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<CheckBuffersAllocatedRequest, CheckBuffersAllocatedResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<BufferCollection::CheckBuffersAllocatedResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


BufferCollection::ResultOf::CloseSingleBuffer_Impl::CloseSingleBuffer_Impl(zx::unowned_channel _client_end, uint64_t buffer_index) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseSingleBufferRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CloseSingleBufferRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CloseSingleBufferRequest*>(_write_bytes);
  _request.buffer_index = std::move(buffer_index);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseSingleBufferRequest));
  ::fidl::DecodedMessage<CloseSingleBufferRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      BufferCollection::InPlace::CloseSingleBuffer(std::move(_client_end), std::move(_decoded_request)));
}

BufferCollection::ResultOf::CloseSingleBuffer BufferCollection::SyncClient::CloseSingleBuffer(uint64_t buffer_index) {
  return ResultOf::CloseSingleBuffer(zx::unowned_channel(this->channel_), std::move(buffer_index));
}

BufferCollection::ResultOf::CloseSingleBuffer BufferCollection::Call::CloseSingleBuffer(zx::unowned_channel _client_end, uint64_t buffer_index) {
  return ResultOf::CloseSingleBuffer(std::move(_client_end), std::move(buffer_index));
}


BufferCollection::UnownedResultOf::CloseSingleBuffer_Impl::CloseSingleBuffer_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t buffer_index) {
  if (_request_buffer.capacity() < CloseSingleBufferRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, CloseSingleBufferRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CloseSingleBufferRequest*>(_request_buffer.data());
  _request.buffer_index = std::move(buffer_index);
  _request_buffer.set_actual(sizeof(CloseSingleBufferRequest));
  ::fidl::DecodedMessage<CloseSingleBufferRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      BufferCollection::InPlace::CloseSingleBuffer(std::move(_client_end), std::move(_decoded_request)));
}

BufferCollection::UnownedResultOf::CloseSingleBuffer BufferCollection::SyncClient::CloseSingleBuffer(::fidl::BytePart _request_buffer, uint64_t buffer_index) {
  return UnownedResultOf::CloseSingleBuffer(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(buffer_index));
}

BufferCollection::UnownedResultOf::CloseSingleBuffer BufferCollection::Call::CloseSingleBuffer(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t buffer_index) {
  return UnownedResultOf::CloseSingleBuffer(std::move(_client_end), std::move(_request_buffer), std::move(buffer_index));
}

::fidl::internal::StatusAndError BufferCollection::InPlace::CloseSingleBuffer(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CloseSingleBufferRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kBufferCollection_CloseSingleBuffer_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


BufferCollection::ResultOf::AllocateSingleBuffer_Impl::AllocateSingleBuffer_Impl(zx::unowned_channel _client_end, uint64_t buffer_index) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<AllocateSingleBufferRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, AllocateSingleBufferRequest::PrimarySize);
  auto& _request = *reinterpret_cast<AllocateSingleBufferRequest*>(_write_bytes);
  _request.buffer_index = std::move(buffer_index);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(AllocateSingleBufferRequest));
  ::fidl::DecodedMessage<AllocateSingleBufferRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      BufferCollection::InPlace::AllocateSingleBuffer(std::move(_client_end), std::move(_decoded_request)));
}

BufferCollection::ResultOf::AllocateSingleBuffer BufferCollection::SyncClient::AllocateSingleBuffer(uint64_t buffer_index) {
  return ResultOf::AllocateSingleBuffer(zx::unowned_channel(this->channel_), std::move(buffer_index));
}

BufferCollection::ResultOf::AllocateSingleBuffer BufferCollection::Call::AllocateSingleBuffer(zx::unowned_channel _client_end, uint64_t buffer_index) {
  return ResultOf::AllocateSingleBuffer(std::move(_client_end), std::move(buffer_index));
}


BufferCollection::UnownedResultOf::AllocateSingleBuffer_Impl::AllocateSingleBuffer_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t buffer_index) {
  if (_request_buffer.capacity() < AllocateSingleBufferRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, AllocateSingleBufferRequest::PrimarySize);
  auto& _request = *reinterpret_cast<AllocateSingleBufferRequest*>(_request_buffer.data());
  _request.buffer_index = std::move(buffer_index);
  _request_buffer.set_actual(sizeof(AllocateSingleBufferRequest));
  ::fidl::DecodedMessage<AllocateSingleBufferRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      BufferCollection::InPlace::AllocateSingleBuffer(std::move(_client_end), std::move(_decoded_request)));
}

BufferCollection::UnownedResultOf::AllocateSingleBuffer BufferCollection::SyncClient::AllocateSingleBuffer(::fidl::BytePart _request_buffer, uint64_t buffer_index) {
  return UnownedResultOf::AllocateSingleBuffer(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(buffer_index));
}

BufferCollection::UnownedResultOf::AllocateSingleBuffer BufferCollection::Call::AllocateSingleBuffer(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t buffer_index) {
  return UnownedResultOf::AllocateSingleBuffer(std::move(_client_end), std::move(_request_buffer), std::move(buffer_index));
}

::fidl::internal::StatusAndError BufferCollection::InPlace::AllocateSingleBuffer(zx::unowned_channel _client_end, ::fidl::DecodedMessage<AllocateSingleBufferRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kBufferCollection_AllocateSingleBuffer_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
BufferCollection::ResultOf::WaitForSingleBufferAllocated_Impl<BufferCollection::WaitForSingleBufferAllocatedResponse>::WaitForSingleBufferAllocated_Impl(zx::unowned_channel _client_end, uint64_t buffer_index) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WaitForSingleBufferAllocatedRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, WaitForSingleBufferAllocatedRequest::PrimarySize);
  auto& _request = *reinterpret_cast<WaitForSingleBufferAllocatedRequest*>(_write_bytes);
  _request.buffer_index = std::move(buffer_index);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(WaitForSingleBufferAllocatedRequest));
  ::fidl::DecodedMessage<WaitForSingleBufferAllocatedRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      BufferCollection::InPlace::WaitForSingleBufferAllocated(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

BufferCollection::ResultOf::WaitForSingleBufferAllocated BufferCollection::SyncClient::WaitForSingleBufferAllocated(uint64_t buffer_index) {
  return ResultOf::WaitForSingleBufferAllocated(zx::unowned_channel(this->channel_), std::move(buffer_index));
}

BufferCollection::ResultOf::WaitForSingleBufferAllocated BufferCollection::Call::WaitForSingleBufferAllocated(zx::unowned_channel _client_end, uint64_t buffer_index) {
  return ResultOf::WaitForSingleBufferAllocated(std::move(_client_end), std::move(buffer_index));
}

template <>
BufferCollection::UnownedResultOf::WaitForSingleBufferAllocated_Impl<BufferCollection::WaitForSingleBufferAllocatedResponse>::WaitForSingleBufferAllocated_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t buffer_index, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < WaitForSingleBufferAllocatedRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<WaitForSingleBufferAllocatedResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, WaitForSingleBufferAllocatedRequest::PrimarySize);
  auto& _request = *reinterpret_cast<WaitForSingleBufferAllocatedRequest*>(_request_buffer.data());
  _request.buffer_index = std::move(buffer_index);
  _request_buffer.set_actual(sizeof(WaitForSingleBufferAllocatedRequest));
  ::fidl::DecodedMessage<WaitForSingleBufferAllocatedRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      BufferCollection::InPlace::WaitForSingleBufferAllocated(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

BufferCollection::UnownedResultOf::WaitForSingleBufferAllocated BufferCollection::SyncClient::WaitForSingleBufferAllocated(::fidl::BytePart _request_buffer, uint64_t buffer_index, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WaitForSingleBufferAllocated(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(buffer_index), std::move(_response_buffer));
}

BufferCollection::UnownedResultOf::WaitForSingleBufferAllocated BufferCollection::Call::WaitForSingleBufferAllocated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t buffer_index, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WaitForSingleBufferAllocated(std::move(_client_end), std::move(_request_buffer), std::move(buffer_index), std::move(_response_buffer));
}

::fidl::DecodeResult<BufferCollection::WaitForSingleBufferAllocatedResponse> BufferCollection::InPlace::WaitForSingleBufferAllocated(zx::unowned_channel _client_end, ::fidl::DecodedMessage<WaitForSingleBufferAllocatedRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kBufferCollection_WaitForSingleBufferAllocated_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<BufferCollection::WaitForSingleBufferAllocatedResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<WaitForSingleBufferAllocatedRequest, WaitForSingleBufferAllocatedResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<BufferCollection::WaitForSingleBufferAllocatedResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


BufferCollection::ResultOf::CheckSingleBufferAllocated_Impl::CheckSingleBufferAllocated_Impl(zx::unowned_channel _client_end, uint64_t buffer_index) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CheckSingleBufferAllocatedRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CheckSingleBufferAllocatedRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CheckSingleBufferAllocatedRequest*>(_write_bytes);
  _request.buffer_index = std::move(buffer_index);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CheckSingleBufferAllocatedRequest));
  ::fidl::DecodedMessage<CheckSingleBufferAllocatedRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      BufferCollection::InPlace::CheckSingleBufferAllocated(std::move(_client_end), std::move(_decoded_request)));
}

BufferCollection::ResultOf::CheckSingleBufferAllocated BufferCollection::SyncClient::CheckSingleBufferAllocated(uint64_t buffer_index) {
  return ResultOf::CheckSingleBufferAllocated(zx::unowned_channel(this->channel_), std::move(buffer_index));
}

BufferCollection::ResultOf::CheckSingleBufferAllocated BufferCollection::Call::CheckSingleBufferAllocated(zx::unowned_channel _client_end, uint64_t buffer_index) {
  return ResultOf::CheckSingleBufferAllocated(std::move(_client_end), std::move(buffer_index));
}


BufferCollection::UnownedResultOf::CheckSingleBufferAllocated_Impl::CheckSingleBufferAllocated_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t buffer_index) {
  if (_request_buffer.capacity() < CheckSingleBufferAllocatedRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, CheckSingleBufferAllocatedRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CheckSingleBufferAllocatedRequest*>(_request_buffer.data());
  _request.buffer_index = std::move(buffer_index);
  _request_buffer.set_actual(sizeof(CheckSingleBufferAllocatedRequest));
  ::fidl::DecodedMessage<CheckSingleBufferAllocatedRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      BufferCollection::InPlace::CheckSingleBufferAllocated(std::move(_client_end), std::move(_decoded_request)));
}

BufferCollection::UnownedResultOf::CheckSingleBufferAllocated BufferCollection::SyncClient::CheckSingleBufferAllocated(::fidl::BytePart _request_buffer, uint64_t buffer_index) {
  return UnownedResultOf::CheckSingleBufferAllocated(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(buffer_index));
}

BufferCollection::UnownedResultOf::CheckSingleBufferAllocated BufferCollection::Call::CheckSingleBufferAllocated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t buffer_index) {
  return UnownedResultOf::CheckSingleBufferAllocated(std::move(_client_end), std::move(_request_buffer), std::move(buffer_index));
}

::fidl::internal::StatusAndError BufferCollection::InPlace::CheckSingleBufferAllocated(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CheckSingleBufferAllocatedRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kBufferCollection_CheckSingleBufferAllocated_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


BufferCollection::ResultOf::Close_Impl::Close_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CloseRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseRequest));
  ::fidl::DecodedMessage<CloseRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      BufferCollection::InPlace::Close(std::move(_client_end)));
}

BufferCollection::ResultOf::Close BufferCollection::SyncClient::Close() {
  return ResultOf::Close(zx::unowned_channel(this->channel_));
}

BufferCollection::ResultOf::Close BufferCollection::Call::Close(zx::unowned_channel _client_end) {
  return ResultOf::Close(std::move(_client_end));
}

::fidl::internal::StatusAndError BufferCollection::InPlace::Close(zx::unowned_channel _client_end) {
  constexpr uint32_t _write_num_bytes = sizeof(CloseRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<CloseRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kBufferCollection_Close_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


bool BufferCollection::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kBufferCollection_SetEventSink_Ordinal:
    {
      auto result = ::fidl::DecodeAs<SetEventSinkRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetEventSink(std::move(message->events),
        Interface::SetEventSinkCompleter::Sync(txn));
      return true;
    }
    case kBufferCollection_Sync_Ordinal:
    {
      auto result = ::fidl::DecodeAs<SyncRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Sync(
        Interface::SyncCompleter::Sync(txn));
      return true;
    }
    case kBufferCollection_SetConstraints_Ordinal:
    {
      auto result = ::fidl::DecodeAs<SetConstraintsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetConstraints(std::move(message->has_constraints), std::move(message->constraints),
        Interface::SetConstraintsCompleter::Sync(txn));
      return true;
    }
    case kBufferCollection_WaitForBuffersAllocated_Ordinal:
    {
      auto result = ::fidl::DecodeAs<WaitForBuffersAllocatedRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->WaitForBuffersAllocated(
        Interface::WaitForBuffersAllocatedCompleter::Sync(txn));
      return true;
    }
    case kBufferCollection_CheckBuffersAllocated_Ordinal:
    {
      auto result = ::fidl::DecodeAs<CheckBuffersAllocatedRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->CheckBuffersAllocated(
        Interface::CheckBuffersAllocatedCompleter::Sync(txn));
      return true;
    }
    case kBufferCollection_CloseSingleBuffer_Ordinal:
    {
      auto result = ::fidl::DecodeAs<CloseSingleBufferRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->CloseSingleBuffer(std::move(message->buffer_index),
        Interface::CloseSingleBufferCompleter::Sync(txn));
      return true;
    }
    case kBufferCollection_AllocateSingleBuffer_Ordinal:
    {
      auto result = ::fidl::DecodeAs<AllocateSingleBufferRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->AllocateSingleBuffer(std::move(message->buffer_index),
        Interface::AllocateSingleBufferCompleter::Sync(txn));
      return true;
    }
    case kBufferCollection_WaitForSingleBufferAllocated_Ordinal:
    {
      auto result = ::fidl::DecodeAs<WaitForSingleBufferAllocatedRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->WaitForSingleBufferAllocated(std::move(message->buffer_index),
        Interface::WaitForSingleBufferAllocatedCompleter::Sync(txn));
      return true;
    }
    case kBufferCollection_CheckSingleBufferAllocated_Ordinal:
    {
      auto result = ::fidl::DecodeAs<CheckSingleBufferAllocatedRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->CheckSingleBufferAllocated(std::move(message->buffer_index),
        Interface::CheckSingleBufferAllocatedCompleter::Sync(txn));
      return true;
    }
    case kBufferCollection_Close_Ordinal:
    {
      auto result = ::fidl::DecodeAs<CloseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Close(
        Interface::CloseCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool BufferCollection::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void BufferCollection::Interface::SyncCompleterBase::Reply() {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SyncResponse*>(_write_bytes);
  _response._hdr.ordinal = kBufferCollection_Sync_Ordinal;
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SyncResponse>(std::move(_response_bytes)));
}


void BufferCollection::Interface::WaitForBuffersAllocatedCompleterBase::Reply(int32_t status, BufferCollectionInfo_2 buffer_collection_info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WaitForBuffersAllocatedResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  auto& _response = *reinterpret_cast<WaitForBuffersAllocatedResponse*>(_write_bytes);
  _response._hdr.ordinal = kBufferCollection_WaitForBuffersAllocated_Ordinal;
  _response.status = std::move(status);
  _response.buffer_collection_info = std::move(buffer_collection_info);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(WaitForBuffersAllocatedResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WaitForBuffersAllocatedResponse>(std::move(_response_bytes)));
}

void BufferCollection::Interface::WaitForBuffersAllocatedCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status, BufferCollectionInfo_2 buffer_collection_info) {
  if (_buffer.capacity() < WaitForBuffersAllocatedResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<WaitForBuffersAllocatedResponse*>(_buffer.data());
  _response._hdr.ordinal = kBufferCollection_WaitForBuffersAllocated_Ordinal;
  _response.status = std::move(status);
  _response.buffer_collection_info = std::move(buffer_collection_info);
  _buffer.set_actual(sizeof(WaitForBuffersAllocatedResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WaitForBuffersAllocatedResponse>(std::move(_buffer)));
}

void BufferCollection::Interface::WaitForBuffersAllocatedCompleterBase::Reply(::fidl::DecodedMessage<WaitForBuffersAllocatedResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kBufferCollection_WaitForBuffersAllocated_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void BufferCollection::Interface::CheckBuffersAllocatedCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CheckBuffersAllocatedResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<CheckBuffersAllocatedResponse*>(_write_bytes);
  _response._hdr.ordinal = kBufferCollection_CheckBuffersAllocated_Ordinal;
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(CheckBuffersAllocatedResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CheckBuffersAllocatedResponse>(std::move(_response_bytes)));
}

void BufferCollection::Interface::CheckBuffersAllocatedCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < CheckBuffersAllocatedResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<CheckBuffersAllocatedResponse*>(_buffer.data());
  _response._hdr.ordinal = kBufferCollection_CheckBuffersAllocated_Ordinal;
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(CheckBuffersAllocatedResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CheckBuffersAllocatedResponse>(std::move(_buffer)));
}

void BufferCollection::Interface::CheckBuffersAllocatedCompleterBase::Reply(::fidl::DecodedMessage<CheckBuffersAllocatedResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kBufferCollection_CheckBuffersAllocated_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void BufferCollection::Interface::WaitForSingleBufferAllocatedCompleterBase::Reply(int32_t status, SingleBufferInfo buffer_info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WaitForSingleBufferAllocatedResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<WaitForSingleBufferAllocatedResponse*>(_write_bytes);
  _response._hdr.ordinal = kBufferCollection_WaitForSingleBufferAllocated_Ordinal;
  _response.status = std::move(status);
  _response.buffer_info = std::move(buffer_info);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(WaitForSingleBufferAllocatedResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WaitForSingleBufferAllocatedResponse>(std::move(_response_bytes)));
}

void BufferCollection::Interface::WaitForSingleBufferAllocatedCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status, SingleBufferInfo buffer_info) {
  if (_buffer.capacity() < WaitForSingleBufferAllocatedResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<WaitForSingleBufferAllocatedResponse*>(_buffer.data());
  _response._hdr.ordinal = kBufferCollection_WaitForSingleBufferAllocated_Ordinal;
  _response.status = std::move(status);
  _response.buffer_info = std::move(buffer_info);
  _buffer.set_actual(sizeof(WaitForSingleBufferAllocatedResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WaitForSingleBufferAllocatedResponse>(std::move(_buffer)));
}

void BufferCollection::Interface::WaitForSingleBufferAllocatedCompleterBase::Reply(::fidl::DecodedMessage<WaitForSingleBufferAllocatedResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kBufferCollection_WaitForSingleBufferAllocated_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


}  // namespace sysmem
}  // namespace fuchsia
}  // namespace llcpp

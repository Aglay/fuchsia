// WARNING: This file is machine generated by fidlgen.

#include <fuchsia/cobalt/llcpp/fidl.h>
#include <memory>

namespace llcpp {

namespace fuchsia {
namespace cobalt {

void ::llcpp::fuchsia::cobalt::Value::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(Value) == sizeof(fidl_xunion_t));
  static_assert(offsetof(Value, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(Value, envelope_) == offsetof(fidl_xunion_t, envelope));
}

namespace {

[[maybe_unused]]
constexpr uint64_t kController_RequestSendSoon_Ordinal = 0x8d7092700000000lu;
[[maybe_unused]]
constexpr uint64_t kController_RequestSendSoon_GenOrdinal = 0x554e66bab8f72e3dlu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_ControllerRequestSendSoonRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_ControllerRequestSendSoonResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_BlockUntilEmpty_Ordinal = 0x2bf57e3200000000lu;
[[maybe_unused]]
constexpr uint64_t kController_BlockUntilEmpty_GenOrdinal = 0x72bcf7dd29d1cd5alu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_ControllerBlockUntilEmptyRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_ControllerBlockUntilEmptyResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_GetNumSendAttempts_Ordinal = 0x5805f03f00000000lu;
[[maybe_unused]]
constexpr uint64_t kController_GetNumSendAttempts_GenOrdinal = 0x7ec5409cbc36c796lu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_ControllerGetNumSendAttemptsRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_ControllerGetNumSendAttemptsResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_GetFailedSendAttempts_Ordinal = 0x3a378f4700000000lu;
[[maybe_unused]]
constexpr uint64_t kController_GetFailedSendAttempts_GenOrdinal = 0x5c5af723b6a5067lu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_ControllerGetFailedSendAttemptsRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_ControllerGetFailedSendAttemptsResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_GetNumObservationsAdded_Ordinal = 0x2889cd4500000000lu;
[[maybe_unused]]
constexpr uint64_t kController_GetNumObservationsAdded_GenOrdinal = 0x2f568da2a6cf0ec5lu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_ControllerGetNumObservationsAddedRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_ControllerGetNumObservationsAddedResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_GenerateAggregatedObservations_Ordinal = 0x5ad64bce00000000lu;
[[maybe_unused]]
constexpr uint64_t kController_GenerateAggregatedObservations_GenOrdinal = 0x79e058c9497f1ab1lu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_ControllerGenerateAggregatedObservationsRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_ControllerGenerateAggregatedObservationsResponseTable;

}  // namespace
template <>
Controller::ResultOf::RequestSendSoon_Impl<Controller::RequestSendSoonResponse>::RequestSendSoon_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RequestSendSoonRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, RequestSendSoonRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(RequestSendSoonRequest));
  ::fidl::DecodedMessage<RequestSendSoonRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::RequestSendSoon(std::move(_client_end), Super::response_buffer()));
}

Controller::ResultOf::RequestSendSoon Controller::SyncClient::RequestSendSoon() {
    return ResultOf::RequestSendSoon(::zx::unowned_channel(this->channel_));
}

Controller::ResultOf::RequestSendSoon Controller::Call::RequestSendSoon(::zx::unowned_channel _client_end) {
  return ResultOf::RequestSendSoon(std::move(_client_end));
}

template <>
Controller::UnownedResultOf::RequestSendSoon_Impl<Controller::RequestSendSoonResponse>::RequestSendSoon_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(RequestSendSoonRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, RequestSendSoonRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(RequestSendSoonRequest));
  ::fidl::DecodedMessage<RequestSendSoonRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::RequestSendSoon(std::move(_client_end), std::move(_response_buffer)));
}

Controller::UnownedResultOf::RequestSendSoon Controller::SyncClient::RequestSendSoon(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::RequestSendSoon(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Controller::UnownedResultOf::RequestSendSoon Controller::Call::RequestSendSoon(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::RequestSendSoon(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::RequestSendSoonResponse> Controller::InPlace::RequestSendSoon(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(RequestSendSoonRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<RequestSendSoonRequest> params(std::move(_request_buffer));
  Controller::SetTransactionHeaderFor::RequestSendSoonRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::RequestSendSoonResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<RequestSendSoonRequest, RequestSendSoonResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::RequestSendSoonResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::BlockUntilEmpty_Impl<Controller::BlockUntilEmptyResponse>::BlockUntilEmpty_Impl(::zx::unowned_channel _client_end, uint32_t max_wait_seconds) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<BlockUntilEmptyRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, BlockUntilEmptyRequest::PrimarySize);
  auto& _request = *reinterpret_cast<BlockUntilEmptyRequest*>(_write_bytes);
  _request.max_wait_seconds = std::move(max_wait_seconds);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(BlockUntilEmptyRequest));
  ::fidl::DecodedMessage<BlockUntilEmptyRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::BlockUntilEmpty(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Controller::ResultOf::BlockUntilEmpty Controller::SyncClient::BlockUntilEmpty(uint32_t max_wait_seconds) {
    return ResultOf::BlockUntilEmpty(::zx::unowned_channel(this->channel_), std::move(max_wait_seconds));
}

Controller::ResultOf::BlockUntilEmpty Controller::Call::BlockUntilEmpty(::zx::unowned_channel _client_end, uint32_t max_wait_seconds) {
  return ResultOf::BlockUntilEmpty(std::move(_client_end), std::move(max_wait_seconds));
}

template <>
Controller::UnownedResultOf::BlockUntilEmpty_Impl<Controller::BlockUntilEmptyResponse>::BlockUntilEmpty_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t max_wait_seconds, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < BlockUntilEmptyRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<BlockUntilEmptyResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, BlockUntilEmptyRequest::PrimarySize);
  auto& _request = *reinterpret_cast<BlockUntilEmptyRequest*>(_request_buffer.data());
  _request.max_wait_seconds = std::move(max_wait_seconds);
  _request_buffer.set_actual(sizeof(BlockUntilEmptyRequest));
  ::fidl::DecodedMessage<BlockUntilEmptyRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::BlockUntilEmpty(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Controller::UnownedResultOf::BlockUntilEmpty Controller::SyncClient::BlockUntilEmpty(::fidl::BytePart _request_buffer, uint32_t max_wait_seconds, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::BlockUntilEmpty(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(max_wait_seconds), std::move(_response_buffer));
}

Controller::UnownedResultOf::BlockUntilEmpty Controller::Call::BlockUntilEmpty(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t max_wait_seconds, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::BlockUntilEmpty(std::move(_client_end), std::move(_request_buffer), std::move(max_wait_seconds), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::BlockUntilEmptyResponse> Controller::InPlace::BlockUntilEmpty(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<BlockUntilEmptyRequest> params, ::fidl::BytePart response_buffer) {
  Controller::SetTransactionHeaderFor::BlockUntilEmptyRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::BlockUntilEmptyResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<BlockUntilEmptyRequest, BlockUntilEmptyResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::BlockUntilEmptyResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::GetNumSendAttempts_Impl<Controller::GetNumSendAttemptsResponse>::GetNumSendAttempts_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetNumSendAttemptsRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetNumSendAttemptsRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetNumSendAttemptsRequest));
  ::fidl::DecodedMessage<GetNumSendAttemptsRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::GetNumSendAttempts(std::move(_client_end), Super::response_buffer()));
}

Controller::ResultOf::GetNumSendAttempts Controller::SyncClient::GetNumSendAttempts() {
    return ResultOf::GetNumSendAttempts(::zx::unowned_channel(this->channel_));
}

Controller::ResultOf::GetNumSendAttempts Controller::Call::GetNumSendAttempts(::zx::unowned_channel _client_end) {
  return ResultOf::GetNumSendAttempts(std::move(_client_end));
}

template <>
Controller::UnownedResultOf::GetNumSendAttempts_Impl<Controller::GetNumSendAttemptsResponse>::GetNumSendAttempts_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetNumSendAttemptsRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetNumSendAttemptsRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetNumSendAttemptsRequest));
  ::fidl::DecodedMessage<GetNumSendAttemptsRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::GetNumSendAttempts(std::move(_client_end), std::move(_response_buffer)));
}

Controller::UnownedResultOf::GetNumSendAttempts Controller::SyncClient::GetNumSendAttempts(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetNumSendAttempts(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Controller::UnownedResultOf::GetNumSendAttempts Controller::Call::GetNumSendAttempts(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetNumSendAttempts(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::GetNumSendAttemptsResponse> Controller::InPlace::GetNumSendAttempts(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetNumSendAttemptsRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetNumSendAttemptsRequest> params(std::move(_request_buffer));
  Controller::SetTransactionHeaderFor::GetNumSendAttemptsRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetNumSendAttemptsResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetNumSendAttemptsRequest, GetNumSendAttemptsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetNumSendAttemptsResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::GetFailedSendAttempts_Impl<Controller::GetFailedSendAttemptsResponse>::GetFailedSendAttempts_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetFailedSendAttemptsRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetFailedSendAttemptsRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetFailedSendAttemptsRequest));
  ::fidl::DecodedMessage<GetFailedSendAttemptsRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::GetFailedSendAttempts(std::move(_client_end), Super::response_buffer()));
}

Controller::ResultOf::GetFailedSendAttempts Controller::SyncClient::GetFailedSendAttempts() {
    return ResultOf::GetFailedSendAttempts(::zx::unowned_channel(this->channel_));
}

Controller::ResultOf::GetFailedSendAttempts Controller::Call::GetFailedSendAttempts(::zx::unowned_channel _client_end) {
  return ResultOf::GetFailedSendAttempts(std::move(_client_end));
}

template <>
Controller::UnownedResultOf::GetFailedSendAttempts_Impl<Controller::GetFailedSendAttemptsResponse>::GetFailedSendAttempts_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetFailedSendAttemptsRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetFailedSendAttemptsRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetFailedSendAttemptsRequest));
  ::fidl::DecodedMessage<GetFailedSendAttemptsRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::GetFailedSendAttempts(std::move(_client_end), std::move(_response_buffer)));
}

Controller::UnownedResultOf::GetFailedSendAttempts Controller::SyncClient::GetFailedSendAttempts(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetFailedSendAttempts(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Controller::UnownedResultOf::GetFailedSendAttempts Controller::Call::GetFailedSendAttempts(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetFailedSendAttempts(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::GetFailedSendAttemptsResponse> Controller::InPlace::GetFailedSendAttempts(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetFailedSendAttemptsRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetFailedSendAttemptsRequest> params(std::move(_request_buffer));
  Controller::SetTransactionHeaderFor::GetFailedSendAttemptsRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetFailedSendAttemptsResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetFailedSendAttemptsRequest, GetFailedSendAttemptsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetFailedSendAttemptsResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::GetNumObservationsAdded_Impl<Controller::GetNumObservationsAddedResponse>::GetNumObservationsAdded_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetNumObservationsAddedRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetNumObservationsAddedRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetNumObservationsAddedRequest));
  ::fidl::DecodedMessage<GetNumObservationsAddedRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::GetNumObservationsAdded(std::move(_client_end), Super::response_buffer()));
}

Controller::ResultOf::GetNumObservationsAdded Controller::SyncClient::GetNumObservationsAdded() {
    return ResultOf::GetNumObservationsAdded(::zx::unowned_channel(this->channel_));
}

Controller::ResultOf::GetNumObservationsAdded Controller::Call::GetNumObservationsAdded(::zx::unowned_channel _client_end) {
  return ResultOf::GetNumObservationsAdded(std::move(_client_end));
}

template <>
Controller::UnownedResultOf::GetNumObservationsAdded_Impl<Controller::GetNumObservationsAddedResponse>::GetNumObservationsAdded_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetNumObservationsAddedRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetNumObservationsAddedRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetNumObservationsAddedRequest));
  ::fidl::DecodedMessage<GetNumObservationsAddedRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::GetNumObservationsAdded(std::move(_client_end), std::move(_response_buffer)));
}

Controller::UnownedResultOf::GetNumObservationsAdded Controller::SyncClient::GetNumObservationsAdded(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetNumObservationsAdded(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Controller::UnownedResultOf::GetNumObservationsAdded Controller::Call::GetNumObservationsAdded(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetNumObservationsAdded(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::GetNumObservationsAddedResponse> Controller::InPlace::GetNumObservationsAdded(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetNumObservationsAddedRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetNumObservationsAddedRequest> params(std::move(_request_buffer));
  Controller::SetTransactionHeaderFor::GetNumObservationsAddedRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetNumObservationsAddedResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetNumObservationsAddedRequest, GetNumObservationsAddedResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetNumObservationsAddedResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::GenerateAggregatedObservations_Impl<Controller::GenerateAggregatedObservationsResponse>::GenerateAggregatedObservations_Impl(::zx::unowned_channel _client_end, uint32_t day_index, ::fidl::VectorView<uint32_t> report_ids) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GenerateAggregatedObservationsRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  GenerateAggregatedObservationsRequest _request = {};
  _request.day_index = std::move(day_index);
  _request.report_ids = std::move(report_ids);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<GenerateAggregatedObservationsRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Controller::InPlace::GenerateAggregatedObservations(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Controller::ResultOf::GenerateAggregatedObservations Controller::SyncClient::GenerateAggregatedObservations(uint32_t day_index, ::fidl::VectorView<uint32_t> report_ids) {
    return ResultOf::GenerateAggregatedObservations(::zx::unowned_channel(this->channel_), std::move(day_index), std::move(report_ids));
}

Controller::ResultOf::GenerateAggregatedObservations Controller::Call::GenerateAggregatedObservations(::zx::unowned_channel _client_end, uint32_t day_index, ::fidl::VectorView<uint32_t> report_ids) {
  return ResultOf::GenerateAggregatedObservations(std::move(_client_end), std::move(day_index), std::move(report_ids));
}

template <>
Controller::UnownedResultOf::GenerateAggregatedObservations_Impl<Controller::GenerateAggregatedObservationsResponse>::GenerateAggregatedObservations_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t day_index, ::fidl::VectorView<uint32_t> report_ids, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < GenerateAggregatedObservationsRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<GenerateAggregatedObservationsResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  GenerateAggregatedObservationsRequest _request = {};
  _request.day_index = std::move(day_index);
  _request.report_ids = std::move(report_ids);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<GenerateAggregatedObservationsRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Controller::InPlace::GenerateAggregatedObservations(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Controller::UnownedResultOf::GenerateAggregatedObservations Controller::SyncClient::GenerateAggregatedObservations(::fidl::BytePart _request_buffer, uint32_t day_index, ::fidl::VectorView<uint32_t> report_ids, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GenerateAggregatedObservations(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(day_index), std::move(report_ids), std::move(_response_buffer));
}

Controller::UnownedResultOf::GenerateAggregatedObservations Controller::Call::GenerateAggregatedObservations(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t day_index, ::fidl::VectorView<uint32_t> report_ids, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GenerateAggregatedObservations(std::move(_client_end), std::move(_request_buffer), std::move(day_index), std::move(report_ids), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::GenerateAggregatedObservationsResponse> Controller::InPlace::GenerateAggregatedObservations(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GenerateAggregatedObservationsRequest> params, ::fidl::BytePart response_buffer) {
  Controller::SetTransactionHeaderFor::GenerateAggregatedObservationsRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GenerateAggregatedObservationsResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GenerateAggregatedObservationsRequest, GenerateAggregatedObservationsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GenerateAggregatedObservationsResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool Controller::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kController_RequestSendSoon_Ordinal:
    case kController_RequestSendSoon_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<RequestSendSoonRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->RequestSendSoon(
          Interface::RequestSendSoonCompleter::Sync(txn));
      return true;
    }
    case kController_BlockUntilEmpty_Ordinal:
    case kController_BlockUntilEmpty_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<BlockUntilEmptyRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->BlockUntilEmpty(std::move(message->max_wait_seconds),
          Interface::BlockUntilEmptyCompleter::Sync(txn));
      return true;
    }
    case kController_GetNumSendAttempts_Ordinal:
    case kController_GetNumSendAttempts_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetNumSendAttemptsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetNumSendAttempts(
          Interface::GetNumSendAttemptsCompleter::Sync(txn));
      return true;
    }
    case kController_GetFailedSendAttempts_Ordinal:
    case kController_GetFailedSendAttempts_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetFailedSendAttemptsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetFailedSendAttempts(
          Interface::GetFailedSendAttemptsCompleter::Sync(txn));
      return true;
    }
    case kController_GetNumObservationsAdded_Ordinal:
    case kController_GetNumObservationsAdded_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetNumObservationsAddedRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetNumObservationsAdded(
          Interface::GetNumObservationsAddedCompleter::Sync(txn));
      return true;
    }
    case kController_GenerateAggregatedObservations_Ordinal:
    case kController_GenerateAggregatedObservations_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GenerateAggregatedObservationsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->GenerateAggregatedObservations(std::move(message->day_index), std::move(message->report_ids),
          Interface::GenerateAggregatedObservationsCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Controller::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void Controller::Interface::RequestSendSoonCompleterBase::Reply(bool success) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RequestSendSoonResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<RequestSendSoonResponse*>(_write_bytes);
  Controller::SetTransactionHeaderFor::RequestSendSoonResponse(
      ::fidl::DecodedMessage<RequestSendSoonResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              RequestSendSoonResponse::PrimarySize,
              RequestSendSoonResponse::PrimarySize)));
  _response.success = std::move(success);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(RequestSendSoonResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<RequestSendSoonResponse>(std::move(_response_bytes)));
}

void Controller::Interface::RequestSendSoonCompleterBase::Reply(::fidl::BytePart _buffer, bool success) {
  if (_buffer.capacity() < RequestSendSoonResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<RequestSendSoonResponse*>(_buffer.data());
  Controller::SetTransactionHeaderFor::RequestSendSoonResponse(
      ::fidl::DecodedMessage<RequestSendSoonResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              RequestSendSoonResponse::PrimarySize,
              RequestSendSoonResponse::PrimarySize)));
  _response.success = std::move(success);
  _buffer.set_actual(sizeof(RequestSendSoonResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<RequestSendSoonResponse>(std::move(_buffer)));
}

void Controller::Interface::RequestSendSoonCompleterBase::Reply(::fidl::DecodedMessage<RequestSendSoonResponse> params) {
  Controller::SetTransactionHeaderFor::RequestSendSoonResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::BlockUntilEmptyCompleterBase::Reply() {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<BlockUntilEmptyResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<BlockUntilEmptyResponse*>(_write_bytes);
  Controller::SetTransactionHeaderFor::BlockUntilEmptyResponse(
      ::fidl::DecodedMessage<BlockUntilEmptyResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              BlockUntilEmptyResponse::PrimarySize,
              BlockUntilEmptyResponse::PrimarySize)));
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(BlockUntilEmptyResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<BlockUntilEmptyResponse>(std::move(_response_bytes)));
}


void Controller::Interface::GetNumSendAttemptsCompleterBase::Reply(uint32_t num) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetNumSendAttemptsResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetNumSendAttemptsResponse*>(_write_bytes);
  Controller::SetTransactionHeaderFor::GetNumSendAttemptsResponse(
      ::fidl::DecodedMessage<GetNumSendAttemptsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetNumSendAttemptsResponse::PrimarySize,
              GetNumSendAttemptsResponse::PrimarySize)));
  _response.num = std::move(num);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetNumSendAttemptsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetNumSendAttemptsResponse>(std::move(_response_bytes)));
}

void Controller::Interface::GetNumSendAttemptsCompleterBase::Reply(::fidl::BytePart _buffer, uint32_t num) {
  if (_buffer.capacity() < GetNumSendAttemptsResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetNumSendAttemptsResponse*>(_buffer.data());
  Controller::SetTransactionHeaderFor::GetNumSendAttemptsResponse(
      ::fidl::DecodedMessage<GetNumSendAttemptsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetNumSendAttemptsResponse::PrimarySize,
              GetNumSendAttemptsResponse::PrimarySize)));
  _response.num = std::move(num);
  _buffer.set_actual(sizeof(GetNumSendAttemptsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetNumSendAttemptsResponse>(std::move(_buffer)));
}

void Controller::Interface::GetNumSendAttemptsCompleterBase::Reply(::fidl::DecodedMessage<GetNumSendAttemptsResponse> params) {
  Controller::SetTransactionHeaderFor::GetNumSendAttemptsResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::GetFailedSendAttemptsCompleterBase::Reply(uint32_t num) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetFailedSendAttemptsResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetFailedSendAttemptsResponse*>(_write_bytes);
  Controller::SetTransactionHeaderFor::GetFailedSendAttemptsResponse(
      ::fidl::DecodedMessage<GetFailedSendAttemptsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetFailedSendAttemptsResponse::PrimarySize,
              GetFailedSendAttemptsResponse::PrimarySize)));
  _response.num = std::move(num);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetFailedSendAttemptsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetFailedSendAttemptsResponse>(std::move(_response_bytes)));
}

void Controller::Interface::GetFailedSendAttemptsCompleterBase::Reply(::fidl::BytePart _buffer, uint32_t num) {
  if (_buffer.capacity() < GetFailedSendAttemptsResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetFailedSendAttemptsResponse*>(_buffer.data());
  Controller::SetTransactionHeaderFor::GetFailedSendAttemptsResponse(
      ::fidl::DecodedMessage<GetFailedSendAttemptsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetFailedSendAttemptsResponse::PrimarySize,
              GetFailedSendAttemptsResponse::PrimarySize)));
  _response.num = std::move(num);
  _buffer.set_actual(sizeof(GetFailedSendAttemptsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetFailedSendAttemptsResponse>(std::move(_buffer)));
}

void Controller::Interface::GetFailedSendAttemptsCompleterBase::Reply(::fidl::DecodedMessage<GetFailedSendAttemptsResponse> params) {
  Controller::SetTransactionHeaderFor::GetFailedSendAttemptsResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::GetNumObservationsAddedCompleterBase::Reply(uint64_t num_obs) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetNumObservationsAddedResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetNumObservationsAddedResponse*>(_write_bytes);
  Controller::SetTransactionHeaderFor::GetNumObservationsAddedResponse(
      ::fidl::DecodedMessage<GetNumObservationsAddedResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetNumObservationsAddedResponse::PrimarySize,
              GetNumObservationsAddedResponse::PrimarySize)));
  _response.num_obs = std::move(num_obs);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetNumObservationsAddedResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetNumObservationsAddedResponse>(std::move(_response_bytes)));
}

void Controller::Interface::GetNumObservationsAddedCompleterBase::Reply(::fidl::BytePart _buffer, uint64_t num_obs) {
  if (_buffer.capacity() < GetNumObservationsAddedResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetNumObservationsAddedResponse*>(_buffer.data());
  Controller::SetTransactionHeaderFor::GetNumObservationsAddedResponse(
      ::fidl::DecodedMessage<GetNumObservationsAddedResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetNumObservationsAddedResponse::PrimarySize,
              GetNumObservationsAddedResponse::PrimarySize)));
  _response.num_obs = std::move(num_obs);
  _buffer.set_actual(sizeof(GetNumObservationsAddedResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetNumObservationsAddedResponse>(std::move(_buffer)));
}

void Controller::Interface::GetNumObservationsAddedCompleterBase::Reply(::fidl::DecodedMessage<GetNumObservationsAddedResponse> params) {
  Controller::SetTransactionHeaderFor::GetNumObservationsAddedResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::GenerateAggregatedObservationsCompleterBase::Reply(::fidl::VectorView<uint64_t> num_obs) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GenerateAggregatedObservationsResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  GenerateAggregatedObservationsResponse _response = {};
  Controller::SetTransactionHeaderFor::GenerateAggregatedObservationsResponse(
      ::fidl::DecodedMessage<GenerateAggregatedObservationsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GenerateAggregatedObservationsResponse::PrimarySize,
              GenerateAggregatedObservationsResponse::PrimarySize)));
  _response.num_obs = std::move(num_obs);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Controller::Interface::GenerateAggregatedObservationsCompleterBase::Reply(::fidl::BytePart _buffer, ::fidl::VectorView<uint64_t> num_obs) {
  if (_buffer.capacity() < GenerateAggregatedObservationsResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GenerateAggregatedObservationsResponse _response = {};
  Controller::SetTransactionHeaderFor::GenerateAggregatedObservationsResponse(
      ::fidl::DecodedMessage<GenerateAggregatedObservationsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GenerateAggregatedObservationsResponse::PrimarySize,
              GenerateAggregatedObservationsResponse::PrimarySize)));
  _response.num_obs = std::move(num_obs);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Controller::Interface::GenerateAggregatedObservationsCompleterBase::Reply(::fidl::DecodedMessage<GenerateAggregatedObservationsResponse> params) {
  Controller::SetTransactionHeaderFor::GenerateAggregatedObservationsResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void Controller::SetTransactionHeaderFor::RequestSendSoonRequest(const ::fidl::DecodedMessage<Controller::RequestSendSoonRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_RequestSendSoon_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Controller::SetTransactionHeaderFor::RequestSendSoonResponse(const ::fidl::DecodedMessage<Controller::RequestSendSoonResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_RequestSendSoon_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Controller::SetTransactionHeaderFor::BlockUntilEmptyRequest(const ::fidl::DecodedMessage<Controller::BlockUntilEmptyRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_BlockUntilEmpty_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Controller::SetTransactionHeaderFor::BlockUntilEmptyResponse(const ::fidl::DecodedMessage<Controller::BlockUntilEmptyResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_BlockUntilEmpty_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Controller::SetTransactionHeaderFor::GetNumSendAttemptsRequest(const ::fidl::DecodedMessage<Controller::GetNumSendAttemptsRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_GetNumSendAttempts_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Controller::SetTransactionHeaderFor::GetNumSendAttemptsResponse(const ::fidl::DecodedMessage<Controller::GetNumSendAttemptsResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_GetNumSendAttempts_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Controller::SetTransactionHeaderFor::GetFailedSendAttemptsRequest(const ::fidl::DecodedMessage<Controller::GetFailedSendAttemptsRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_GetFailedSendAttempts_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Controller::SetTransactionHeaderFor::GetFailedSendAttemptsResponse(const ::fidl::DecodedMessage<Controller::GetFailedSendAttemptsResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_GetFailedSendAttempts_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Controller::SetTransactionHeaderFor::GetNumObservationsAddedRequest(const ::fidl::DecodedMessage<Controller::GetNumObservationsAddedRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_GetNumObservationsAdded_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Controller::SetTransactionHeaderFor::GetNumObservationsAddedResponse(const ::fidl::DecodedMessage<Controller::GetNumObservationsAddedResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_GetNumObservationsAdded_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Controller::SetTransactionHeaderFor::GenerateAggregatedObservationsRequest(const ::fidl::DecodedMessage<Controller::GenerateAggregatedObservationsRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_GenerateAggregatedObservations_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Controller::SetTransactionHeaderFor::GenerateAggregatedObservationsResponse(const ::fidl::DecodedMessage<Controller::GenerateAggregatedObservationsResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_GenerateAggregatedObservations_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

namespace {

[[maybe_unused]]
constexpr uint64_t kLoggerBase_LogEvent_Ordinal = 0x135d628d00000000lu;
[[maybe_unused]]
constexpr uint64_t kLoggerBase_LogEvent_GenOrdinal = 0x293433df480dd41elu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerBaseLogEventRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerBaseLogEventResponseTable;
[[maybe_unused]]
constexpr uint64_t kLoggerBase_LogEventCount_Ordinal = 0x6fce776500000000lu;
[[maybe_unused]]
constexpr uint64_t kLoggerBase_LogEventCount_GenOrdinal = 0x5f73f8b900d4bbb1lu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerBaseLogEventCountRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerBaseLogEventCountResponseTable;
[[maybe_unused]]
constexpr uint64_t kLoggerBase_LogElapsedTime_Ordinal = 0x14f4912000000000lu;
[[maybe_unused]]
constexpr uint64_t kLoggerBase_LogElapsedTime_GenOrdinal = 0x42e58931fd6c785lu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerBaseLogElapsedTimeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerBaseLogElapsedTimeResponseTable;
[[maybe_unused]]
constexpr uint64_t kLoggerBase_LogFrameRate_Ordinal = 0x2b8722b800000000lu;
[[maybe_unused]]
constexpr uint64_t kLoggerBase_LogFrameRate_GenOrdinal = 0x4c701bca4836097lu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerBaseLogFrameRateRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerBaseLogFrameRateResponseTable;
[[maybe_unused]]
constexpr uint64_t kLoggerBase_LogMemoryUsage_Ordinal = 0x66c69d1b00000000lu;
[[maybe_unused]]
constexpr uint64_t kLoggerBase_LogMemoryUsage_GenOrdinal = 0x14189c11cc19d641lu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerBaseLogMemoryUsageRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerBaseLogMemoryUsageResponseTable;
[[maybe_unused]]
constexpr uint64_t kLoggerBase_StartTimer_Ordinal = 0x4a5c612000000000lu;
[[maybe_unused]]
constexpr uint64_t kLoggerBase_StartTimer_GenOrdinal = 0x68cec08d094e4938lu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerBaseStartTimerRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerBaseStartTimerResponseTable;
[[maybe_unused]]
constexpr uint64_t kLoggerBase_EndTimer_Ordinal = 0x65db6e4200000000lu;
[[maybe_unused]]
constexpr uint64_t kLoggerBase_EndTimer_GenOrdinal = 0xf0043bc7ed4b561lu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerBaseEndTimerRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerBaseEndTimerResponseTable;

}  // namespace
template <>
LoggerBase::ResultOf::LogEvent_Impl<LoggerBase::LogEventResponse>::LogEvent_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogEventRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, LogEventRequest::PrimarySize);
  auto& _request = *reinterpret_cast<LogEventRequest*>(_write_bytes);
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(LogEventRequest));
  ::fidl::DecodedMessage<LogEventRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      LoggerBase::InPlace::LogEvent(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

LoggerBase::ResultOf::LogEvent LoggerBase::SyncClient::LogEvent(uint32_t metric_id, uint32_t event_code) {
    return ResultOf::LogEvent(::zx::unowned_channel(this->channel_), std::move(metric_id), std::move(event_code));
}

LoggerBase::ResultOf::LogEvent LoggerBase::Call::LogEvent(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code) {
  return ResultOf::LogEvent(std::move(_client_end), std::move(metric_id), std::move(event_code));
}

template <>
LoggerBase::UnownedResultOf::LogEvent_Impl<LoggerBase::LogEventResponse>::LogEvent_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < LogEventRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<LogEventResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, LogEventRequest::PrimarySize);
  auto& _request = *reinterpret_cast<LogEventRequest*>(_request_buffer.data());
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request_buffer.set_actual(sizeof(LogEventRequest));
  ::fidl::DecodedMessage<LogEventRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      LoggerBase::InPlace::LogEvent(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

LoggerBase::UnownedResultOf::LogEvent LoggerBase::SyncClient::LogEvent(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogEvent(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(_response_buffer));
}

LoggerBase::UnownedResultOf::LogEvent LoggerBase::Call::LogEvent(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogEvent(std::move(_client_end), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(_response_buffer));
}

::fidl::DecodeResult<LoggerBase::LogEventResponse> LoggerBase::InPlace::LogEvent(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogEventRequest> params, ::fidl::BytePart response_buffer) {
  LoggerBase::SetTransactionHeaderFor::LogEventRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerBase::LogEventResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<LogEventRequest, LogEventResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerBase::LogEventResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
LoggerBase::ResultOf::LogEventCount_Impl<LoggerBase::LogEventCountResponse>::LogEventCount_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogEventCountRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  LogEventCountRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request.component = std::move(component);
  _request.period_duration_micros = std::move(period_duration_micros);
  _request.count = std::move(count);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LogEventCountRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      LoggerBase::InPlace::LogEventCount(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

LoggerBase::ResultOf::LogEventCount LoggerBase::SyncClient::LogEventCount(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count) {
    return ResultOf::LogEventCount(::zx::unowned_channel(this->channel_), std::move(metric_id), std::move(event_code), std::move(component), std::move(period_duration_micros), std::move(count));
}

LoggerBase::ResultOf::LogEventCount LoggerBase::Call::LogEventCount(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count) {
  return ResultOf::LogEventCount(std::move(_client_end), std::move(metric_id), std::move(event_code), std::move(component), std::move(period_duration_micros), std::move(count));
}

template <>
LoggerBase::UnownedResultOf::LogEventCount_Impl<LoggerBase::LogEventCountResponse>::LogEventCount_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < LogEventCountRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<LogEventCountResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  LogEventCountRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request.component = std::move(component);
  _request.period_duration_micros = std::move(period_duration_micros);
  _request.count = std::move(count);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LogEventCountRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      LoggerBase::InPlace::LogEventCount(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

LoggerBase::UnownedResultOf::LogEventCount LoggerBase::SyncClient::LogEventCount(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogEventCount(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(component), std::move(period_duration_micros), std::move(count), std::move(_response_buffer));
}

LoggerBase::UnownedResultOf::LogEventCount LoggerBase::Call::LogEventCount(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogEventCount(std::move(_client_end), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(component), std::move(period_duration_micros), std::move(count), std::move(_response_buffer));
}

::fidl::DecodeResult<LoggerBase::LogEventCountResponse> LoggerBase::InPlace::LogEventCount(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogEventCountRequest> params, ::fidl::BytePart response_buffer) {
  LoggerBase::SetTransactionHeaderFor::LogEventCountRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerBase::LogEventCountResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<LogEventCountRequest, LogEventCountResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerBase::LogEventCountResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
LoggerBase::ResultOf::LogElapsedTime_Impl<LoggerBase::LogElapsedTimeResponse>::LogElapsedTime_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogElapsedTimeRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  LogElapsedTimeRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request.component = std::move(component);
  _request.elapsed_micros = std::move(elapsed_micros);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LogElapsedTimeRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      LoggerBase::InPlace::LogElapsedTime(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

LoggerBase::ResultOf::LogElapsedTime LoggerBase::SyncClient::LogElapsedTime(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros) {
    return ResultOf::LogElapsedTime(::zx::unowned_channel(this->channel_), std::move(metric_id), std::move(event_code), std::move(component), std::move(elapsed_micros));
}

LoggerBase::ResultOf::LogElapsedTime LoggerBase::Call::LogElapsedTime(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros) {
  return ResultOf::LogElapsedTime(std::move(_client_end), std::move(metric_id), std::move(event_code), std::move(component), std::move(elapsed_micros));
}

template <>
LoggerBase::UnownedResultOf::LogElapsedTime_Impl<LoggerBase::LogElapsedTimeResponse>::LogElapsedTime_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < LogElapsedTimeRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<LogElapsedTimeResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  LogElapsedTimeRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request.component = std::move(component);
  _request.elapsed_micros = std::move(elapsed_micros);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LogElapsedTimeRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      LoggerBase::InPlace::LogElapsedTime(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

LoggerBase::UnownedResultOf::LogElapsedTime LoggerBase::SyncClient::LogElapsedTime(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogElapsedTime(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(component), std::move(elapsed_micros), std::move(_response_buffer));
}

LoggerBase::UnownedResultOf::LogElapsedTime LoggerBase::Call::LogElapsedTime(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogElapsedTime(std::move(_client_end), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(component), std::move(elapsed_micros), std::move(_response_buffer));
}

::fidl::DecodeResult<LoggerBase::LogElapsedTimeResponse> LoggerBase::InPlace::LogElapsedTime(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogElapsedTimeRequest> params, ::fidl::BytePart response_buffer) {
  LoggerBase::SetTransactionHeaderFor::LogElapsedTimeRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerBase::LogElapsedTimeResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<LogElapsedTimeRequest, LogElapsedTimeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerBase::LogElapsedTimeResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
LoggerBase::ResultOf::LogFrameRate_Impl<LoggerBase::LogFrameRateResponse>::LogFrameRate_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogFrameRateRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  LogFrameRateRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request.component = std::move(component);
  _request.fps = std::move(fps);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LogFrameRateRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      LoggerBase::InPlace::LogFrameRate(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

LoggerBase::ResultOf::LogFrameRate LoggerBase::SyncClient::LogFrameRate(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps) {
    return ResultOf::LogFrameRate(::zx::unowned_channel(this->channel_), std::move(metric_id), std::move(event_code), std::move(component), std::move(fps));
}

LoggerBase::ResultOf::LogFrameRate LoggerBase::Call::LogFrameRate(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps) {
  return ResultOf::LogFrameRate(std::move(_client_end), std::move(metric_id), std::move(event_code), std::move(component), std::move(fps));
}

template <>
LoggerBase::UnownedResultOf::LogFrameRate_Impl<LoggerBase::LogFrameRateResponse>::LogFrameRate_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < LogFrameRateRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<LogFrameRateResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  LogFrameRateRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request.component = std::move(component);
  _request.fps = std::move(fps);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LogFrameRateRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      LoggerBase::InPlace::LogFrameRate(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

LoggerBase::UnownedResultOf::LogFrameRate LoggerBase::SyncClient::LogFrameRate(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogFrameRate(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(component), std::move(fps), std::move(_response_buffer));
}

LoggerBase::UnownedResultOf::LogFrameRate LoggerBase::Call::LogFrameRate(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogFrameRate(std::move(_client_end), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(component), std::move(fps), std::move(_response_buffer));
}

::fidl::DecodeResult<LoggerBase::LogFrameRateResponse> LoggerBase::InPlace::LogFrameRate(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogFrameRateRequest> params, ::fidl::BytePart response_buffer) {
  LoggerBase::SetTransactionHeaderFor::LogFrameRateRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerBase::LogFrameRateResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<LogFrameRateRequest, LogFrameRateResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerBase::LogFrameRateResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
LoggerBase::ResultOf::LogMemoryUsage_Impl<LoggerBase::LogMemoryUsageResponse>::LogMemoryUsage_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogMemoryUsageRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  LogMemoryUsageRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request.component = std::move(component);
  _request.bytes = std::move(bytes);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LogMemoryUsageRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      LoggerBase::InPlace::LogMemoryUsage(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

LoggerBase::ResultOf::LogMemoryUsage LoggerBase::SyncClient::LogMemoryUsage(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes) {
    return ResultOf::LogMemoryUsage(::zx::unowned_channel(this->channel_), std::move(metric_id), std::move(event_code), std::move(component), std::move(bytes));
}

LoggerBase::ResultOf::LogMemoryUsage LoggerBase::Call::LogMemoryUsage(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes) {
  return ResultOf::LogMemoryUsage(std::move(_client_end), std::move(metric_id), std::move(event_code), std::move(component), std::move(bytes));
}

template <>
LoggerBase::UnownedResultOf::LogMemoryUsage_Impl<LoggerBase::LogMemoryUsageResponse>::LogMemoryUsage_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < LogMemoryUsageRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<LogMemoryUsageResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  LogMemoryUsageRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request.component = std::move(component);
  _request.bytes = std::move(bytes);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LogMemoryUsageRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      LoggerBase::InPlace::LogMemoryUsage(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

LoggerBase::UnownedResultOf::LogMemoryUsage LoggerBase::SyncClient::LogMemoryUsage(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogMemoryUsage(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(component), std::move(bytes), std::move(_response_buffer));
}

LoggerBase::UnownedResultOf::LogMemoryUsage LoggerBase::Call::LogMemoryUsage(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogMemoryUsage(std::move(_client_end), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(component), std::move(bytes), std::move(_response_buffer));
}

::fidl::DecodeResult<LoggerBase::LogMemoryUsageResponse> LoggerBase::InPlace::LogMemoryUsage(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogMemoryUsageRequest> params, ::fidl::BytePart response_buffer) {
  LoggerBase::SetTransactionHeaderFor::LogMemoryUsageRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerBase::LogMemoryUsageResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<LogMemoryUsageRequest, LogMemoryUsageResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerBase::LogMemoryUsageResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
LoggerBase::ResultOf::StartTimer_Impl<LoggerBase::StartTimerResponse>::StartTimer_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<StartTimerRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  StartTimerRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request.component = std::move(component);
  _request.timer_id = std::move(timer_id);
  _request.timestamp = std::move(timestamp);
  _request.timeout_s = std::move(timeout_s);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<StartTimerRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      LoggerBase::InPlace::StartTimer(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

LoggerBase::ResultOf::StartTimer LoggerBase::SyncClient::StartTimer(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s) {
    return ResultOf::StartTimer(::zx::unowned_channel(this->channel_), std::move(metric_id), std::move(event_code), std::move(component), std::move(timer_id), std::move(timestamp), std::move(timeout_s));
}

LoggerBase::ResultOf::StartTimer LoggerBase::Call::StartTimer(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s) {
  return ResultOf::StartTimer(std::move(_client_end), std::move(metric_id), std::move(event_code), std::move(component), std::move(timer_id), std::move(timestamp), std::move(timeout_s));
}

template <>
LoggerBase::UnownedResultOf::StartTimer_Impl<LoggerBase::StartTimerResponse>::StartTimer_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < StartTimerRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<StartTimerResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  StartTimerRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request.component = std::move(component);
  _request.timer_id = std::move(timer_id);
  _request.timestamp = std::move(timestamp);
  _request.timeout_s = std::move(timeout_s);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<StartTimerRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      LoggerBase::InPlace::StartTimer(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

LoggerBase::UnownedResultOf::StartTimer LoggerBase::SyncClient::StartTimer(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::StartTimer(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(component), std::move(timer_id), std::move(timestamp), std::move(timeout_s), std::move(_response_buffer));
}

LoggerBase::UnownedResultOf::StartTimer LoggerBase::Call::StartTimer(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::StartTimer(std::move(_client_end), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(component), std::move(timer_id), std::move(timestamp), std::move(timeout_s), std::move(_response_buffer));
}

::fidl::DecodeResult<LoggerBase::StartTimerResponse> LoggerBase::InPlace::StartTimer(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<StartTimerRequest> params, ::fidl::BytePart response_buffer) {
  LoggerBase::SetTransactionHeaderFor::StartTimerRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerBase::StartTimerResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<StartTimerRequest, StartTimerResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerBase::StartTimerResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
LoggerBase::ResultOf::EndTimer_Impl<LoggerBase::EndTimerResponse>::EndTimer_Impl(::zx::unowned_channel _client_end, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<EndTimerRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  EndTimerRequest _request = {};
  _request.timer_id = std::move(timer_id);
  _request.timestamp = std::move(timestamp);
  _request.timeout_s = std::move(timeout_s);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<EndTimerRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      LoggerBase::InPlace::EndTimer(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

LoggerBase::ResultOf::EndTimer LoggerBase::SyncClient::EndTimer(::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s) {
    return ResultOf::EndTimer(::zx::unowned_channel(this->channel_), std::move(timer_id), std::move(timestamp), std::move(timeout_s));
}

LoggerBase::ResultOf::EndTimer LoggerBase::Call::EndTimer(::zx::unowned_channel _client_end, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s) {
  return ResultOf::EndTimer(std::move(_client_end), std::move(timer_id), std::move(timestamp), std::move(timeout_s));
}

template <>
LoggerBase::UnownedResultOf::EndTimer_Impl<LoggerBase::EndTimerResponse>::EndTimer_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < EndTimerRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<EndTimerResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  EndTimerRequest _request = {};
  _request.timer_id = std::move(timer_id);
  _request.timestamp = std::move(timestamp);
  _request.timeout_s = std::move(timeout_s);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<EndTimerRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      LoggerBase::InPlace::EndTimer(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

LoggerBase::UnownedResultOf::EndTimer LoggerBase::SyncClient::EndTimer(::fidl::BytePart _request_buffer, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::EndTimer(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(timer_id), std::move(timestamp), std::move(timeout_s), std::move(_response_buffer));
}

LoggerBase::UnownedResultOf::EndTimer LoggerBase::Call::EndTimer(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::EndTimer(std::move(_client_end), std::move(_request_buffer), std::move(timer_id), std::move(timestamp), std::move(timeout_s), std::move(_response_buffer));
}

::fidl::DecodeResult<LoggerBase::EndTimerResponse> LoggerBase::InPlace::EndTimer(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<EndTimerRequest> params, ::fidl::BytePart response_buffer) {
  LoggerBase::SetTransactionHeaderFor::EndTimerRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerBase::EndTimerResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<EndTimerRequest, EndTimerResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerBase::EndTimerResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool LoggerBase::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kLoggerBase_LogEvent_Ordinal:
    case kLoggerBase_LogEvent_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<LogEventRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->LogEvent(std::move(message->metric_id), std::move(message->event_code),
          Interface::LogEventCompleter::Sync(txn));
      return true;
    }
    case kLoggerBase_LogEventCount_Ordinal:
    case kLoggerBase_LogEventCount_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<LogEventCountRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->LogEventCount(std::move(message->metric_id), std::move(message->event_code), std::move(message->component), std::move(message->period_duration_micros), std::move(message->count),
          Interface::LogEventCountCompleter::Sync(txn));
      return true;
    }
    case kLoggerBase_LogElapsedTime_Ordinal:
    case kLoggerBase_LogElapsedTime_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<LogElapsedTimeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->LogElapsedTime(std::move(message->metric_id), std::move(message->event_code), std::move(message->component), std::move(message->elapsed_micros),
          Interface::LogElapsedTimeCompleter::Sync(txn));
      return true;
    }
    case kLoggerBase_LogFrameRate_Ordinal:
    case kLoggerBase_LogFrameRate_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<LogFrameRateRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->LogFrameRate(std::move(message->metric_id), std::move(message->event_code), std::move(message->component), std::move(message->fps),
          Interface::LogFrameRateCompleter::Sync(txn));
      return true;
    }
    case kLoggerBase_LogMemoryUsage_Ordinal:
    case kLoggerBase_LogMemoryUsage_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<LogMemoryUsageRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->LogMemoryUsage(std::move(message->metric_id), std::move(message->event_code), std::move(message->component), std::move(message->bytes),
          Interface::LogMemoryUsageCompleter::Sync(txn));
      return true;
    }
    case kLoggerBase_StartTimer_Ordinal:
    case kLoggerBase_StartTimer_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<StartTimerRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->StartTimer(std::move(message->metric_id), std::move(message->event_code), std::move(message->component), std::move(message->timer_id), std::move(message->timestamp), std::move(message->timeout_s),
          Interface::StartTimerCompleter::Sync(txn));
      return true;
    }
    case kLoggerBase_EndTimer_Ordinal:
    case kLoggerBase_EndTimer_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<EndTimerRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->EndTimer(std::move(message->timer_id), std::move(message->timestamp), std::move(message->timeout_s),
          Interface::EndTimerCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool LoggerBase::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void LoggerBase::Interface::LogEventCompleterBase::Reply(::llcpp::fuchsia::cobalt::Status status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogEventResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<LogEventResponse*>(_write_bytes);
  LoggerBase::SetTransactionHeaderFor::LogEventResponse(
      ::fidl::DecodedMessage<LogEventResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogEventResponse::PrimarySize,
              LogEventResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(LogEventResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogEventResponse>(std::move(_response_bytes)));
}

void LoggerBase::Interface::LogEventCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status) {
  if (_buffer.capacity() < LogEventResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<LogEventResponse*>(_buffer.data());
  LoggerBase::SetTransactionHeaderFor::LogEventResponse(
      ::fidl::DecodedMessage<LogEventResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogEventResponse::PrimarySize,
              LogEventResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(LogEventResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogEventResponse>(std::move(_buffer)));
}

void LoggerBase::Interface::LogEventCompleterBase::Reply(::fidl::DecodedMessage<LogEventResponse> params) {
  LoggerBase::SetTransactionHeaderFor::LogEventResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void LoggerBase::Interface::LogEventCountCompleterBase::Reply(::llcpp::fuchsia::cobalt::Status status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogEventCountResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<LogEventCountResponse*>(_write_bytes);
  LoggerBase::SetTransactionHeaderFor::LogEventCountResponse(
      ::fidl::DecodedMessage<LogEventCountResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogEventCountResponse::PrimarySize,
              LogEventCountResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(LogEventCountResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogEventCountResponse>(std::move(_response_bytes)));
}

void LoggerBase::Interface::LogEventCountCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status) {
  if (_buffer.capacity() < LogEventCountResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<LogEventCountResponse*>(_buffer.data());
  LoggerBase::SetTransactionHeaderFor::LogEventCountResponse(
      ::fidl::DecodedMessage<LogEventCountResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogEventCountResponse::PrimarySize,
              LogEventCountResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(LogEventCountResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogEventCountResponse>(std::move(_buffer)));
}

void LoggerBase::Interface::LogEventCountCompleterBase::Reply(::fidl::DecodedMessage<LogEventCountResponse> params) {
  LoggerBase::SetTransactionHeaderFor::LogEventCountResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void LoggerBase::Interface::LogElapsedTimeCompleterBase::Reply(::llcpp::fuchsia::cobalt::Status status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogElapsedTimeResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<LogElapsedTimeResponse*>(_write_bytes);
  LoggerBase::SetTransactionHeaderFor::LogElapsedTimeResponse(
      ::fidl::DecodedMessage<LogElapsedTimeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogElapsedTimeResponse::PrimarySize,
              LogElapsedTimeResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(LogElapsedTimeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogElapsedTimeResponse>(std::move(_response_bytes)));
}

void LoggerBase::Interface::LogElapsedTimeCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status) {
  if (_buffer.capacity() < LogElapsedTimeResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<LogElapsedTimeResponse*>(_buffer.data());
  LoggerBase::SetTransactionHeaderFor::LogElapsedTimeResponse(
      ::fidl::DecodedMessage<LogElapsedTimeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogElapsedTimeResponse::PrimarySize,
              LogElapsedTimeResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(LogElapsedTimeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogElapsedTimeResponse>(std::move(_buffer)));
}

void LoggerBase::Interface::LogElapsedTimeCompleterBase::Reply(::fidl::DecodedMessage<LogElapsedTimeResponse> params) {
  LoggerBase::SetTransactionHeaderFor::LogElapsedTimeResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void LoggerBase::Interface::LogFrameRateCompleterBase::Reply(::llcpp::fuchsia::cobalt::Status status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogFrameRateResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<LogFrameRateResponse*>(_write_bytes);
  LoggerBase::SetTransactionHeaderFor::LogFrameRateResponse(
      ::fidl::DecodedMessage<LogFrameRateResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogFrameRateResponse::PrimarySize,
              LogFrameRateResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(LogFrameRateResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogFrameRateResponse>(std::move(_response_bytes)));
}

void LoggerBase::Interface::LogFrameRateCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status) {
  if (_buffer.capacity() < LogFrameRateResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<LogFrameRateResponse*>(_buffer.data());
  LoggerBase::SetTransactionHeaderFor::LogFrameRateResponse(
      ::fidl::DecodedMessage<LogFrameRateResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogFrameRateResponse::PrimarySize,
              LogFrameRateResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(LogFrameRateResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogFrameRateResponse>(std::move(_buffer)));
}

void LoggerBase::Interface::LogFrameRateCompleterBase::Reply(::fidl::DecodedMessage<LogFrameRateResponse> params) {
  LoggerBase::SetTransactionHeaderFor::LogFrameRateResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void LoggerBase::Interface::LogMemoryUsageCompleterBase::Reply(::llcpp::fuchsia::cobalt::Status status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogMemoryUsageResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<LogMemoryUsageResponse*>(_write_bytes);
  LoggerBase::SetTransactionHeaderFor::LogMemoryUsageResponse(
      ::fidl::DecodedMessage<LogMemoryUsageResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogMemoryUsageResponse::PrimarySize,
              LogMemoryUsageResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(LogMemoryUsageResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogMemoryUsageResponse>(std::move(_response_bytes)));
}

void LoggerBase::Interface::LogMemoryUsageCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status) {
  if (_buffer.capacity() < LogMemoryUsageResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<LogMemoryUsageResponse*>(_buffer.data());
  LoggerBase::SetTransactionHeaderFor::LogMemoryUsageResponse(
      ::fidl::DecodedMessage<LogMemoryUsageResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogMemoryUsageResponse::PrimarySize,
              LogMemoryUsageResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(LogMemoryUsageResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogMemoryUsageResponse>(std::move(_buffer)));
}

void LoggerBase::Interface::LogMemoryUsageCompleterBase::Reply(::fidl::DecodedMessage<LogMemoryUsageResponse> params) {
  LoggerBase::SetTransactionHeaderFor::LogMemoryUsageResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void LoggerBase::Interface::StartTimerCompleterBase::Reply(::llcpp::fuchsia::cobalt::Status status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<StartTimerResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<StartTimerResponse*>(_write_bytes);
  LoggerBase::SetTransactionHeaderFor::StartTimerResponse(
      ::fidl::DecodedMessage<StartTimerResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              StartTimerResponse::PrimarySize,
              StartTimerResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(StartTimerResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<StartTimerResponse>(std::move(_response_bytes)));
}

void LoggerBase::Interface::StartTimerCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status) {
  if (_buffer.capacity() < StartTimerResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<StartTimerResponse*>(_buffer.data());
  LoggerBase::SetTransactionHeaderFor::StartTimerResponse(
      ::fidl::DecodedMessage<StartTimerResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              StartTimerResponse::PrimarySize,
              StartTimerResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(StartTimerResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<StartTimerResponse>(std::move(_buffer)));
}

void LoggerBase::Interface::StartTimerCompleterBase::Reply(::fidl::DecodedMessage<StartTimerResponse> params) {
  LoggerBase::SetTransactionHeaderFor::StartTimerResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void LoggerBase::Interface::EndTimerCompleterBase::Reply(::llcpp::fuchsia::cobalt::Status status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<EndTimerResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<EndTimerResponse*>(_write_bytes);
  LoggerBase::SetTransactionHeaderFor::EndTimerResponse(
      ::fidl::DecodedMessage<EndTimerResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              EndTimerResponse::PrimarySize,
              EndTimerResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(EndTimerResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<EndTimerResponse>(std::move(_response_bytes)));
}

void LoggerBase::Interface::EndTimerCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status) {
  if (_buffer.capacity() < EndTimerResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<EndTimerResponse*>(_buffer.data());
  LoggerBase::SetTransactionHeaderFor::EndTimerResponse(
      ::fidl::DecodedMessage<EndTimerResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              EndTimerResponse::PrimarySize,
              EndTimerResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(EndTimerResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<EndTimerResponse>(std::move(_buffer)));
}

void LoggerBase::Interface::EndTimerCompleterBase::Reply(::fidl::DecodedMessage<EndTimerResponse> params) {
  LoggerBase::SetTransactionHeaderFor::EndTimerResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void LoggerBase::SetTransactionHeaderFor::LogEventRequest(const ::fidl::DecodedMessage<LoggerBase::LogEventRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerBase_LogEvent_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void LoggerBase::SetTransactionHeaderFor::LogEventResponse(const ::fidl::DecodedMessage<LoggerBase::LogEventResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerBase_LogEvent_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void LoggerBase::SetTransactionHeaderFor::LogEventCountRequest(const ::fidl::DecodedMessage<LoggerBase::LogEventCountRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerBase_LogEventCount_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void LoggerBase::SetTransactionHeaderFor::LogEventCountResponse(const ::fidl::DecodedMessage<LoggerBase::LogEventCountResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerBase_LogEventCount_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void LoggerBase::SetTransactionHeaderFor::LogElapsedTimeRequest(const ::fidl::DecodedMessage<LoggerBase::LogElapsedTimeRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerBase_LogElapsedTime_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void LoggerBase::SetTransactionHeaderFor::LogElapsedTimeResponse(const ::fidl::DecodedMessage<LoggerBase::LogElapsedTimeResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerBase_LogElapsedTime_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void LoggerBase::SetTransactionHeaderFor::LogFrameRateRequest(const ::fidl::DecodedMessage<LoggerBase::LogFrameRateRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerBase_LogFrameRate_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void LoggerBase::SetTransactionHeaderFor::LogFrameRateResponse(const ::fidl::DecodedMessage<LoggerBase::LogFrameRateResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerBase_LogFrameRate_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void LoggerBase::SetTransactionHeaderFor::LogMemoryUsageRequest(const ::fidl::DecodedMessage<LoggerBase::LogMemoryUsageRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerBase_LogMemoryUsage_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void LoggerBase::SetTransactionHeaderFor::LogMemoryUsageResponse(const ::fidl::DecodedMessage<LoggerBase::LogMemoryUsageResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerBase_LogMemoryUsage_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void LoggerBase::SetTransactionHeaderFor::StartTimerRequest(const ::fidl::DecodedMessage<LoggerBase::StartTimerRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerBase_StartTimer_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void LoggerBase::SetTransactionHeaderFor::StartTimerResponse(const ::fidl::DecodedMessage<LoggerBase::StartTimerResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerBase_StartTimer_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void LoggerBase::SetTransactionHeaderFor::EndTimerRequest(const ::fidl::DecodedMessage<LoggerBase::EndTimerRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerBase_EndTimer_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void LoggerBase::SetTransactionHeaderFor::EndTimerResponse(const ::fidl::DecodedMessage<LoggerBase::EndTimerResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerBase_EndTimer_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

namespace {

[[maybe_unused]]
constexpr uint64_t kLoggerSimple_LogEvent_Ordinal = 0x135d628d00000000lu;
[[maybe_unused]]
constexpr uint64_t kLoggerSimple_LogEvent_GenOrdinal = 0x293433df480dd41elu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerSimpleLogEventRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerSimpleLogEventResponseTable;
[[maybe_unused]]
constexpr uint64_t kLoggerSimple_LogEventCount_Ordinal = 0x6fce776500000000lu;
[[maybe_unused]]
constexpr uint64_t kLoggerSimple_LogEventCount_GenOrdinal = 0x5f73f8b900d4bbb1lu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerSimpleLogEventCountRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerSimpleLogEventCountResponseTable;
[[maybe_unused]]
constexpr uint64_t kLoggerSimple_LogElapsedTime_Ordinal = 0x14f4912000000000lu;
[[maybe_unused]]
constexpr uint64_t kLoggerSimple_LogElapsedTime_GenOrdinal = 0x42e58931fd6c785lu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerSimpleLogElapsedTimeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerSimpleLogElapsedTimeResponseTable;
[[maybe_unused]]
constexpr uint64_t kLoggerSimple_LogFrameRate_Ordinal = 0x2b8722b800000000lu;
[[maybe_unused]]
constexpr uint64_t kLoggerSimple_LogFrameRate_GenOrdinal = 0x4c701bca4836097lu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerSimpleLogFrameRateRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerSimpleLogFrameRateResponseTable;
[[maybe_unused]]
constexpr uint64_t kLoggerSimple_LogMemoryUsage_Ordinal = 0x66c69d1b00000000lu;
[[maybe_unused]]
constexpr uint64_t kLoggerSimple_LogMemoryUsage_GenOrdinal = 0x14189c11cc19d641lu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerSimpleLogMemoryUsageRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerSimpleLogMemoryUsageResponseTable;
[[maybe_unused]]
constexpr uint64_t kLoggerSimple_StartTimer_Ordinal = 0x4a5c612000000000lu;
[[maybe_unused]]
constexpr uint64_t kLoggerSimple_StartTimer_GenOrdinal = 0x68cec08d094e4938lu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerSimpleStartTimerRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerSimpleStartTimerResponseTable;
[[maybe_unused]]
constexpr uint64_t kLoggerSimple_EndTimer_Ordinal = 0x65db6e4200000000lu;
[[maybe_unused]]
constexpr uint64_t kLoggerSimple_EndTimer_GenOrdinal = 0xf0043bc7ed4b561lu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerSimpleEndTimerRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerSimpleEndTimerResponseTable;
[[maybe_unused]]
constexpr uint64_t kLoggerSimple_LogIntHistogram_Ordinal = 0x2d40524800000000lu;
[[maybe_unused]]
constexpr uint64_t kLoggerSimple_LogIntHistogram_GenOrdinal = 0x7edf09f7389af401lu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerSimpleLogIntHistogramRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerSimpleLogIntHistogramResponseTable;

}  // namespace
template <>
LoggerSimple::ResultOf::LogEvent_Impl<LoggerSimple::LogEventResponse>::LogEvent_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogEventRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, LogEventRequest::PrimarySize);
  auto& _request = *reinterpret_cast<LogEventRequest*>(_write_bytes);
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(LogEventRequest));
  ::fidl::DecodedMessage<LogEventRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      LoggerSimple::InPlace::LogEvent(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

LoggerSimple::ResultOf::LogEvent LoggerSimple::SyncClient::LogEvent(uint32_t metric_id, uint32_t event_code) {
    return ResultOf::LogEvent(::zx::unowned_channel(this->channel_), std::move(metric_id), std::move(event_code));
}

LoggerSimple::ResultOf::LogEvent LoggerSimple::Call::LogEvent(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code) {
  return ResultOf::LogEvent(std::move(_client_end), std::move(metric_id), std::move(event_code));
}

template <>
LoggerSimple::UnownedResultOf::LogEvent_Impl<LoggerSimple::LogEventResponse>::LogEvent_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < LogEventRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<LogEventResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, LogEventRequest::PrimarySize);
  auto& _request = *reinterpret_cast<LogEventRequest*>(_request_buffer.data());
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request_buffer.set_actual(sizeof(LogEventRequest));
  ::fidl::DecodedMessage<LogEventRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      LoggerSimple::InPlace::LogEvent(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

LoggerSimple::UnownedResultOf::LogEvent LoggerSimple::SyncClient::LogEvent(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogEvent(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(_response_buffer));
}

LoggerSimple::UnownedResultOf::LogEvent LoggerSimple::Call::LogEvent(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogEvent(std::move(_client_end), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(_response_buffer));
}

::fidl::DecodeResult<LoggerSimple::LogEventResponse> LoggerSimple::InPlace::LogEvent(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogEventRequest> params, ::fidl::BytePart response_buffer) {
  LoggerSimple::SetTransactionHeaderFor::LogEventRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerSimple::LogEventResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<LogEventRequest, LogEventResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerSimple::LogEventResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
LoggerSimple::ResultOf::LogEventCount_Impl<LoggerSimple::LogEventCountResponse>::LogEventCount_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogEventCountRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  LogEventCountRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request.component = std::move(component);
  _request.period_duration_micros = std::move(period_duration_micros);
  _request.count = std::move(count);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LogEventCountRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      LoggerSimple::InPlace::LogEventCount(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

LoggerSimple::ResultOf::LogEventCount LoggerSimple::SyncClient::LogEventCount(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count) {
    return ResultOf::LogEventCount(::zx::unowned_channel(this->channel_), std::move(metric_id), std::move(event_code), std::move(component), std::move(period_duration_micros), std::move(count));
}

LoggerSimple::ResultOf::LogEventCount LoggerSimple::Call::LogEventCount(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count) {
  return ResultOf::LogEventCount(std::move(_client_end), std::move(metric_id), std::move(event_code), std::move(component), std::move(period_duration_micros), std::move(count));
}

template <>
LoggerSimple::UnownedResultOf::LogEventCount_Impl<LoggerSimple::LogEventCountResponse>::LogEventCount_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < LogEventCountRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<LogEventCountResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  LogEventCountRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request.component = std::move(component);
  _request.period_duration_micros = std::move(period_duration_micros);
  _request.count = std::move(count);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LogEventCountRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      LoggerSimple::InPlace::LogEventCount(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

LoggerSimple::UnownedResultOf::LogEventCount LoggerSimple::SyncClient::LogEventCount(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogEventCount(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(component), std::move(period_duration_micros), std::move(count), std::move(_response_buffer));
}

LoggerSimple::UnownedResultOf::LogEventCount LoggerSimple::Call::LogEventCount(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogEventCount(std::move(_client_end), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(component), std::move(period_duration_micros), std::move(count), std::move(_response_buffer));
}

::fidl::DecodeResult<LoggerSimple::LogEventCountResponse> LoggerSimple::InPlace::LogEventCount(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogEventCountRequest> params, ::fidl::BytePart response_buffer) {
  LoggerSimple::SetTransactionHeaderFor::LogEventCountRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerSimple::LogEventCountResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<LogEventCountRequest, LogEventCountResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerSimple::LogEventCountResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
LoggerSimple::ResultOf::LogElapsedTime_Impl<LoggerSimple::LogElapsedTimeResponse>::LogElapsedTime_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogElapsedTimeRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  LogElapsedTimeRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request.component = std::move(component);
  _request.elapsed_micros = std::move(elapsed_micros);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LogElapsedTimeRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      LoggerSimple::InPlace::LogElapsedTime(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

LoggerSimple::ResultOf::LogElapsedTime LoggerSimple::SyncClient::LogElapsedTime(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros) {
    return ResultOf::LogElapsedTime(::zx::unowned_channel(this->channel_), std::move(metric_id), std::move(event_code), std::move(component), std::move(elapsed_micros));
}

LoggerSimple::ResultOf::LogElapsedTime LoggerSimple::Call::LogElapsedTime(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros) {
  return ResultOf::LogElapsedTime(std::move(_client_end), std::move(metric_id), std::move(event_code), std::move(component), std::move(elapsed_micros));
}

template <>
LoggerSimple::UnownedResultOf::LogElapsedTime_Impl<LoggerSimple::LogElapsedTimeResponse>::LogElapsedTime_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < LogElapsedTimeRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<LogElapsedTimeResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  LogElapsedTimeRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request.component = std::move(component);
  _request.elapsed_micros = std::move(elapsed_micros);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LogElapsedTimeRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      LoggerSimple::InPlace::LogElapsedTime(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

LoggerSimple::UnownedResultOf::LogElapsedTime LoggerSimple::SyncClient::LogElapsedTime(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogElapsedTime(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(component), std::move(elapsed_micros), std::move(_response_buffer));
}

LoggerSimple::UnownedResultOf::LogElapsedTime LoggerSimple::Call::LogElapsedTime(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogElapsedTime(std::move(_client_end), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(component), std::move(elapsed_micros), std::move(_response_buffer));
}

::fidl::DecodeResult<LoggerSimple::LogElapsedTimeResponse> LoggerSimple::InPlace::LogElapsedTime(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogElapsedTimeRequest> params, ::fidl::BytePart response_buffer) {
  LoggerSimple::SetTransactionHeaderFor::LogElapsedTimeRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerSimple::LogElapsedTimeResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<LogElapsedTimeRequest, LogElapsedTimeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerSimple::LogElapsedTimeResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
LoggerSimple::ResultOf::LogFrameRate_Impl<LoggerSimple::LogFrameRateResponse>::LogFrameRate_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogFrameRateRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  LogFrameRateRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request.component = std::move(component);
  _request.fps = std::move(fps);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LogFrameRateRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      LoggerSimple::InPlace::LogFrameRate(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

LoggerSimple::ResultOf::LogFrameRate LoggerSimple::SyncClient::LogFrameRate(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps) {
    return ResultOf::LogFrameRate(::zx::unowned_channel(this->channel_), std::move(metric_id), std::move(event_code), std::move(component), std::move(fps));
}

LoggerSimple::ResultOf::LogFrameRate LoggerSimple::Call::LogFrameRate(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps) {
  return ResultOf::LogFrameRate(std::move(_client_end), std::move(metric_id), std::move(event_code), std::move(component), std::move(fps));
}

template <>
LoggerSimple::UnownedResultOf::LogFrameRate_Impl<LoggerSimple::LogFrameRateResponse>::LogFrameRate_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < LogFrameRateRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<LogFrameRateResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  LogFrameRateRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request.component = std::move(component);
  _request.fps = std::move(fps);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LogFrameRateRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      LoggerSimple::InPlace::LogFrameRate(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

LoggerSimple::UnownedResultOf::LogFrameRate LoggerSimple::SyncClient::LogFrameRate(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogFrameRate(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(component), std::move(fps), std::move(_response_buffer));
}

LoggerSimple::UnownedResultOf::LogFrameRate LoggerSimple::Call::LogFrameRate(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogFrameRate(std::move(_client_end), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(component), std::move(fps), std::move(_response_buffer));
}

::fidl::DecodeResult<LoggerSimple::LogFrameRateResponse> LoggerSimple::InPlace::LogFrameRate(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogFrameRateRequest> params, ::fidl::BytePart response_buffer) {
  LoggerSimple::SetTransactionHeaderFor::LogFrameRateRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerSimple::LogFrameRateResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<LogFrameRateRequest, LogFrameRateResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerSimple::LogFrameRateResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
LoggerSimple::ResultOf::LogMemoryUsage_Impl<LoggerSimple::LogMemoryUsageResponse>::LogMemoryUsage_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogMemoryUsageRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  LogMemoryUsageRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request.component = std::move(component);
  _request.bytes = std::move(bytes);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LogMemoryUsageRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      LoggerSimple::InPlace::LogMemoryUsage(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

LoggerSimple::ResultOf::LogMemoryUsage LoggerSimple::SyncClient::LogMemoryUsage(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes) {
    return ResultOf::LogMemoryUsage(::zx::unowned_channel(this->channel_), std::move(metric_id), std::move(event_code), std::move(component), std::move(bytes));
}

LoggerSimple::ResultOf::LogMemoryUsage LoggerSimple::Call::LogMemoryUsage(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes) {
  return ResultOf::LogMemoryUsage(std::move(_client_end), std::move(metric_id), std::move(event_code), std::move(component), std::move(bytes));
}

template <>
LoggerSimple::UnownedResultOf::LogMemoryUsage_Impl<LoggerSimple::LogMemoryUsageResponse>::LogMemoryUsage_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < LogMemoryUsageRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<LogMemoryUsageResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  LogMemoryUsageRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request.component = std::move(component);
  _request.bytes = std::move(bytes);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LogMemoryUsageRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      LoggerSimple::InPlace::LogMemoryUsage(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

LoggerSimple::UnownedResultOf::LogMemoryUsage LoggerSimple::SyncClient::LogMemoryUsage(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogMemoryUsage(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(component), std::move(bytes), std::move(_response_buffer));
}

LoggerSimple::UnownedResultOf::LogMemoryUsage LoggerSimple::Call::LogMemoryUsage(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogMemoryUsage(std::move(_client_end), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(component), std::move(bytes), std::move(_response_buffer));
}

::fidl::DecodeResult<LoggerSimple::LogMemoryUsageResponse> LoggerSimple::InPlace::LogMemoryUsage(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogMemoryUsageRequest> params, ::fidl::BytePart response_buffer) {
  LoggerSimple::SetTransactionHeaderFor::LogMemoryUsageRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerSimple::LogMemoryUsageResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<LogMemoryUsageRequest, LogMemoryUsageResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerSimple::LogMemoryUsageResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
LoggerSimple::ResultOf::StartTimer_Impl<LoggerSimple::StartTimerResponse>::StartTimer_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<StartTimerRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  StartTimerRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request.component = std::move(component);
  _request.timer_id = std::move(timer_id);
  _request.timestamp = std::move(timestamp);
  _request.timeout_s = std::move(timeout_s);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<StartTimerRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      LoggerSimple::InPlace::StartTimer(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

LoggerSimple::ResultOf::StartTimer LoggerSimple::SyncClient::StartTimer(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s) {
    return ResultOf::StartTimer(::zx::unowned_channel(this->channel_), std::move(metric_id), std::move(event_code), std::move(component), std::move(timer_id), std::move(timestamp), std::move(timeout_s));
}

LoggerSimple::ResultOf::StartTimer LoggerSimple::Call::StartTimer(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s) {
  return ResultOf::StartTimer(std::move(_client_end), std::move(metric_id), std::move(event_code), std::move(component), std::move(timer_id), std::move(timestamp), std::move(timeout_s));
}

template <>
LoggerSimple::UnownedResultOf::StartTimer_Impl<LoggerSimple::StartTimerResponse>::StartTimer_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < StartTimerRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<StartTimerResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  StartTimerRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request.component = std::move(component);
  _request.timer_id = std::move(timer_id);
  _request.timestamp = std::move(timestamp);
  _request.timeout_s = std::move(timeout_s);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<StartTimerRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      LoggerSimple::InPlace::StartTimer(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

LoggerSimple::UnownedResultOf::StartTimer LoggerSimple::SyncClient::StartTimer(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::StartTimer(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(component), std::move(timer_id), std::move(timestamp), std::move(timeout_s), std::move(_response_buffer));
}

LoggerSimple::UnownedResultOf::StartTimer LoggerSimple::Call::StartTimer(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::StartTimer(std::move(_client_end), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(component), std::move(timer_id), std::move(timestamp), std::move(timeout_s), std::move(_response_buffer));
}

::fidl::DecodeResult<LoggerSimple::StartTimerResponse> LoggerSimple::InPlace::StartTimer(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<StartTimerRequest> params, ::fidl::BytePart response_buffer) {
  LoggerSimple::SetTransactionHeaderFor::StartTimerRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerSimple::StartTimerResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<StartTimerRequest, StartTimerResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerSimple::StartTimerResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
LoggerSimple::ResultOf::EndTimer_Impl<LoggerSimple::EndTimerResponse>::EndTimer_Impl(::zx::unowned_channel _client_end, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<EndTimerRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  EndTimerRequest _request = {};
  _request.timer_id = std::move(timer_id);
  _request.timestamp = std::move(timestamp);
  _request.timeout_s = std::move(timeout_s);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<EndTimerRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      LoggerSimple::InPlace::EndTimer(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

LoggerSimple::ResultOf::EndTimer LoggerSimple::SyncClient::EndTimer(::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s) {
    return ResultOf::EndTimer(::zx::unowned_channel(this->channel_), std::move(timer_id), std::move(timestamp), std::move(timeout_s));
}

LoggerSimple::ResultOf::EndTimer LoggerSimple::Call::EndTimer(::zx::unowned_channel _client_end, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s) {
  return ResultOf::EndTimer(std::move(_client_end), std::move(timer_id), std::move(timestamp), std::move(timeout_s));
}

template <>
LoggerSimple::UnownedResultOf::EndTimer_Impl<LoggerSimple::EndTimerResponse>::EndTimer_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < EndTimerRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<EndTimerResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  EndTimerRequest _request = {};
  _request.timer_id = std::move(timer_id);
  _request.timestamp = std::move(timestamp);
  _request.timeout_s = std::move(timeout_s);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<EndTimerRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      LoggerSimple::InPlace::EndTimer(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

LoggerSimple::UnownedResultOf::EndTimer LoggerSimple::SyncClient::EndTimer(::fidl::BytePart _request_buffer, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::EndTimer(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(timer_id), std::move(timestamp), std::move(timeout_s), std::move(_response_buffer));
}

LoggerSimple::UnownedResultOf::EndTimer LoggerSimple::Call::EndTimer(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::EndTimer(std::move(_client_end), std::move(_request_buffer), std::move(timer_id), std::move(timestamp), std::move(timeout_s), std::move(_response_buffer));
}

::fidl::DecodeResult<LoggerSimple::EndTimerResponse> LoggerSimple::InPlace::EndTimer(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<EndTimerRequest> params, ::fidl::BytePart response_buffer) {
  LoggerSimple::SetTransactionHeaderFor::EndTimerRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerSimple::EndTimerResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<EndTimerRequest, EndTimerResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerSimple::EndTimerResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
LoggerSimple::ResultOf::LogIntHistogram_Impl<LoggerSimple::LogIntHistogramResponse>::LogIntHistogram_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::VectorView<uint32_t> bucket_indices, ::fidl::VectorView<uint64_t> bucket_counts) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogIntHistogramRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  LogIntHistogramRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request.component = std::move(component);
  _request.bucket_indices = std::move(bucket_indices);
  _request.bucket_counts = std::move(bucket_counts);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LogIntHistogramRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      LoggerSimple::InPlace::LogIntHistogram(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

LoggerSimple::ResultOf::LogIntHistogram LoggerSimple::SyncClient::LogIntHistogram(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::VectorView<uint32_t> bucket_indices, ::fidl::VectorView<uint64_t> bucket_counts) {
    return ResultOf::LogIntHistogram(::zx::unowned_channel(this->channel_), std::move(metric_id), std::move(event_code), std::move(component), std::move(bucket_indices), std::move(bucket_counts));
}

LoggerSimple::ResultOf::LogIntHistogram LoggerSimple::Call::LogIntHistogram(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::VectorView<uint32_t> bucket_indices, ::fidl::VectorView<uint64_t> bucket_counts) {
  return ResultOf::LogIntHistogram(std::move(_client_end), std::move(metric_id), std::move(event_code), std::move(component), std::move(bucket_indices), std::move(bucket_counts));
}

template <>
LoggerSimple::UnownedResultOf::LogIntHistogram_Impl<LoggerSimple::LogIntHistogramResponse>::LogIntHistogram_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::VectorView<uint32_t> bucket_indices, ::fidl::VectorView<uint64_t> bucket_counts, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < LogIntHistogramRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<LogIntHistogramResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  LogIntHistogramRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request.component = std::move(component);
  _request.bucket_indices = std::move(bucket_indices);
  _request.bucket_counts = std::move(bucket_counts);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LogIntHistogramRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      LoggerSimple::InPlace::LogIntHistogram(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

LoggerSimple::UnownedResultOf::LogIntHistogram LoggerSimple::SyncClient::LogIntHistogram(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::VectorView<uint32_t> bucket_indices, ::fidl::VectorView<uint64_t> bucket_counts, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogIntHistogram(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(component), std::move(bucket_indices), std::move(bucket_counts), std::move(_response_buffer));
}

LoggerSimple::UnownedResultOf::LogIntHistogram LoggerSimple::Call::LogIntHistogram(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::VectorView<uint32_t> bucket_indices, ::fidl::VectorView<uint64_t> bucket_counts, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogIntHistogram(std::move(_client_end), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(component), std::move(bucket_indices), std::move(bucket_counts), std::move(_response_buffer));
}

::fidl::DecodeResult<LoggerSimple::LogIntHistogramResponse> LoggerSimple::InPlace::LogIntHistogram(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogIntHistogramRequest> params, ::fidl::BytePart response_buffer) {
  LoggerSimple::SetTransactionHeaderFor::LogIntHistogramRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerSimple::LogIntHistogramResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<LogIntHistogramRequest, LogIntHistogramResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerSimple::LogIntHistogramResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool LoggerSimple::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kLoggerSimple_LogEvent_Ordinal:
    case kLoggerSimple_LogEvent_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<LogEventRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->LogEvent(std::move(message->metric_id), std::move(message->event_code),
          Interface::LogEventCompleter::Sync(txn));
      return true;
    }
    case kLoggerSimple_LogEventCount_Ordinal:
    case kLoggerSimple_LogEventCount_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<LogEventCountRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->LogEventCount(std::move(message->metric_id), std::move(message->event_code), std::move(message->component), std::move(message->period_duration_micros), std::move(message->count),
          Interface::LogEventCountCompleter::Sync(txn));
      return true;
    }
    case kLoggerSimple_LogElapsedTime_Ordinal:
    case kLoggerSimple_LogElapsedTime_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<LogElapsedTimeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->LogElapsedTime(std::move(message->metric_id), std::move(message->event_code), std::move(message->component), std::move(message->elapsed_micros),
          Interface::LogElapsedTimeCompleter::Sync(txn));
      return true;
    }
    case kLoggerSimple_LogFrameRate_Ordinal:
    case kLoggerSimple_LogFrameRate_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<LogFrameRateRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->LogFrameRate(std::move(message->metric_id), std::move(message->event_code), std::move(message->component), std::move(message->fps),
          Interface::LogFrameRateCompleter::Sync(txn));
      return true;
    }
    case kLoggerSimple_LogMemoryUsage_Ordinal:
    case kLoggerSimple_LogMemoryUsage_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<LogMemoryUsageRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->LogMemoryUsage(std::move(message->metric_id), std::move(message->event_code), std::move(message->component), std::move(message->bytes),
          Interface::LogMemoryUsageCompleter::Sync(txn));
      return true;
    }
    case kLoggerSimple_StartTimer_Ordinal:
    case kLoggerSimple_StartTimer_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<StartTimerRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->StartTimer(std::move(message->metric_id), std::move(message->event_code), std::move(message->component), std::move(message->timer_id), std::move(message->timestamp), std::move(message->timeout_s),
          Interface::StartTimerCompleter::Sync(txn));
      return true;
    }
    case kLoggerSimple_EndTimer_Ordinal:
    case kLoggerSimple_EndTimer_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<EndTimerRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->EndTimer(std::move(message->timer_id), std::move(message->timestamp), std::move(message->timeout_s),
          Interface::EndTimerCompleter::Sync(txn));
      return true;
    }
    case kLoggerSimple_LogIntHistogram_Ordinal:
    case kLoggerSimple_LogIntHistogram_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<LogIntHistogramRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->LogIntHistogram(std::move(message->metric_id), std::move(message->event_code), std::move(message->component), std::move(message->bucket_indices), std::move(message->bucket_counts),
          Interface::LogIntHistogramCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool LoggerSimple::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void LoggerSimple::Interface::LogEventCompleterBase::Reply(::llcpp::fuchsia::cobalt::Status status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogEventResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<LogEventResponse*>(_write_bytes);
  LoggerSimple::SetTransactionHeaderFor::LogEventResponse(
      ::fidl::DecodedMessage<LogEventResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogEventResponse::PrimarySize,
              LogEventResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(LogEventResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogEventResponse>(std::move(_response_bytes)));
}

void LoggerSimple::Interface::LogEventCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status) {
  if (_buffer.capacity() < LogEventResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<LogEventResponse*>(_buffer.data());
  LoggerSimple::SetTransactionHeaderFor::LogEventResponse(
      ::fidl::DecodedMessage<LogEventResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogEventResponse::PrimarySize,
              LogEventResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(LogEventResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogEventResponse>(std::move(_buffer)));
}

void LoggerSimple::Interface::LogEventCompleterBase::Reply(::fidl::DecodedMessage<LogEventResponse> params) {
  LoggerSimple::SetTransactionHeaderFor::LogEventResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void LoggerSimple::Interface::LogEventCountCompleterBase::Reply(::llcpp::fuchsia::cobalt::Status status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogEventCountResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<LogEventCountResponse*>(_write_bytes);
  LoggerSimple::SetTransactionHeaderFor::LogEventCountResponse(
      ::fidl::DecodedMessage<LogEventCountResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogEventCountResponse::PrimarySize,
              LogEventCountResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(LogEventCountResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogEventCountResponse>(std::move(_response_bytes)));
}

void LoggerSimple::Interface::LogEventCountCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status) {
  if (_buffer.capacity() < LogEventCountResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<LogEventCountResponse*>(_buffer.data());
  LoggerSimple::SetTransactionHeaderFor::LogEventCountResponse(
      ::fidl::DecodedMessage<LogEventCountResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogEventCountResponse::PrimarySize,
              LogEventCountResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(LogEventCountResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogEventCountResponse>(std::move(_buffer)));
}

void LoggerSimple::Interface::LogEventCountCompleterBase::Reply(::fidl::DecodedMessage<LogEventCountResponse> params) {
  LoggerSimple::SetTransactionHeaderFor::LogEventCountResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void LoggerSimple::Interface::LogElapsedTimeCompleterBase::Reply(::llcpp::fuchsia::cobalt::Status status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogElapsedTimeResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<LogElapsedTimeResponse*>(_write_bytes);
  LoggerSimple::SetTransactionHeaderFor::LogElapsedTimeResponse(
      ::fidl::DecodedMessage<LogElapsedTimeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogElapsedTimeResponse::PrimarySize,
              LogElapsedTimeResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(LogElapsedTimeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogElapsedTimeResponse>(std::move(_response_bytes)));
}

void LoggerSimple::Interface::LogElapsedTimeCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status) {
  if (_buffer.capacity() < LogElapsedTimeResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<LogElapsedTimeResponse*>(_buffer.data());
  LoggerSimple::SetTransactionHeaderFor::LogElapsedTimeResponse(
      ::fidl::DecodedMessage<LogElapsedTimeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogElapsedTimeResponse::PrimarySize,
              LogElapsedTimeResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(LogElapsedTimeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogElapsedTimeResponse>(std::move(_buffer)));
}

void LoggerSimple::Interface::LogElapsedTimeCompleterBase::Reply(::fidl::DecodedMessage<LogElapsedTimeResponse> params) {
  LoggerSimple::SetTransactionHeaderFor::LogElapsedTimeResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void LoggerSimple::Interface::LogFrameRateCompleterBase::Reply(::llcpp::fuchsia::cobalt::Status status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogFrameRateResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<LogFrameRateResponse*>(_write_bytes);
  LoggerSimple::SetTransactionHeaderFor::LogFrameRateResponse(
      ::fidl::DecodedMessage<LogFrameRateResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogFrameRateResponse::PrimarySize,
              LogFrameRateResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(LogFrameRateResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogFrameRateResponse>(std::move(_response_bytes)));
}

void LoggerSimple::Interface::LogFrameRateCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status) {
  if (_buffer.capacity() < LogFrameRateResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<LogFrameRateResponse*>(_buffer.data());
  LoggerSimple::SetTransactionHeaderFor::LogFrameRateResponse(
      ::fidl::DecodedMessage<LogFrameRateResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogFrameRateResponse::PrimarySize,
              LogFrameRateResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(LogFrameRateResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogFrameRateResponse>(std::move(_buffer)));
}

void LoggerSimple::Interface::LogFrameRateCompleterBase::Reply(::fidl::DecodedMessage<LogFrameRateResponse> params) {
  LoggerSimple::SetTransactionHeaderFor::LogFrameRateResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void LoggerSimple::Interface::LogMemoryUsageCompleterBase::Reply(::llcpp::fuchsia::cobalt::Status status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogMemoryUsageResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<LogMemoryUsageResponse*>(_write_bytes);
  LoggerSimple::SetTransactionHeaderFor::LogMemoryUsageResponse(
      ::fidl::DecodedMessage<LogMemoryUsageResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogMemoryUsageResponse::PrimarySize,
              LogMemoryUsageResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(LogMemoryUsageResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogMemoryUsageResponse>(std::move(_response_bytes)));
}

void LoggerSimple::Interface::LogMemoryUsageCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status) {
  if (_buffer.capacity() < LogMemoryUsageResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<LogMemoryUsageResponse*>(_buffer.data());
  LoggerSimple::SetTransactionHeaderFor::LogMemoryUsageResponse(
      ::fidl::DecodedMessage<LogMemoryUsageResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogMemoryUsageResponse::PrimarySize,
              LogMemoryUsageResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(LogMemoryUsageResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogMemoryUsageResponse>(std::move(_buffer)));
}

void LoggerSimple::Interface::LogMemoryUsageCompleterBase::Reply(::fidl::DecodedMessage<LogMemoryUsageResponse> params) {
  LoggerSimple::SetTransactionHeaderFor::LogMemoryUsageResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void LoggerSimple::Interface::StartTimerCompleterBase::Reply(::llcpp::fuchsia::cobalt::Status status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<StartTimerResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<StartTimerResponse*>(_write_bytes);
  LoggerSimple::SetTransactionHeaderFor::StartTimerResponse(
      ::fidl::DecodedMessage<StartTimerResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              StartTimerResponse::PrimarySize,
              StartTimerResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(StartTimerResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<StartTimerResponse>(std::move(_response_bytes)));
}

void LoggerSimple::Interface::StartTimerCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status) {
  if (_buffer.capacity() < StartTimerResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<StartTimerResponse*>(_buffer.data());
  LoggerSimple::SetTransactionHeaderFor::StartTimerResponse(
      ::fidl::DecodedMessage<StartTimerResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              StartTimerResponse::PrimarySize,
              StartTimerResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(StartTimerResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<StartTimerResponse>(std::move(_buffer)));
}

void LoggerSimple::Interface::StartTimerCompleterBase::Reply(::fidl::DecodedMessage<StartTimerResponse> params) {
  LoggerSimple::SetTransactionHeaderFor::StartTimerResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void LoggerSimple::Interface::EndTimerCompleterBase::Reply(::llcpp::fuchsia::cobalt::Status status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<EndTimerResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<EndTimerResponse*>(_write_bytes);
  LoggerSimple::SetTransactionHeaderFor::EndTimerResponse(
      ::fidl::DecodedMessage<EndTimerResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              EndTimerResponse::PrimarySize,
              EndTimerResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(EndTimerResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<EndTimerResponse>(std::move(_response_bytes)));
}

void LoggerSimple::Interface::EndTimerCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status) {
  if (_buffer.capacity() < EndTimerResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<EndTimerResponse*>(_buffer.data());
  LoggerSimple::SetTransactionHeaderFor::EndTimerResponse(
      ::fidl::DecodedMessage<EndTimerResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              EndTimerResponse::PrimarySize,
              EndTimerResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(EndTimerResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<EndTimerResponse>(std::move(_buffer)));
}

void LoggerSimple::Interface::EndTimerCompleterBase::Reply(::fidl::DecodedMessage<EndTimerResponse> params) {
  LoggerSimple::SetTransactionHeaderFor::EndTimerResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void LoggerSimple::Interface::LogIntHistogramCompleterBase::Reply(::llcpp::fuchsia::cobalt::Status status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogIntHistogramResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<LogIntHistogramResponse*>(_write_bytes);
  LoggerSimple::SetTransactionHeaderFor::LogIntHistogramResponse(
      ::fidl::DecodedMessage<LogIntHistogramResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogIntHistogramResponse::PrimarySize,
              LogIntHistogramResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(LogIntHistogramResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogIntHistogramResponse>(std::move(_response_bytes)));
}

void LoggerSimple::Interface::LogIntHistogramCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status) {
  if (_buffer.capacity() < LogIntHistogramResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<LogIntHistogramResponse*>(_buffer.data());
  LoggerSimple::SetTransactionHeaderFor::LogIntHistogramResponse(
      ::fidl::DecodedMessage<LogIntHistogramResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogIntHistogramResponse::PrimarySize,
              LogIntHistogramResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(LogIntHistogramResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogIntHistogramResponse>(std::move(_buffer)));
}

void LoggerSimple::Interface::LogIntHistogramCompleterBase::Reply(::fidl::DecodedMessage<LogIntHistogramResponse> params) {
  LoggerSimple::SetTransactionHeaderFor::LogIntHistogramResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void LoggerSimple::SetTransactionHeaderFor::LogEventRequest(const ::fidl::DecodedMessage<LoggerSimple::LogEventRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerSimple_LogEvent_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void LoggerSimple::SetTransactionHeaderFor::LogEventResponse(const ::fidl::DecodedMessage<LoggerSimple::LogEventResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerSimple_LogEvent_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void LoggerSimple::SetTransactionHeaderFor::LogEventCountRequest(const ::fidl::DecodedMessage<LoggerSimple::LogEventCountRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerSimple_LogEventCount_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void LoggerSimple::SetTransactionHeaderFor::LogEventCountResponse(const ::fidl::DecodedMessage<LoggerSimple::LogEventCountResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerSimple_LogEventCount_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void LoggerSimple::SetTransactionHeaderFor::LogElapsedTimeRequest(const ::fidl::DecodedMessage<LoggerSimple::LogElapsedTimeRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerSimple_LogElapsedTime_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void LoggerSimple::SetTransactionHeaderFor::LogElapsedTimeResponse(const ::fidl::DecodedMessage<LoggerSimple::LogElapsedTimeResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerSimple_LogElapsedTime_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void LoggerSimple::SetTransactionHeaderFor::LogFrameRateRequest(const ::fidl::DecodedMessage<LoggerSimple::LogFrameRateRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerSimple_LogFrameRate_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void LoggerSimple::SetTransactionHeaderFor::LogFrameRateResponse(const ::fidl::DecodedMessage<LoggerSimple::LogFrameRateResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerSimple_LogFrameRate_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void LoggerSimple::SetTransactionHeaderFor::LogMemoryUsageRequest(const ::fidl::DecodedMessage<LoggerSimple::LogMemoryUsageRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerSimple_LogMemoryUsage_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void LoggerSimple::SetTransactionHeaderFor::LogMemoryUsageResponse(const ::fidl::DecodedMessage<LoggerSimple::LogMemoryUsageResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerSimple_LogMemoryUsage_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void LoggerSimple::SetTransactionHeaderFor::StartTimerRequest(const ::fidl::DecodedMessage<LoggerSimple::StartTimerRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerSimple_StartTimer_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void LoggerSimple::SetTransactionHeaderFor::StartTimerResponse(const ::fidl::DecodedMessage<LoggerSimple::StartTimerResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerSimple_StartTimer_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void LoggerSimple::SetTransactionHeaderFor::EndTimerRequest(const ::fidl::DecodedMessage<LoggerSimple::EndTimerRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerSimple_EndTimer_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void LoggerSimple::SetTransactionHeaderFor::EndTimerResponse(const ::fidl::DecodedMessage<LoggerSimple::EndTimerResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerSimple_EndTimer_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void LoggerSimple::SetTransactionHeaderFor::LogIntHistogramRequest(const ::fidl::DecodedMessage<LoggerSimple::LogIntHistogramRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerSimple_LogIntHistogram_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void LoggerSimple::SetTransactionHeaderFor::LogIntHistogramResponse(const ::fidl::DecodedMessage<LoggerSimple::LogIntHistogramResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerSimple_LogIntHistogram_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

namespace {

[[maybe_unused]]
constexpr uint64_t kLoggerFactory_CreateLogger_Ordinal = 0x5f08858100000000lu;
[[maybe_unused]]
constexpr uint64_t kLoggerFactory_CreateLogger_GenOrdinal = 0x2a6a220ee3111ab0lu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerFactoryCreateLoggerRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerFactoryCreateLoggerResponseTable;
[[maybe_unused]]
constexpr uint64_t kLoggerFactory_CreateLoggerSimple_Ordinal = 0x5f07c39f00000000lu;
[[maybe_unused]]
constexpr uint64_t kLoggerFactory_CreateLoggerSimple_GenOrdinal = 0x5aa6be2e24fa92f8lu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerFactoryCreateLoggerSimpleRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerFactoryCreateLoggerSimpleResponseTable;
[[maybe_unused]]
constexpr uint64_t kLoggerFactory_CreateLoggerFromProjectId_Ordinal = 0x2b04487500000000lu;
[[maybe_unused]]
constexpr uint64_t kLoggerFactory_CreateLoggerFromProjectId_GenOrdinal = 0x44ee41845029c9celu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerFactoryCreateLoggerFromProjectIdRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerFactoryCreateLoggerFromProjectIdResponseTable;
[[maybe_unused]]
constexpr uint64_t kLoggerFactory_CreateLoggerSimpleFromProjectId_Ordinal = 0x118ecf3100000000lu;
[[maybe_unused]]
constexpr uint64_t kLoggerFactory_CreateLoggerSimpleFromProjectId_GenOrdinal = 0x1f76f43312ce641flu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerFactoryCreateLoggerSimpleFromProjectIdRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerFactoryCreateLoggerSimpleFromProjectIdResponseTable;

}  // namespace
template <>
LoggerFactory::ResultOf::CreateLogger_Impl<LoggerFactory::CreateLoggerResponse>::CreateLogger_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::cobalt::ProjectProfile profile, ::zx::channel logger) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CreateLoggerRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CreateLoggerRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CreateLoggerRequest*>(_write_bytes);
  _request.profile = std::move(profile);
  _request.logger = std::move(logger);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CreateLoggerRequest));
  ::fidl::DecodedMessage<CreateLoggerRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      LoggerFactory::InPlace::CreateLogger(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

LoggerFactory::ResultOf::CreateLogger LoggerFactory::SyncClient::CreateLogger(::llcpp::fuchsia::cobalt::ProjectProfile profile, ::zx::channel logger) {
    return ResultOf::CreateLogger(::zx::unowned_channel(this->channel_), std::move(profile), std::move(logger));
}

LoggerFactory::ResultOf::CreateLogger LoggerFactory::Call::CreateLogger(::zx::unowned_channel _client_end, ::llcpp::fuchsia::cobalt::ProjectProfile profile, ::zx::channel logger) {
  return ResultOf::CreateLogger(std::move(_client_end), std::move(profile), std::move(logger));
}

template <>
LoggerFactory::UnownedResultOf::CreateLogger_Impl<LoggerFactory::CreateLoggerResponse>::CreateLogger_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::cobalt::ProjectProfile profile, ::zx::channel logger, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < CreateLoggerRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<CreateLoggerResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, CreateLoggerRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CreateLoggerRequest*>(_request_buffer.data());
  _request.profile = std::move(profile);
  _request.logger = std::move(logger);
  _request_buffer.set_actual(sizeof(CreateLoggerRequest));
  ::fidl::DecodedMessage<CreateLoggerRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      LoggerFactory::InPlace::CreateLogger(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

LoggerFactory::UnownedResultOf::CreateLogger LoggerFactory::SyncClient::CreateLogger(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::cobalt::ProjectProfile profile, ::zx::channel logger, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::CreateLogger(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(profile), std::move(logger), std::move(_response_buffer));
}

LoggerFactory::UnownedResultOf::CreateLogger LoggerFactory::Call::CreateLogger(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::cobalt::ProjectProfile profile, ::zx::channel logger, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::CreateLogger(std::move(_client_end), std::move(_request_buffer), std::move(profile), std::move(logger), std::move(_response_buffer));
}

::fidl::DecodeResult<LoggerFactory::CreateLoggerResponse> LoggerFactory::InPlace::CreateLogger(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<CreateLoggerRequest> params, ::fidl::BytePart response_buffer) {
  LoggerFactory::SetTransactionHeaderFor::CreateLoggerRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerFactory::CreateLoggerResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<CreateLoggerRequest, CreateLoggerResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerFactory::CreateLoggerResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
LoggerFactory::ResultOf::CreateLoggerSimple_Impl<LoggerFactory::CreateLoggerSimpleResponse>::CreateLoggerSimple_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::cobalt::ProjectProfile profile, ::zx::channel logger) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CreateLoggerSimpleRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CreateLoggerSimpleRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CreateLoggerSimpleRequest*>(_write_bytes);
  _request.profile = std::move(profile);
  _request.logger = std::move(logger);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CreateLoggerSimpleRequest));
  ::fidl::DecodedMessage<CreateLoggerSimpleRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      LoggerFactory::InPlace::CreateLoggerSimple(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

LoggerFactory::ResultOf::CreateLoggerSimple LoggerFactory::SyncClient::CreateLoggerSimple(::llcpp::fuchsia::cobalt::ProjectProfile profile, ::zx::channel logger) {
    return ResultOf::CreateLoggerSimple(::zx::unowned_channel(this->channel_), std::move(profile), std::move(logger));
}

LoggerFactory::ResultOf::CreateLoggerSimple LoggerFactory::Call::CreateLoggerSimple(::zx::unowned_channel _client_end, ::llcpp::fuchsia::cobalt::ProjectProfile profile, ::zx::channel logger) {
  return ResultOf::CreateLoggerSimple(std::move(_client_end), std::move(profile), std::move(logger));
}

template <>
LoggerFactory::UnownedResultOf::CreateLoggerSimple_Impl<LoggerFactory::CreateLoggerSimpleResponse>::CreateLoggerSimple_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::cobalt::ProjectProfile profile, ::zx::channel logger, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < CreateLoggerSimpleRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<CreateLoggerSimpleResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, CreateLoggerSimpleRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CreateLoggerSimpleRequest*>(_request_buffer.data());
  _request.profile = std::move(profile);
  _request.logger = std::move(logger);
  _request_buffer.set_actual(sizeof(CreateLoggerSimpleRequest));
  ::fidl::DecodedMessage<CreateLoggerSimpleRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      LoggerFactory::InPlace::CreateLoggerSimple(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

LoggerFactory::UnownedResultOf::CreateLoggerSimple LoggerFactory::SyncClient::CreateLoggerSimple(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::cobalt::ProjectProfile profile, ::zx::channel logger, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::CreateLoggerSimple(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(profile), std::move(logger), std::move(_response_buffer));
}

LoggerFactory::UnownedResultOf::CreateLoggerSimple LoggerFactory::Call::CreateLoggerSimple(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::cobalt::ProjectProfile profile, ::zx::channel logger, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::CreateLoggerSimple(std::move(_client_end), std::move(_request_buffer), std::move(profile), std::move(logger), std::move(_response_buffer));
}

::fidl::DecodeResult<LoggerFactory::CreateLoggerSimpleResponse> LoggerFactory::InPlace::CreateLoggerSimple(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<CreateLoggerSimpleRequest> params, ::fidl::BytePart response_buffer) {
  LoggerFactory::SetTransactionHeaderFor::CreateLoggerSimpleRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerFactory::CreateLoggerSimpleResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<CreateLoggerSimpleRequest, CreateLoggerSimpleResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerFactory::CreateLoggerSimpleResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
LoggerFactory::ResultOf::CreateLoggerFromProjectId_Impl<LoggerFactory::CreateLoggerFromProjectIdResponse>::CreateLoggerFromProjectId_Impl(::zx::unowned_channel _client_end, uint32_t project_id, ::zx::channel logger) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CreateLoggerFromProjectIdRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CreateLoggerFromProjectIdRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CreateLoggerFromProjectIdRequest*>(_write_bytes);
  _request.project_id = std::move(project_id);
  _request.logger = std::move(logger);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CreateLoggerFromProjectIdRequest));
  ::fidl::DecodedMessage<CreateLoggerFromProjectIdRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      LoggerFactory::InPlace::CreateLoggerFromProjectId(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

LoggerFactory::ResultOf::CreateLoggerFromProjectId LoggerFactory::SyncClient::CreateLoggerFromProjectId(uint32_t project_id, ::zx::channel logger) {
    return ResultOf::CreateLoggerFromProjectId(::zx::unowned_channel(this->channel_), std::move(project_id), std::move(logger));
}

LoggerFactory::ResultOf::CreateLoggerFromProjectId LoggerFactory::Call::CreateLoggerFromProjectId(::zx::unowned_channel _client_end, uint32_t project_id, ::zx::channel logger) {
  return ResultOf::CreateLoggerFromProjectId(std::move(_client_end), std::move(project_id), std::move(logger));
}

template <>
LoggerFactory::UnownedResultOf::CreateLoggerFromProjectId_Impl<LoggerFactory::CreateLoggerFromProjectIdResponse>::CreateLoggerFromProjectId_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t project_id, ::zx::channel logger, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < CreateLoggerFromProjectIdRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<CreateLoggerFromProjectIdResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, CreateLoggerFromProjectIdRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CreateLoggerFromProjectIdRequest*>(_request_buffer.data());
  _request.project_id = std::move(project_id);
  _request.logger = std::move(logger);
  _request_buffer.set_actual(sizeof(CreateLoggerFromProjectIdRequest));
  ::fidl::DecodedMessage<CreateLoggerFromProjectIdRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      LoggerFactory::InPlace::CreateLoggerFromProjectId(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

LoggerFactory::UnownedResultOf::CreateLoggerFromProjectId LoggerFactory::SyncClient::CreateLoggerFromProjectId(::fidl::BytePart _request_buffer, uint32_t project_id, ::zx::channel logger, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::CreateLoggerFromProjectId(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(project_id), std::move(logger), std::move(_response_buffer));
}

LoggerFactory::UnownedResultOf::CreateLoggerFromProjectId LoggerFactory::Call::CreateLoggerFromProjectId(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t project_id, ::zx::channel logger, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::CreateLoggerFromProjectId(std::move(_client_end), std::move(_request_buffer), std::move(project_id), std::move(logger), std::move(_response_buffer));
}

::fidl::DecodeResult<LoggerFactory::CreateLoggerFromProjectIdResponse> LoggerFactory::InPlace::CreateLoggerFromProjectId(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<CreateLoggerFromProjectIdRequest> params, ::fidl::BytePart response_buffer) {
  LoggerFactory::SetTransactionHeaderFor::CreateLoggerFromProjectIdRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerFactory::CreateLoggerFromProjectIdResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<CreateLoggerFromProjectIdRequest, CreateLoggerFromProjectIdResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerFactory::CreateLoggerFromProjectIdResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
LoggerFactory::ResultOf::CreateLoggerSimpleFromProjectId_Impl<LoggerFactory::CreateLoggerSimpleFromProjectIdResponse>::CreateLoggerSimpleFromProjectId_Impl(::zx::unowned_channel _client_end, uint32_t project_id, ::zx::channel logger) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CreateLoggerSimpleFromProjectIdRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CreateLoggerSimpleFromProjectIdRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CreateLoggerSimpleFromProjectIdRequest*>(_write_bytes);
  _request.project_id = std::move(project_id);
  _request.logger = std::move(logger);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CreateLoggerSimpleFromProjectIdRequest));
  ::fidl::DecodedMessage<CreateLoggerSimpleFromProjectIdRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      LoggerFactory::InPlace::CreateLoggerSimpleFromProjectId(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

LoggerFactory::ResultOf::CreateLoggerSimpleFromProjectId LoggerFactory::SyncClient::CreateLoggerSimpleFromProjectId(uint32_t project_id, ::zx::channel logger) {
    return ResultOf::CreateLoggerSimpleFromProjectId(::zx::unowned_channel(this->channel_), std::move(project_id), std::move(logger));
}

LoggerFactory::ResultOf::CreateLoggerSimpleFromProjectId LoggerFactory::Call::CreateLoggerSimpleFromProjectId(::zx::unowned_channel _client_end, uint32_t project_id, ::zx::channel logger) {
  return ResultOf::CreateLoggerSimpleFromProjectId(std::move(_client_end), std::move(project_id), std::move(logger));
}

template <>
LoggerFactory::UnownedResultOf::CreateLoggerSimpleFromProjectId_Impl<LoggerFactory::CreateLoggerSimpleFromProjectIdResponse>::CreateLoggerSimpleFromProjectId_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t project_id, ::zx::channel logger, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < CreateLoggerSimpleFromProjectIdRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<CreateLoggerSimpleFromProjectIdResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, CreateLoggerSimpleFromProjectIdRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CreateLoggerSimpleFromProjectIdRequest*>(_request_buffer.data());
  _request.project_id = std::move(project_id);
  _request.logger = std::move(logger);
  _request_buffer.set_actual(sizeof(CreateLoggerSimpleFromProjectIdRequest));
  ::fidl::DecodedMessage<CreateLoggerSimpleFromProjectIdRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      LoggerFactory::InPlace::CreateLoggerSimpleFromProjectId(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

LoggerFactory::UnownedResultOf::CreateLoggerSimpleFromProjectId LoggerFactory::SyncClient::CreateLoggerSimpleFromProjectId(::fidl::BytePart _request_buffer, uint32_t project_id, ::zx::channel logger, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::CreateLoggerSimpleFromProjectId(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(project_id), std::move(logger), std::move(_response_buffer));
}

LoggerFactory::UnownedResultOf::CreateLoggerSimpleFromProjectId LoggerFactory::Call::CreateLoggerSimpleFromProjectId(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t project_id, ::zx::channel logger, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::CreateLoggerSimpleFromProjectId(std::move(_client_end), std::move(_request_buffer), std::move(project_id), std::move(logger), std::move(_response_buffer));
}

::fidl::DecodeResult<LoggerFactory::CreateLoggerSimpleFromProjectIdResponse> LoggerFactory::InPlace::CreateLoggerSimpleFromProjectId(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<CreateLoggerSimpleFromProjectIdRequest> params, ::fidl::BytePart response_buffer) {
  LoggerFactory::SetTransactionHeaderFor::CreateLoggerSimpleFromProjectIdRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerFactory::CreateLoggerSimpleFromProjectIdResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<CreateLoggerSimpleFromProjectIdRequest, CreateLoggerSimpleFromProjectIdResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LoggerFactory::CreateLoggerSimpleFromProjectIdResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool LoggerFactory::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kLoggerFactory_CreateLogger_Ordinal:
    case kLoggerFactory_CreateLogger_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<CreateLoggerRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->CreateLogger(std::move(message->profile), std::move(message->logger),
          Interface::CreateLoggerCompleter::Sync(txn));
      return true;
    }
    case kLoggerFactory_CreateLoggerSimple_Ordinal:
    case kLoggerFactory_CreateLoggerSimple_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<CreateLoggerSimpleRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->CreateLoggerSimple(std::move(message->profile), std::move(message->logger),
          Interface::CreateLoggerSimpleCompleter::Sync(txn));
      return true;
    }
    case kLoggerFactory_CreateLoggerFromProjectId_Ordinal:
    case kLoggerFactory_CreateLoggerFromProjectId_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<CreateLoggerFromProjectIdRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->CreateLoggerFromProjectId(std::move(message->project_id), std::move(message->logger),
          Interface::CreateLoggerFromProjectIdCompleter::Sync(txn));
      return true;
    }
    case kLoggerFactory_CreateLoggerSimpleFromProjectId_Ordinal:
    case kLoggerFactory_CreateLoggerSimpleFromProjectId_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<CreateLoggerSimpleFromProjectIdRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->CreateLoggerSimpleFromProjectId(std::move(message->project_id), std::move(message->logger),
          Interface::CreateLoggerSimpleFromProjectIdCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool LoggerFactory::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void LoggerFactory::Interface::CreateLoggerCompleterBase::Reply(::llcpp::fuchsia::cobalt::Status status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CreateLoggerResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<CreateLoggerResponse*>(_write_bytes);
  LoggerFactory::SetTransactionHeaderFor::CreateLoggerResponse(
      ::fidl::DecodedMessage<CreateLoggerResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              CreateLoggerResponse::PrimarySize,
              CreateLoggerResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(CreateLoggerResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CreateLoggerResponse>(std::move(_response_bytes)));
}

void LoggerFactory::Interface::CreateLoggerCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status) {
  if (_buffer.capacity() < CreateLoggerResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<CreateLoggerResponse*>(_buffer.data());
  LoggerFactory::SetTransactionHeaderFor::CreateLoggerResponse(
      ::fidl::DecodedMessage<CreateLoggerResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              CreateLoggerResponse::PrimarySize,
              CreateLoggerResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(CreateLoggerResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CreateLoggerResponse>(std::move(_buffer)));
}

void LoggerFactory::Interface::CreateLoggerCompleterBase::Reply(::fidl::DecodedMessage<CreateLoggerResponse> params) {
  LoggerFactory::SetTransactionHeaderFor::CreateLoggerResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void LoggerFactory::Interface::CreateLoggerSimpleCompleterBase::Reply(::llcpp::fuchsia::cobalt::Status status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CreateLoggerSimpleResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<CreateLoggerSimpleResponse*>(_write_bytes);
  LoggerFactory::SetTransactionHeaderFor::CreateLoggerSimpleResponse(
      ::fidl::DecodedMessage<CreateLoggerSimpleResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              CreateLoggerSimpleResponse::PrimarySize,
              CreateLoggerSimpleResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(CreateLoggerSimpleResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CreateLoggerSimpleResponse>(std::move(_response_bytes)));
}

void LoggerFactory::Interface::CreateLoggerSimpleCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status) {
  if (_buffer.capacity() < CreateLoggerSimpleResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<CreateLoggerSimpleResponse*>(_buffer.data());
  LoggerFactory::SetTransactionHeaderFor::CreateLoggerSimpleResponse(
      ::fidl::DecodedMessage<CreateLoggerSimpleResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              CreateLoggerSimpleResponse::PrimarySize,
              CreateLoggerSimpleResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(CreateLoggerSimpleResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CreateLoggerSimpleResponse>(std::move(_buffer)));
}

void LoggerFactory::Interface::CreateLoggerSimpleCompleterBase::Reply(::fidl::DecodedMessage<CreateLoggerSimpleResponse> params) {
  LoggerFactory::SetTransactionHeaderFor::CreateLoggerSimpleResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void LoggerFactory::Interface::CreateLoggerFromProjectIdCompleterBase::Reply(::llcpp::fuchsia::cobalt::Status status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CreateLoggerFromProjectIdResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<CreateLoggerFromProjectIdResponse*>(_write_bytes);
  LoggerFactory::SetTransactionHeaderFor::CreateLoggerFromProjectIdResponse(
      ::fidl::DecodedMessage<CreateLoggerFromProjectIdResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              CreateLoggerFromProjectIdResponse::PrimarySize,
              CreateLoggerFromProjectIdResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(CreateLoggerFromProjectIdResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CreateLoggerFromProjectIdResponse>(std::move(_response_bytes)));
}

void LoggerFactory::Interface::CreateLoggerFromProjectIdCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status) {
  if (_buffer.capacity() < CreateLoggerFromProjectIdResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<CreateLoggerFromProjectIdResponse*>(_buffer.data());
  LoggerFactory::SetTransactionHeaderFor::CreateLoggerFromProjectIdResponse(
      ::fidl::DecodedMessage<CreateLoggerFromProjectIdResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              CreateLoggerFromProjectIdResponse::PrimarySize,
              CreateLoggerFromProjectIdResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(CreateLoggerFromProjectIdResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CreateLoggerFromProjectIdResponse>(std::move(_buffer)));
}

void LoggerFactory::Interface::CreateLoggerFromProjectIdCompleterBase::Reply(::fidl::DecodedMessage<CreateLoggerFromProjectIdResponse> params) {
  LoggerFactory::SetTransactionHeaderFor::CreateLoggerFromProjectIdResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void LoggerFactory::Interface::CreateLoggerSimpleFromProjectIdCompleterBase::Reply(::llcpp::fuchsia::cobalt::Status status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CreateLoggerSimpleFromProjectIdResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<CreateLoggerSimpleFromProjectIdResponse*>(_write_bytes);
  LoggerFactory::SetTransactionHeaderFor::CreateLoggerSimpleFromProjectIdResponse(
      ::fidl::DecodedMessage<CreateLoggerSimpleFromProjectIdResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              CreateLoggerSimpleFromProjectIdResponse::PrimarySize,
              CreateLoggerSimpleFromProjectIdResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(CreateLoggerSimpleFromProjectIdResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CreateLoggerSimpleFromProjectIdResponse>(std::move(_response_bytes)));
}

void LoggerFactory::Interface::CreateLoggerSimpleFromProjectIdCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status) {
  if (_buffer.capacity() < CreateLoggerSimpleFromProjectIdResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<CreateLoggerSimpleFromProjectIdResponse*>(_buffer.data());
  LoggerFactory::SetTransactionHeaderFor::CreateLoggerSimpleFromProjectIdResponse(
      ::fidl::DecodedMessage<CreateLoggerSimpleFromProjectIdResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              CreateLoggerSimpleFromProjectIdResponse::PrimarySize,
              CreateLoggerSimpleFromProjectIdResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(CreateLoggerSimpleFromProjectIdResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CreateLoggerSimpleFromProjectIdResponse>(std::move(_buffer)));
}

void LoggerFactory::Interface::CreateLoggerSimpleFromProjectIdCompleterBase::Reply(::fidl::DecodedMessage<CreateLoggerSimpleFromProjectIdResponse> params) {
  LoggerFactory::SetTransactionHeaderFor::CreateLoggerSimpleFromProjectIdResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void LoggerFactory::SetTransactionHeaderFor::CreateLoggerRequest(const ::fidl::DecodedMessage<LoggerFactory::CreateLoggerRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerFactory_CreateLogger_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void LoggerFactory::SetTransactionHeaderFor::CreateLoggerResponse(const ::fidl::DecodedMessage<LoggerFactory::CreateLoggerResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerFactory_CreateLogger_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void LoggerFactory::SetTransactionHeaderFor::CreateLoggerSimpleRequest(const ::fidl::DecodedMessage<LoggerFactory::CreateLoggerSimpleRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerFactory_CreateLoggerSimple_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void LoggerFactory::SetTransactionHeaderFor::CreateLoggerSimpleResponse(const ::fidl::DecodedMessage<LoggerFactory::CreateLoggerSimpleResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerFactory_CreateLoggerSimple_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void LoggerFactory::SetTransactionHeaderFor::CreateLoggerFromProjectIdRequest(const ::fidl::DecodedMessage<LoggerFactory::CreateLoggerFromProjectIdRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerFactory_CreateLoggerFromProjectId_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void LoggerFactory::SetTransactionHeaderFor::CreateLoggerFromProjectIdResponse(const ::fidl::DecodedMessage<LoggerFactory::CreateLoggerFromProjectIdResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerFactory_CreateLoggerFromProjectId_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void LoggerFactory::SetTransactionHeaderFor::CreateLoggerSimpleFromProjectIdRequest(const ::fidl::DecodedMessage<LoggerFactory::CreateLoggerSimpleFromProjectIdRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerFactory_CreateLoggerSimpleFromProjectId_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void LoggerFactory::SetTransactionHeaderFor::CreateLoggerSimpleFromProjectIdResponse(const ::fidl::DecodedMessage<LoggerFactory::CreateLoggerSimpleFromProjectIdResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLoggerFactory_CreateLoggerSimpleFromProjectId_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

namespace {

[[maybe_unused]]
constexpr uint64_t kSystemDataUpdater_SetExperimentState_Ordinal = 0x7179ca9100000000lu;
[[maybe_unused]]
constexpr uint64_t kSystemDataUpdater_SetExperimentState_GenOrdinal = 0x64c8f26bffbe2e2elu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_SystemDataUpdaterSetExperimentStateRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_SystemDataUpdaterSetExperimentStateResponseTable;
[[maybe_unused]]
constexpr uint64_t kSystemDataUpdater_SetChannel_Ordinal = 0x37f1709100000000lu;
[[maybe_unused]]
constexpr uint64_t kSystemDataUpdater_SetChannel_GenOrdinal = 0x550a753f31ff2ce2lu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_SystemDataUpdaterSetChannelRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_SystemDataUpdaterSetChannelResponseTable;

}  // namespace
template <>
SystemDataUpdater::ResultOf::SetExperimentState_Impl<SystemDataUpdater::SetExperimentStateResponse>::SetExperimentState_Impl(::zx::unowned_channel _client_end, ::fidl::VectorView<::llcpp::fuchsia::cobalt::Experiment> experiments) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetExperimentStateRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  SetExperimentStateRequest _request = {};
  _request.experiments = std::move(experiments);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<SetExperimentStateRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      SystemDataUpdater::InPlace::SetExperimentState(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

SystemDataUpdater::ResultOf::SetExperimentState SystemDataUpdater::SyncClient::SetExperimentState(::fidl::VectorView<::llcpp::fuchsia::cobalt::Experiment> experiments) {
    return ResultOf::SetExperimentState(::zx::unowned_channel(this->channel_), std::move(experiments));
}

SystemDataUpdater::ResultOf::SetExperimentState SystemDataUpdater::Call::SetExperimentState(::zx::unowned_channel _client_end, ::fidl::VectorView<::llcpp::fuchsia::cobalt::Experiment> experiments) {
  return ResultOf::SetExperimentState(std::move(_client_end), std::move(experiments));
}

template <>
SystemDataUpdater::UnownedResultOf::SetExperimentState_Impl<SystemDataUpdater::SetExperimentStateResponse>::SetExperimentState_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<::llcpp::fuchsia::cobalt::Experiment> experiments, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < SetExperimentStateRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<SetExperimentStateResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  SetExperimentStateRequest _request = {};
  _request.experiments = std::move(experiments);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<SetExperimentStateRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      SystemDataUpdater::InPlace::SetExperimentState(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

SystemDataUpdater::UnownedResultOf::SetExperimentState SystemDataUpdater::SyncClient::SetExperimentState(::fidl::BytePart _request_buffer, ::fidl::VectorView<::llcpp::fuchsia::cobalt::Experiment> experiments, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetExperimentState(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(experiments), std::move(_response_buffer));
}

SystemDataUpdater::UnownedResultOf::SetExperimentState SystemDataUpdater::Call::SetExperimentState(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<::llcpp::fuchsia::cobalt::Experiment> experiments, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetExperimentState(std::move(_client_end), std::move(_request_buffer), std::move(experiments), std::move(_response_buffer));
}

::fidl::DecodeResult<SystemDataUpdater::SetExperimentStateResponse> SystemDataUpdater::InPlace::SetExperimentState(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetExperimentStateRequest> params, ::fidl::BytePart response_buffer) {
  SystemDataUpdater::SetTransactionHeaderFor::SetExperimentStateRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SystemDataUpdater::SetExperimentStateResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SetExperimentStateRequest, SetExperimentStateResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SystemDataUpdater::SetExperimentStateResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
SystemDataUpdater::ResultOf::SetChannel_Impl<SystemDataUpdater::SetChannelResponse>::SetChannel_Impl(::zx::unowned_channel _client_end, ::fidl::StringView current_channel) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetChannelRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  SetChannelRequest _request = {};
  _request.current_channel = std::move(current_channel);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<SetChannelRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      SystemDataUpdater::InPlace::SetChannel(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

SystemDataUpdater::ResultOf::SetChannel SystemDataUpdater::SyncClient::SetChannel(::fidl::StringView current_channel) {
    return ResultOf::SetChannel(::zx::unowned_channel(this->channel_), std::move(current_channel));
}

SystemDataUpdater::ResultOf::SetChannel SystemDataUpdater::Call::SetChannel(::zx::unowned_channel _client_end, ::fidl::StringView current_channel) {
  return ResultOf::SetChannel(std::move(_client_end), std::move(current_channel));
}

template <>
SystemDataUpdater::UnownedResultOf::SetChannel_Impl<SystemDataUpdater::SetChannelResponse>::SetChannel_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView current_channel, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < SetChannelRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<SetChannelResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  SetChannelRequest _request = {};
  _request.current_channel = std::move(current_channel);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<SetChannelRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      SystemDataUpdater::InPlace::SetChannel(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

SystemDataUpdater::UnownedResultOf::SetChannel SystemDataUpdater::SyncClient::SetChannel(::fidl::BytePart _request_buffer, ::fidl::StringView current_channel, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetChannel(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(current_channel), std::move(_response_buffer));
}

SystemDataUpdater::UnownedResultOf::SetChannel SystemDataUpdater::Call::SetChannel(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView current_channel, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetChannel(std::move(_client_end), std::move(_request_buffer), std::move(current_channel), std::move(_response_buffer));
}

::fidl::DecodeResult<SystemDataUpdater::SetChannelResponse> SystemDataUpdater::InPlace::SetChannel(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetChannelRequest> params, ::fidl::BytePart response_buffer) {
  SystemDataUpdater::SetTransactionHeaderFor::SetChannelRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SystemDataUpdater::SetChannelResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SetChannelRequest, SetChannelResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SystemDataUpdater::SetChannelResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool SystemDataUpdater::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kSystemDataUpdater_SetExperimentState_Ordinal:
    case kSystemDataUpdater_SetExperimentState_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetExperimentStateRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetExperimentState(std::move(message->experiments),
          Interface::SetExperimentStateCompleter::Sync(txn));
      return true;
    }
    case kSystemDataUpdater_SetChannel_Ordinal:
    case kSystemDataUpdater_SetChannel_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetChannelRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetChannel(std::move(message->current_channel),
          Interface::SetChannelCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool SystemDataUpdater::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void SystemDataUpdater::Interface::SetExperimentStateCompleterBase::Reply(::llcpp::fuchsia::cobalt::Status status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetExperimentStateResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SetExperimentStateResponse*>(_write_bytes);
  SystemDataUpdater::SetTransactionHeaderFor::SetExperimentStateResponse(
      ::fidl::DecodedMessage<SetExperimentStateResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetExperimentStateResponse::PrimarySize,
              SetExperimentStateResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetExperimentStateResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetExperimentStateResponse>(std::move(_response_bytes)));
}

void SystemDataUpdater::Interface::SetExperimentStateCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status) {
  if (_buffer.capacity() < SetExperimentStateResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SetExperimentStateResponse*>(_buffer.data());
  SystemDataUpdater::SetTransactionHeaderFor::SetExperimentStateResponse(
      ::fidl::DecodedMessage<SetExperimentStateResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetExperimentStateResponse::PrimarySize,
              SetExperimentStateResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(SetExperimentStateResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetExperimentStateResponse>(std::move(_buffer)));
}

void SystemDataUpdater::Interface::SetExperimentStateCompleterBase::Reply(::fidl::DecodedMessage<SetExperimentStateResponse> params) {
  SystemDataUpdater::SetTransactionHeaderFor::SetExperimentStateResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void SystemDataUpdater::Interface::SetChannelCompleterBase::Reply(::llcpp::fuchsia::cobalt::Status status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetChannelResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SetChannelResponse*>(_write_bytes);
  SystemDataUpdater::SetTransactionHeaderFor::SetChannelResponse(
      ::fidl::DecodedMessage<SetChannelResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetChannelResponse::PrimarySize,
              SetChannelResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetChannelResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetChannelResponse>(std::move(_response_bytes)));
}

void SystemDataUpdater::Interface::SetChannelCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status) {
  if (_buffer.capacity() < SetChannelResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SetChannelResponse*>(_buffer.data());
  SystemDataUpdater::SetTransactionHeaderFor::SetChannelResponse(
      ::fidl::DecodedMessage<SetChannelResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetChannelResponse::PrimarySize,
              SetChannelResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(SetChannelResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetChannelResponse>(std::move(_buffer)));
}

void SystemDataUpdater::Interface::SetChannelCompleterBase::Reply(::fidl::DecodedMessage<SetChannelResponse> params) {
  SystemDataUpdater::SetTransactionHeaderFor::SetChannelResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void SystemDataUpdater::SetTransactionHeaderFor::SetExperimentStateRequest(const ::fidl::DecodedMessage<SystemDataUpdater::SetExperimentStateRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kSystemDataUpdater_SetExperimentState_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void SystemDataUpdater::SetTransactionHeaderFor::SetExperimentStateResponse(const ::fidl::DecodedMessage<SystemDataUpdater::SetExperimentStateResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kSystemDataUpdater_SetExperimentState_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void SystemDataUpdater::SetTransactionHeaderFor::SetChannelRequest(const ::fidl::DecodedMessage<SystemDataUpdater::SetChannelRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kSystemDataUpdater_SetChannel_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void SystemDataUpdater::SetTransactionHeaderFor::SetChannelResponse(const ::fidl::DecodedMessage<SystemDataUpdater::SetChannelResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kSystemDataUpdater_SetChannel_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void ::llcpp::fuchsia::cobalt::EventPayload::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(EventPayload) == sizeof(fidl_xunion_t));
  static_assert(offsetof(EventPayload, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(EventPayload, envelope_) == offsetof(fidl_xunion_t, envelope));
}

namespace {

[[maybe_unused]]
constexpr uint64_t kLogger_LogEvent_Ordinal = 0x135d628d00000000lu;
[[maybe_unused]]
constexpr uint64_t kLogger_LogEvent_GenOrdinal = 0x293433df480dd41elu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogEventRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogEventResponseTable;
[[maybe_unused]]
constexpr uint64_t kLogger_LogEventCount_Ordinal = 0x6fce776500000000lu;
[[maybe_unused]]
constexpr uint64_t kLogger_LogEventCount_GenOrdinal = 0x5f73f8b900d4bbb1lu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogEventCountRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogEventCountResponseTable;
[[maybe_unused]]
constexpr uint64_t kLogger_LogElapsedTime_Ordinal = 0x14f4912000000000lu;
[[maybe_unused]]
constexpr uint64_t kLogger_LogElapsedTime_GenOrdinal = 0x42e58931fd6c785lu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogElapsedTimeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogElapsedTimeResponseTable;
[[maybe_unused]]
constexpr uint64_t kLogger_LogFrameRate_Ordinal = 0x2b8722b800000000lu;
[[maybe_unused]]
constexpr uint64_t kLogger_LogFrameRate_GenOrdinal = 0x4c701bca4836097lu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogFrameRateRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogFrameRateResponseTable;
[[maybe_unused]]
constexpr uint64_t kLogger_LogMemoryUsage_Ordinal = 0x66c69d1b00000000lu;
[[maybe_unused]]
constexpr uint64_t kLogger_LogMemoryUsage_GenOrdinal = 0x14189c11cc19d641lu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogMemoryUsageRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogMemoryUsageResponseTable;
[[maybe_unused]]
constexpr uint64_t kLogger_StartTimer_Ordinal = 0x4a5c612000000000lu;
[[maybe_unused]]
constexpr uint64_t kLogger_StartTimer_GenOrdinal = 0x68cec08d094e4938lu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerStartTimerRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerStartTimerResponseTable;
[[maybe_unused]]
constexpr uint64_t kLogger_EndTimer_Ordinal = 0x65db6e4200000000lu;
[[maybe_unused]]
constexpr uint64_t kLogger_EndTimer_GenOrdinal = 0xf0043bc7ed4b561lu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerEndTimerRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerEndTimerResponseTable;
[[maybe_unused]]
constexpr uint64_t kLogger_LogIntHistogram_Ordinal = 0x7afcfd3000000000lu;
[[maybe_unused]]
constexpr uint64_t kLogger_LogIntHistogram_GenOrdinal = 0x3382c4827c0c0b0elu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogIntHistogramRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogIntHistogramResponseTable;
[[maybe_unused]]
constexpr uint64_t kLogger_LogCustomEvent_Ordinal = 0x3cfd7fbc00000000lu;
[[maybe_unused]]
constexpr uint64_t kLogger_LogCustomEvent_GenOrdinal = 0x65d92921e13e94b8lu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogCustomEventRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogCustomEventResponseTable;
[[maybe_unused]]
constexpr uint64_t kLogger_LogCobaltEvent_Ordinal = 0x667d288400000000lu;
[[maybe_unused]]
constexpr uint64_t kLogger_LogCobaltEvent_GenOrdinal = 0x2da5db50fd49332lu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogCobaltEventRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogCobaltEventResponseTable;
[[maybe_unused]]
constexpr uint64_t kLogger_LogCobaltEvents_Ordinal = 0x2905d69400000000lu;
[[maybe_unused]]
constexpr uint64_t kLogger_LogCobaltEvents_GenOrdinal = 0x4e51a78396369f7flu;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogCobaltEventsRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogCobaltEventsResponseTable;

}  // namespace
template <>
Logger::ResultOf::LogEvent_Impl<Logger::LogEventResponse>::LogEvent_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogEventRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, LogEventRequest::PrimarySize);
  auto& _request = *reinterpret_cast<LogEventRequest*>(_write_bytes);
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(LogEventRequest));
  ::fidl::DecodedMessage<LogEventRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Logger::InPlace::LogEvent(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Logger::ResultOf::LogEvent Logger::SyncClient::LogEvent(uint32_t metric_id, uint32_t event_code) {
    return ResultOf::LogEvent(::zx::unowned_channel(this->channel_), std::move(metric_id), std::move(event_code));
}

Logger::ResultOf::LogEvent Logger::Call::LogEvent(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code) {
  return ResultOf::LogEvent(std::move(_client_end), std::move(metric_id), std::move(event_code));
}

template <>
Logger::UnownedResultOf::LogEvent_Impl<Logger::LogEventResponse>::LogEvent_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < LogEventRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<LogEventResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, LogEventRequest::PrimarySize);
  auto& _request = *reinterpret_cast<LogEventRequest*>(_request_buffer.data());
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request_buffer.set_actual(sizeof(LogEventRequest));
  ::fidl::DecodedMessage<LogEventRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Logger::InPlace::LogEvent(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Logger::UnownedResultOf::LogEvent Logger::SyncClient::LogEvent(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogEvent(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(_response_buffer));
}

Logger::UnownedResultOf::LogEvent Logger::Call::LogEvent(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogEvent(std::move(_client_end), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(_response_buffer));
}

::fidl::DecodeResult<Logger::LogEventResponse> Logger::InPlace::LogEvent(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogEventRequest> params, ::fidl::BytePart response_buffer) {
  Logger::SetTransactionHeaderFor::LogEventRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Logger::LogEventResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<LogEventRequest, LogEventResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Logger::LogEventResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Logger::ResultOf::LogEventCount_Impl<Logger::LogEventCountResponse>::LogEventCount_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogEventCountRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  LogEventCountRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request.component = std::move(component);
  _request.period_duration_micros = std::move(period_duration_micros);
  _request.count = std::move(count);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LogEventCountRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Logger::InPlace::LogEventCount(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Logger::ResultOf::LogEventCount Logger::SyncClient::LogEventCount(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count) {
    return ResultOf::LogEventCount(::zx::unowned_channel(this->channel_), std::move(metric_id), std::move(event_code), std::move(component), std::move(period_duration_micros), std::move(count));
}

Logger::ResultOf::LogEventCount Logger::Call::LogEventCount(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count) {
  return ResultOf::LogEventCount(std::move(_client_end), std::move(metric_id), std::move(event_code), std::move(component), std::move(period_duration_micros), std::move(count));
}

template <>
Logger::UnownedResultOf::LogEventCount_Impl<Logger::LogEventCountResponse>::LogEventCount_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < LogEventCountRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<LogEventCountResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  LogEventCountRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request.component = std::move(component);
  _request.period_duration_micros = std::move(period_duration_micros);
  _request.count = std::move(count);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LogEventCountRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Logger::InPlace::LogEventCount(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Logger::UnownedResultOf::LogEventCount Logger::SyncClient::LogEventCount(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogEventCount(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(component), std::move(period_duration_micros), std::move(count), std::move(_response_buffer));
}

Logger::UnownedResultOf::LogEventCount Logger::Call::LogEventCount(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogEventCount(std::move(_client_end), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(component), std::move(period_duration_micros), std::move(count), std::move(_response_buffer));
}

::fidl::DecodeResult<Logger::LogEventCountResponse> Logger::InPlace::LogEventCount(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogEventCountRequest> params, ::fidl::BytePart response_buffer) {
  Logger::SetTransactionHeaderFor::LogEventCountRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Logger::LogEventCountResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<LogEventCountRequest, LogEventCountResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Logger::LogEventCountResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Logger::ResultOf::LogElapsedTime_Impl<Logger::LogElapsedTimeResponse>::LogElapsedTime_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogElapsedTimeRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  LogElapsedTimeRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request.component = std::move(component);
  _request.elapsed_micros = std::move(elapsed_micros);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LogElapsedTimeRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Logger::InPlace::LogElapsedTime(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Logger::ResultOf::LogElapsedTime Logger::SyncClient::LogElapsedTime(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros) {
    return ResultOf::LogElapsedTime(::zx::unowned_channel(this->channel_), std::move(metric_id), std::move(event_code), std::move(component), std::move(elapsed_micros));
}

Logger::ResultOf::LogElapsedTime Logger::Call::LogElapsedTime(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros) {
  return ResultOf::LogElapsedTime(std::move(_client_end), std::move(metric_id), std::move(event_code), std::move(component), std::move(elapsed_micros));
}

template <>
Logger::UnownedResultOf::LogElapsedTime_Impl<Logger::LogElapsedTimeResponse>::LogElapsedTime_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < LogElapsedTimeRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<LogElapsedTimeResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  LogElapsedTimeRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request.component = std::move(component);
  _request.elapsed_micros = std::move(elapsed_micros);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LogElapsedTimeRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Logger::InPlace::LogElapsedTime(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Logger::UnownedResultOf::LogElapsedTime Logger::SyncClient::LogElapsedTime(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogElapsedTime(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(component), std::move(elapsed_micros), std::move(_response_buffer));
}

Logger::UnownedResultOf::LogElapsedTime Logger::Call::LogElapsedTime(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogElapsedTime(std::move(_client_end), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(component), std::move(elapsed_micros), std::move(_response_buffer));
}

::fidl::DecodeResult<Logger::LogElapsedTimeResponse> Logger::InPlace::LogElapsedTime(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogElapsedTimeRequest> params, ::fidl::BytePart response_buffer) {
  Logger::SetTransactionHeaderFor::LogElapsedTimeRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Logger::LogElapsedTimeResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<LogElapsedTimeRequest, LogElapsedTimeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Logger::LogElapsedTimeResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Logger::ResultOf::LogFrameRate_Impl<Logger::LogFrameRateResponse>::LogFrameRate_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogFrameRateRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  LogFrameRateRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request.component = std::move(component);
  _request.fps = std::move(fps);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LogFrameRateRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Logger::InPlace::LogFrameRate(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Logger::ResultOf::LogFrameRate Logger::SyncClient::LogFrameRate(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps) {
    return ResultOf::LogFrameRate(::zx::unowned_channel(this->channel_), std::move(metric_id), std::move(event_code), std::move(component), std::move(fps));
}

Logger::ResultOf::LogFrameRate Logger::Call::LogFrameRate(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps) {
  return ResultOf::LogFrameRate(std::move(_client_end), std::move(metric_id), std::move(event_code), std::move(component), std::move(fps));
}

template <>
Logger::UnownedResultOf::LogFrameRate_Impl<Logger::LogFrameRateResponse>::LogFrameRate_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < LogFrameRateRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<LogFrameRateResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  LogFrameRateRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request.component = std::move(component);
  _request.fps = std::move(fps);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LogFrameRateRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Logger::InPlace::LogFrameRate(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Logger::UnownedResultOf::LogFrameRate Logger::SyncClient::LogFrameRate(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogFrameRate(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(component), std::move(fps), std::move(_response_buffer));
}

Logger::UnownedResultOf::LogFrameRate Logger::Call::LogFrameRate(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogFrameRate(std::move(_client_end), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(component), std::move(fps), std::move(_response_buffer));
}

::fidl::DecodeResult<Logger::LogFrameRateResponse> Logger::InPlace::LogFrameRate(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogFrameRateRequest> params, ::fidl::BytePart response_buffer) {
  Logger::SetTransactionHeaderFor::LogFrameRateRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Logger::LogFrameRateResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<LogFrameRateRequest, LogFrameRateResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Logger::LogFrameRateResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Logger::ResultOf::LogMemoryUsage_Impl<Logger::LogMemoryUsageResponse>::LogMemoryUsage_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogMemoryUsageRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  LogMemoryUsageRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request.component = std::move(component);
  _request.bytes = std::move(bytes);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LogMemoryUsageRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Logger::InPlace::LogMemoryUsage(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Logger::ResultOf::LogMemoryUsage Logger::SyncClient::LogMemoryUsage(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes) {
    return ResultOf::LogMemoryUsage(::zx::unowned_channel(this->channel_), std::move(metric_id), std::move(event_code), std::move(component), std::move(bytes));
}

Logger::ResultOf::LogMemoryUsage Logger::Call::LogMemoryUsage(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes) {
  return ResultOf::LogMemoryUsage(std::move(_client_end), std::move(metric_id), std::move(event_code), std::move(component), std::move(bytes));
}

template <>
Logger::UnownedResultOf::LogMemoryUsage_Impl<Logger::LogMemoryUsageResponse>::LogMemoryUsage_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < LogMemoryUsageRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<LogMemoryUsageResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  LogMemoryUsageRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request.component = std::move(component);
  _request.bytes = std::move(bytes);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LogMemoryUsageRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Logger::InPlace::LogMemoryUsage(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Logger::UnownedResultOf::LogMemoryUsage Logger::SyncClient::LogMemoryUsage(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogMemoryUsage(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(component), std::move(bytes), std::move(_response_buffer));
}

Logger::UnownedResultOf::LogMemoryUsage Logger::Call::LogMemoryUsage(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogMemoryUsage(std::move(_client_end), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(component), std::move(bytes), std::move(_response_buffer));
}

::fidl::DecodeResult<Logger::LogMemoryUsageResponse> Logger::InPlace::LogMemoryUsage(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogMemoryUsageRequest> params, ::fidl::BytePart response_buffer) {
  Logger::SetTransactionHeaderFor::LogMemoryUsageRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Logger::LogMemoryUsageResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<LogMemoryUsageRequest, LogMemoryUsageResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Logger::LogMemoryUsageResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Logger::ResultOf::StartTimer_Impl<Logger::StartTimerResponse>::StartTimer_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<StartTimerRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  StartTimerRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request.component = std::move(component);
  _request.timer_id = std::move(timer_id);
  _request.timestamp = std::move(timestamp);
  _request.timeout_s = std::move(timeout_s);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<StartTimerRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Logger::InPlace::StartTimer(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Logger::ResultOf::StartTimer Logger::SyncClient::StartTimer(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s) {
    return ResultOf::StartTimer(::zx::unowned_channel(this->channel_), std::move(metric_id), std::move(event_code), std::move(component), std::move(timer_id), std::move(timestamp), std::move(timeout_s));
}

Logger::ResultOf::StartTimer Logger::Call::StartTimer(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s) {
  return ResultOf::StartTimer(std::move(_client_end), std::move(metric_id), std::move(event_code), std::move(component), std::move(timer_id), std::move(timestamp), std::move(timeout_s));
}

template <>
Logger::UnownedResultOf::StartTimer_Impl<Logger::StartTimerResponse>::StartTimer_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < StartTimerRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<StartTimerResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  StartTimerRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request.component = std::move(component);
  _request.timer_id = std::move(timer_id);
  _request.timestamp = std::move(timestamp);
  _request.timeout_s = std::move(timeout_s);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<StartTimerRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Logger::InPlace::StartTimer(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Logger::UnownedResultOf::StartTimer Logger::SyncClient::StartTimer(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::StartTimer(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(component), std::move(timer_id), std::move(timestamp), std::move(timeout_s), std::move(_response_buffer));
}

Logger::UnownedResultOf::StartTimer Logger::Call::StartTimer(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::StartTimer(std::move(_client_end), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(component), std::move(timer_id), std::move(timestamp), std::move(timeout_s), std::move(_response_buffer));
}

::fidl::DecodeResult<Logger::StartTimerResponse> Logger::InPlace::StartTimer(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<StartTimerRequest> params, ::fidl::BytePart response_buffer) {
  Logger::SetTransactionHeaderFor::StartTimerRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Logger::StartTimerResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<StartTimerRequest, StartTimerResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Logger::StartTimerResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Logger::ResultOf::EndTimer_Impl<Logger::EndTimerResponse>::EndTimer_Impl(::zx::unowned_channel _client_end, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<EndTimerRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  EndTimerRequest _request = {};
  _request.timer_id = std::move(timer_id);
  _request.timestamp = std::move(timestamp);
  _request.timeout_s = std::move(timeout_s);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<EndTimerRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Logger::InPlace::EndTimer(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Logger::ResultOf::EndTimer Logger::SyncClient::EndTimer(::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s) {
    return ResultOf::EndTimer(::zx::unowned_channel(this->channel_), std::move(timer_id), std::move(timestamp), std::move(timeout_s));
}

Logger::ResultOf::EndTimer Logger::Call::EndTimer(::zx::unowned_channel _client_end, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s) {
  return ResultOf::EndTimer(std::move(_client_end), std::move(timer_id), std::move(timestamp), std::move(timeout_s));
}

template <>
Logger::UnownedResultOf::EndTimer_Impl<Logger::EndTimerResponse>::EndTimer_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < EndTimerRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<EndTimerResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  EndTimerRequest _request = {};
  _request.timer_id = std::move(timer_id);
  _request.timestamp = std::move(timestamp);
  _request.timeout_s = std::move(timeout_s);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<EndTimerRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Logger::InPlace::EndTimer(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Logger::UnownedResultOf::EndTimer Logger::SyncClient::EndTimer(::fidl::BytePart _request_buffer, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::EndTimer(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(timer_id), std::move(timestamp), std::move(timeout_s), std::move(_response_buffer));
}

Logger::UnownedResultOf::EndTimer Logger::Call::EndTimer(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::EndTimer(std::move(_client_end), std::move(_request_buffer), std::move(timer_id), std::move(timestamp), std::move(timeout_s), std::move(_response_buffer));
}

::fidl::DecodeResult<Logger::EndTimerResponse> Logger::InPlace::EndTimer(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<EndTimerRequest> params, ::fidl::BytePart response_buffer) {
  Logger::SetTransactionHeaderFor::EndTimerRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Logger::EndTimerResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<EndTimerRequest, EndTimerResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Logger::EndTimerResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Logger::ResultOf::LogIntHistogram_Impl<Logger::LogIntHistogramResponse>::LogIntHistogram_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::VectorView<::llcpp::fuchsia::cobalt::HistogramBucket> histogram) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogIntHistogramRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  LogIntHistogramRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request.component = std::move(component);
  _request.histogram = std::move(histogram);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LogIntHistogramRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Logger::InPlace::LogIntHistogram(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Logger::ResultOf::LogIntHistogram Logger::SyncClient::LogIntHistogram(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::VectorView<::llcpp::fuchsia::cobalt::HistogramBucket> histogram) {
    return ResultOf::LogIntHistogram(::zx::unowned_channel(this->channel_), std::move(metric_id), std::move(event_code), std::move(component), std::move(histogram));
}

Logger::ResultOf::LogIntHistogram Logger::Call::LogIntHistogram(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::VectorView<::llcpp::fuchsia::cobalt::HistogramBucket> histogram) {
  return ResultOf::LogIntHistogram(std::move(_client_end), std::move(metric_id), std::move(event_code), std::move(component), std::move(histogram));
}

template <>
Logger::UnownedResultOf::LogIntHistogram_Impl<Logger::LogIntHistogramResponse>::LogIntHistogram_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::VectorView<::llcpp::fuchsia::cobalt::HistogramBucket> histogram, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < LogIntHistogramRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<LogIntHistogramResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  LogIntHistogramRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_code = std::move(event_code);
  _request.component = std::move(component);
  _request.histogram = std::move(histogram);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LogIntHistogramRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Logger::InPlace::LogIntHistogram(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Logger::UnownedResultOf::LogIntHistogram Logger::SyncClient::LogIntHistogram(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::VectorView<::llcpp::fuchsia::cobalt::HistogramBucket> histogram, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogIntHistogram(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(component), std::move(histogram), std::move(_response_buffer));
}

Logger::UnownedResultOf::LogIntHistogram Logger::Call::LogIntHistogram(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::VectorView<::llcpp::fuchsia::cobalt::HistogramBucket> histogram, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogIntHistogram(std::move(_client_end), std::move(_request_buffer), std::move(metric_id), std::move(event_code), std::move(component), std::move(histogram), std::move(_response_buffer));
}

::fidl::DecodeResult<Logger::LogIntHistogramResponse> Logger::InPlace::LogIntHistogram(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogIntHistogramRequest> params, ::fidl::BytePart response_buffer) {
  Logger::SetTransactionHeaderFor::LogIntHistogramRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Logger::LogIntHistogramResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<LogIntHistogramRequest, LogIntHistogramResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Logger::LogIntHistogramResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Logger::ResultOf::LogCustomEvent_Impl<Logger::LogCustomEventResponse>::LogCustomEvent_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, ::fidl::VectorView<::llcpp::fuchsia::cobalt::CustomEventValue> event_values) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogCustomEventRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  LogCustomEventRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_values = std::move(event_values);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LogCustomEventRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Logger::InPlace::LogCustomEvent(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Logger::ResultOf::LogCustomEvent Logger::SyncClient::LogCustomEvent(uint32_t metric_id, ::fidl::VectorView<::llcpp::fuchsia::cobalt::CustomEventValue> event_values) {
    return ResultOf::LogCustomEvent(::zx::unowned_channel(this->channel_), std::move(metric_id), std::move(event_values));
}

Logger::ResultOf::LogCustomEvent Logger::Call::LogCustomEvent(::zx::unowned_channel _client_end, uint32_t metric_id, ::fidl::VectorView<::llcpp::fuchsia::cobalt::CustomEventValue> event_values) {
  return ResultOf::LogCustomEvent(std::move(_client_end), std::move(metric_id), std::move(event_values));
}

template <>
Logger::UnownedResultOf::LogCustomEvent_Impl<Logger::LogCustomEventResponse>::LogCustomEvent_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, ::fidl::VectorView<::llcpp::fuchsia::cobalt::CustomEventValue> event_values, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < LogCustomEventRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<LogCustomEventResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  LogCustomEventRequest _request = {};
  _request.metric_id = std::move(metric_id);
  _request.event_values = std::move(event_values);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LogCustomEventRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Logger::InPlace::LogCustomEvent(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Logger::UnownedResultOf::LogCustomEvent Logger::SyncClient::LogCustomEvent(::fidl::BytePart _request_buffer, uint32_t metric_id, ::fidl::VectorView<::llcpp::fuchsia::cobalt::CustomEventValue> event_values, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogCustomEvent(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(metric_id), std::move(event_values), std::move(_response_buffer));
}

Logger::UnownedResultOf::LogCustomEvent Logger::Call::LogCustomEvent(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, ::fidl::VectorView<::llcpp::fuchsia::cobalt::CustomEventValue> event_values, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogCustomEvent(std::move(_client_end), std::move(_request_buffer), std::move(metric_id), std::move(event_values), std::move(_response_buffer));
}

::fidl::DecodeResult<Logger::LogCustomEventResponse> Logger::InPlace::LogCustomEvent(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogCustomEventRequest> params, ::fidl::BytePart response_buffer) {
  Logger::SetTransactionHeaderFor::LogCustomEventRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Logger::LogCustomEventResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<LogCustomEventRequest, LogCustomEventResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Logger::LogCustomEventResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Logger::ResultOf::LogCobaltEvent_Impl<Logger::LogCobaltEventResponse>::LogCobaltEvent_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::cobalt::CobaltEvent event) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogCobaltEventRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  LogCobaltEventRequest _request = {};
  _request.event = std::move(event);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LogCobaltEventRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Logger::InPlace::LogCobaltEvent(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Logger::ResultOf::LogCobaltEvent Logger::SyncClient::LogCobaltEvent(::llcpp::fuchsia::cobalt::CobaltEvent event) {
    return ResultOf::LogCobaltEvent(::zx::unowned_channel(this->channel_), std::move(event));
}

Logger::ResultOf::LogCobaltEvent Logger::Call::LogCobaltEvent(::zx::unowned_channel _client_end, ::llcpp::fuchsia::cobalt::CobaltEvent event) {
  return ResultOf::LogCobaltEvent(std::move(_client_end), std::move(event));
}

template <>
Logger::UnownedResultOf::LogCobaltEvent_Impl<Logger::LogCobaltEventResponse>::LogCobaltEvent_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::cobalt::CobaltEvent event, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < LogCobaltEventRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<LogCobaltEventResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  LogCobaltEventRequest _request = {};
  _request.event = std::move(event);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LogCobaltEventRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Logger::InPlace::LogCobaltEvent(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Logger::UnownedResultOf::LogCobaltEvent Logger::SyncClient::LogCobaltEvent(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::cobalt::CobaltEvent event, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogCobaltEvent(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(event), std::move(_response_buffer));
}

Logger::UnownedResultOf::LogCobaltEvent Logger::Call::LogCobaltEvent(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::cobalt::CobaltEvent event, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogCobaltEvent(std::move(_client_end), std::move(_request_buffer), std::move(event), std::move(_response_buffer));
}

::fidl::DecodeResult<Logger::LogCobaltEventResponse> Logger::InPlace::LogCobaltEvent(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogCobaltEventRequest> params, ::fidl::BytePart response_buffer) {
  Logger::SetTransactionHeaderFor::LogCobaltEventRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Logger::LogCobaltEventResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<LogCobaltEventRequest, LogCobaltEventResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Logger::LogCobaltEventResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Logger::ResultOf::LogCobaltEvents_Impl<Logger::LogCobaltEventsResponse>::LogCobaltEvents_Impl(::zx::unowned_channel _client_end, ::fidl::VectorView<::llcpp::fuchsia::cobalt::CobaltEvent> events) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogCobaltEventsRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  LogCobaltEventsRequest _request = {};
  _request.events = std::move(events);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LogCobaltEventsRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Logger::InPlace::LogCobaltEvents(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Logger::ResultOf::LogCobaltEvents Logger::SyncClient::LogCobaltEvents(::fidl::VectorView<::llcpp::fuchsia::cobalt::CobaltEvent> events) {
    return ResultOf::LogCobaltEvents(::zx::unowned_channel(this->channel_), std::move(events));
}

Logger::ResultOf::LogCobaltEvents Logger::Call::LogCobaltEvents(::zx::unowned_channel _client_end, ::fidl::VectorView<::llcpp::fuchsia::cobalt::CobaltEvent> events) {
  return ResultOf::LogCobaltEvents(std::move(_client_end), std::move(events));
}

template <>
Logger::UnownedResultOf::LogCobaltEvents_Impl<Logger::LogCobaltEventsResponse>::LogCobaltEvents_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<::llcpp::fuchsia::cobalt::CobaltEvent> events, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < LogCobaltEventsRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<LogCobaltEventsResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  LogCobaltEventsRequest _request = {};
  _request.events = std::move(events);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LogCobaltEventsRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Logger::InPlace::LogCobaltEvents(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Logger::UnownedResultOf::LogCobaltEvents Logger::SyncClient::LogCobaltEvents(::fidl::BytePart _request_buffer, ::fidl::VectorView<::llcpp::fuchsia::cobalt::CobaltEvent> events, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogCobaltEvents(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(events), std::move(_response_buffer));
}

Logger::UnownedResultOf::LogCobaltEvents Logger::Call::LogCobaltEvents(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<::llcpp::fuchsia::cobalt::CobaltEvent> events, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::LogCobaltEvents(std::move(_client_end), std::move(_request_buffer), std::move(events), std::move(_response_buffer));
}

::fidl::DecodeResult<Logger::LogCobaltEventsResponse> Logger::InPlace::LogCobaltEvents(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogCobaltEventsRequest> params, ::fidl::BytePart response_buffer) {
  Logger::SetTransactionHeaderFor::LogCobaltEventsRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Logger::LogCobaltEventsResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<LogCobaltEventsRequest, LogCobaltEventsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Logger::LogCobaltEventsResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool Logger::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kLogger_LogEvent_Ordinal:
    case kLogger_LogEvent_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<LogEventRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->LogEvent(std::move(message->metric_id), std::move(message->event_code),
          Interface::LogEventCompleter::Sync(txn));
      return true;
    }
    case kLogger_LogEventCount_Ordinal:
    case kLogger_LogEventCount_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<LogEventCountRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->LogEventCount(std::move(message->metric_id), std::move(message->event_code), std::move(message->component), std::move(message->period_duration_micros), std::move(message->count),
          Interface::LogEventCountCompleter::Sync(txn));
      return true;
    }
    case kLogger_LogElapsedTime_Ordinal:
    case kLogger_LogElapsedTime_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<LogElapsedTimeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->LogElapsedTime(std::move(message->metric_id), std::move(message->event_code), std::move(message->component), std::move(message->elapsed_micros),
          Interface::LogElapsedTimeCompleter::Sync(txn));
      return true;
    }
    case kLogger_LogFrameRate_Ordinal:
    case kLogger_LogFrameRate_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<LogFrameRateRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->LogFrameRate(std::move(message->metric_id), std::move(message->event_code), std::move(message->component), std::move(message->fps),
          Interface::LogFrameRateCompleter::Sync(txn));
      return true;
    }
    case kLogger_LogMemoryUsage_Ordinal:
    case kLogger_LogMemoryUsage_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<LogMemoryUsageRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->LogMemoryUsage(std::move(message->metric_id), std::move(message->event_code), std::move(message->component), std::move(message->bytes),
          Interface::LogMemoryUsageCompleter::Sync(txn));
      return true;
    }
    case kLogger_StartTimer_Ordinal:
    case kLogger_StartTimer_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<StartTimerRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->StartTimer(std::move(message->metric_id), std::move(message->event_code), std::move(message->component), std::move(message->timer_id), std::move(message->timestamp), std::move(message->timeout_s),
          Interface::StartTimerCompleter::Sync(txn));
      return true;
    }
    case kLogger_EndTimer_Ordinal:
    case kLogger_EndTimer_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<EndTimerRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->EndTimer(std::move(message->timer_id), std::move(message->timestamp), std::move(message->timeout_s),
          Interface::EndTimerCompleter::Sync(txn));
      return true;
    }
    case kLogger_LogIntHistogram_Ordinal:
    case kLogger_LogIntHistogram_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<LogIntHistogramRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->LogIntHistogram(std::move(message->metric_id), std::move(message->event_code), std::move(message->component), std::move(message->histogram),
          Interface::LogIntHistogramCompleter::Sync(txn));
      return true;
    }
    case kLogger_LogCustomEvent_Ordinal:
    case kLogger_LogCustomEvent_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<LogCustomEventRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->LogCustomEvent(std::move(message->metric_id), std::move(message->event_values),
          Interface::LogCustomEventCompleter::Sync(txn));
      return true;
    }
    case kLogger_LogCobaltEvent_Ordinal:
    case kLogger_LogCobaltEvent_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<LogCobaltEventRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->LogCobaltEvent(std::move(message->event),
          Interface::LogCobaltEventCompleter::Sync(txn));
      return true;
    }
    case kLogger_LogCobaltEvents_Ordinal:
    case kLogger_LogCobaltEvents_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<LogCobaltEventsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->LogCobaltEvents(std::move(message->events),
          Interface::LogCobaltEventsCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Logger::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void Logger::Interface::LogEventCompleterBase::Reply(::llcpp::fuchsia::cobalt::Status status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogEventResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<LogEventResponse*>(_write_bytes);
  Logger::SetTransactionHeaderFor::LogEventResponse(
      ::fidl::DecodedMessage<LogEventResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogEventResponse::PrimarySize,
              LogEventResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(LogEventResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogEventResponse>(std::move(_response_bytes)));
}

void Logger::Interface::LogEventCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status) {
  if (_buffer.capacity() < LogEventResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<LogEventResponse*>(_buffer.data());
  Logger::SetTransactionHeaderFor::LogEventResponse(
      ::fidl::DecodedMessage<LogEventResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogEventResponse::PrimarySize,
              LogEventResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(LogEventResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogEventResponse>(std::move(_buffer)));
}

void Logger::Interface::LogEventCompleterBase::Reply(::fidl::DecodedMessage<LogEventResponse> params) {
  Logger::SetTransactionHeaderFor::LogEventResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Logger::Interface::LogEventCountCompleterBase::Reply(::llcpp::fuchsia::cobalt::Status status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogEventCountResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<LogEventCountResponse*>(_write_bytes);
  Logger::SetTransactionHeaderFor::LogEventCountResponse(
      ::fidl::DecodedMessage<LogEventCountResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogEventCountResponse::PrimarySize,
              LogEventCountResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(LogEventCountResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogEventCountResponse>(std::move(_response_bytes)));
}

void Logger::Interface::LogEventCountCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status) {
  if (_buffer.capacity() < LogEventCountResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<LogEventCountResponse*>(_buffer.data());
  Logger::SetTransactionHeaderFor::LogEventCountResponse(
      ::fidl::DecodedMessage<LogEventCountResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogEventCountResponse::PrimarySize,
              LogEventCountResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(LogEventCountResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogEventCountResponse>(std::move(_buffer)));
}

void Logger::Interface::LogEventCountCompleterBase::Reply(::fidl::DecodedMessage<LogEventCountResponse> params) {
  Logger::SetTransactionHeaderFor::LogEventCountResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Logger::Interface::LogElapsedTimeCompleterBase::Reply(::llcpp::fuchsia::cobalt::Status status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogElapsedTimeResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<LogElapsedTimeResponse*>(_write_bytes);
  Logger::SetTransactionHeaderFor::LogElapsedTimeResponse(
      ::fidl::DecodedMessage<LogElapsedTimeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogElapsedTimeResponse::PrimarySize,
              LogElapsedTimeResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(LogElapsedTimeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogElapsedTimeResponse>(std::move(_response_bytes)));
}

void Logger::Interface::LogElapsedTimeCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status) {
  if (_buffer.capacity() < LogElapsedTimeResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<LogElapsedTimeResponse*>(_buffer.data());
  Logger::SetTransactionHeaderFor::LogElapsedTimeResponse(
      ::fidl::DecodedMessage<LogElapsedTimeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogElapsedTimeResponse::PrimarySize,
              LogElapsedTimeResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(LogElapsedTimeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogElapsedTimeResponse>(std::move(_buffer)));
}

void Logger::Interface::LogElapsedTimeCompleterBase::Reply(::fidl::DecodedMessage<LogElapsedTimeResponse> params) {
  Logger::SetTransactionHeaderFor::LogElapsedTimeResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Logger::Interface::LogFrameRateCompleterBase::Reply(::llcpp::fuchsia::cobalt::Status status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogFrameRateResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<LogFrameRateResponse*>(_write_bytes);
  Logger::SetTransactionHeaderFor::LogFrameRateResponse(
      ::fidl::DecodedMessage<LogFrameRateResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogFrameRateResponse::PrimarySize,
              LogFrameRateResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(LogFrameRateResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogFrameRateResponse>(std::move(_response_bytes)));
}

void Logger::Interface::LogFrameRateCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status) {
  if (_buffer.capacity() < LogFrameRateResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<LogFrameRateResponse*>(_buffer.data());
  Logger::SetTransactionHeaderFor::LogFrameRateResponse(
      ::fidl::DecodedMessage<LogFrameRateResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogFrameRateResponse::PrimarySize,
              LogFrameRateResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(LogFrameRateResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogFrameRateResponse>(std::move(_buffer)));
}

void Logger::Interface::LogFrameRateCompleterBase::Reply(::fidl::DecodedMessage<LogFrameRateResponse> params) {
  Logger::SetTransactionHeaderFor::LogFrameRateResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Logger::Interface::LogMemoryUsageCompleterBase::Reply(::llcpp::fuchsia::cobalt::Status status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogMemoryUsageResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<LogMemoryUsageResponse*>(_write_bytes);
  Logger::SetTransactionHeaderFor::LogMemoryUsageResponse(
      ::fidl::DecodedMessage<LogMemoryUsageResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogMemoryUsageResponse::PrimarySize,
              LogMemoryUsageResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(LogMemoryUsageResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogMemoryUsageResponse>(std::move(_response_bytes)));
}

void Logger::Interface::LogMemoryUsageCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status) {
  if (_buffer.capacity() < LogMemoryUsageResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<LogMemoryUsageResponse*>(_buffer.data());
  Logger::SetTransactionHeaderFor::LogMemoryUsageResponse(
      ::fidl::DecodedMessage<LogMemoryUsageResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogMemoryUsageResponse::PrimarySize,
              LogMemoryUsageResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(LogMemoryUsageResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogMemoryUsageResponse>(std::move(_buffer)));
}

void Logger::Interface::LogMemoryUsageCompleterBase::Reply(::fidl::DecodedMessage<LogMemoryUsageResponse> params) {
  Logger::SetTransactionHeaderFor::LogMemoryUsageResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Logger::Interface::StartTimerCompleterBase::Reply(::llcpp::fuchsia::cobalt::Status status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<StartTimerResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<StartTimerResponse*>(_write_bytes);
  Logger::SetTransactionHeaderFor::StartTimerResponse(
      ::fidl::DecodedMessage<StartTimerResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              StartTimerResponse::PrimarySize,
              StartTimerResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(StartTimerResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<StartTimerResponse>(std::move(_response_bytes)));
}

void Logger::Interface::StartTimerCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status) {
  if (_buffer.capacity() < StartTimerResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<StartTimerResponse*>(_buffer.data());
  Logger::SetTransactionHeaderFor::StartTimerResponse(
      ::fidl::DecodedMessage<StartTimerResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              StartTimerResponse::PrimarySize,
              StartTimerResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(StartTimerResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<StartTimerResponse>(std::move(_buffer)));
}

void Logger::Interface::StartTimerCompleterBase::Reply(::fidl::DecodedMessage<StartTimerResponse> params) {
  Logger::SetTransactionHeaderFor::StartTimerResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Logger::Interface::EndTimerCompleterBase::Reply(::llcpp::fuchsia::cobalt::Status status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<EndTimerResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<EndTimerResponse*>(_write_bytes);
  Logger::SetTransactionHeaderFor::EndTimerResponse(
      ::fidl::DecodedMessage<EndTimerResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              EndTimerResponse::PrimarySize,
              EndTimerResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(EndTimerResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<EndTimerResponse>(std::move(_response_bytes)));
}

void Logger::Interface::EndTimerCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status) {
  if (_buffer.capacity() < EndTimerResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<EndTimerResponse*>(_buffer.data());
  Logger::SetTransactionHeaderFor::EndTimerResponse(
      ::fidl::DecodedMessage<EndTimerResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              EndTimerResponse::PrimarySize,
              EndTimerResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(EndTimerResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<EndTimerResponse>(std::move(_buffer)));
}

void Logger::Interface::EndTimerCompleterBase::Reply(::fidl::DecodedMessage<EndTimerResponse> params) {
  Logger::SetTransactionHeaderFor::EndTimerResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Logger::Interface::LogIntHistogramCompleterBase::Reply(::llcpp::fuchsia::cobalt::Status status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogIntHistogramResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<LogIntHistogramResponse*>(_write_bytes);
  Logger::SetTransactionHeaderFor::LogIntHistogramResponse(
      ::fidl::DecodedMessage<LogIntHistogramResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogIntHistogramResponse::PrimarySize,
              LogIntHistogramResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(LogIntHistogramResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogIntHistogramResponse>(std::move(_response_bytes)));
}

void Logger::Interface::LogIntHistogramCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status) {
  if (_buffer.capacity() < LogIntHistogramResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<LogIntHistogramResponse*>(_buffer.data());
  Logger::SetTransactionHeaderFor::LogIntHistogramResponse(
      ::fidl::DecodedMessage<LogIntHistogramResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogIntHistogramResponse::PrimarySize,
              LogIntHistogramResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(LogIntHistogramResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogIntHistogramResponse>(std::move(_buffer)));
}

void Logger::Interface::LogIntHistogramCompleterBase::Reply(::fidl::DecodedMessage<LogIntHistogramResponse> params) {
  Logger::SetTransactionHeaderFor::LogIntHistogramResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Logger::Interface::LogCustomEventCompleterBase::Reply(::llcpp::fuchsia::cobalt::Status status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogCustomEventResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<LogCustomEventResponse*>(_write_bytes);
  Logger::SetTransactionHeaderFor::LogCustomEventResponse(
      ::fidl::DecodedMessage<LogCustomEventResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogCustomEventResponse::PrimarySize,
              LogCustomEventResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(LogCustomEventResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogCustomEventResponse>(std::move(_response_bytes)));
}

void Logger::Interface::LogCustomEventCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status) {
  if (_buffer.capacity() < LogCustomEventResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<LogCustomEventResponse*>(_buffer.data());
  Logger::SetTransactionHeaderFor::LogCustomEventResponse(
      ::fidl::DecodedMessage<LogCustomEventResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogCustomEventResponse::PrimarySize,
              LogCustomEventResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(LogCustomEventResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogCustomEventResponse>(std::move(_buffer)));
}

void Logger::Interface::LogCustomEventCompleterBase::Reply(::fidl::DecodedMessage<LogCustomEventResponse> params) {
  Logger::SetTransactionHeaderFor::LogCustomEventResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Logger::Interface::LogCobaltEventCompleterBase::Reply(::llcpp::fuchsia::cobalt::Status status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogCobaltEventResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<LogCobaltEventResponse*>(_write_bytes);
  Logger::SetTransactionHeaderFor::LogCobaltEventResponse(
      ::fidl::DecodedMessage<LogCobaltEventResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogCobaltEventResponse::PrimarySize,
              LogCobaltEventResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(LogCobaltEventResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogCobaltEventResponse>(std::move(_response_bytes)));
}

void Logger::Interface::LogCobaltEventCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status) {
  if (_buffer.capacity() < LogCobaltEventResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<LogCobaltEventResponse*>(_buffer.data());
  Logger::SetTransactionHeaderFor::LogCobaltEventResponse(
      ::fidl::DecodedMessage<LogCobaltEventResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogCobaltEventResponse::PrimarySize,
              LogCobaltEventResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(LogCobaltEventResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogCobaltEventResponse>(std::move(_buffer)));
}

void Logger::Interface::LogCobaltEventCompleterBase::Reply(::fidl::DecodedMessage<LogCobaltEventResponse> params) {
  Logger::SetTransactionHeaderFor::LogCobaltEventResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Logger::Interface::LogCobaltEventsCompleterBase::Reply(::llcpp::fuchsia::cobalt::Status status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LogCobaltEventsResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<LogCobaltEventsResponse*>(_write_bytes);
  Logger::SetTransactionHeaderFor::LogCobaltEventsResponse(
      ::fidl::DecodedMessage<LogCobaltEventsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogCobaltEventsResponse::PrimarySize,
              LogCobaltEventsResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(LogCobaltEventsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogCobaltEventsResponse>(std::move(_response_bytes)));
}

void Logger::Interface::LogCobaltEventsCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status) {
  if (_buffer.capacity() < LogCobaltEventsResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<LogCobaltEventsResponse*>(_buffer.data());
  Logger::SetTransactionHeaderFor::LogCobaltEventsResponse(
      ::fidl::DecodedMessage<LogCobaltEventsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LogCobaltEventsResponse::PrimarySize,
              LogCobaltEventsResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(LogCobaltEventsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LogCobaltEventsResponse>(std::move(_buffer)));
}

void Logger::Interface::LogCobaltEventsCompleterBase::Reply(::fidl::DecodedMessage<LogCobaltEventsResponse> params) {
  Logger::SetTransactionHeaderFor::LogCobaltEventsResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void Logger::SetTransactionHeaderFor::LogEventRequest(const ::fidl::DecodedMessage<Logger::LogEventRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLogger_LogEvent_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Logger::SetTransactionHeaderFor::LogEventResponse(const ::fidl::DecodedMessage<Logger::LogEventResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLogger_LogEvent_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Logger::SetTransactionHeaderFor::LogEventCountRequest(const ::fidl::DecodedMessage<Logger::LogEventCountRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLogger_LogEventCount_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Logger::SetTransactionHeaderFor::LogEventCountResponse(const ::fidl::DecodedMessage<Logger::LogEventCountResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLogger_LogEventCount_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Logger::SetTransactionHeaderFor::LogElapsedTimeRequest(const ::fidl::DecodedMessage<Logger::LogElapsedTimeRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLogger_LogElapsedTime_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Logger::SetTransactionHeaderFor::LogElapsedTimeResponse(const ::fidl::DecodedMessage<Logger::LogElapsedTimeResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLogger_LogElapsedTime_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Logger::SetTransactionHeaderFor::LogFrameRateRequest(const ::fidl::DecodedMessage<Logger::LogFrameRateRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLogger_LogFrameRate_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Logger::SetTransactionHeaderFor::LogFrameRateResponse(const ::fidl::DecodedMessage<Logger::LogFrameRateResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLogger_LogFrameRate_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Logger::SetTransactionHeaderFor::LogMemoryUsageRequest(const ::fidl::DecodedMessage<Logger::LogMemoryUsageRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLogger_LogMemoryUsage_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Logger::SetTransactionHeaderFor::LogMemoryUsageResponse(const ::fidl::DecodedMessage<Logger::LogMemoryUsageResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLogger_LogMemoryUsage_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Logger::SetTransactionHeaderFor::StartTimerRequest(const ::fidl::DecodedMessage<Logger::StartTimerRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLogger_StartTimer_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Logger::SetTransactionHeaderFor::StartTimerResponse(const ::fidl::DecodedMessage<Logger::StartTimerResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLogger_StartTimer_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Logger::SetTransactionHeaderFor::EndTimerRequest(const ::fidl::DecodedMessage<Logger::EndTimerRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLogger_EndTimer_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Logger::SetTransactionHeaderFor::EndTimerResponse(const ::fidl::DecodedMessage<Logger::EndTimerResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLogger_EndTimer_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Logger::SetTransactionHeaderFor::LogIntHistogramRequest(const ::fidl::DecodedMessage<Logger::LogIntHistogramRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLogger_LogIntHistogram_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Logger::SetTransactionHeaderFor::LogIntHistogramResponse(const ::fidl::DecodedMessage<Logger::LogIntHistogramResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLogger_LogIntHistogram_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Logger::SetTransactionHeaderFor::LogCustomEventRequest(const ::fidl::DecodedMessage<Logger::LogCustomEventRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLogger_LogCustomEvent_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Logger::SetTransactionHeaderFor::LogCustomEventResponse(const ::fidl::DecodedMessage<Logger::LogCustomEventResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLogger_LogCustomEvent_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Logger::SetTransactionHeaderFor::LogCobaltEventRequest(const ::fidl::DecodedMessage<Logger::LogCobaltEventRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLogger_LogCobaltEvent_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Logger::SetTransactionHeaderFor::LogCobaltEventResponse(const ::fidl::DecodedMessage<Logger::LogCobaltEventResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLogger_LogCobaltEvent_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Logger::SetTransactionHeaderFor::LogCobaltEventsRequest(const ::fidl::DecodedMessage<Logger::LogCobaltEventsRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLogger_LogCobaltEvents_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Logger::SetTransactionHeaderFor::LogCobaltEventsResponse(const ::fidl::DecodedMessage<Logger::LogCobaltEventsResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLogger_LogCobaltEvents_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

}  // namespace cobalt
}  // namespace fuchsia
}  // namespace llcpp

// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/txn_header.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/connect_service.h>
#include <lib/fidl/llcpp/service_handler_interface.h>
#include <lib/fidl/llcpp/string_view.h>
#include <lib/fidl/llcpp/sync_call.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/fidl/llcpp/vector_view.h>
#include <lib/fit/function.h>
#include <lib/zx/channel.h>
#include <lib/zx/thread.h>
#include <lib/zx/vmo.h>
#include <zircon/fidl.h>

namespace llcpp {

namespace fuchsia {
namespace hardware {
namespace cpu {
namespace insntrace {

enum class Mode : uint8_t {
  CPU = 0u,
  THREAD = 1u,
};


struct Allocation;
struct Controller_Terminate_Response;
struct Controller_Terminate_Result;
struct Controller_ReleaseThreadBuffer_Response;
struct Controller_ReleaseThreadBuffer_Result;
struct Controller_Initialize_Response;
struct Controller_Initialize_Result;
struct Controller_AssignThreadBuffer_Response;
struct Controller_AssignThreadBuffer_Result;
struct BufferState;
struct Controller_AllocateBuffer_Response;
struct Controller_AllocateBuffer_Result;
struct AddressRange;
struct BufferConfig;
class Controller;

extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_AllocationTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_AllocationTable;

// The allocation configuration of a trace.
struct Allocation {
  static constexpr const fidl_type_t* Type = &fuchsia_hardware_cpu_insntrace_AllocationTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_cpu_insntrace_AllocationTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  ::llcpp::fuchsia::hardware::cpu::insntrace::Mode mode = {};

  uint16_t num_traces = {};
};

// The maximum number of traces that can be collected at once.
// A "trace" is the instruction stream for one entity, cpu or thread.
constexpr uint16_t MAX_NUM_TRACES = 64u;

// The maximum number of supported address ranges.
constexpr uint16_t MAX_NUM_ADDR_RANGES = 2u;

extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_Controller_Terminate_ResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_Controller_Terminate_ResponseTable;

struct Controller_Terminate_Response {
  static constexpr const fidl_type_t* Type = &fuchsia_hardware_cpu_insntrace_Controller_Terminate_ResponseTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_cpu_insntrace_Controller_Terminate_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  uint8_t __reserved = {};
};

extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_Controller_Terminate_ResultTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_Controller_Terminate_ResultTable;

struct Controller_Terminate_Result {
  enum class Tag : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
  };

  Controller_Terminate_Result();
  ~Controller_Terminate_Result();

  Controller_Terminate_Result(Controller_Terminate_Result&& other) {
    ordinal_ = Ordinal::Invalid;
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
  }

  Controller_Terminate_Result& operator=(Controller_Terminate_Result&& other) {
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
    return *this;
  }

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == Ordinal::kResponse; }

  // TODO(fxb/41475) Remove this in favor of the pointer version.
  static Controller_Terminate_Result WithResponse(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Terminate_Response&& val) {
    Controller_Terminate_Result result;
    result.set_response(std::move(val));
    return result;
  }
  static Controller_Terminate_Result WithResponse(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Terminate_Response* val) {
    Controller_Terminate_Result result;
    result.set_response(val);
    return result;
  }

  ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Terminate_Response& mutable_response();

  // TODO(fxb/41475) Remove this in favor of the pointer version.
  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Terminate_Response>::value && std::is_copy_assignable<T>::value>
  set_response(const T& v) {
    mutable_response() = v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Terminate_Response>::value && std::is_copy_assignable<T>::value>
  set_response(const T* v) {
    mutable_response() = *v;
  }

  // TODO(fxb/41475) Remove this in favor of the pointer version.
  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Terminate_Response>::value && std::is_move_assignable<T>::value>
  set_response(T&& v) {
    mutable_response() = std::move(v);
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Terminate_Response>::value && std::is_move_assignable<T>::value>
  set_response(T* v) {
    mutable_response() = std::move(*v);
  }

  ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Terminate_Response const & response() const { return response_; }

  bool is_err() const { return ordinal_ == Ordinal::kErr; }

  // TODO(fxb/41475) Remove this in favor of the pointer version.
  static Controller_Terminate_Result WithErr(int32_t&& val) {
    Controller_Terminate_Result result;
    result.set_err(std::move(val));
    return result;
  }
  static Controller_Terminate_Result WithErr(int32_t* val) {
    Controller_Terminate_Result result;
    result.set_err(val);
    return result;
  }

  int32_t& mutable_err();

  // TODO(fxb/41475) Remove this in favor of the pointer version.
  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_copy_assignable<T>::value>
  set_err(const T& v) {
    mutable_err() = v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_copy_assignable<T>::value>
  set_err(const T* v) {
    mutable_err() = *v;
  }

  // TODO(fxb/41475) Remove this in favor of the pointer version.
  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_move_assignable<T>::value>
  set_err(T&& v) {
    mutable_err() = std::move(v);
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_move_assignable<T>::value>
  set_err(T* v) {
    mutable_err() = std::move(*v);
  }

  int32_t const & err() const { return err_; }

  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &fuchsia_hardware_cpu_insntrace_Controller_Terminate_ResultTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_cpu_insntrace_Controller_Terminate_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 8;

 private:
  enum class Ordinal : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  void Destroy();
  void MoveImpl_(Controller_Terminate_Result&& other);
  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  union {
    ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Terminate_Response response_;
    int32_t err_;
  };
};

extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_Controller_ReleaseThreadBuffer_ResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_Controller_ReleaseThreadBuffer_ResponseTable;

struct Controller_ReleaseThreadBuffer_Response {
  static constexpr const fidl_type_t* Type = &fuchsia_hardware_cpu_insntrace_Controller_ReleaseThreadBuffer_ResponseTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_cpu_insntrace_Controller_ReleaseThreadBuffer_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  uint8_t __reserved = {};
};

extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_Controller_ReleaseThreadBuffer_ResultTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_Controller_ReleaseThreadBuffer_ResultTable;

struct Controller_ReleaseThreadBuffer_Result {
  enum class Tag : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
  };

  Controller_ReleaseThreadBuffer_Result();
  ~Controller_ReleaseThreadBuffer_Result();

  Controller_ReleaseThreadBuffer_Result(Controller_ReleaseThreadBuffer_Result&& other) {
    ordinal_ = Ordinal::Invalid;
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
  }

  Controller_ReleaseThreadBuffer_Result& operator=(Controller_ReleaseThreadBuffer_Result&& other) {
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
    return *this;
  }

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == Ordinal::kResponse; }

  // TODO(fxb/41475) Remove this in favor of the pointer version.
  static Controller_ReleaseThreadBuffer_Result WithResponse(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_ReleaseThreadBuffer_Response&& val) {
    Controller_ReleaseThreadBuffer_Result result;
    result.set_response(std::move(val));
    return result;
  }
  static Controller_ReleaseThreadBuffer_Result WithResponse(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_ReleaseThreadBuffer_Response* val) {
    Controller_ReleaseThreadBuffer_Result result;
    result.set_response(val);
    return result;
  }

  ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_ReleaseThreadBuffer_Response& mutable_response();

  // TODO(fxb/41475) Remove this in favor of the pointer version.
  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_ReleaseThreadBuffer_Response>::value && std::is_copy_assignable<T>::value>
  set_response(const T& v) {
    mutable_response() = v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_ReleaseThreadBuffer_Response>::value && std::is_copy_assignable<T>::value>
  set_response(const T* v) {
    mutable_response() = *v;
  }

  // TODO(fxb/41475) Remove this in favor of the pointer version.
  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_ReleaseThreadBuffer_Response>::value && std::is_move_assignable<T>::value>
  set_response(T&& v) {
    mutable_response() = std::move(v);
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_ReleaseThreadBuffer_Response>::value && std::is_move_assignable<T>::value>
  set_response(T* v) {
    mutable_response() = std::move(*v);
  }

  ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_ReleaseThreadBuffer_Response const & response() const { return response_; }

  bool is_err() const { return ordinal_ == Ordinal::kErr; }

  // TODO(fxb/41475) Remove this in favor of the pointer version.
  static Controller_ReleaseThreadBuffer_Result WithErr(int32_t&& val) {
    Controller_ReleaseThreadBuffer_Result result;
    result.set_err(std::move(val));
    return result;
  }
  static Controller_ReleaseThreadBuffer_Result WithErr(int32_t* val) {
    Controller_ReleaseThreadBuffer_Result result;
    result.set_err(val);
    return result;
  }

  int32_t& mutable_err();

  // TODO(fxb/41475) Remove this in favor of the pointer version.
  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_copy_assignable<T>::value>
  set_err(const T& v) {
    mutable_err() = v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_copy_assignable<T>::value>
  set_err(const T* v) {
    mutable_err() = *v;
  }

  // TODO(fxb/41475) Remove this in favor of the pointer version.
  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_move_assignable<T>::value>
  set_err(T&& v) {
    mutable_err() = std::move(v);
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_move_assignable<T>::value>
  set_err(T* v) {
    mutable_err() = std::move(*v);
  }

  int32_t const & err() const { return err_; }

  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &fuchsia_hardware_cpu_insntrace_Controller_ReleaseThreadBuffer_ResultTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_cpu_insntrace_Controller_ReleaseThreadBuffer_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 8;

 private:
  enum class Ordinal : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  void Destroy();
  void MoveImpl_(Controller_ReleaseThreadBuffer_Result&& other);
  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  union {
    ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_ReleaseThreadBuffer_Response response_;
    int32_t err_;
  };
};

extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_Controller_Initialize_ResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_Controller_Initialize_ResponseTable;

struct Controller_Initialize_Response {
  static constexpr const fidl_type_t* Type = &fuchsia_hardware_cpu_insntrace_Controller_Initialize_ResponseTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_cpu_insntrace_Controller_Initialize_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  uint8_t __reserved = {};
};

extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_Controller_Initialize_ResultTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_Controller_Initialize_ResultTable;

struct Controller_Initialize_Result {
  enum class Tag : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
  };

  Controller_Initialize_Result();
  ~Controller_Initialize_Result();

  Controller_Initialize_Result(Controller_Initialize_Result&& other) {
    ordinal_ = Ordinal::Invalid;
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
  }

  Controller_Initialize_Result& operator=(Controller_Initialize_Result&& other) {
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
    return *this;
  }

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == Ordinal::kResponse; }

  // TODO(fxb/41475) Remove this in favor of the pointer version.
  static Controller_Initialize_Result WithResponse(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Initialize_Response&& val) {
    Controller_Initialize_Result result;
    result.set_response(std::move(val));
    return result;
  }
  static Controller_Initialize_Result WithResponse(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Initialize_Response* val) {
    Controller_Initialize_Result result;
    result.set_response(val);
    return result;
  }

  ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Initialize_Response& mutable_response();

  // TODO(fxb/41475) Remove this in favor of the pointer version.
  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Initialize_Response>::value && std::is_copy_assignable<T>::value>
  set_response(const T& v) {
    mutable_response() = v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Initialize_Response>::value && std::is_copy_assignable<T>::value>
  set_response(const T* v) {
    mutable_response() = *v;
  }

  // TODO(fxb/41475) Remove this in favor of the pointer version.
  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Initialize_Response>::value && std::is_move_assignable<T>::value>
  set_response(T&& v) {
    mutable_response() = std::move(v);
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Initialize_Response>::value && std::is_move_assignable<T>::value>
  set_response(T* v) {
    mutable_response() = std::move(*v);
  }

  ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Initialize_Response const & response() const { return response_; }

  bool is_err() const { return ordinal_ == Ordinal::kErr; }

  // TODO(fxb/41475) Remove this in favor of the pointer version.
  static Controller_Initialize_Result WithErr(int32_t&& val) {
    Controller_Initialize_Result result;
    result.set_err(std::move(val));
    return result;
  }
  static Controller_Initialize_Result WithErr(int32_t* val) {
    Controller_Initialize_Result result;
    result.set_err(val);
    return result;
  }

  int32_t& mutable_err();

  // TODO(fxb/41475) Remove this in favor of the pointer version.
  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_copy_assignable<T>::value>
  set_err(const T& v) {
    mutable_err() = v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_copy_assignable<T>::value>
  set_err(const T* v) {
    mutable_err() = *v;
  }

  // TODO(fxb/41475) Remove this in favor of the pointer version.
  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_move_assignable<T>::value>
  set_err(T&& v) {
    mutable_err() = std::move(v);
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_move_assignable<T>::value>
  set_err(T* v) {
    mutable_err() = std::move(*v);
  }

  int32_t const & err() const { return err_; }

  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &fuchsia_hardware_cpu_insntrace_Controller_Initialize_ResultTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_cpu_insntrace_Controller_Initialize_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 8;

 private:
  enum class Ordinal : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  void Destroy();
  void MoveImpl_(Controller_Initialize_Result&& other);
  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  union {
    ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Initialize_Response response_;
    int32_t err_;
  };
};

extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_Controller_AssignThreadBuffer_ResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_Controller_AssignThreadBuffer_ResponseTable;

struct Controller_AssignThreadBuffer_Response {
  static constexpr const fidl_type_t* Type = &fuchsia_hardware_cpu_insntrace_Controller_AssignThreadBuffer_ResponseTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_cpu_insntrace_Controller_AssignThreadBuffer_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  uint8_t __reserved = {};
};

extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_Controller_AssignThreadBuffer_ResultTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_Controller_AssignThreadBuffer_ResultTable;

struct Controller_AssignThreadBuffer_Result {
  enum class Tag : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
  };

  Controller_AssignThreadBuffer_Result();
  ~Controller_AssignThreadBuffer_Result();

  Controller_AssignThreadBuffer_Result(Controller_AssignThreadBuffer_Result&& other) {
    ordinal_ = Ordinal::Invalid;
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
  }

  Controller_AssignThreadBuffer_Result& operator=(Controller_AssignThreadBuffer_Result&& other) {
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
    return *this;
  }

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == Ordinal::kResponse; }

  // TODO(fxb/41475) Remove this in favor of the pointer version.
  static Controller_AssignThreadBuffer_Result WithResponse(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AssignThreadBuffer_Response&& val) {
    Controller_AssignThreadBuffer_Result result;
    result.set_response(std::move(val));
    return result;
  }
  static Controller_AssignThreadBuffer_Result WithResponse(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AssignThreadBuffer_Response* val) {
    Controller_AssignThreadBuffer_Result result;
    result.set_response(val);
    return result;
  }

  ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AssignThreadBuffer_Response& mutable_response();

  // TODO(fxb/41475) Remove this in favor of the pointer version.
  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AssignThreadBuffer_Response>::value && std::is_copy_assignable<T>::value>
  set_response(const T& v) {
    mutable_response() = v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AssignThreadBuffer_Response>::value && std::is_copy_assignable<T>::value>
  set_response(const T* v) {
    mutable_response() = *v;
  }

  // TODO(fxb/41475) Remove this in favor of the pointer version.
  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AssignThreadBuffer_Response>::value && std::is_move_assignable<T>::value>
  set_response(T&& v) {
    mutable_response() = std::move(v);
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AssignThreadBuffer_Response>::value && std::is_move_assignable<T>::value>
  set_response(T* v) {
    mutable_response() = std::move(*v);
  }

  ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AssignThreadBuffer_Response const & response() const { return response_; }

  bool is_err() const { return ordinal_ == Ordinal::kErr; }

  // TODO(fxb/41475) Remove this in favor of the pointer version.
  static Controller_AssignThreadBuffer_Result WithErr(int32_t&& val) {
    Controller_AssignThreadBuffer_Result result;
    result.set_err(std::move(val));
    return result;
  }
  static Controller_AssignThreadBuffer_Result WithErr(int32_t* val) {
    Controller_AssignThreadBuffer_Result result;
    result.set_err(val);
    return result;
  }

  int32_t& mutable_err();

  // TODO(fxb/41475) Remove this in favor of the pointer version.
  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_copy_assignable<T>::value>
  set_err(const T& v) {
    mutable_err() = v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_copy_assignable<T>::value>
  set_err(const T* v) {
    mutable_err() = *v;
  }

  // TODO(fxb/41475) Remove this in favor of the pointer version.
  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_move_assignable<T>::value>
  set_err(T&& v) {
    mutable_err() = std::move(v);
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_move_assignable<T>::value>
  set_err(T* v) {
    mutable_err() = std::move(*v);
  }

  int32_t const & err() const { return err_; }

  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &fuchsia_hardware_cpu_insntrace_Controller_AssignThreadBuffer_ResultTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_cpu_insntrace_Controller_AssignThreadBuffer_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 8;

 private:
  enum class Ordinal : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  void Destroy();
  void MoveImpl_(Controller_AssignThreadBuffer_Result&& other);
  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  union {
    ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AssignThreadBuffer_Response response_;
    int32_t err_;
  };
};

extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_BufferStateTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_BufferStateTable;

// A buffer's runtime state.
struct BufferState {
  static constexpr const fidl_type_t* Type = &fuchsia_hardware_cpu_insntrace_BufferStateTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_cpu_insntrace_BufferStateTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  // This is the offset in the buffer where tracing stopped (treating all
  // buffers as one large one). If using a circular buffer then all of the
  // buffer may contain data, there's no current way to know if tracing
  // wrapped without scanning records.
  uint64_t capture_end = {};
};

extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_Controller_AllocateBuffer_ResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_Controller_AllocateBuffer_ResponseTable;

struct Controller_AllocateBuffer_Response {
  static constexpr const fidl_type_t* Type = &fuchsia_hardware_cpu_insntrace_Controller_AllocateBuffer_ResponseTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_cpu_insntrace_Controller_AllocateBuffer_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  uint32_t descriptor = {};
};

extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_Controller_AllocateBuffer_ResultTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_Controller_AllocateBuffer_ResultTable;

struct Controller_AllocateBuffer_Result {
  enum class Tag : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
  };

  Controller_AllocateBuffer_Result();
  ~Controller_AllocateBuffer_Result();

  Controller_AllocateBuffer_Result(Controller_AllocateBuffer_Result&& other) {
    ordinal_ = Ordinal::Invalid;
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
  }

  Controller_AllocateBuffer_Result& operator=(Controller_AllocateBuffer_Result&& other) {
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
    return *this;
  }

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == Ordinal::kResponse; }

  // TODO(fxb/41475) Remove this in favor of the pointer version.
  static Controller_AllocateBuffer_Result WithResponse(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AllocateBuffer_Response&& val) {
    Controller_AllocateBuffer_Result result;
    result.set_response(std::move(val));
    return result;
  }
  static Controller_AllocateBuffer_Result WithResponse(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AllocateBuffer_Response* val) {
    Controller_AllocateBuffer_Result result;
    result.set_response(val);
    return result;
  }

  ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AllocateBuffer_Response& mutable_response();

  // TODO(fxb/41475) Remove this in favor of the pointer version.
  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AllocateBuffer_Response>::value && std::is_copy_assignable<T>::value>
  set_response(const T& v) {
    mutable_response() = v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AllocateBuffer_Response>::value && std::is_copy_assignable<T>::value>
  set_response(const T* v) {
    mutable_response() = *v;
  }

  // TODO(fxb/41475) Remove this in favor of the pointer version.
  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AllocateBuffer_Response>::value && std::is_move_assignable<T>::value>
  set_response(T&& v) {
    mutable_response() = std::move(v);
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AllocateBuffer_Response>::value && std::is_move_assignable<T>::value>
  set_response(T* v) {
    mutable_response() = std::move(*v);
  }

  ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AllocateBuffer_Response const & response() const { return response_; }

  bool is_err() const { return ordinal_ == Ordinal::kErr; }

  // TODO(fxb/41475) Remove this in favor of the pointer version.
  static Controller_AllocateBuffer_Result WithErr(int32_t&& val) {
    Controller_AllocateBuffer_Result result;
    result.set_err(std::move(val));
    return result;
  }
  static Controller_AllocateBuffer_Result WithErr(int32_t* val) {
    Controller_AllocateBuffer_Result result;
    result.set_err(val);
    return result;
  }

  int32_t& mutable_err();

  // TODO(fxb/41475) Remove this in favor of the pointer version.
  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_copy_assignable<T>::value>
  set_err(const T& v) {
    mutable_err() = v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_copy_assignable<T>::value>
  set_err(const T* v) {
    mutable_err() = *v;
  }

  // TODO(fxb/41475) Remove this in favor of the pointer version.
  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_move_assignable<T>::value>
  set_err(T&& v) {
    mutable_err() = std::move(v);
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_move_assignable<T>::value>
  set_err(T* v) {
    mutable_err() = std::move(*v);
  }

  int32_t const & err() const { return err_; }

  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &fuchsia_hardware_cpu_insntrace_Controller_AllocateBuffer_ResultTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_cpu_insntrace_Controller_AllocateBuffer_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 8;

 private:
  enum class Ordinal : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  void Destroy();
  void MoveImpl_(Controller_AllocateBuffer_Result&& other);
  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  union {
    ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AllocateBuffer_Response response_;
    int32_t err_;
  };
};

extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_AddressRangeTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_AddressRangeTable;

// An address range, as [start,end].
struct AddressRange {
  static constexpr const fidl_type_t* Type = &fuchsia_hardware_cpu_insntrace_AddressRangeTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_cpu_insntrace_AddressRangeTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  uint64_t start = {};

  uint64_t end = {};
};

extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_BufferConfigTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_BufferConfigTable;

// A buffer's configuration.
struct BufferConfig {
  static constexpr const fidl_type_t* Type = &fuchsia_hardware_cpu_insntrace_BufferConfigTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_cpu_insntrace_BufferConfigTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 64;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 64;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  // A "buffer" is made up of |num_chunks| chunks with each chunk having
  // size |1<<chunk_order| pages.
  uint32_t num_chunks = {};

  // log2 of the number of pages
  uint32_t chunk_order = {};

  // If true then use circular buffering.
  bool is_circular = {};

  // The value of the control register.
  uint64_t ctl = {};

  // If non-zero then the address space of the instruction must match in
  // order for the instruction to be traced. On x86 architectures the
  // address space is specified by CR3.
  uint64_t address_space_match = {};

  // If non-zero, tracing is restricted to these address ranges.
  // TODO(dje): There's only two, and vectors don't currently work here,
  // so spell these out individually
  ::llcpp::fuchsia::hardware::cpu::insntrace::AddressRange address_range_0 = {};

  ::llcpp::fuchsia::hardware::cpu::insntrace::AddressRange address_range_1 = {};
};

extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerInitializeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerInitializeRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerInitializeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerInitializeResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerTerminateRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerTerminateRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerTerminateResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerTerminateResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerGetAllocationRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerGetAllocationRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerGetAllocationResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerGetAllocationResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerAllocateBufferRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerAllocateBufferRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerAllocateBufferResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerAllocateBufferResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerAssignThreadBufferRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerAssignThreadBufferRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerAssignThreadBufferResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerAssignThreadBufferResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerReleaseThreadBufferRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerReleaseThreadBufferRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerReleaseThreadBufferResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerReleaseThreadBufferResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerGetBufferConfigRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerGetBufferConfigRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerGetBufferConfigResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerGetBufferConfigResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerGetBufferStateRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerGetBufferStateRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerGetBufferStateResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerGetBufferStateResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerGetChunkHandleRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerGetChunkHandleRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerGetChunkHandleResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerGetChunkHandleResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerFreeBufferRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerFreeBufferRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerFreeBufferResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerFreeBufferResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerStartRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerStartRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerStartResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerStartResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerStopRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerStopRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerStopResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerStopResponseTable;

class Controller final {
  Controller() = delete;
 public:

  struct InitializeResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Initialize_Result result;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_cpu_insntrace_ControllerInitializeResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_cpu_insntrace_ControllerInitializeResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct InitializeRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::cpu::insntrace::Allocation allocation;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_cpu_insntrace_ControllerInitializeRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_cpu_insntrace_ControllerInitializeRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = InitializeResponse;
  };

  struct TerminateResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Terminate_Result result;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_cpu_insntrace_ControllerTerminateResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_cpu_insntrace_ControllerTerminateResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using TerminateRequest = ::fidl::AnyZeroArgMessage;

  struct GetAllocationResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::cpu::insntrace::Allocation* allocation;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_cpu_insntrace_ControllerGetAllocationResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_cpu_insntrace_ControllerGetAllocationResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetAllocationRequest = ::fidl::AnyZeroArgMessage;

  struct AllocateBufferResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AllocateBuffer_Result result;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_cpu_insntrace_ControllerAllocateBufferResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_cpu_insntrace_ControllerAllocateBufferResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct AllocateBufferRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::cpu::insntrace::BufferConfig config;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_cpu_insntrace_ControllerAllocateBufferRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_cpu_insntrace_ControllerAllocateBufferRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 80;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 80;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = AllocateBufferResponse;
  };

  struct AssignThreadBufferResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AssignThreadBuffer_Result result;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_cpu_insntrace_ControllerAssignThreadBufferResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_cpu_insntrace_ControllerAssignThreadBufferResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct AssignThreadBufferRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t descriptor;
    ::zx::thread thread;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_cpu_insntrace_ControllerAssignThreadBufferRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_cpu_insntrace_ControllerAssignThreadBufferRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = AssignThreadBufferResponse;
  };

  struct ReleaseThreadBufferResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_ReleaseThreadBuffer_Result result;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_cpu_insntrace_ControllerReleaseThreadBufferResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_cpu_insntrace_ControllerReleaseThreadBufferResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct ReleaseThreadBufferRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t descriptor;
    ::zx::thread thread;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_cpu_insntrace_ControllerReleaseThreadBufferRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_cpu_insntrace_ControllerReleaseThreadBufferRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = ReleaseThreadBufferResponse;
  };

  struct GetBufferConfigResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::cpu::insntrace::BufferConfig* config;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_cpu_insntrace_ControllerGetBufferConfigResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_cpu_insntrace_ControllerGetBufferConfigResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 64;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 64;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct GetBufferConfigRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t descriptor;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_cpu_insntrace_ControllerGetBufferConfigRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_cpu_insntrace_ControllerGetBufferConfigRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = GetBufferConfigResponse;
  };

  struct GetBufferStateResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::cpu::insntrace::BufferState* state;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_cpu_insntrace_ControllerGetBufferStateResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_cpu_insntrace_ControllerGetBufferStateResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct GetBufferStateRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t descriptor;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_cpu_insntrace_ControllerGetBufferStateRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_cpu_insntrace_ControllerGetBufferStateRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = GetBufferStateResponse;
  };

  struct GetChunkHandleResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::vmo buffer;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_cpu_insntrace_ControllerGetChunkHandleResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_cpu_insntrace_ControllerGetChunkHandleResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct GetChunkHandleRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t descriptor;
    uint32_t chunk_num;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_cpu_insntrace_ControllerGetChunkHandleRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_cpu_insntrace_ControllerGetChunkHandleRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = GetChunkHandleResponse;
  };

  using FreeBufferResponse = ::fidl::AnyZeroArgMessage;
  struct FreeBufferRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t descriptor;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_cpu_insntrace_ControllerFreeBufferRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_cpu_insntrace_ControllerFreeBufferRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  using StartResponse = ::fidl::AnyZeroArgMessage;
  using StartRequest = ::fidl::AnyZeroArgMessage;

  using StopResponse = ::fidl::AnyZeroArgMessage;
  using StopRequest = ::fidl::AnyZeroArgMessage;


  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    template <typename ResponseType>
    class Initialize_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Initialize_Impl(zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::cpu::insntrace::Allocation allocation);
      ~Initialize_Impl() = default;
      Initialize_Impl(Initialize_Impl&& other) = default;
      Initialize_Impl& operator=(Initialize_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Terminate_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Terminate_Impl(zx::unowned_channel _client_end);
      ~Terminate_Impl() = default;
      Terminate_Impl(Terminate_Impl&& other) = default;
      Terminate_Impl& operator=(Terminate_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetAllocation_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetAllocation_Impl(zx::unowned_channel _client_end);
      ~GetAllocation_Impl() = default;
      GetAllocation_Impl(GetAllocation_Impl&& other) = default;
      GetAllocation_Impl& operator=(GetAllocation_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class AllocateBuffer_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      AllocateBuffer_Impl(zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::cpu::insntrace::BufferConfig config);
      ~AllocateBuffer_Impl() = default;
      AllocateBuffer_Impl(AllocateBuffer_Impl&& other) = default;
      AllocateBuffer_Impl& operator=(AllocateBuffer_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class AssignThreadBuffer_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      AssignThreadBuffer_Impl(zx::unowned_channel _client_end, uint32_t descriptor, ::zx::thread thread);
      ~AssignThreadBuffer_Impl() = default;
      AssignThreadBuffer_Impl(AssignThreadBuffer_Impl&& other) = default;
      AssignThreadBuffer_Impl& operator=(AssignThreadBuffer_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class ReleaseThreadBuffer_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      ReleaseThreadBuffer_Impl(zx::unowned_channel _client_end, uint32_t descriptor, ::zx::thread thread);
      ~ReleaseThreadBuffer_Impl() = default;
      ReleaseThreadBuffer_Impl(ReleaseThreadBuffer_Impl&& other) = default;
      ReleaseThreadBuffer_Impl& operator=(ReleaseThreadBuffer_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetBufferConfig_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetBufferConfig_Impl(zx::unowned_channel _client_end, uint32_t descriptor);
      ~GetBufferConfig_Impl() = default;
      GetBufferConfig_Impl(GetBufferConfig_Impl&& other) = default;
      GetBufferConfig_Impl& operator=(GetBufferConfig_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetBufferState_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetBufferState_Impl(zx::unowned_channel _client_end, uint32_t descriptor);
      ~GetBufferState_Impl() = default;
      GetBufferState_Impl(GetBufferState_Impl&& other) = default;
      GetBufferState_Impl& operator=(GetBufferState_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetChunkHandle_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetChunkHandle_Impl(zx::unowned_channel _client_end, uint32_t descriptor, uint32_t chunk_num);
      ~GetChunkHandle_Impl() = default;
      GetChunkHandle_Impl(GetChunkHandle_Impl&& other) = default;
      GetChunkHandle_Impl& operator=(GetChunkHandle_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class FreeBuffer_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      FreeBuffer_Impl(zx::unowned_channel _client_end, uint32_t descriptor);
      ~FreeBuffer_Impl() = default;
      FreeBuffer_Impl(FreeBuffer_Impl&& other) = default;
      FreeBuffer_Impl& operator=(FreeBuffer_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Start_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Start_Impl(zx::unowned_channel _client_end);
      ~Start_Impl() = default;
      Start_Impl(Start_Impl&& other) = default;
      Start_Impl& operator=(Start_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Stop_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Stop_Impl(zx::unowned_channel _client_end);
      ~Stop_Impl() = default;
      Stop_Impl(Stop_Impl&& other) = default;
      Stop_Impl& operator=(Stop_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Initialize = Initialize_Impl<InitializeResponse>;
    using Terminate = Terminate_Impl<TerminateResponse>;
    using GetAllocation = GetAllocation_Impl<GetAllocationResponse>;
    using AllocateBuffer = AllocateBuffer_Impl<AllocateBufferResponse>;
    using AssignThreadBuffer = AssignThreadBuffer_Impl<AssignThreadBufferResponse>;
    using ReleaseThreadBuffer = ReleaseThreadBuffer_Impl<ReleaseThreadBufferResponse>;
    using GetBufferConfig = GetBufferConfig_Impl<GetBufferConfigResponse>;
    using GetBufferState = GetBufferState_Impl<GetBufferStateResponse>;
    using GetChunkHandle = GetChunkHandle_Impl<GetChunkHandleResponse>;
    using FreeBuffer = FreeBuffer_Impl<FreeBufferResponse>;
    using Start = Start_Impl<StartResponse>;
    using Stop = Stop_Impl<StopResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    template <typename ResponseType>
    class Initialize_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Initialize_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::cpu::insntrace::Allocation allocation, ::fidl::BytePart _response_buffer);
      ~Initialize_Impl() = default;
      Initialize_Impl(Initialize_Impl&& other) = default;
      Initialize_Impl& operator=(Initialize_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Terminate_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Terminate_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Terminate_Impl() = default;
      Terminate_Impl(Terminate_Impl&& other) = default;
      Terminate_Impl& operator=(Terminate_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetAllocation_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetAllocation_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetAllocation_Impl() = default;
      GetAllocation_Impl(GetAllocation_Impl&& other) = default;
      GetAllocation_Impl& operator=(GetAllocation_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class AllocateBuffer_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      AllocateBuffer_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::cpu::insntrace::BufferConfig config, ::fidl::BytePart _response_buffer);
      ~AllocateBuffer_Impl() = default;
      AllocateBuffer_Impl(AllocateBuffer_Impl&& other) = default;
      AllocateBuffer_Impl& operator=(AllocateBuffer_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class AssignThreadBuffer_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      AssignThreadBuffer_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t descriptor, ::zx::thread thread, ::fidl::BytePart _response_buffer);
      ~AssignThreadBuffer_Impl() = default;
      AssignThreadBuffer_Impl(AssignThreadBuffer_Impl&& other) = default;
      AssignThreadBuffer_Impl& operator=(AssignThreadBuffer_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class ReleaseThreadBuffer_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      ReleaseThreadBuffer_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t descriptor, ::zx::thread thread, ::fidl::BytePart _response_buffer);
      ~ReleaseThreadBuffer_Impl() = default;
      ReleaseThreadBuffer_Impl(ReleaseThreadBuffer_Impl&& other) = default;
      ReleaseThreadBuffer_Impl& operator=(ReleaseThreadBuffer_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetBufferConfig_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetBufferConfig_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t descriptor, ::fidl::BytePart _response_buffer);
      ~GetBufferConfig_Impl() = default;
      GetBufferConfig_Impl(GetBufferConfig_Impl&& other) = default;
      GetBufferConfig_Impl& operator=(GetBufferConfig_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetBufferState_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetBufferState_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t descriptor, ::fidl::BytePart _response_buffer);
      ~GetBufferState_Impl() = default;
      GetBufferState_Impl(GetBufferState_Impl&& other) = default;
      GetBufferState_Impl& operator=(GetBufferState_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetChunkHandle_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetChunkHandle_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t descriptor, uint32_t chunk_num, ::fidl::BytePart _response_buffer);
      ~GetChunkHandle_Impl() = default;
      GetChunkHandle_Impl(GetChunkHandle_Impl&& other) = default;
      GetChunkHandle_Impl& operator=(GetChunkHandle_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class FreeBuffer_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      FreeBuffer_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t descriptor, ::fidl::BytePart _response_buffer);
      ~FreeBuffer_Impl() = default;
      FreeBuffer_Impl(FreeBuffer_Impl&& other) = default;
      FreeBuffer_Impl& operator=(FreeBuffer_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Start_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Start_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Start_Impl() = default;
      Start_Impl(Start_Impl&& other) = default;
      Start_Impl& operator=(Start_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Stop_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Stop_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Stop_Impl() = default;
      Stop_Impl(Stop_Impl&& other) = default;
      Stop_Impl& operator=(Stop_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Initialize = Initialize_Impl<InitializeResponse>;
    using Terminate = Terminate_Impl<TerminateResponse>;
    using GetAllocation = GetAllocation_Impl<GetAllocationResponse>;
    using AllocateBuffer = AllocateBuffer_Impl<AllocateBufferResponse>;
    using AssignThreadBuffer = AssignThreadBuffer_Impl<AssignThreadBufferResponse>;
    using ReleaseThreadBuffer = ReleaseThreadBuffer_Impl<ReleaseThreadBufferResponse>;
    using GetBufferConfig = GetBufferConfig_Impl<GetBufferConfigResponse>;
    using GetBufferState = GetBufferState_Impl<GetBufferStateResponse>;
    using GetChunkHandle = GetChunkHandle_Impl<GetChunkHandleResponse>;
    using FreeBuffer = FreeBuffer_Impl<FreeBufferResponse>;
    using Start = Start_Impl<StartResponse>;
    using Stop = Stop_Impl<StopResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Initialize the trace.
    // This does not include allocating space for the trace buffers, that is
    // done later by |AllocateBuffer()|.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Initialize Initialize(::llcpp::fuchsia::hardware::cpu::insntrace::Allocation allocation);

    // Initialize the trace.
    // This does not include allocating space for the trace buffers, that is
    // done later by |AllocateBuffer()|.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Initialize Initialize(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::cpu::insntrace::Allocation allocation, ::fidl::BytePart _response_buffer);

    // Free all trace buffers and any other resources allocated for the trace.
    // This is also done when the connection is closed (as well as stopping
    // the trace).
    // May be called multiple times.
    // This can only fail when tracing in THREAD mode where tracing is
    // terminated differently, in which case the error is `ZX_ERR_BAD_STATE`.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Terminate Terminate();

    // Free all trace buffers and any other resources allocated for the trace.
    // This is also done when the connection is closed (as well as stopping
    // the trace).
    // May be called multiple times.
    // This can only fail when tracing in THREAD mode where tracing is
    // terminated differently, in which case the error is `ZX_ERR_BAD_STATE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Terminate Terminate(::fidl::BytePart _response_buffer);

    // Return the trace allocation configuration.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetAllocation GetAllocation();

    // Return the trace allocation configuration.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetAllocation GetAllocation(::fidl::BytePart _response_buffer);

    // Allocate a trace buffer.
    // When tracing cpus, buffers are auto-assigned to cpus: the resulting
    // trace buffer descriptor is the number of the cpu using the buffer.
    // Allocates 104 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::AllocateBuffer AllocateBuffer(::llcpp::fuchsia::hardware::cpu::insntrace::BufferConfig config);

    // Allocate a trace buffer.
    // When tracing cpus, buffers are auto-assigned to cpus: the resulting
    // trace buffer descriptor is the number of the cpu using the buffer.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::AllocateBuffer AllocateBuffer(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::cpu::insntrace::BufferConfig config, ::fidl::BytePart _response_buffer);

    // Assign a buffer to a thread.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::AssignThreadBuffer AssignThreadBuffer(uint32_t descriptor, ::zx::thread thread);

    // Assign a buffer to a thread.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::AssignThreadBuffer AssignThreadBuffer(::fidl::BytePart _request_buffer, uint32_t descriptor, ::zx::thread thread, ::fidl::BytePart _response_buffer);

    // Release a previously assigned buffer from a thread.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::ReleaseThreadBuffer ReleaseThreadBuffer(uint32_t descriptor, ::zx::thread thread);

    // Release a previously assigned buffer from a thread.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::ReleaseThreadBuffer ReleaseThreadBuffer(::fidl::BytePart _request_buffer, uint32_t descriptor, ::zx::thread thread, ::fidl::BytePart _response_buffer);

    // Fetch a buffer's configuration.
    // Allocates 112 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetBufferConfig GetBufferConfig(uint32_t descriptor);

    // Fetch a buffer's configuration.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetBufferConfig GetBufferConfig(::fidl::BytePart _request_buffer, uint32_t descriptor, ::fidl::BytePart _response_buffer);

    // Fetch runtime information about a buffer.
    // Allocates 56 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetBufferState GetBufferState(uint32_t descriptor);

    // Fetch runtime information about a buffer.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetBufferState GetBufferState(::fidl::BytePart _request_buffer, uint32_t descriptor, ::fidl::BytePart _response_buffer);

    // Fetch the handle of a chunk of a trace buffer.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetChunkHandle GetChunkHandle(uint32_t descriptor, uint32_t chunk_num);

    // Fetch the handle of a chunk of a trace buffer.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetChunkHandle GetChunkHandle(::fidl::BytePart _request_buffer, uint32_t descriptor, uint32_t chunk_num, ::fidl::BytePart _response_buffer);

    // Free a previously allocated trace buffer.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::FreeBuffer FreeBuffer(uint32_t descriptor);

    // Free a previously allocated trace buffer.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::FreeBuffer FreeBuffer(::fidl::BytePart _request_buffer, uint32_t descriptor, ::fidl::BytePart _response_buffer);

    // Start tracing.
    // Must be called after |Initialize()| + |AllocateBuffer()|,
    // with tracing off.
    // Allocates 32 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Start Start();


    // Stop tracing.
    // May be called any time after |Allocate()| has been called and before
    // |Free()|. If called at other times the call is ignored.
    // May be called multiple times.
    // Allocates 32 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Stop Stop();


   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Initialize the trace.
    // This does not include allocating space for the trace buffers, that is
    // done later by |AllocateBuffer()|.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Initialize Initialize(zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::cpu::insntrace::Allocation allocation);

    // Initialize the trace.
    // This does not include allocating space for the trace buffers, that is
    // done later by |AllocateBuffer()|.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Initialize Initialize(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::cpu::insntrace::Allocation allocation, ::fidl::BytePart _response_buffer);

    // Free all trace buffers and any other resources allocated for the trace.
    // This is also done when the connection is closed (as well as stopping
    // the trace).
    // May be called multiple times.
    // This can only fail when tracing in THREAD mode where tracing is
    // terminated differently, in which case the error is `ZX_ERR_BAD_STATE`.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Terminate Terminate(zx::unowned_channel _client_end);

    // Free all trace buffers and any other resources allocated for the trace.
    // This is also done when the connection is closed (as well as stopping
    // the trace).
    // May be called multiple times.
    // This can only fail when tracing in THREAD mode where tracing is
    // terminated differently, in which case the error is `ZX_ERR_BAD_STATE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Terminate Terminate(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Return the trace allocation configuration.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetAllocation GetAllocation(zx::unowned_channel _client_end);

    // Return the trace allocation configuration.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetAllocation GetAllocation(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Allocate a trace buffer.
    // When tracing cpus, buffers are auto-assigned to cpus: the resulting
    // trace buffer descriptor is the number of the cpu using the buffer.
    // Allocates 104 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::AllocateBuffer AllocateBuffer(zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::cpu::insntrace::BufferConfig config);

    // Allocate a trace buffer.
    // When tracing cpus, buffers are auto-assigned to cpus: the resulting
    // trace buffer descriptor is the number of the cpu using the buffer.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::AllocateBuffer AllocateBuffer(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::cpu::insntrace::BufferConfig config, ::fidl::BytePart _response_buffer);

    // Assign a buffer to a thread.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::AssignThreadBuffer AssignThreadBuffer(zx::unowned_channel _client_end, uint32_t descriptor, ::zx::thread thread);

    // Assign a buffer to a thread.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::AssignThreadBuffer AssignThreadBuffer(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t descriptor, ::zx::thread thread, ::fidl::BytePart _response_buffer);

    // Release a previously assigned buffer from a thread.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::ReleaseThreadBuffer ReleaseThreadBuffer(zx::unowned_channel _client_end, uint32_t descriptor, ::zx::thread thread);

    // Release a previously assigned buffer from a thread.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::ReleaseThreadBuffer ReleaseThreadBuffer(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t descriptor, ::zx::thread thread, ::fidl::BytePart _response_buffer);

    // Fetch a buffer's configuration.
    // Allocates 112 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetBufferConfig GetBufferConfig(zx::unowned_channel _client_end, uint32_t descriptor);

    // Fetch a buffer's configuration.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetBufferConfig GetBufferConfig(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t descriptor, ::fidl::BytePart _response_buffer);

    // Fetch runtime information about a buffer.
    // Allocates 56 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetBufferState GetBufferState(zx::unowned_channel _client_end, uint32_t descriptor);

    // Fetch runtime information about a buffer.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetBufferState GetBufferState(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t descriptor, ::fidl::BytePart _response_buffer);

    // Fetch the handle of a chunk of a trace buffer.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetChunkHandle GetChunkHandle(zx::unowned_channel _client_end, uint32_t descriptor, uint32_t chunk_num);

    // Fetch the handle of a chunk of a trace buffer.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetChunkHandle GetChunkHandle(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t descriptor, uint32_t chunk_num, ::fidl::BytePart _response_buffer);

    // Free a previously allocated trace buffer.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::FreeBuffer FreeBuffer(zx::unowned_channel _client_end, uint32_t descriptor);

    // Free a previously allocated trace buffer.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::FreeBuffer FreeBuffer(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t descriptor, ::fidl::BytePart _response_buffer);

    // Start tracing.
    // Must be called after |Initialize()| + |AllocateBuffer()|,
    // with tracing off.
    // Allocates 32 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Start Start(zx::unowned_channel _client_end);


    // Stop tracing.
    // May be called any time after |Allocate()| has been called and before
    // |Free()|. If called at other times the call is ignored.
    // May be called multiple times.
    // Allocates 32 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Stop Stop(zx::unowned_channel _client_end);


  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Initialize the trace.
    // This does not include allocating space for the trace buffers, that is
    // done later by |AllocateBuffer()|.
    static ::fidl::DecodeResult<InitializeResponse> Initialize(zx::unowned_channel _client_end, ::fidl::DecodedMessage<InitializeRequest> params, ::fidl::BytePart response_buffer);

    // Free all trace buffers and any other resources allocated for the trace.
    // This is also done when the connection is closed (as well as stopping
    // the trace).
    // May be called multiple times.
    // This can only fail when tracing in THREAD mode where tracing is
    // terminated differently, in which case the error is `ZX_ERR_BAD_STATE`.
    static ::fidl::DecodeResult<TerminateResponse> Terminate(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Return the trace allocation configuration.
    static ::fidl::DecodeResult<GetAllocationResponse> GetAllocation(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Allocate a trace buffer.
    // When tracing cpus, buffers are auto-assigned to cpus: the resulting
    // trace buffer descriptor is the number of the cpu using the buffer.
    static ::fidl::DecodeResult<AllocateBufferResponse> AllocateBuffer(zx::unowned_channel _client_end, ::fidl::DecodedMessage<AllocateBufferRequest> params, ::fidl::BytePart response_buffer);

    // Assign a buffer to a thread.
    static ::fidl::DecodeResult<AssignThreadBufferResponse> AssignThreadBuffer(zx::unowned_channel _client_end, ::fidl::DecodedMessage<AssignThreadBufferRequest> params, ::fidl::BytePart response_buffer);

    // Release a previously assigned buffer from a thread.
    static ::fidl::DecodeResult<ReleaseThreadBufferResponse> ReleaseThreadBuffer(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReleaseThreadBufferRequest> params, ::fidl::BytePart response_buffer);

    // Fetch a buffer's configuration.
    static ::fidl::DecodeResult<GetBufferConfigResponse> GetBufferConfig(zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetBufferConfigRequest> params, ::fidl::BytePart response_buffer);

    // Fetch runtime information about a buffer.
    static ::fidl::DecodeResult<GetBufferStateResponse> GetBufferState(zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetBufferStateRequest> params, ::fidl::BytePart response_buffer);

    // Fetch the handle of a chunk of a trace buffer.
    static ::fidl::DecodeResult<GetChunkHandleResponse> GetChunkHandle(zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetChunkHandleRequest> params, ::fidl::BytePart response_buffer);

    // Free a previously allocated trace buffer.
    static ::fidl::DecodeResult<FreeBufferResponse> FreeBuffer(zx::unowned_channel _client_end, ::fidl::DecodedMessage<FreeBufferRequest> params, ::fidl::BytePart response_buffer);

    // Start tracing.
    // Must be called after |Initialize()| + |AllocateBuffer()|,
    // with tracing off.
    static ::fidl::DecodeResult<StartResponse> Start(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Stop tracing.
    // May be called any time after |Allocate()| has been called and before
    // |Free()|. If called at other times the call is ignored.
    // May be called multiple times.
    static ::fidl::DecodeResult<StopResponse> Stop(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Controller;
    using _Base = ::fidl::CompleterBase;

    class InitializeCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Initialize_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Initialize_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<InitializeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using InitializeCompleter = ::fidl::Completer<InitializeCompleterBase>;

    virtual void Initialize(::llcpp::fuchsia::hardware::cpu::insntrace::Allocation allocation, InitializeCompleter::Sync _completer) = 0;

    class TerminateCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Terminate_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Terminate_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<TerminateResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using TerminateCompleter = ::fidl::Completer<TerminateCompleterBase>;

    virtual void Terminate(TerminateCompleter::Sync _completer) = 0;

    class GetAllocationCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::hardware::cpu::insntrace::Allocation* allocation);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::cpu::insntrace::Allocation* allocation);
      void Reply(::fidl::DecodedMessage<GetAllocationResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetAllocationCompleter = ::fidl::Completer<GetAllocationCompleterBase>;

    virtual void GetAllocation(GetAllocationCompleter::Sync _completer) = 0;

    class AllocateBufferCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AllocateBuffer_Result result);
      void ReplySuccess(uint32_t descriptor);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AllocateBuffer_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, uint32_t descriptor);
      void Reply(::fidl::DecodedMessage<AllocateBufferResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using AllocateBufferCompleter = ::fidl::Completer<AllocateBufferCompleterBase>;

    virtual void AllocateBuffer(::llcpp::fuchsia::hardware::cpu::insntrace::BufferConfig config, AllocateBufferCompleter::Sync _completer) = 0;

    class AssignThreadBufferCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AssignThreadBuffer_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AssignThreadBuffer_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<AssignThreadBufferResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using AssignThreadBufferCompleter = ::fidl::Completer<AssignThreadBufferCompleterBase>;

    virtual void AssignThreadBuffer(uint32_t descriptor, ::zx::thread thread, AssignThreadBufferCompleter::Sync _completer) = 0;

    class ReleaseThreadBufferCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_ReleaseThreadBuffer_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_ReleaseThreadBuffer_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<ReleaseThreadBufferResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ReleaseThreadBufferCompleter = ::fidl::Completer<ReleaseThreadBufferCompleterBase>;

    virtual void ReleaseThreadBuffer(uint32_t descriptor, ::zx::thread thread, ReleaseThreadBufferCompleter::Sync _completer) = 0;

    class GetBufferConfigCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::hardware::cpu::insntrace::BufferConfig* config);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::cpu::insntrace::BufferConfig* config);
      void Reply(::fidl::DecodedMessage<GetBufferConfigResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetBufferConfigCompleter = ::fidl::Completer<GetBufferConfigCompleterBase>;

    virtual void GetBufferConfig(uint32_t descriptor, GetBufferConfigCompleter::Sync _completer) = 0;

    class GetBufferStateCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::hardware::cpu::insntrace::BufferState* state);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::cpu::insntrace::BufferState* state);
      void Reply(::fidl::DecodedMessage<GetBufferStateResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetBufferStateCompleter = ::fidl::Completer<GetBufferStateCompleterBase>;

    virtual void GetBufferState(uint32_t descriptor, GetBufferStateCompleter::Sync _completer) = 0;

    class GetChunkHandleCompleterBase : public _Base {
     public:
      void Reply(::zx::vmo buffer);
      void Reply(::fidl::BytePart _buffer, ::zx::vmo buffer);
      void Reply(::fidl::DecodedMessage<GetChunkHandleResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetChunkHandleCompleter = ::fidl::Completer<GetChunkHandleCompleterBase>;

    virtual void GetChunkHandle(uint32_t descriptor, uint32_t chunk_num, GetChunkHandleCompleter::Sync _completer) = 0;

    class FreeBufferCompleterBase : public _Base {
     public:
      void Reply();

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using FreeBufferCompleter = ::fidl::Completer<FreeBufferCompleterBase>;

    virtual void FreeBuffer(uint32_t descriptor, FreeBufferCompleter::Sync _completer) = 0;

    class StartCompleterBase : public _Base {
     public:
      void Reply();

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using StartCompleter = ::fidl::Completer<StartCompleterBase>;

    virtual void Start(StartCompleter::Sync _completer) = 0;

    class StopCompleterBase : public _Base {
     public:
      void Reply();

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using StopCompleter = ::fidl::Completer<StopCompleterBase>;

    virtual void Stop(StopCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void InitializeRequest(const ::fidl::DecodedMessage<Controller::InitializeRequest>& _msg);
    static void InitializeResponse(const ::fidl::DecodedMessage<Controller::InitializeResponse>& _msg);
    static void TerminateRequest(const ::fidl::DecodedMessage<Controller::TerminateRequest>& _msg);
    static void TerminateResponse(const ::fidl::DecodedMessage<Controller::TerminateResponse>& _msg);
    static void GetAllocationRequest(const ::fidl::DecodedMessage<Controller::GetAllocationRequest>& _msg);
    static void GetAllocationResponse(const ::fidl::DecodedMessage<Controller::GetAllocationResponse>& _msg);
    static void AllocateBufferRequest(const ::fidl::DecodedMessage<Controller::AllocateBufferRequest>& _msg);
    static void AllocateBufferResponse(const ::fidl::DecodedMessage<Controller::AllocateBufferResponse>& _msg);
    static void AssignThreadBufferRequest(const ::fidl::DecodedMessage<Controller::AssignThreadBufferRequest>& _msg);
    static void AssignThreadBufferResponse(const ::fidl::DecodedMessage<Controller::AssignThreadBufferResponse>& _msg);
    static void ReleaseThreadBufferRequest(const ::fidl::DecodedMessage<Controller::ReleaseThreadBufferRequest>& _msg);
    static void ReleaseThreadBufferResponse(const ::fidl::DecodedMessage<Controller::ReleaseThreadBufferResponse>& _msg);
    static void GetBufferConfigRequest(const ::fidl::DecodedMessage<Controller::GetBufferConfigRequest>& _msg);
    static void GetBufferConfigResponse(const ::fidl::DecodedMessage<Controller::GetBufferConfigResponse>& _msg);
    static void GetBufferStateRequest(const ::fidl::DecodedMessage<Controller::GetBufferStateRequest>& _msg);
    static void GetBufferStateResponse(const ::fidl::DecodedMessage<Controller::GetBufferStateResponse>& _msg);
    static void GetChunkHandleRequest(const ::fidl::DecodedMessage<Controller::GetChunkHandleRequest>& _msg);
    static void GetChunkHandleResponse(const ::fidl::DecodedMessage<Controller::GetChunkHandleResponse>& _msg);
    static void FreeBufferRequest(const ::fidl::DecodedMessage<Controller::FreeBufferRequest>& _msg);
    static void FreeBufferResponse(const ::fidl::DecodedMessage<Controller::FreeBufferResponse>& _msg);
    static void StartRequest(const ::fidl::DecodedMessage<Controller::StartRequest>& _msg);
    static void StartResponse(const ::fidl::DecodedMessage<Controller::StartResponse>& _msg);
    static void StopRequest(const ::fidl::DecodedMessage<Controller::StopRequest>& _msg);
    static void StopResponse(const ::fidl::DecodedMessage<Controller::StopResponse>& _msg);
  };
};

constexpr uint16_t API_VERSION = 0u;

}  // namespace insntrace
}  // namespace cpu
}  // namespace hardware
}  // namespace fuchsia
}  // namespace llcpp

namespace fidl {

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::cpu::insntrace::Allocation> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::cpu::insntrace::Allocation>);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Allocation, mode) == 0);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Allocation, num_traces) == 2);
static_assert(sizeof(::llcpp::fuchsia::hardware::cpu::insntrace::Allocation) == ::llcpp::fuchsia::hardware::cpu::insntrace::Allocation::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Terminate_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Terminate_Response>);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Terminate_Response, __reserved) == 0);
static_assert(sizeof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Terminate_Response) == ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Terminate_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Terminate_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Terminate_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::cpu::insntrace::Controller_ReleaseThreadBuffer_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::cpu::insntrace::Controller_ReleaseThreadBuffer_Response>);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_ReleaseThreadBuffer_Response, __reserved) == 0);
static_assert(sizeof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_ReleaseThreadBuffer_Response) == ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_ReleaseThreadBuffer_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::cpu::insntrace::Controller_ReleaseThreadBuffer_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::cpu::insntrace::Controller_ReleaseThreadBuffer_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Initialize_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Initialize_Response>);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Initialize_Response, __reserved) == 0);
static_assert(sizeof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Initialize_Response) == ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Initialize_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Initialize_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Initialize_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AssignThreadBuffer_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AssignThreadBuffer_Response>);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AssignThreadBuffer_Response, __reserved) == 0);
static_assert(sizeof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AssignThreadBuffer_Response) == ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AssignThreadBuffer_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AssignThreadBuffer_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AssignThreadBuffer_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::cpu::insntrace::BufferState> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::cpu::insntrace::BufferState>);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::BufferState, capture_end) == 0);
static_assert(sizeof(::llcpp::fuchsia::hardware::cpu::insntrace::BufferState) == ::llcpp::fuchsia::hardware::cpu::insntrace::BufferState::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AllocateBuffer_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AllocateBuffer_Response>);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AllocateBuffer_Response, descriptor) == 0);
static_assert(sizeof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AllocateBuffer_Response) == ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AllocateBuffer_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AllocateBuffer_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AllocateBuffer_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::cpu::insntrace::AddressRange> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::cpu::insntrace::AddressRange>);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::AddressRange, start) == 0);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::AddressRange, end) == 8);
static_assert(sizeof(::llcpp::fuchsia::hardware::cpu::insntrace::AddressRange) == ::llcpp::fuchsia::hardware::cpu::insntrace::AddressRange::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::cpu::insntrace::BufferConfig> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::cpu::insntrace::BufferConfig>);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::BufferConfig, num_chunks) == 0);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::BufferConfig, chunk_order) == 4);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::BufferConfig, is_circular) == 8);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::BufferConfig, ctl) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::BufferConfig, address_space_match) == 24);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::BufferConfig, address_range_0) == 32);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::BufferConfig, address_range_1) == 48);
static_assert(sizeof(::llcpp::fuchsia::hardware::cpu::insntrace::BufferConfig) == ::llcpp::fuchsia::hardware::cpu::insntrace::BufferConfig::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::cpu::insntrace::Controller::InitializeRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::cpu::insntrace::Controller::InitializeRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::InitializeRequest)
    == ::llcpp::fuchsia::hardware::cpu::insntrace::Controller::InitializeRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::InitializeRequest, allocation) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::cpu::insntrace::Controller::InitializeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::cpu::insntrace::Controller::InitializeResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::InitializeResponse)
    == ::llcpp::fuchsia::hardware::cpu::insntrace::Controller::InitializeResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::InitializeResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::cpu::insntrace::Controller::TerminateResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::cpu::insntrace::Controller::TerminateResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::TerminateResponse)
    == ::llcpp::fuchsia::hardware::cpu::insntrace::Controller::TerminateResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::TerminateResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetAllocationResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetAllocationResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetAllocationResponse)
    == ::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetAllocationResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetAllocationResponse, allocation) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::cpu::insntrace::Controller::AllocateBufferRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::cpu::insntrace::Controller::AllocateBufferRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::AllocateBufferRequest)
    == ::llcpp::fuchsia::hardware::cpu::insntrace::Controller::AllocateBufferRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::AllocateBufferRequest, config) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::cpu::insntrace::Controller::AllocateBufferResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::cpu::insntrace::Controller::AllocateBufferResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::AllocateBufferResponse)
    == ::llcpp::fuchsia::hardware::cpu::insntrace::Controller::AllocateBufferResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::AllocateBufferResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::cpu::insntrace::Controller::AssignThreadBufferRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::cpu::insntrace::Controller::AssignThreadBufferRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::AssignThreadBufferRequest)
    == ::llcpp::fuchsia::hardware::cpu::insntrace::Controller::AssignThreadBufferRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::AssignThreadBufferRequest, descriptor) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::AssignThreadBufferRequest, thread) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::cpu::insntrace::Controller::AssignThreadBufferResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::cpu::insntrace::Controller::AssignThreadBufferResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::AssignThreadBufferResponse)
    == ::llcpp::fuchsia::hardware::cpu::insntrace::Controller::AssignThreadBufferResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::AssignThreadBufferResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::cpu::insntrace::Controller::ReleaseThreadBufferRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::cpu::insntrace::Controller::ReleaseThreadBufferRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::ReleaseThreadBufferRequest)
    == ::llcpp::fuchsia::hardware::cpu::insntrace::Controller::ReleaseThreadBufferRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::ReleaseThreadBufferRequest, descriptor) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::ReleaseThreadBufferRequest, thread) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::cpu::insntrace::Controller::ReleaseThreadBufferResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::cpu::insntrace::Controller::ReleaseThreadBufferResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::ReleaseThreadBufferResponse)
    == ::llcpp::fuchsia::hardware::cpu::insntrace::Controller::ReleaseThreadBufferResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::ReleaseThreadBufferResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetBufferConfigRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetBufferConfigRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetBufferConfigRequest)
    == ::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetBufferConfigRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetBufferConfigRequest, descriptor) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetBufferConfigResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetBufferConfigResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetBufferConfigResponse)
    == ::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetBufferConfigResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetBufferConfigResponse, config) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetBufferStateRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetBufferStateRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetBufferStateRequest)
    == ::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetBufferStateRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetBufferStateRequest, descriptor) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetBufferStateResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetBufferStateResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetBufferStateResponse)
    == ::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetBufferStateResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetBufferStateResponse, state) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetChunkHandleRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetChunkHandleRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetChunkHandleRequest)
    == ::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetChunkHandleRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetChunkHandleRequest, descriptor) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetChunkHandleRequest, chunk_num) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetChunkHandleResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetChunkHandleResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetChunkHandleResponse)
    == ::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetChunkHandleResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::GetChunkHandleResponse, buffer) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::cpu::insntrace::Controller::FreeBufferRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::cpu::insntrace::Controller::FreeBufferRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::FreeBufferRequest)
    == ::llcpp::fuchsia::hardware::cpu::insntrace::Controller::FreeBufferRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller::FreeBufferRequest, descriptor) == 16);

}  // namespace fidl

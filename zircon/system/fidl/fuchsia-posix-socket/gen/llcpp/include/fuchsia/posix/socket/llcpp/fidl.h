// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/txn_header.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/connect_service.h>
#include <lib/fidl/llcpp/service_handler_interface.h>
#include <lib/fidl/llcpp/string_view.h>
#include <lib/fidl/llcpp/sync_call.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/fidl/llcpp/vector_view.h>
#include <lib/fit/function.h>
#include <lib/zx/channel.h>
#include <zircon/fidl.h>

#include <fuchsia/io/llcpp/fidl.h>

namespace llcpp {

namespace fuchsia {
namespace posix {
namespace socket {

struct BaseSocket_GetSockOpt_Response;
struct BaseSocket_GetSockOpt_Result;
struct DatagramSocket_RecvMsg_Response;
struct DatagramSocket_RecvMsg_Result;
struct BaseSocket_GetSockName_Response;
struct BaseSocket_GetSockName_Result;
struct BaseSocket_GetPeerName_Response;
struct BaseSocket_GetPeerName_Result;
struct StreamSocket_Listen_Response;
struct StreamSocket_Listen_Result;
struct StreamSocket_Accept_Response;
struct StreamSocket_Accept_Result;
struct Provider_Socket2_Response;
struct Provider_Socket2_Result;
class Provider;
struct DatagramSocket_Shutdown_Response;
struct DatagramSocket_Shutdown_Result;
struct DatagramSocket_SendMsg_Response;
struct DatagramSocket_SendMsg_Result;
struct BaseSocket_SetSockOpt_Response;
struct BaseSocket_SetSockOpt_Result;
struct BaseSocket_Connect_Response;
struct BaseSocket_Connect_Result;
struct BaseSocket_Bind_Response;
struct BaseSocket_Bind_Result;
class Control;
class BaseSocket;
class StreamSocket;
class DatagramSocket;

extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocket_GetSockOpt_ResultTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocket_GetSockOpt_ResultTable;

struct BaseSocket_GetSockOpt_Result {
  BaseSocket_GetSockOpt_Result() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal() == Ordinal::kResponse; }

  static BaseSocket_GetSockOpt_Result WithResponse(::llcpp::fuchsia::posix::socket::BaseSocket_GetSockOpt_Response* val) {
    BaseSocket_GetSockOpt_Result result;
    result.set_response(val);
    return result;
  }

  void set_response(::llcpp::fuchsia::posix::socket::BaseSocket_GetSockOpt_Response* elem) {
    ordinal_ = Ordinal::kResponse;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::posix::socket::BaseSocket_GetSockOpt_Response& mutable_response() {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::posix::socket::BaseSocket_GetSockOpt_Response*>(envelope_.data);
  }
  const ::llcpp::fuchsia::posix::socket::BaseSocket_GetSockOpt_Response& response() const {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::posix::socket::BaseSocket_GetSockOpt_Response*>(envelope_.data);
  }

  bool is_err() const { return ordinal() == Ordinal::kErr; }

  static BaseSocket_GetSockOpt_Result WithErr(int32_t* val) {
    BaseSocket_GetSockOpt_Result result;
    result.set_err(val);
    return result;
  }

  void set_err(int32_t* elem) {
    ordinal_ = Ordinal::kErr;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_err() {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_BaseSocket_GetSockOpt_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 920;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocket_RecvMsg_ResultTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocket_RecvMsg_ResultTable;

struct DatagramSocket_RecvMsg_Result {
  DatagramSocket_RecvMsg_Result() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal() == Ordinal::kResponse; }

  static DatagramSocket_RecvMsg_Result WithResponse(::llcpp::fuchsia::posix::socket::DatagramSocket_RecvMsg_Response* val) {
    DatagramSocket_RecvMsg_Result result;
    result.set_response(val);
    return result;
  }

  void set_response(::llcpp::fuchsia::posix::socket::DatagramSocket_RecvMsg_Response* elem) {
    ordinal_ = Ordinal::kResponse;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::posix::socket::DatagramSocket_RecvMsg_Response& mutable_response() {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::posix::socket::DatagramSocket_RecvMsg_Response*>(envelope_.data);
  }
  const ::llcpp::fuchsia::posix::socket::DatagramSocket_RecvMsg_Response& response() const {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::posix::socket::DatagramSocket_RecvMsg_Response*>(envelope_.data);
  }

  bool is_err() const { return ordinal() == Ordinal::kErr; }

  static DatagramSocket_RecvMsg_Result WithErr(int32_t* val) {
    DatagramSocket_RecvMsg_Result result;
    result.set_err(val);
    return result;
  }

  void set_err(int32_t* elem) {
    ordinal_ = Ordinal::kErr;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_err() {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_DatagramSocket_RecvMsg_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocket_GetSockName_ResultTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocket_GetSockName_ResultTable;

struct BaseSocket_GetSockName_Result {
  BaseSocket_GetSockName_Result() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal() == Ordinal::kResponse; }

  static BaseSocket_GetSockName_Result WithResponse(::llcpp::fuchsia::posix::socket::BaseSocket_GetSockName_Response* val) {
    BaseSocket_GetSockName_Result result;
    result.set_response(val);
    return result;
  }

  void set_response(::llcpp::fuchsia::posix::socket::BaseSocket_GetSockName_Response* elem) {
    ordinal_ = Ordinal::kResponse;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::posix::socket::BaseSocket_GetSockName_Response& mutable_response() {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::posix::socket::BaseSocket_GetSockName_Response*>(envelope_.data);
  }
  const ::llcpp::fuchsia::posix::socket::BaseSocket_GetSockName_Response& response() const {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::posix::socket::BaseSocket_GetSockName_Response*>(envelope_.data);
  }

  bool is_err() const { return ordinal() == Ordinal::kErr; }

  static BaseSocket_GetSockName_Result WithErr(int32_t* val) {
    BaseSocket_GetSockName_Result result;
    result.set_err(val);
    return result;
  }

  void set_err(int32_t* elem) {
    ordinal_ = Ordinal::kErr;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_err() {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_BaseSocket_GetSockName_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 144;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocket_GetPeerName_ResultTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocket_GetPeerName_ResultTable;

struct BaseSocket_GetPeerName_Result {
  BaseSocket_GetPeerName_Result() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal() == Ordinal::kResponse; }

  static BaseSocket_GetPeerName_Result WithResponse(::llcpp::fuchsia::posix::socket::BaseSocket_GetPeerName_Response* val) {
    BaseSocket_GetPeerName_Result result;
    result.set_response(val);
    return result;
  }

  void set_response(::llcpp::fuchsia::posix::socket::BaseSocket_GetPeerName_Response* elem) {
    ordinal_ = Ordinal::kResponse;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::posix::socket::BaseSocket_GetPeerName_Response& mutable_response() {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::posix::socket::BaseSocket_GetPeerName_Response*>(envelope_.data);
  }
  const ::llcpp::fuchsia::posix::socket::BaseSocket_GetPeerName_Response& response() const {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::posix::socket::BaseSocket_GetPeerName_Response*>(envelope_.data);
  }

  bool is_err() const { return ordinal() == Ordinal::kErr; }

  static BaseSocket_GetPeerName_Result WithErr(int32_t* val) {
    BaseSocket_GetPeerName_Result result;
    result.set_err(val);
    return result;
  }

  void set_err(int32_t* elem) {
    ordinal_ = Ordinal::kErr;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_err() {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_BaseSocket_GetPeerName_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 144;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocket_Listen_ResultTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocket_Listen_ResultTable;

struct StreamSocket_Listen_Result {
  StreamSocket_Listen_Result() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal() == Ordinal::kResponse; }

  static StreamSocket_Listen_Result WithResponse(::llcpp::fuchsia::posix::socket::StreamSocket_Listen_Response* val) {
    StreamSocket_Listen_Result result;
    result.set_response(val);
    return result;
  }

  void set_response(::llcpp::fuchsia::posix::socket::StreamSocket_Listen_Response* elem) {
    ordinal_ = Ordinal::kResponse;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::posix::socket::StreamSocket_Listen_Response& mutable_response() {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::posix::socket::StreamSocket_Listen_Response*>(envelope_.data);
  }
  const ::llcpp::fuchsia::posix::socket::StreamSocket_Listen_Response& response() const {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::posix::socket::StreamSocket_Listen_Response*>(envelope_.data);
  }

  bool is_err() const { return ordinal() == Ordinal::kErr; }

  static StreamSocket_Listen_Result WithErr(int32_t* val) {
    StreamSocket_Listen_Result result;
    result.set_err(val);
    return result;
  }

  void set_err(int32_t* elem) {
    ordinal_ = Ordinal::kErr;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_err() {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_StreamSocket_Listen_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocket_Accept_ResultTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocket_Accept_ResultTable;

struct StreamSocket_Accept_Result {
  StreamSocket_Accept_Result() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal() == Ordinal::kResponse; }

  static StreamSocket_Accept_Result WithResponse(::llcpp::fuchsia::posix::socket::StreamSocket_Accept_Response* val) {
    StreamSocket_Accept_Result result;
    result.set_response(val);
    return result;
  }

  void set_response(::llcpp::fuchsia::posix::socket::StreamSocket_Accept_Response* elem) {
    ordinal_ = Ordinal::kResponse;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::posix::socket::StreamSocket_Accept_Response& mutable_response() {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::posix::socket::StreamSocket_Accept_Response*>(envelope_.data);
  }
  const ::llcpp::fuchsia::posix::socket::StreamSocket_Accept_Response& response() const {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::posix::socket::StreamSocket_Accept_Response*>(envelope_.data);
  }

  bool is_err() const { return ordinal() == Ordinal::kErr; }

  static StreamSocket_Accept_Result WithErr(int32_t* val) {
    StreamSocket_Accept_Result result;
    result.set_err(val);
    return result;
  }

  void set_err(int32_t* elem) {
    ordinal_ = Ordinal::kErr;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_err() {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_StreamSocket_Accept_ResultTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t fuchsia_posix_socket_Provider_Socket2_ResultTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_Provider_Socket2_ResultTable;

struct Provider_Socket2_Result {
  Provider_Socket2_Result() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal() == Ordinal::kResponse; }

  static Provider_Socket2_Result WithResponse(::llcpp::fuchsia::posix::socket::Provider_Socket2_Response* val) {
    Provider_Socket2_Result result;
    result.set_response(val);
    return result;
  }

  void set_response(::llcpp::fuchsia::posix::socket::Provider_Socket2_Response* elem) {
    ordinal_ = Ordinal::kResponse;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::posix::socket::Provider_Socket2_Response& mutable_response() {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::posix::socket::Provider_Socket2_Response*>(envelope_.data);
  }
  const ::llcpp::fuchsia::posix::socket::Provider_Socket2_Response& response() const {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::posix::socket::Provider_Socket2_Response*>(envelope_.data);
  }

  bool is_err() const { return ordinal() == Ordinal::kErr; }

  static Provider_Socket2_Result WithErr(int32_t* val) {
    Provider_Socket2_Result result;
    result.set_err(val);
    return result;
  }

  void set_err(int32_t* elem) {
    ordinal_ = Ordinal::kErr;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_err() {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_Provider_Socket2_ResultTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocket_Shutdown_ResultTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocket_Shutdown_ResultTable;

struct DatagramSocket_Shutdown_Result {
  DatagramSocket_Shutdown_Result() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal() == Ordinal::kResponse; }

  static DatagramSocket_Shutdown_Result WithResponse(::llcpp::fuchsia::posix::socket::DatagramSocket_Shutdown_Response* val) {
    DatagramSocket_Shutdown_Result result;
    result.set_response(val);
    return result;
  }

  void set_response(::llcpp::fuchsia::posix::socket::DatagramSocket_Shutdown_Response* elem) {
    ordinal_ = Ordinal::kResponse;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::posix::socket::DatagramSocket_Shutdown_Response& mutable_response() {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::posix::socket::DatagramSocket_Shutdown_Response*>(envelope_.data);
  }
  const ::llcpp::fuchsia::posix::socket::DatagramSocket_Shutdown_Response& response() const {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::posix::socket::DatagramSocket_Shutdown_Response*>(envelope_.data);
  }

  bool is_err() const { return ordinal() == Ordinal::kErr; }

  static DatagramSocket_Shutdown_Result WithErr(int32_t* val) {
    DatagramSocket_Shutdown_Result result;
    result.set_err(val);
    return result;
  }

  void set_err(int32_t* elem) {
    ordinal_ = Ordinal::kErr;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_err() {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_DatagramSocket_Shutdown_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocket_SendMsg_ResultTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocket_SendMsg_ResultTable;

struct DatagramSocket_SendMsg_Result {
  DatagramSocket_SendMsg_Result() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal() == Ordinal::kResponse; }

  static DatagramSocket_SendMsg_Result WithResponse(::llcpp::fuchsia::posix::socket::DatagramSocket_SendMsg_Response* val) {
    DatagramSocket_SendMsg_Result result;
    result.set_response(val);
    return result;
  }

  void set_response(::llcpp::fuchsia::posix::socket::DatagramSocket_SendMsg_Response* elem) {
    ordinal_ = Ordinal::kResponse;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::posix::socket::DatagramSocket_SendMsg_Response& mutable_response() {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::posix::socket::DatagramSocket_SendMsg_Response*>(envelope_.data);
  }
  const ::llcpp::fuchsia::posix::socket::DatagramSocket_SendMsg_Response& response() const {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::posix::socket::DatagramSocket_SendMsg_Response*>(envelope_.data);
  }

  bool is_err() const { return ordinal() == Ordinal::kErr; }

  static DatagramSocket_SendMsg_Result WithErr(int32_t* val) {
    DatagramSocket_SendMsg_Result result;
    result.set_err(val);
    return result;
  }

  void set_err(int32_t* elem) {
    ordinal_ = Ordinal::kErr;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_err() {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_DatagramSocket_SendMsg_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocket_SetSockOpt_ResultTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocket_SetSockOpt_ResultTable;

struct BaseSocket_SetSockOpt_Result {
  BaseSocket_SetSockOpt_Result() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal() == Ordinal::kResponse; }

  static BaseSocket_SetSockOpt_Result WithResponse(::llcpp::fuchsia::posix::socket::BaseSocket_SetSockOpt_Response* val) {
    BaseSocket_SetSockOpt_Result result;
    result.set_response(val);
    return result;
  }

  void set_response(::llcpp::fuchsia::posix::socket::BaseSocket_SetSockOpt_Response* elem) {
    ordinal_ = Ordinal::kResponse;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::posix::socket::BaseSocket_SetSockOpt_Response& mutable_response() {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::posix::socket::BaseSocket_SetSockOpt_Response*>(envelope_.data);
  }
  const ::llcpp::fuchsia::posix::socket::BaseSocket_SetSockOpt_Response& response() const {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::posix::socket::BaseSocket_SetSockOpt_Response*>(envelope_.data);
  }

  bool is_err() const { return ordinal() == Ordinal::kErr; }

  static BaseSocket_SetSockOpt_Result WithErr(int32_t* val) {
    BaseSocket_SetSockOpt_Result result;
    result.set_err(val);
    return result;
  }

  void set_err(int32_t* elem) {
    ordinal_ = Ordinal::kErr;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_err() {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_BaseSocket_SetSockOpt_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocket_Connect_ResultTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocket_Connect_ResultTable;

struct BaseSocket_Connect_Result {
  BaseSocket_Connect_Result() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal() == Ordinal::kResponse; }

  static BaseSocket_Connect_Result WithResponse(::llcpp::fuchsia::posix::socket::BaseSocket_Connect_Response* val) {
    BaseSocket_Connect_Result result;
    result.set_response(val);
    return result;
  }

  void set_response(::llcpp::fuchsia::posix::socket::BaseSocket_Connect_Response* elem) {
    ordinal_ = Ordinal::kResponse;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::posix::socket::BaseSocket_Connect_Response& mutable_response() {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::posix::socket::BaseSocket_Connect_Response*>(envelope_.data);
  }
  const ::llcpp::fuchsia::posix::socket::BaseSocket_Connect_Response& response() const {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::posix::socket::BaseSocket_Connect_Response*>(envelope_.data);
  }

  bool is_err() const { return ordinal() == Ordinal::kErr; }

  static BaseSocket_Connect_Result WithErr(int32_t* val) {
    BaseSocket_Connect_Result result;
    result.set_err(val);
    return result;
  }

  void set_err(int32_t* elem) {
    ordinal_ = Ordinal::kErr;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_err() {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_BaseSocket_Connect_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocket_Bind_ResultTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocket_Bind_ResultTable;

struct BaseSocket_Bind_Result {
  BaseSocket_Bind_Result() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal() == Ordinal::kResponse; }

  static BaseSocket_Bind_Result WithResponse(::llcpp::fuchsia::posix::socket::BaseSocket_Bind_Response* val) {
    BaseSocket_Bind_Result result;
    result.set_response(val);
    return result;
  }

  void set_response(::llcpp::fuchsia::posix::socket::BaseSocket_Bind_Response* elem) {
    ordinal_ = Ordinal::kResponse;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::posix::socket::BaseSocket_Bind_Response& mutable_response() {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::posix::socket::BaseSocket_Bind_Response*>(envelope_.data);
  }
  const ::llcpp::fuchsia::posix::socket::BaseSocket_Bind_Response& response() const {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::posix::socket::BaseSocket_Bind_Response*>(envelope_.data);
  }

  bool is_err() const { return ordinal() == Ordinal::kErr; }

  static BaseSocket_Bind_Result WithErr(int32_t* val) {
    BaseSocket_Bind_Result result;
    result.set_err(val);
    return result;
  }

  void set_err(int32_t* elem) {
    ordinal_ = Ordinal::kErr;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_err() {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_BaseSocket_Bind_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocket_GetSockOpt_ResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocket_GetSockOpt_ResponseTable;

struct BaseSocket_GetSockOpt_Response {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_BaseSocket_GetSockOpt_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 904;

  ::fidl::VectorView<uint8_t> optval = {};
};

extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocket_RecvMsg_ResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocket_RecvMsg_ResponseTable;

struct DatagramSocket_RecvMsg_Response {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_DatagramSocket_RecvMsg_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 56;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;

  ::fidl::VectorView<uint8_t> addr = {};

  ::fidl::VectorView<uint8_t> data = {};

  ::fidl::VectorView<uint8_t> control = {};

  uint32_t truncated = {};
};

extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocket_GetSockName_ResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocket_GetSockName_ResponseTable;

struct BaseSocket_GetSockName_Response {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_BaseSocket_GetSockName_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 128;

  ::fidl::VectorView<uint8_t> addr = {};
};

extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocket_GetPeerName_ResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocket_GetPeerName_ResponseTable;

struct BaseSocket_GetPeerName_Response {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_BaseSocket_GetPeerName_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 128;

  ::fidl::VectorView<uint8_t> addr = {};
};

extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocket_Listen_ResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocket_Listen_ResponseTable;

struct StreamSocket_Listen_Response {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_StreamSocket_Listen_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  uint8_t __reserved = {};
};

extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocket_Accept_ResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocket_Accept_ResponseTable;

struct StreamSocket_Accept_Response {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_StreamSocket_Accept_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  ::zx::channel s = {};
};

extern "C" const fidl_type_t fuchsia_posix_socket_Provider_Socket2_ResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_Provider_Socket2_ResponseTable;

struct Provider_Socket2_Response {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_Provider_Socket2_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  ::zx::channel s = {};
};

extern "C" const fidl_type_t fuchsia_posix_socket_ProviderSocketRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ProviderSocketRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ProviderSocketResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ProviderSocketResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ProviderSocket2RequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ProviderSocket2RequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ProviderSocket2ResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ProviderSocket2ResponseTable;

// Provider implements the POSIX sockets API.
class Provider final {
  Provider() = delete;
 public:
  static constexpr char Name[] = "fuchsia.posix.socket.Provider";

  struct SocketResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;
    ::zx::channel s;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_ProviderSocketResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_ProviderSocketResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SocketRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t domain;
    int16_t type;
    int16_t protocol;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_ProviderSocketRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_ProviderSocketRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SocketResponse;
  };

  struct Socket2Response final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::posix::socket::Provider_Socket2_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_ProviderSocket2ResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_ProviderSocket2ResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct Socket2Request final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t domain;
    int16_t type;
    int16_t protocol;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_ProviderSocket2RequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_ProviderSocket2RequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = Socket2Response;
  };


  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    template <typename ResponseType>
    class Socket_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Socket_Impl(::zx::unowned_channel _client_end, int16_t domain, int16_t type, int16_t protocol);
      ~Socket_Impl() = default;
      Socket_Impl(Socket_Impl&& other) = default;
      Socket_Impl& operator=(Socket_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Socket2_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Socket2_Impl(::zx::unowned_channel _client_end, int16_t domain, int16_t type, int16_t protocol);
      ~Socket2_Impl() = default;
      Socket2_Impl(Socket2_Impl&& other) = default;
      Socket2_Impl& operator=(Socket2_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Socket = Socket_Impl<SocketResponse>;
    using Socket2 = Socket2_Impl<Socket2Response>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    template <typename ResponseType>
    class Socket_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Socket_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t domain, int16_t type, int16_t protocol, ::fidl::BytePart _response_buffer);
      ~Socket_Impl() = default;
      Socket_Impl(Socket_Impl&& other) = default;
      Socket_Impl& operator=(Socket_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Socket2_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Socket2_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t domain, int16_t type, int16_t protocol, ::fidl::BytePart _response_buffer);
      ~Socket2_Impl() = default;
      Socket2_Impl(Socket2_Impl&& other) = default;
      Socket2_Impl& operator=(Socket2_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Socket = Socket_Impl<SocketResponse>;
    using Socket2 = Socket2_Impl<Socket2Response>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Requests a socket with the specified parameters. Values for `code` are defined in errno.h.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Socket Socket(int16_t domain, int16_t type, int16_t protocol);

    // Requests a socket with the specified parameters. Values for `code` are defined in errno.h.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Socket Socket(::fidl::BytePart _request_buffer, int16_t domain, int16_t type, int16_t protocol, ::fidl::BytePart _response_buffer);

    // Requests a socket with the specified parameters. Error values are defined in errno.h.
    // Allocates 56 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Socket2 Socket2(int16_t domain, int16_t type, int16_t protocol);

    // Requests a socket with the specified parameters. Error values are defined in errno.h.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Socket2 Socket2(::fidl::BytePart _request_buffer, int16_t domain, int16_t type, int16_t protocol, ::fidl::BytePart _response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Requests a socket with the specified parameters. Values for `code` are defined in errno.h.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Socket Socket(::zx::unowned_channel _client_end, int16_t domain, int16_t type, int16_t protocol);

    // Requests a socket with the specified parameters. Values for `code` are defined in errno.h.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Socket Socket(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t domain, int16_t type, int16_t protocol, ::fidl::BytePart _response_buffer);

    // Requests a socket with the specified parameters. Error values are defined in errno.h.
    // Allocates 56 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Socket2 Socket2(::zx::unowned_channel _client_end, int16_t domain, int16_t type, int16_t protocol);

    // Requests a socket with the specified parameters. Error values are defined in errno.h.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Socket2 Socket2(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t domain, int16_t type, int16_t protocol, ::fidl::BytePart _response_buffer);

  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Requests a socket with the specified parameters. Values for `code` are defined in errno.h.
    static ::fidl::DecodeResult<SocketResponse> Socket(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SocketRequest> params, ::fidl::BytePart response_buffer);

    // Requests a socket with the specified parameters. Error values are defined in errno.h.
    static ::fidl::DecodeResult<Socket2Response> Socket2(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<Socket2Request> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Provider;
    using _Base = ::fidl::CompleterBase;

    class SocketCompleterBase : public _Base {
     public:
      void Reply(int16_t code, ::zx::channel s);
      void Reply(::fidl::BytePart _buffer, int16_t code, ::zx::channel s);
      void Reply(::fidl::DecodedMessage<SocketResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SocketCompleter = ::fidl::Completer<SocketCompleterBase>;

    virtual void Socket(int16_t domain, int16_t type, int16_t protocol, SocketCompleter::Sync _completer) = 0;

    class Socket2CompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::posix::socket::Provider_Socket2_Result result);
      void ReplySuccess(::zx::channel s);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::posix::socket::Provider_Socket2_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, ::zx::channel s);
      void Reply(::fidl::DecodedMessage<Socket2Response> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using Socket2Completer = ::fidl::Completer<Socket2CompleterBase>;

    virtual void Socket2(int16_t domain, int16_t type, int16_t protocol, Socket2Completer::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void SocketRequest(const ::fidl::DecodedMessage<Provider::SocketRequest>& _msg);
    static void SocketResponse(const ::fidl::DecodedMessage<Provider::SocketResponse>& _msg);
    static void Socket2Request(const ::fidl::DecodedMessage<Provider::Socket2Request>& _msg);
    static void Socket2Response(const ::fidl::DecodedMessage<Provider::Socket2Response>& _msg);
  };
};

extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocket_Shutdown_ResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocket_Shutdown_ResponseTable;

struct DatagramSocket_Shutdown_Response {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_DatagramSocket_Shutdown_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  uint8_t __reserved = {};
};

extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocket_SendMsg_ResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocket_SendMsg_ResponseTable;

struct DatagramSocket_SendMsg_Response {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_DatagramSocket_SendMsg_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  int64_t len = {};
};

extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocket_SetSockOpt_ResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocket_SetSockOpt_ResponseTable;

struct BaseSocket_SetSockOpt_Response {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_BaseSocket_SetSockOpt_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  uint8_t __reserved = {};
};

extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocket_Connect_ResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocket_Connect_ResponseTable;

struct BaseSocket_Connect_Response {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_BaseSocket_Connect_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  uint8_t __reserved = {};
};

extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocket_Bind_ResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocket_Bind_ResponseTable;

struct BaseSocket_Bind_Response {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_BaseSocket_Bind_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  uint8_t __reserved = {};
};

extern "C" const fidl_type_t fuchsia_posix_socket_ControlCloneRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlCloneRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlCloneResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlCloneResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlCloseRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlCloseRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlCloseResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlCloseResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlDescribeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlDescribeRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlDescribeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlDescribeResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlOnOpenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlOnOpenRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlOnOpenEventTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlOnOpenEventTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlSyncRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlSyncRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlSyncResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlSyncResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlGetAttrRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlGetAttrRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlGetAttrResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlGetAttrResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlSetAttrRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlSetAttrRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlSetAttrResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlSetAttrResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlNodeGetFlagsRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlNodeGetFlagsRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlNodeGetFlagsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlNodeGetFlagsResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlNodeSetFlagsRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlNodeSetFlagsRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlNodeSetFlagsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlNodeSetFlagsResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlBindRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlBindRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlBindResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlBindResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlConnectRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlConnectRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlConnectResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlConnectResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlListenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlListenRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlListenResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlListenResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlAcceptRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlAcceptRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlAcceptResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlAcceptResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlGetSockNameRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlGetSockNameRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlGetSockNameResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlGetSockNameResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlGetPeerNameRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlGetPeerNameRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlGetPeerNameResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlGetPeerNameResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlSetSockOptRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlSetSockOptRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlSetSockOptResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlSetSockOptResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlGetSockOptRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlGetSockOptRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlGetSockOptResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlGetSockOptResponseTable;

// The control plane for a network socket.
//
// Once a socket has been retrieved from a `Provider`, this interface is then used to further
// configure and use the socket. This interface is essentially POSIX. Its implementation must
// support Linux-specific arguments to {Get,Set}SockOpt.
//
// *Warning:* This protocol is not yet ready for direct use by clients. Instead, clients should
// use the BSD sockets API to interact with sockets. We plan to change this protocol substantially
// and clients that couple directly to this protocol will make those changes more difficult.
class Control final {
  Control() = delete;
 public:

  struct CloneRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;
    ::zx::channel object;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_ControlCloneRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_ControlCloneRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct CloseResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_ControlCloseResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_ControlCloseResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using CloseRequest = ::fidl::AnyZeroArgMessage;

  struct DescribeResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io::NodeInfo info;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_ControlDescribeResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_ControlDescribeResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 24;
    static constexpr uint32_t AltPrimarySize = 48;
    static constexpr uint32_t AltMaxOutOfLine = 24;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using DescribeRequest = ::fidl::AnyZeroArgMessage;

  struct OnOpenResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::llcpp::fuchsia::io::NodeInfo info;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_ControlOnOpenEventTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_ControlOnOpenEventTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 24;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 24;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SyncResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_ControlSyncResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_ControlSyncResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using SyncRequest = ::fidl::AnyZeroArgMessage;

  struct GetAttrResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::llcpp::fuchsia::io::NodeAttributes attributes;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_ControlGetAttrResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_ControlGetAttrResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 80;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 80;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetAttrRequest = ::fidl::AnyZeroArgMessage;

  struct SetAttrResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_ControlSetAttrResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_ControlSetAttrResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SetAttrRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;
    ::llcpp::fuchsia::io::NodeAttributes attributes;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_ControlSetAttrRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_ControlSetAttrRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 80;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 80;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SetAttrResponse;
  };

  struct NodeGetFlagsResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    uint32_t flags;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_ControlNodeGetFlagsResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_ControlNodeGetFlagsResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using NodeGetFlagsRequest = ::fidl::AnyZeroArgMessage;

  struct NodeSetFlagsResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_ControlNodeSetFlagsResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_ControlNodeSetFlagsResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct NodeSetFlagsRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_ControlNodeSetFlagsRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_ControlNodeSetFlagsRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = NodeSetFlagsResponse;
  };

  struct BindResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_ControlBindResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_ControlBindResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct BindRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::VectorView<uint8_t> addr;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_ControlBindRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_ControlBindRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 128;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 128;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = BindResponse;
  };

  struct ConnectResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_ControlConnectResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_ControlConnectResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct ConnectRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::VectorView<uint8_t> addr;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_ControlConnectRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_ControlConnectRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 128;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 128;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = ConnectResponse;
  };

  struct ListenResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_ControlListenResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_ControlListenResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct ListenRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t backlog;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_ControlListenRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_ControlListenRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = ListenResponse;
  };

  struct AcceptResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;
    ::zx::channel s;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_ControlAcceptResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_ControlAcceptResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct AcceptRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t flags;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_ControlAcceptRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_ControlAcceptRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = AcceptResponse;
  };

  struct GetSockNameResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;
    ::fidl::VectorView<uint8_t> addr;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_ControlGetSockNameResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_ControlGetSockNameResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 128;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 128;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetSockNameRequest = ::fidl::AnyZeroArgMessage;

  struct GetPeerNameResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;
    ::fidl::VectorView<uint8_t> addr;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_ControlGetPeerNameResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_ControlGetPeerNameResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 128;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 128;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetPeerNameRequest = ::fidl::AnyZeroArgMessage;

  struct SetSockOptResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_ControlSetSockOptResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_ControlSetSockOptResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SetSockOptRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t level;
    int16_t optname;
    ::fidl::VectorView<uint8_t> optval;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_ControlSetSockOptRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_ControlSetSockOptRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 904;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 904;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SetSockOptResponse;
  };

  struct GetSockOptResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;
    ::fidl::VectorView<uint8_t> optval;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_ControlGetSockOptResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_ControlGetSockOptResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 904;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 904;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct GetSockOptRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t level;
    int16_t optname;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_ControlGetSockOptRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_ControlGetSockOptRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = GetSockOptResponse;
  };


  struct EventHandlers {
    // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
    //
    // Indicates the success or failure of the open operation, and optionally describes the
    // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
    // (the same as would be returned by `Describe`).
    fit::callback<zx_status_t(int32_t s, ::llcpp::fuchsia::io::NodeInfo info)> on_open;

    // Fallback handler when an unknown ordinal is received.
    // Caller may put custom error handling logic here.
    fit::callback<zx_status_t()> unknown;
  };

  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    class Clone_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Clone_Impl(::zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object);
      ~Clone_Impl() = default;
      Clone_Impl(Clone_Impl&& other) = default;
      Clone_Impl& operator=(Clone_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class Close_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Close_Impl(::zx::unowned_channel _client_end);
      ~Close_Impl() = default;
      Close_Impl(Close_Impl&& other) = default;
      Close_Impl& operator=(Close_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Describe_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Describe_Impl(::zx::unowned_channel _client_end);
      ~Describe_Impl() = default;
      Describe_Impl(Describe_Impl&& other) = default;
      Describe_Impl& operator=(Describe_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Sync_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Sync_Impl(::zx::unowned_channel _client_end);
      ~Sync_Impl() = default;
      Sync_Impl(Sync_Impl&& other) = default;
      Sync_Impl& operator=(Sync_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetAttr_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetAttr_Impl(::zx::unowned_channel _client_end);
      ~GetAttr_Impl() = default;
      GetAttr_Impl(GetAttr_Impl&& other) = default;
      GetAttr_Impl& operator=(GetAttr_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetAttr_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      SetAttr_Impl(::zx::unowned_channel _client_end, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes);
      ~SetAttr_Impl() = default;
      SetAttr_Impl(SetAttr_Impl&& other) = default;
      SetAttr_Impl& operator=(SetAttr_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class NodeGetFlags_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      NodeGetFlags_Impl(::zx::unowned_channel _client_end);
      ~NodeGetFlags_Impl() = default;
      NodeGetFlags_Impl(NodeGetFlags_Impl&& other) = default;
      NodeGetFlags_Impl& operator=(NodeGetFlags_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class NodeSetFlags_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      NodeSetFlags_Impl(::zx::unowned_channel _client_end, uint32_t flags);
      ~NodeSetFlags_Impl() = default;
      NodeSetFlags_Impl(NodeSetFlags_Impl&& other) = default;
      NodeSetFlags_Impl& operator=(NodeSetFlags_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Bind_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Bind_Impl(::zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> addr);
      ~Bind_Impl() = default;
      Bind_Impl(Bind_Impl&& other) = default;
      Bind_Impl& operator=(Bind_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Connect_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Connect_Impl(::zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> addr);
      ~Connect_Impl() = default;
      Connect_Impl(Connect_Impl&& other) = default;
      Connect_Impl& operator=(Connect_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Listen_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Listen_Impl(::zx::unowned_channel _client_end, int16_t backlog);
      ~Listen_Impl() = default;
      Listen_Impl(Listen_Impl&& other) = default;
      Listen_Impl& operator=(Listen_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Accept_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Accept_Impl(::zx::unowned_channel _client_end, int16_t flags);
      ~Accept_Impl() = default;
      Accept_Impl(Accept_Impl&& other) = default;
      Accept_Impl& operator=(Accept_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetSockName_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetSockName_Impl(::zx::unowned_channel _client_end);
      ~GetSockName_Impl() = default;
      GetSockName_Impl(GetSockName_Impl&& other) = default;
      GetSockName_Impl& operator=(GetSockName_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetPeerName_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetPeerName_Impl(::zx::unowned_channel _client_end);
      ~GetPeerName_Impl() = default;
      GetPeerName_Impl(GetPeerName_Impl&& other) = default;
      GetPeerName_Impl& operator=(GetPeerName_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetSockOpt_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      SetSockOpt_Impl(::zx::unowned_channel _client_end, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval);
      ~SetSockOpt_Impl() = default;
      SetSockOpt_Impl(SetSockOpt_Impl&& other) = default;
      SetSockOpt_Impl& operator=(SetSockOpt_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetSockOpt_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetSockOpt_Impl(::zx::unowned_channel _client_end, int16_t level, int16_t optname);
      ~GetSockOpt_Impl() = default;
      GetSockOpt_Impl(GetSockOpt_Impl&& other) = default;
      GetSockOpt_Impl& operator=(GetSockOpt_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Clone = Clone_Impl;
    using Close = Close_Impl<CloseResponse>;
    using Describe = Describe_Impl<DescribeResponse>;
    using Sync = Sync_Impl<SyncResponse>;
    using GetAttr = GetAttr_Impl<GetAttrResponse>;
    using SetAttr = SetAttr_Impl<SetAttrResponse>;
    using NodeGetFlags = NodeGetFlags_Impl<NodeGetFlagsResponse>;
    using NodeSetFlags = NodeSetFlags_Impl<NodeSetFlagsResponse>;
    using Bind = Bind_Impl<BindResponse>;
    using Connect = Connect_Impl<ConnectResponse>;
    using Listen = Listen_Impl<ListenResponse>;
    using Accept = Accept_Impl<AcceptResponse>;
    using GetSockName = GetSockName_Impl<GetSockNameResponse>;
    using GetPeerName = GetPeerName_Impl<GetPeerNameResponse>;
    using SetSockOpt = SetSockOpt_Impl<SetSockOptResponse>;
    using GetSockOpt = GetSockOpt_Impl<GetSockOptResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    class Clone_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Clone_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);
      ~Clone_Impl() = default;
      Clone_Impl(Clone_Impl&& other) = default;
      Clone_Impl& operator=(Clone_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class Close_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Close_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Close_Impl() = default;
      Close_Impl(Close_Impl&& other) = default;
      Close_Impl& operator=(Close_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Describe_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Describe_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Describe_Impl() = default;
      Describe_Impl(Describe_Impl&& other) = default;
      Describe_Impl& operator=(Describe_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Sync_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Sync_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Sync_Impl() = default;
      Sync_Impl(Sync_Impl&& other) = default;
      Sync_Impl& operator=(Sync_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetAttr_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetAttr_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetAttr_Impl() = default;
      GetAttr_Impl(GetAttr_Impl&& other) = default;
      GetAttr_Impl& operator=(GetAttr_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetAttr_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      SetAttr_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer);
      ~SetAttr_Impl() = default;
      SetAttr_Impl(SetAttr_Impl&& other) = default;
      SetAttr_Impl& operator=(SetAttr_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class NodeGetFlags_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      NodeGetFlags_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~NodeGetFlags_Impl() = default;
      NodeGetFlags_Impl(NodeGetFlags_Impl&& other) = default;
      NodeGetFlags_Impl& operator=(NodeGetFlags_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class NodeSetFlags_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      NodeSetFlags_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer);
      ~NodeSetFlags_Impl() = default;
      NodeSetFlags_Impl(NodeSetFlags_Impl&& other) = default;
      NodeSetFlags_Impl& operator=(NodeSetFlags_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Bind_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Bind_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);
      ~Bind_Impl() = default;
      Bind_Impl(Bind_Impl&& other) = default;
      Bind_Impl& operator=(Bind_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Connect_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Connect_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);
      ~Connect_Impl() = default;
      Connect_Impl(Connect_Impl&& other) = default;
      Connect_Impl& operator=(Connect_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Listen_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Listen_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t backlog, ::fidl::BytePart _response_buffer);
      ~Listen_Impl() = default;
      Listen_Impl(Listen_Impl&& other) = default;
      Listen_Impl& operator=(Listen_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Accept_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Accept_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t flags, ::fidl::BytePart _response_buffer);
      ~Accept_Impl() = default;
      Accept_Impl(Accept_Impl&& other) = default;
      Accept_Impl& operator=(Accept_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetSockName_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetSockName_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetSockName_Impl() = default;
      GetSockName_Impl(GetSockName_Impl&& other) = default;
      GetSockName_Impl& operator=(GetSockName_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetPeerName_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetPeerName_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetPeerName_Impl() = default;
      GetPeerName_Impl(GetPeerName_Impl&& other) = default;
      GetPeerName_Impl& operator=(GetPeerName_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetSockOpt_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      SetSockOpt_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, ::fidl::BytePart _response_buffer);
      ~SetSockOpt_Impl() = default;
      SetSockOpt_Impl(SetSockOpt_Impl&& other) = default;
      SetSockOpt_Impl& operator=(SetSockOpt_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetSockOpt_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetSockOpt_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::BytePart _response_buffer);
      ~GetSockOpt_Impl() = default;
      GetSockOpt_Impl(GetSockOpt_Impl&& other) = default;
      GetSockOpt_Impl& operator=(GetSockOpt_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Clone = Clone_Impl;
    using Close = Close_Impl<CloseResponse>;
    using Describe = Describe_Impl<DescribeResponse>;
    using Sync = Sync_Impl<SyncResponse>;
    using GetAttr = GetAttr_Impl<GetAttrResponse>;
    using SetAttr = SetAttr_Impl<SetAttrResponse>;
    using NodeGetFlags = NodeGetFlags_Impl<NodeGetFlagsResponse>;
    using NodeSetFlags = NodeSetFlags_Impl<NodeSetFlagsResponse>;
    using Bind = Bind_Impl<BindResponse>;
    using Connect = Connect_Impl<ConnectResponse>;
    using Listen = Listen_Impl<ListenResponse>;
    using Accept = Accept_Impl<AcceptResponse>;
    using GetSockName = GetSockName_Impl<GetSockNameResponse>;
    using GetPeerName = GetPeerName_Impl<GetPeerNameResponse>;
    using SetSockOpt = SetSockOpt_Impl<SetSockOptResponse>;
    using GetSockOpt = GetSockOpt_Impl<GetSockOptResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    //
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with
    // `CLONE_FLAG_SAME_RIGHTS`.
    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Clone Clone(uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    //
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with
    // `CLONE_FLAG_SAME_RIGHTS`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Clone Clone(::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Close Close();

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Close Close(::fidl::BytePart _response_buffer);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Allocates 88 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Describe Describe();

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Describe Describe(::fidl::BytePart _response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Sync Sync();

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Sync Sync(::fidl::BytePart _response_buffer);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Allocates 96 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetAttr GetAttr();

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetAttr GetAttr(::fidl::BytePart _response_buffer);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Allocates 104 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::SetAttr SetAttr(uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetAttr SetAttr(::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer);

    // Acquires the `Directory.Open` rights and flags used to access this file.
    //
    // This method does not require any rights.
    // This method has the same functionality as GetFlags for File and is
    // meant as an in-progress replacement.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::NodeGetFlags NodeGetFlags();

    // Acquires the `Directory.Open` rights and flags used to access this file.
    //
    // This method does not require any rights.
    // This method has the same functionality as GetFlags for File and is
    // meant as an in-progress replacement.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::NodeGetFlags NodeGetFlags(::fidl::BytePart _response_buffer);

    // Changes the `Directory.Open` flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // This method has the same functionality as SetFlags for File and is
    // meant as an in-progress replacement.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::NodeSetFlags NodeSetFlags(uint32_t flags);

    // Changes the `Directory.Open` flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // This method has the same functionality as SetFlags for File and is
    // meant as an in-progress replacement.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::NodeSetFlags NodeSetFlags(::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer);

    // Sets the local address used for the socket.
    // Allocates 184 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Bind Bind(::fidl::VectorView<uint8_t> addr);

    // Sets the local address used for the socket.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Bind Bind(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);

    // Initiates a connection to a remote address.
    // Allocates 184 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Connect Connect(::fidl::VectorView<uint8_t> addr);

    // Initiates a connection to a remote address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Connect Connect(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);

    // Begins listening for new incoming connections. At most `backlog` connections will be
    // buffered.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Listen Listen(int16_t backlog);

    // Begins listening for new incoming connections. At most `backlog` connections will be
    // buffered.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Listen Listen(::fidl::BytePart _request_buffer, int16_t backlog, ::fidl::BytePart _response_buffer);

    // Accepts a buffered incoming connection.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Accept Accept(int16_t flags);

    // Accepts a buffered incoming connection.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Accept Accept(::fidl::BytePart _request_buffer, int16_t flags, ::fidl::BytePart _response_buffer);

    // Retrieves the local socket address.
    // Allocates 184 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetSockName GetSockName();

    // Retrieves the local socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetSockName GetSockName(::fidl::BytePart _response_buffer);

    // Retrieves the remote socket address.
    // Allocates 184 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetPeerName GetPeerName();

    // Retrieves the remote socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetPeerName GetPeerName(::fidl::BytePart _response_buffer);

    // Sets the value of a socket option.
    // Allocates 24 bytes of response buffer on the stack. Request is heap-allocated.
    ResultOf::SetSockOpt SetSockOpt(int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval);

    // Sets the value of a socket option.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetSockOpt SetSockOpt(::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, ::fidl::BytePart _response_buffer);

    // Retrieves the value of a socket option.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::GetSockOpt GetSockOpt(int16_t level, int16_t optname);

    // Retrieves the value of a socket option.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetSockOpt GetSockOpt(::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::BytePart _response_buffer);

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    zx_status_t HandleEvents(EventHandlers handlers);
   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    //
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with
    // `CLONE_FLAG_SAME_RIGHTS`.
    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Clone Clone(::zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    //
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with
    // `CLONE_FLAG_SAME_RIGHTS`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Clone Clone(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Close Close(::zx::unowned_channel _client_end);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Close Close(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Allocates 88 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Describe Describe(::zx::unowned_channel _client_end);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Describe Describe(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Sync Sync(::zx::unowned_channel _client_end);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Sync Sync(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Allocates 96 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetAttr GetAttr(::zx::unowned_channel _client_end);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetAttr GetAttr(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Allocates 104 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::SetAttr SetAttr(::zx::unowned_channel _client_end, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetAttr SetAttr(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer);

    // Acquires the `Directory.Open` rights and flags used to access this file.
    //
    // This method does not require any rights.
    // This method has the same functionality as GetFlags for File and is
    // meant as an in-progress replacement.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::NodeGetFlags NodeGetFlags(::zx::unowned_channel _client_end);

    // Acquires the `Directory.Open` rights and flags used to access this file.
    //
    // This method does not require any rights.
    // This method has the same functionality as GetFlags for File and is
    // meant as an in-progress replacement.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::NodeGetFlags NodeGetFlags(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Changes the `Directory.Open` flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // This method has the same functionality as SetFlags for File and is
    // meant as an in-progress replacement.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::NodeSetFlags NodeSetFlags(::zx::unowned_channel _client_end, uint32_t flags);

    // Changes the `Directory.Open` flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // This method has the same functionality as SetFlags for File and is
    // meant as an in-progress replacement.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::NodeSetFlags NodeSetFlags(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer);

    // Sets the local address used for the socket.
    // Allocates 184 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Bind Bind(::zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> addr);

    // Sets the local address used for the socket.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Bind Bind(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);

    // Initiates a connection to a remote address.
    // Allocates 184 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Connect Connect(::zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> addr);

    // Initiates a connection to a remote address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Connect Connect(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);

    // Begins listening for new incoming connections. At most `backlog` connections will be
    // buffered.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Listen Listen(::zx::unowned_channel _client_end, int16_t backlog);

    // Begins listening for new incoming connections. At most `backlog` connections will be
    // buffered.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Listen Listen(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t backlog, ::fidl::BytePart _response_buffer);

    // Accepts a buffered incoming connection.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Accept Accept(::zx::unowned_channel _client_end, int16_t flags);

    // Accepts a buffered incoming connection.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Accept Accept(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t flags, ::fidl::BytePart _response_buffer);

    // Retrieves the local socket address.
    // Allocates 184 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetSockName GetSockName(::zx::unowned_channel _client_end);

    // Retrieves the local socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetSockName GetSockName(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Retrieves the remote socket address.
    // Allocates 184 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetPeerName GetPeerName(::zx::unowned_channel _client_end);

    // Retrieves the remote socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetPeerName GetPeerName(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Sets the value of a socket option.
    // Allocates 24 bytes of response buffer on the stack. Request is heap-allocated.
    static ResultOf::SetSockOpt SetSockOpt(::zx::unowned_channel _client_end, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval);

    // Sets the value of a socket option.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetSockOpt SetSockOpt(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, ::fidl::BytePart _response_buffer);

    // Retrieves the value of a socket option.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::GetSockOpt GetSockOpt(::zx::unowned_channel _client_end, int16_t level, int16_t optname);

    // Retrieves the value of a socket option.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetSockOpt GetSockOpt(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::BytePart _response_buffer);

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    static zx_status_t HandleEvents(::zx::unowned_channel client_end, EventHandlers handlers);
  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    //
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with
    // `CLONE_FLAG_SAME_RIGHTS`.
    static ::fidl::internal::StatusAndError Clone(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<CloneRequest> params);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<CloseResponse> Close(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<DescribeResponse> Describe(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<SyncResponse> Sync(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<GetAttrResponse> GetAttr(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    static ::fidl::DecodeResult<SetAttrResponse> SetAttr(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetAttrRequest> params, ::fidl::BytePart response_buffer);

    // Acquires the `Directory.Open` rights and flags used to access this file.
    //
    // This method does not require any rights.
    // This method has the same functionality as GetFlags for File and is
    // meant as an in-progress replacement.
    static ::fidl::DecodeResult<NodeGetFlagsResponse> NodeGetFlags(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Changes the `Directory.Open` flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // This method has the same functionality as SetFlags for File and is
    // meant as an in-progress replacement.
    static ::fidl::DecodeResult<NodeSetFlagsResponse> NodeSetFlags(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<NodeSetFlagsRequest> params, ::fidl::BytePart response_buffer);

    // Sets the local address used for the socket.
    static ::fidl::DecodeResult<BindResponse> Bind(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<BindRequest> params, ::fidl::BytePart response_buffer);

    // Initiates a connection to a remote address.
    static ::fidl::DecodeResult<ConnectResponse> Connect(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ConnectRequest> params, ::fidl::BytePart response_buffer);

    // Begins listening for new incoming connections. At most `backlog` connections will be
    // buffered.
    static ::fidl::DecodeResult<ListenResponse> Listen(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ListenRequest> params, ::fidl::BytePart response_buffer);

    // Accepts a buffered incoming connection.
    static ::fidl::DecodeResult<AcceptResponse> Accept(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<AcceptRequest> params, ::fidl::BytePart response_buffer);

    // Retrieves the local socket address.
    static ::fidl::DecodeResult<GetSockNameResponse> GetSockName(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Retrieves the remote socket address.
    static ::fidl::DecodeResult<GetPeerNameResponse> GetPeerName(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Sets the value of a socket option.
    static ::fidl::DecodeResult<SetSockOptResponse> SetSockOpt(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetSockOptRequest> params, ::fidl::BytePart response_buffer);

    // Retrieves the value of a socket option.
    static ::fidl::DecodeResult<GetSockOptResponse> GetSockOpt(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetSockOptRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Control;
    using _Base = ::fidl::CompleterBase;

    using CloneCompleter = ::fidl::Completer<>;

    virtual void Clone(uint32_t flags, ::zx::channel object, CloneCompleter::Sync _completer) = 0;

    class CloseCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<CloseResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using CloseCompleter = ::fidl::Completer<CloseCompleterBase>;

    virtual void Close(CloseCompleter::Sync _completer) = 0;

    class DescribeCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io::NodeInfo info);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io::NodeInfo info);
      void Reply(::fidl::DecodedMessage<DescribeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using DescribeCompleter = ::fidl::Completer<DescribeCompleterBase>;

    virtual void Describe(DescribeCompleter::Sync _completer) = 0;

    class SyncCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<SyncResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SyncCompleter = ::fidl::Completer<SyncCompleterBase>;

    virtual void Sync(SyncCompleter::Sync _completer) = 0;

    class GetAttrCompleterBase : public _Base {
     public:
      void Reply(int32_t s, ::llcpp::fuchsia::io::NodeAttributes attributes);
      void Reply(::fidl::BytePart _buffer, int32_t s, ::llcpp::fuchsia::io::NodeAttributes attributes);
      void Reply(::fidl::DecodedMessage<GetAttrResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetAttrCompleter = ::fidl::Completer<GetAttrCompleterBase>;

    virtual void GetAttr(GetAttrCompleter::Sync _completer) = 0;

    class SetAttrCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<SetAttrResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetAttrCompleter = ::fidl::Completer<SetAttrCompleterBase>;

    virtual void SetAttr(uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, SetAttrCompleter::Sync _completer) = 0;

    class NodeGetFlagsCompleterBase : public _Base {
     public:
      void Reply(int32_t s, uint32_t flags);
      void Reply(::fidl::BytePart _buffer, int32_t s, uint32_t flags);
      void Reply(::fidl::DecodedMessage<NodeGetFlagsResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using NodeGetFlagsCompleter = ::fidl::Completer<NodeGetFlagsCompleterBase>;

    virtual void NodeGetFlags(NodeGetFlagsCompleter::Sync _completer) { _completer.Close(ZX_ERR_NOT_SUPPORTED); }

    class NodeSetFlagsCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<NodeSetFlagsResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using NodeSetFlagsCompleter = ::fidl::Completer<NodeSetFlagsCompleterBase>;

    virtual void NodeSetFlags(uint32_t flags, NodeSetFlagsCompleter::Sync _completer) { _completer.Close(ZX_ERR_NOT_SUPPORTED); }

    class BindCompleterBase : public _Base {
     public:
      void Reply(int16_t code);
      void Reply(::fidl::BytePart _buffer, int16_t code);
      void Reply(::fidl::DecodedMessage<BindResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using BindCompleter = ::fidl::Completer<BindCompleterBase>;

    virtual void Bind(::fidl::VectorView<uint8_t> addr, BindCompleter::Sync _completer) = 0;

    class ConnectCompleterBase : public _Base {
     public:
      void Reply(int16_t code);
      void Reply(::fidl::BytePart _buffer, int16_t code);
      void Reply(::fidl::DecodedMessage<ConnectResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ConnectCompleter = ::fidl::Completer<ConnectCompleterBase>;

    virtual void Connect(::fidl::VectorView<uint8_t> addr, ConnectCompleter::Sync _completer) = 0;

    class ListenCompleterBase : public _Base {
     public:
      void Reply(int16_t code);
      void Reply(::fidl::BytePart _buffer, int16_t code);
      void Reply(::fidl::DecodedMessage<ListenResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ListenCompleter = ::fidl::Completer<ListenCompleterBase>;

    virtual void Listen(int16_t backlog, ListenCompleter::Sync _completer) = 0;

    class AcceptCompleterBase : public _Base {
     public:
      void Reply(int16_t code, ::zx::channel s);
      void Reply(::fidl::BytePart _buffer, int16_t code, ::zx::channel s);
      void Reply(::fidl::DecodedMessage<AcceptResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using AcceptCompleter = ::fidl::Completer<AcceptCompleterBase>;

    virtual void Accept(int16_t flags, AcceptCompleter::Sync _completer) = 0;

    class GetSockNameCompleterBase : public _Base {
     public:
      void Reply(int16_t code, ::fidl::VectorView<uint8_t> addr);
      void Reply(::fidl::BytePart _buffer, int16_t code, ::fidl::VectorView<uint8_t> addr);
      void Reply(::fidl::DecodedMessage<GetSockNameResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetSockNameCompleter = ::fidl::Completer<GetSockNameCompleterBase>;

    virtual void GetSockName(GetSockNameCompleter::Sync _completer) = 0;

    class GetPeerNameCompleterBase : public _Base {
     public:
      void Reply(int16_t code, ::fidl::VectorView<uint8_t> addr);
      void Reply(::fidl::BytePart _buffer, int16_t code, ::fidl::VectorView<uint8_t> addr);
      void Reply(::fidl::DecodedMessage<GetPeerNameResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetPeerNameCompleter = ::fidl::Completer<GetPeerNameCompleterBase>;

    virtual void GetPeerName(GetPeerNameCompleter::Sync _completer) = 0;

    class SetSockOptCompleterBase : public _Base {
     public:
      void Reply(int16_t code);
      void Reply(::fidl::BytePart _buffer, int16_t code);
      void Reply(::fidl::DecodedMessage<SetSockOptResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetSockOptCompleter = ::fidl::Completer<SetSockOptCompleterBase>;

    virtual void SetSockOpt(int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, SetSockOptCompleter::Sync _completer) = 0;

    class GetSockOptCompleterBase : public _Base {
     public:
      void Reply(int16_t code, ::fidl::VectorView<uint8_t> optval);
      void Reply(::fidl::BytePart _buffer, int16_t code, ::fidl::VectorView<uint8_t> optval);
      void Reply(::fidl::DecodedMessage<GetSockOptResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetSockOptCompleter = ::fidl::Completer<GetSockOptCompleterBase>;

    virtual void GetSockOpt(int16_t level, int16_t optname, GetSockOptCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

  // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
  // (the same as would be returned by `Describe`).
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, int32_t s, ::llcpp::fuchsia::io::NodeInfo info);

  // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
  // (the same as would be returned by `Describe`).
  // Caller provides the backing storage for FIDL message via response buffers.
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, int32_t s, ::llcpp::fuchsia::io::NodeInfo info);

  // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
  // (the same as would be returned by `Describe`).
  // Messages are encoded in-place.
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnOpenResponse> params);


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void CloneRequest(const ::fidl::DecodedMessage<Control::CloneRequest>& _msg);
    static void CloseRequest(const ::fidl::DecodedMessage<Control::CloseRequest>& _msg);
    static void CloseResponse(const ::fidl::DecodedMessage<Control::CloseResponse>& _msg);
    static void DescribeRequest(const ::fidl::DecodedMessage<Control::DescribeRequest>& _msg);
    static void DescribeResponse(const ::fidl::DecodedMessage<Control::DescribeResponse>& _msg);
    static void OnOpenResponse(const ::fidl::DecodedMessage<Control::OnOpenResponse>& _msg);
    static void SyncRequest(const ::fidl::DecodedMessage<Control::SyncRequest>& _msg);
    static void SyncResponse(const ::fidl::DecodedMessage<Control::SyncResponse>& _msg);
    static void GetAttrRequest(const ::fidl::DecodedMessage<Control::GetAttrRequest>& _msg);
    static void GetAttrResponse(const ::fidl::DecodedMessage<Control::GetAttrResponse>& _msg);
    static void SetAttrRequest(const ::fidl::DecodedMessage<Control::SetAttrRequest>& _msg);
    static void SetAttrResponse(const ::fidl::DecodedMessage<Control::SetAttrResponse>& _msg);
    static void NodeGetFlagsRequest(const ::fidl::DecodedMessage<Control::NodeGetFlagsRequest>& _msg);
    static void NodeGetFlagsResponse(const ::fidl::DecodedMessage<Control::NodeGetFlagsResponse>& _msg);
    static void NodeSetFlagsRequest(const ::fidl::DecodedMessage<Control::NodeSetFlagsRequest>& _msg);
    static void NodeSetFlagsResponse(const ::fidl::DecodedMessage<Control::NodeSetFlagsResponse>& _msg);
    static void BindRequest(const ::fidl::DecodedMessage<Control::BindRequest>& _msg);
    static void BindResponse(const ::fidl::DecodedMessage<Control::BindResponse>& _msg);
    static void ConnectRequest(const ::fidl::DecodedMessage<Control::ConnectRequest>& _msg);
    static void ConnectResponse(const ::fidl::DecodedMessage<Control::ConnectResponse>& _msg);
    static void ListenRequest(const ::fidl::DecodedMessage<Control::ListenRequest>& _msg);
    static void ListenResponse(const ::fidl::DecodedMessage<Control::ListenResponse>& _msg);
    static void AcceptRequest(const ::fidl::DecodedMessage<Control::AcceptRequest>& _msg);
    static void AcceptResponse(const ::fidl::DecodedMessage<Control::AcceptResponse>& _msg);
    static void GetSockNameRequest(const ::fidl::DecodedMessage<Control::GetSockNameRequest>& _msg);
    static void GetSockNameResponse(const ::fidl::DecodedMessage<Control::GetSockNameResponse>& _msg);
    static void GetPeerNameRequest(const ::fidl::DecodedMessage<Control::GetPeerNameRequest>& _msg);
    static void GetPeerNameResponse(const ::fidl::DecodedMessage<Control::GetPeerNameResponse>& _msg);
    static void SetSockOptRequest(const ::fidl::DecodedMessage<Control::SetSockOptRequest>& _msg);
    static void SetSockOptResponse(const ::fidl::DecodedMessage<Control::SetSockOptResponse>& _msg);
    static void GetSockOptRequest(const ::fidl::DecodedMessage<Control::GetSockOptRequest>& _msg);
    static void GetSockOptResponse(const ::fidl::DecodedMessage<Control::GetSockOptResponse>& _msg);
  };
};

extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocketCloneRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocketCloneRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocketCloneResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocketCloneResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocketCloseRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocketCloseRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocketCloseResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocketCloseResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocketDescribeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocketDescribeRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocketDescribeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocketDescribeResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocketOnOpenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocketOnOpenRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocketOnOpenEventTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocketOnOpenEventTable;
extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocketSyncRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocketSyncRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocketSyncResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocketSyncResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocketGetAttrRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocketGetAttrRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocketGetAttrResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocketGetAttrResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocketSetAttrRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocketSetAttrRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocketSetAttrResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocketSetAttrResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocketNodeGetFlagsRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocketNodeGetFlagsRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocketNodeGetFlagsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocketNodeGetFlagsResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocketNodeSetFlagsRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocketNodeSetFlagsRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocketNodeSetFlagsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocketNodeSetFlagsResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocketBindRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocketBindRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocketBindResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocketBindResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocketConnectRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocketConnectRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocketConnectResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocketConnectResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocketGetSockNameRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocketGetSockNameRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocketGetSockNameResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocketGetSockNameResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocketGetPeerNameRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocketGetPeerNameRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocketGetPeerNameResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocketGetPeerNameResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocketSetSockOptRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocketSetSockOptRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocketSetSockOptResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocketSetSockOptResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocketGetSockOptRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocketGetSockOptRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_BaseSocketGetSockOptResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_BaseSocketGetSockOptResponseTable;

// A network socket.
//
// Once a socket has been retrieved from a `Provider`, this interface is then used to further
// configure and use the socket. This interface is essentially POSIX. Its implementation must
// support Linux-specific arguments to {Get,Set}SockOpt.
//
// All methods on this type are nonblocking; their exact behaviors match their Linux counterparts.
//
// *Warning:* This protocol is not yet ready for direct use by clients. Instead, clients should
// use the BSD sockets API to interact with sockets. We plan to change this protocol substantially
// and clients that couple directly to this protocol will make those changes more difficult.
class BaseSocket final {
  BaseSocket() = delete;
 public:

  struct CloneRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;
    ::zx::channel object;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_BaseSocketCloneRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_BaseSocketCloneRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct CloseResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_BaseSocketCloseResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_BaseSocketCloseResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using CloseRequest = ::fidl::AnyZeroArgMessage;

  struct DescribeResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io::NodeInfo info;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_BaseSocketDescribeResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_BaseSocketDescribeResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 24;
    static constexpr uint32_t AltPrimarySize = 48;
    static constexpr uint32_t AltMaxOutOfLine = 24;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using DescribeRequest = ::fidl::AnyZeroArgMessage;

  struct OnOpenResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::llcpp::fuchsia::io::NodeInfo info;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_BaseSocketOnOpenEventTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_BaseSocketOnOpenEventTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 24;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 24;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SyncResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_BaseSocketSyncResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_BaseSocketSyncResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using SyncRequest = ::fidl::AnyZeroArgMessage;

  struct GetAttrResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::llcpp::fuchsia::io::NodeAttributes attributes;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_BaseSocketGetAttrResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_BaseSocketGetAttrResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 80;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 80;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetAttrRequest = ::fidl::AnyZeroArgMessage;

  struct SetAttrResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_BaseSocketSetAttrResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_BaseSocketSetAttrResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SetAttrRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;
    ::llcpp::fuchsia::io::NodeAttributes attributes;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_BaseSocketSetAttrRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_BaseSocketSetAttrRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 80;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 80;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SetAttrResponse;
  };

  struct NodeGetFlagsResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    uint32_t flags;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_BaseSocketNodeGetFlagsResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_BaseSocketNodeGetFlagsResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using NodeGetFlagsRequest = ::fidl::AnyZeroArgMessage;

  struct NodeSetFlagsResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_BaseSocketNodeSetFlagsResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_BaseSocketNodeSetFlagsResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct NodeSetFlagsRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_BaseSocketNodeSetFlagsRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_BaseSocketNodeSetFlagsRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = NodeSetFlagsResponse;
  };

  struct BindResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::posix::socket::BaseSocket_Bind_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_BaseSocketBindResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_BaseSocketBindResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct BindRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::VectorView<uint8_t> addr;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_BaseSocketBindRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_BaseSocketBindRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 128;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 128;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = BindResponse;
  };

  struct ConnectResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::posix::socket::BaseSocket_Connect_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_BaseSocketConnectResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_BaseSocketConnectResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct ConnectRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::VectorView<uint8_t> addr;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_BaseSocketConnectRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_BaseSocketConnectRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 128;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 128;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = ConnectResponse;
  };

  struct GetSockNameResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::posix::socket::BaseSocket_GetSockName_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_BaseSocketGetSockNameResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_BaseSocketGetSockNameResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 144;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 144;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetSockNameRequest = ::fidl::AnyZeroArgMessage;

  struct GetPeerNameResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::posix::socket::BaseSocket_GetPeerName_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_BaseSocketGetPeerNameResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_BaseSocketGetPeerNameResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 144;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 144;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetPeerNameRequest = ::fidl::AnyZeroArgMessage;

  struct SetSockOptResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::posix::socket::BaseSocket_SetSockOpt_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_BaseSocketSetSockOptResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_BaseSocketSetSockOptResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SetSockOptRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t level;
    int16_t optname;
    ::fidl::VectorView<uint8_t> optval;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_BaseSocketSetSockOptRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_BaseSocketSetSockOptRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 904;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 904;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SetSockOptResponse;
  };

  struct GetSockOptResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::posix::socket::BaseSocket_GetSockOpt_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_BaseSocketGetSockOptResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_BaseSocketGetSockOptResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 920;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 920;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct GetSockOptRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t level;
    int16_t optname;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_BaseSocketGetSockOptRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_BaseSocketGetSockOptRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = GetSockOptResponse;
  };


  struct EventHandlers {
    // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
    //
    // Indicates the success or failure of the open operation, and optionally describes the
    // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
    // (the same as would be returned by `Describe`).
    fit::callback<zx_status_t(int32_t s, ::llcpp::fuchsia::io::NodeInfo info)> on_open;

    // Fallback handler when an unknown ordinal is received.
    // Caller may put custom error handling logic here.
    fit::callback<zx_status_t()> unknown;
  };

  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    class Clone_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Clone_Impl(::zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object);
      ~Clone_Impl() = default;
      Clone_Impl(Clone_Impl&& other) = default;
      Clone_Impl& operator=(Clone_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class Close_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Close_Impl(::zx::unowned_channel _client_end);
      ~Close_Impl() = default;
      Close_Impl(Close_Impl&& other) = default;
      Close_Impl& operator=(Close_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Describe_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Describe_Impl(::zx::unowned_channel _client_end);
      ~Describe_Impl() = default;
      Describe_Impl(Describe_Impl&& other) = default;
      Describe_Impl& operator=(Describe_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Sync_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Sync_Impl(::zx::unowned_channel _client_end);
      ~Sync_Impl() = default;
      Sync_Impl(Sync_Impl&& other) = default;
      Sync_Impl& operator=(Sync_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetAttr_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetAttr_Impl(::zx::unowned_channel _client_end);
      ~GetAttr_Impl() = default;
      GetAttr_Impl(GetAttr_Impl&& other) = default;
      GetAttr_Impl& operator=(GetAttr_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetAttr_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      SetAttr_Impl(::zx::unowned_channel _client_end, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes);
      ~SetAttr_Impl() = default;
      SetAttr_Impl(SetAttr_Impl&& other) = default;
      SetAttr_Impl& operator=(SetAttr_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class NodeGetFlags_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      NodeGetFlags_Impl(::zx::unowned_channel _client_end);
      ~NodeGetFlags_Impl() = default;
      NodeGetFlags_Impl(NodeGetFlags_Impl&& other) = default;
      NodeGetFlags_Impl& operator=(NodeGetFlags_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class NodeSetFlags_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      NodeSetFlags_Impl(::zx::unowned_channel _client_end, uint32_t flags);
      ~NodeSetFlags_Impl() = default;
      NodeSetFlags_Impl(NodeSetFlags_Impl&& other) = default;
      NodeSetFlags_Impl& operator=(NodeSetFlags_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Bind_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Bind_Impl(::zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> addr);
      ~Bind_Impl() = default;
      Bind_Impl(Bind_Impl&& other) = default;
      Bind_Impl& operator=(Bind_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Connect_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Connect_Impl(::zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> addr);
      ~Connect_Impl() = default;
      Connect_Impl(Connect_Impl&& other) = default;
      Connect_Impl& operator=(Connect_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetSockName_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetSockName_Impl(::zx::unowned_channel _client_end);
      ~GetSockName_Impl() = default;
      GetSockName_Impl(GetSockName_Impl&& other) = default;
      GetSockName_Impl& operator=(GetSockName_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetPeerName_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetPeerName_Impl(::zx::unowned_channel _client_end);
      ~GetPeerName_Impl() = default;
      GetPeerName_Impl(GetPeerName_Impl&& other) = default;
      GetPeerName_Impl& operator=(GetPeerName_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetSockOpt_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      SetSockOpt_Impl(::zx::unowned_channel _client_end, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval);
      ~SetSockOpt_Impl() = default;
      SetSockOpt_Impl(SetSockOpt_Impl&& other) = default;
      SetSockOpt_Impl& operator=(SetSockOpt_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetSockOpt_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetSockOpt_Impl(::zx::unowned_channel _client_end, int16_t level, int16_t optname);
      ~GetSockOpt_Impl() = default;
      GetSockOpt_Impl(GetSockOpt_Impl&& other) = default;
      GetSockOpt_Impl& operator=(GetSockOpt_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Clone = Clone_Impl;
    using Close = Close_Impl<CloseResponse>;
    using Describe = Describe_Impl<DescribeResponse>;
    using Sync = Sync_Impl<SyncResponse>;
    using GetAttr = GetAttr_Impl<GetAttrResponse>;
    using SetAttr = SetAttr_Impl<SetAttrResponse>;
    using NodeGetFlags = NodeGetFlags_Impl<NodeGetFlagsResponse>;
    using NodeSetFlags = NodeSetFlags_Impl<NodeSetFlagsResponse>;
    using Bind = Bind_Impl<BindResponse>;
    using Connect = Connect_Impl<ConnectResponse>;
    using GetSockName = GetSockName_Impl<GetSockNameResponse>;
    using GetPeerName = GetPeerName_Impl<GetPeerNameResponse>;
    using SetSockOpt = SetSockOpt_Impl<SetSockOptResponse>;
    using GetSockOpt = GetSockOpt_Impl<GetSockOptResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    class Clone_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Clone_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);
      ~Clone_Impl() = default;
      Clone_Impl(Clone_Impl&& other) = default;
      Clone_Impl& operator=(Clone_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class Close_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Close_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Close_Impl() = default;
      Close_Impl(Close_Impl&& other) = default;
      Close_Impl& operator=(Close_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Describe_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Describe_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Describe_Impl() = default;
      Describe_Impl(Describe_Impl&& other) = default;
      Describe_Impl& operator=(Describe_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Sync_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Sync_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Sync_Impl() = default;
      Sync_Impl(Sync_Impl&& other) = default;
      Sync_Impl& operator=(Sync_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetAttr_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetAttr_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetAttr_Impl() = default;
      GetAttr_Impl(GetAttr_Impl&& other) = default;
      GetAttr_Impl& operator=(GetAttr_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetAttr_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      SetAttr_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer);
      ~SetAttr_Impl() = default;
      SetAttr_Impl(SetAttr_Impl&& other) = default;
      SetAttr_Impl& operator=(SetAttr_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class NodeGetFlags_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      NodeGetFlags_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~NodeGetFlags_Impl() = default;
      NodeGetFlags_Impl(NodeGetFlags_Impl&& other) = default;
      NodeGetFlags_Impl& operator=(NodeGetFlags_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class NodeSetFlags_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      NodeSetFlags_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer);
      ~NodeSetFlags_Impl() = default;
      NodeSetFlags_Impl(NodeSetFlags_Impl&& other) = default;
      NodeSetFlags_Impl& operator=(NodeSetFlags_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Bind_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Bind_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);
      ~Bind_Impl() = default;
      Bind_Impl(Bind_Impl&& other) = default;
      Bind_Impl& operator=(Bind_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Connect_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Connect_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);
      ~Connect_Impl() = default;
      Connect_Impl(Connect_Impl&& other) = default;
      Connect_Impl& operator=(Connect_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetSockName_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetSockName_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetSockName_Impl() = default;
      GetSockName_Impl(GetSockName_Impl&& other) = default;
      GetSockName_Impl& operator=(GetSockName_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetPeerName_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetPeerName_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetPeerName_Impl() = default;
      GetPeerName_Impl(GetPeerName_Impl&& other) = default;
      GetPeerName_Impl& operator=(GetPeerName_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetSockOpt_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      SetSockOpt_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, ::fidl::BytePart _response_buffer);
      ~SetSockOpt_Impl() = default;
      SetSockOpt_Impl(SetSockOpt_Impl&& other) = default;
      SetSockOpt_Impl& operator=(SetSockOpt_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetSockOpt_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetSockOpt_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::BytePart _response_buffer);
      ~GetSockOpt_Impl() = default;
      GetSockOpt_Impl(GetSockOpt_Impl&& other) = default;
      GetSockOpt_Impl& operator=(GetSockOpt_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Clone = Clone_Impl;
    using Close = Close_Impl<CloseResponse>;
    using Describe = Describe_Impl<DescribeResponse>;
    using Sync = Sync_Impl<SyncResponse>;
    using GetAttr = GetAttr_Impl<GetAttrResponse>;
    using SetAttr = SetAttr_Impl<SetAttrResponse>;
    using NodeGetFlags = NodeGetFlags_Impl<NodeGetFlagsResponse>;
    using NodeSetFlags = NodeSetFlags_Impl<NodeSetFlagsResponse>;
    using Bind = Bind_Impl<BindResponse>;
    using Connect = Connect_Impl<ConnectResponse>;
    using GetSockName = GetSockName_Impl<GetSockNameResponse>;
    using GetPeerName = GetPeerName_Impl<GetPeerNameResponse>;
    using SetSockOpt = SetSockOpt_Impl<SetSockOptResponse>;
    using GetSockOpt = GetSockOpt_Impl<GetSockOptResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    //
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with
    // `CLONE_FLAG_SAME_RIGHTS`.
    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Clone Clone(uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    //
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with
    // `CLONE_FLAG_SAME_RIGHTS`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Clone Clone(::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Close Close();

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Close Close(::fidl::BytePart _response_buffer);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Allocates 88 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Describe Describe();

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Describe Describe(::fidl::BytePart _response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Sync Sync();

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Sync Sync(::fidl::BytePart _response_buffer);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Allocates 96 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetAttr GetAttr();

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetAttr GetAttr(::fidl::BytePart _response_buffer);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Allocates 104 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::SetAttr SetAttr(uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetAttr SetAttr(::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer);

    // Acquires the `Directory.Open` rights and flags used to access this file.
    //
    // This method does not require any rights.
    // This method has the same functionality as GetFlags for File and is
    // meant as an in-progress replacement.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::NodeGetFlags NodeGetFlags();

    // Acquires the `Directory.Open` rights and flags used to access this file.
    //
    // This method does not require any rights.
    // This method has the same functionality as GetFlags for File and is
    // meant as an in-progress replacement.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::NodeGetFlags NodeGetFlags(::fidl::BytePart _response_buffer);

    // Changes the `Directory.Open` flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // This method has the same functionality as SetFlags for File and is
    // meant as an in-progress replacement.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::NodeSetFlags NodeSetFlags(uint32_t flags);

    // Changes the `Directory.Open` flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // This method has the same functionality as SetFlags for File and is
    // meant as an in-progress replacement.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::NodeSetFlags NodeSetFlags(::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer);

    // Sets the local address used for the socket.
    // Allocates 192 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Bind Bind(::fidl::VectorView<uint8_t> addr);

    // Sets the local address used for the socket.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Bind Bind(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);

    // Initiates a connection to a remote address.
    // Allocates 192 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Connect Connect(::fidl::VectorView<uint8_t> addr);

    // Initiates a connection to a remote address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Connect Connect(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);

    // Retrieves the local socket address.
    // Allocates 200 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetSockName GetSockName();

    // Retrieves the local socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetSockName GetSockName(::fidl::BytePart _response_buffer);

    // Retrieves the remote socket address.
    // Allocates 200 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetPeerName GetPeerName();

    // Retrieves the remote socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetPeerName GetPeerName(::fidl::BytePart _response_buffer);

    // Sets the value of a socket option.
    // Allocates 32 bytes of response buffer on the stack. Request is heap-allocated.
    ResultOf::SetSockOpt SetSockOpt(int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval);

    // Sets the value of a socket option.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetSockOpt SetSockOpt(::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, ::fidl::BytePart _response_buffer);

    // Retrieves the value of a socket option.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::GetSockOpt GetSockOpt(int16_t level, int16_t optname);

    // Retrieves the value of a socket option.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetSockOpt GetSockOpt(::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::BytePart _response_buffer);

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    zx_status_t HandleEvents(EventHandlers handlers);
   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    //
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with
    // `CLONE_FLAG_SAME_RIGHTS`.
    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Clone Clone(::zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    //
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with
    // `CLONE_FLAG_SAME_RIGHTS`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Clone Clone(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Close Close(::zx::unowned_channel _client_end);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Close Close(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Allocates 88 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Describe Describe(::zx::unowned_channel _client_end);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Describe Describe(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Sync Sync(::zx::unowned_channel _client_end);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Sync Sync(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Allocates 96 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetAttr GetAttr(::zx::unowned_channel _client_end);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetAttr GetAttr(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Allocates 104 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::SetAttr SetAttr(::zx::unowned_channel _client_end, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetAttr SetAttr(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer);

    // Acquires the `Directory.Open` rights and flags used to access this file.
    //
    // This method does not require any rights.
    // This method has the same functionality as GetFlags for File and is
    // meant as an in-progress replacement.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::NodeGetFlags NodeGetFlags(::zx::unowned_channel _client_end);

    // Acquires the `Directory.Open` rights and flags used to access this file.
    //
    // This method does not require any rights.
    // This method has the same functionality as GetFlags for File and is
    // meant as an in-progress replacement.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::NodeGetFlags NodeGetFlags(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Changes the `Directory.Open` flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // This method has the same functionality as SetFlags for File and is
    // meant as an in-progress replacement.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::NodeSetFlags NodeSetFlags(::zx::unowned_channel _client_end, uint32_t flags);

    // Changes the `Directory.Open` flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // This method has the same functionality as SetFlags for File and is
    // meant as an in-progress replacement.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::NodeSetFlags NodeSetFlags(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer);

    // Sets the local address used for the socket.
    // Allocates 192 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Bind Bind(::zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> addr);

    // Sets the local address used for the socket.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Bind Bind(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);

    // Initiates a connection to a remote address.
    // Allocates 192 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Connect Connect(::zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> addr);

    // Initiates a connection to a remote address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Connect Connect(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);

    // Retrieves the local socket address.
    // Allocates 200 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetSockName GetSockName(::zx::unowned_channel _client_end);

    // Retrieves the local socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetSockName GetSockName(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Retrieves the remote socket address.
    // Allocates 200 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetPeerName GetPeerName(::zx::unowned_channel _client_end);

    // Retrieves the remote socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetPeerName GetPeerName(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Sets the value of a socket option.
    // Allocates 32 bytes of response buffer on the stack. Request is heap-allocated.
    static ResultOf::SetSockOpt SetSockOpt(::zx::unowned_channel _client_end, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval);

    // Sets the value of a socket option.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetSockOpt SetSockOpt(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, ::fidl::BytePart _response_buffer);

    // Retrieves the value of a socket option.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::GetSockOpt GetSockOpt(::zx::unowned_channel _client_end, int16_t level, int16_t optname);

    // Retrieves the value of a socket option.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetSockOpt GetSockOpt(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::BytePart _response_buffer);

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    static zx_status_t HandleEvents(::zx::unowned_channel client_end, EventHandlers handlers);
  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    //
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with
    // `CLONE_FLAG_SAME_RIGHTS`.
    static ::fidl::internal::StatusAndError Clone(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<CloneRequest> params);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<CloseResponse> Close(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<DescribeResponse> Describe(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<SyncResponse> Sync(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<GetAttrResponse> GetAttr(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    static ::fidl::DecodeResult<SetAttrResponse> SetAttr(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetAttrRequest> params, ::fidl::BytePart response_buffer);

    // Acquires the `Directory.Open` rights and flags used to access this file.
    //
    // This method does not require any rights.
    // This method has the same functionality as GetFlags for File and is
    // meant as an in-progress replacement.
    static ::fidl::DecodeResult<NodeGetFlagsResponse> NodeGetFlags(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Changes the `Directory.Open` flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // This method has the same functionality as SetFlags for File and is
    // meant as an in-progress replacement.
    static ::fidl::DecodeResult<NodeSetFlagsResponse> NodeSetFlags(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<NodeSetFlagsRequest> params, ::fidl::BytePart response_buffer);

    // Sets the local address used for the socket.
    static ::fidl::DecodeResult<BindResponse> Bind(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<BindRequest> params, ::fidl::BytePart response_buffer);

    // Initiates a connection to a remote address.
    static ::fidl::DecodeResult<ConnectResponse> Connect(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ConnectRequest> params, ::fidl::BytePart response_buffer);

    // Retrieves the local socket address.
    static ::fidl::DecodeResult<GetSockNameResponse> GetSockName(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Retrieves the remote socket address.
    static ::fidl::DecodeResult<GetPeerNameResponse> GetPeerName(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Sets the value of a socket option.
    static ::fidl::DecodeResult<SetSockOptResponse> SetSockOpt(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetSockOptRequest> params, ::fidl::BytePart response_buffer);

    // Retrieves the value of a socket option.
    static ::fidl::DecodeResult<GetSockOptResponse> GetSockOpt(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetSockOptRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = BaseSocket;
    using _Base = ::fidl::CompleterBase;

    using CloneCompleter = ::fidl::Completer<>;

    virtual void Clone(uint32_t flags, ::zx::channel object, CloneCompleter::Sync _completer) = 0;

    class CloseCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<CloseResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using CloseCompleter = ::fidl::Completer<CloseCompleterBase>;

    virtual void Close(CloseCompleter::Sync _completer) = 0;

    class DescribeCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io::NodeInfo info);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io::NodeInfo info);
      void Reply(::fidl::DecodedMessage<DescribeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using DescribeCompleter = ::fidl::Completer<DescribeCompleterBase>;

    virtual void Describe(DescribeCompleter::Sync _completer) = 0;

    class SyncCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<SyncResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SyncCompleter = ::fidl::Completer<SyncCompleterBase>;

    virtual void Sync(SyncCompleter::Sync _completer) = 0;

    class GetAttrCompleterBase : public _Base {
     public:
      void Reply(int32_t s, ::llcpp::fuchsia::io::NodeAttributes attributes);
      void Reply(::fidl::BytePart _buffer, int32_t s, ::llcpp::fuchsia::io::NodeAttributes attributes);
      void Reply(::fidl::DecodedMessage<GetAttrResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetAttrCompleter = ::fidl::Completer<GetAttrCompleterBase>;

    virtual void GetAttr(GetAttrCompleter::Sync _completer) = 0;

    class SetAttrCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<SetAttrResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetAttrCompleter = ::fidl::Completer<SetAttrCompleterBase>;

    virtual void SetAttr(uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, SetAttrCompleter::Sync _completer) = 0;

    class NodeGetFlagsCompleterBase : public _Base {
     public:
      void Reply(int32_t s, uint32_t flags);
      void Reply(::fidl::BytePart _buffer, int32_t s, uint32_t flags);
      void Reply(::fidl::DecodedMessage<NodeGetFlagsResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using NodeGetFlagsCompleter = ::fidl::Completer<NodeGetFlagsCompleterBase>;

    virtual void NodeGetFlags(NodeGetFlagsCompleter::Sync _completer) { _completer.Close(ZX_ERR_NOT_SUPPORTED); }

    class NodeSetFlagsCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<NodeSetFlagsResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using NodeSetFlagsCompleter = ::fidl::Completer<NodeSetFlagsCompleterBase>;

    virtual void NodeSetFlags(uint32_t flags, NodeSetFlagsCompleter::Sync _completer) { _completer.Close(ZX_ERR_NOT_SUPPORTED); }

    class BindCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::posix::socket::BaseSocket_Bind_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::posix::socket::BaseSocket_Bind_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<BindResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using BindCompleter = ::fidl::Completer<BindCompleterBase>;

    virtual void Bind(::fidl::VectorView<uint8_t> addr, BindCompleter::Sync _completer) = 0;

    class ConnectCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::posix::socket::BaseSocket_Connect_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::posix::socket::BaseSocket_Connect_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<ConnectResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ConnectCompleter = ::fidl::Completer<ConnectCompleterBase>;

    virtual void Connect(::fidl::VectorView<uint8_t> addr, ConnectCompleter::Sync _completer) = 0;

    class GetSockNameCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::posix::socket::BaseSocket_GetSockName_Result result);
      void ReplySuccess(::fidl::VectorView<uint8_t> addr);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::posix::socket::BaseSocket_GetSockName_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, ::fidl::VectorView<uint8_t> addr);
      void Reply(::fidl::DecodedMessage<GetSockNameResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetSockNameCompleter = ::fidl::Completer<GetSockNameCompleterBase>;

    virtual void GetSockName(GetSockNameCompleter::Sync _completer) = 0;

    class GetPeerNameCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::posix::socket::BaseSocket_GetPeerName_Result result);
      void ReplySuccess(::fidl::VectorView<uint8_t> addr);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::posix::socket::BaseSocket_GetPeerName_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, ::fidl::VectorView<uint8_t> addr);
      void Reply(::fidl::DecodedMessage<GetPeerNameResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetPeerNameCompleter = ::fidl::Completer<GetPeerNameCompleterBase>;

    virtual void GetPeerName(GetPeerNameCompleter::Sync _completer) = 0;

    class SetSockOptCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::posix::socket::BaseSocket_SetSockOpt_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::posix::socket::BaseSocket_SetSockOpt_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<SetSockOptResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetSockOptCompleter = ::fidl::Completer<SetSockOptCompleterBase>;

    virtual void SetSockOpt(int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, SetSockOptCompleter::Sync _completer) = 0;

    class GetSockOptCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::posix::socket::BaseSocket_GetSockOpt_Result result);
      void ReplySuccess(::fidl::VectorView<uint8_t> optval);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::posix::socket::BaseSocket_GetSockOpt_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, ::fidl::VectorView<uint8_t> optval);
      void Reply(::fidl::DecodedMessage<GetSockOptResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetSockOptCompleter = ::fidl::Completer<GetSockOptCompleterBase>;

    virtual void GetSockOpt(int16_t level, int16_t optname, GetSockOptCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

  // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
  // (the same as would be returned by `Describe`).
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, int32_t s, ::llcpp::fuchsia::io::NodeInfo info);

  // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
  // (the same as would be returned by `Describe`).
  // Caller provides the backing storage for FIDL message via response buffers.
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, int32_t s, ::llcpp::fuchsia::io::NodeInfo info);

  // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
  // (the same as would be returned by `Describe`).
  // Messages are encoded in-place.
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnOpenResponse> params);


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void CloneRequest(const ::fidl::DecodedMessage<BaseSocket::CloneRequest>& _msg);
    static void CloseRequest(const ::fidl::DecodedMessage<BaseSocket::CloseRequest>& _msg);
    static void CloseResponse(const ::fidl::DecodedMessage<BaseSocket::CloseResponse>& _msg);
    static void DescribeRequest(const ::fidl::DecodedMessage<BaseSocket::DescribeRequest>& _msg);
    static void DescribeResponse(const ::fidl::DecodedMessage<BaseSocket::DescribeResponse>& _msg);
    static void OnOpenResponse(const ::fidl::DecodedMessage<BaseSocket::OnOpenResponse>& _msg);
    static void SyncRequest(const ::fidl::DecodedMessage<BaseSocket::SyncRequest>& _msg);
    static void SyncResponse(const ::fidl::DecodedMessage<BaseSocket::SyncResponse>& _msg);
    static void GetAttrRequest(const ::fidl::DecodedMessage<BaseSocket::GetAttrRequest>& _msg);
    static void GetAttrResponse(const ::fidl::DecodedMessage<BaseSocket::GetAttrResponse>& _msg);
    static void SetAttrRequest(const ::fidl::DecodedMessage<BaseSocket::SetAttrRequest>& _msg);
    static void SetAttrResponse(const ::fidl::DecodedMessage<BaseSocket::SetAttrResponse>& _msg);
    static void NodeGetFlagsRequest(const ::fidl::DecodedMessage<BaseSocket::NodeGetFlagsRequest>& _msg);
    static void NodeGetFlagsResponse(const ::fidl::DecodedMessage<BaseSocket::NodeGetFlagsResponse>& _msg);
    static void NodeSetFlagsRequest(const ::fidl::DecodedMessage<BaseSocket::NodeSetFlagsRequest>& _msg);
    static void NodeSetFlagsResponse(const ::fidl::DecodedMessage<BaseSocket::NodeSetFlagsResponse>& _msg);
    static void BindRequest(const ::fidl::DecodedMessage<BaseSocket::BindRequest>& _msg);
    static void BindResponse(const ::fidl::DecodedMessage<BaseSocket::BindResponse>& _msg);
    static void ConnectRequest(const ::fidl::DecodedMessage<BaseSocket::ConnectRequest>& _msg);
    static void ConnectResponse(const ::fidl::DecodedMessage<BaseSocket::ConnectResponse>& _msg);
    static void GetSockNameRequest(const ::fidl::DecodedMessage<BaseSocket::GetSockNameRequest>& _msg);
    static void GetSockNameResponse(const ::fidl::DecodedMessage<BaseSocket::GetSockNameResponse>& _msg);
    static void GetPeerNameRequest(const ::fidl::DecodedMessage<BaseSocket::GetPeerNameRequest>& _msg);
    static void GetPeerNameResponse(const ::fidl::DecodedMessage<BaseSocket::GetPeerNameResponse>& _msg);
    static void SetSockOptRequest(const ::fidl::DecodedMessage<BaseSocket::SetSockOptRequest>& _msg);
    static void SetSockOptResponse(const ::fidl::DecodedMessage<BaseSocket::SetSockOptResponse>& _msg);
    static void GetSockOptRequest(const ::fidl::DecodedMessage<BaseSocket::GetSockOptRequest>& _msg);
    static void GetSockOptResponse(const ::fidl::DecodedMessage<BaseSocket::GetSockOptResponse>& _msg);
  };
};

extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocketCloneRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocketCloneRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocketCloneResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocketCloneResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocketCloseRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocketCloseRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocketCloseResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocketCloseResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocketDescribeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocketDescribeRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocketDescribeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocketDescribeResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocketOnOpenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocketOnOpenRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocketOnOpenEventTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocketOnOpenEventTable;
extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocketSyncRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocketSyncRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocketSyncResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocketSyncResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocketGetAttrRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocketGetAttrRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocketGetAttrResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocketGetAttrResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocketSetAttrRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocketSetAttrRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocketSetAttrResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocketSetAttrResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocketNodeGetFlagsRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocketNodeGetFlagsRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocketNodeGetFlagsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocketNodeGetFlagsResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocketNodeSetFlagsRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocketNodeSetFlagsRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocketNodeSetFlagsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocketNodeSetFlagsResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocketBindRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocketBindRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocketBindResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocketBindResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocketConnectRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocketConnectRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocketConnectResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocketConnectResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocketGetSockNameRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocketGetSockNameRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocketGetSockNameResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocketGetSockNameResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocketGetPeerNameRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocketGetPeerNameRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocketGetPeerNameResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocketGetPeerNameResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocketSetSockOptRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocketSetSockOptRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocketSetSockOptResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocketSetSockOptResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocketGetSockOptRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocketGetSockOptRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocketGetSockOptResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocketGetSockOptResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocketListenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocketListenRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocketListenResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocketListenResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocketAcceptRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocketAcceptRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_StreamSocketAcceptResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_StreamSocketAcceptResponseTable;

// A stream socket.
//
// This type's [`fuchsia.io.Node/Describe`] method returns a socket which is used to transfer data
// to and from the caller. Signals are used to communicate additional information about the state
// of the socket such as connectedness and the presence of incoming connections in the case of a
// listening socket.
//
// All methods on this type are nonblocking; their exact behaviors match their Linux counterparts.
class StreamSocket final {
  StreamSocket() = delete;
 public:

  struct CloneRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;
    ::zx::channel object;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_StreamSocketCloneRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_StreamSocketCloneRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct CloseResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_StreamSocketCloseResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_StreamSocketCloseResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using CloseRequest = ::fidl::AnyZeroArgMessage;

  struct DescribeResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io::NodeInfo info;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_StreamSocketDescribeResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_StreamSocketDescribeResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 24;
    static constexpr uint32_t AltPrimarySize = 48;
    static constexpr uint32_t AltMaxOutOfLine = 24;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using DescribeRequest = ::fidl::AnyZeroArgMessage;

  struct OnOpenResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::llcpp::fuchsia::io::NodeInfo info;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_StreamSocketOnOpenEventTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_StreamSocketOnOpenEventTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 24;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 24;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SyncResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_StreamSocketSyncResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_StreamSocketSyncResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using SyncRequest = ::fidl::AnyZeroArgMessage;

  struct GetAttrResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::llcpp::fuchsia::io::NodeAttributes attributes;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_StreamSocketGetAttrResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_StreamSocketGetAttrResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 80;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 80;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetAttrRequest = ::fidl::AnyZeroArgMessage;

  struct SetAttrResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_StreamSocketSetAttrResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_StreamSocketSetAttrResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SetAttrRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;
    ::llcpp::fuchsia::io::NodeAttributes attributes;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_StreamSocketSetAttrRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_StreamSocketSetAttrRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 80;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 80;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SetAttrResponse;
  };

  struct NodeGetFlagsResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    uint32_t flags;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_StreamSocketNodeGetFlagsResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_StreamSocketNodeGetFlagsResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using NodeGetFlagsRequest = ::fidl::AnyZeroArgMessage;

  struct NodeSetFlagsResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_StreamSocketNodeSetFlagsResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_StreamSocketNodeSetFlagsResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct NodeSetFlagsRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_StreamSocketNodeSetFlagsRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_StreamSocketNodeSetFlagsRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = NodeSetFlagsResponse;
  };

  struct BindResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::posix::socket::BaseSocket_Bind_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_StreamSocketBindResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_StreamSocketBindResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct BindRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::VectorView<uint8_t> addr;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_StreamSocketBindRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_StreamSocketBindRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 128;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 128;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = BindResponse;
  };

  struct ConnectResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::posix::socket::BaseSocket_Connect_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_StreamSocketConnectResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_StreamSocketConnectResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct ConnectRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::VectorView<uint8_t> addr;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_StreamSocketConnectRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_StreamSocketConnectRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 128;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 128;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = ConnectResponse;
  };

  struct GetSockNameResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::posix::socket::BaseSocket_GetSockName_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_StreamSocketGetSockNameResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_StreamSocketGetSockNameResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 144;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 144;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetSockNameRequest = ::fidl::AnyZeroArgMessage;

  struct GetPeerNameResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::posix::socket::BaseSocket_GetPeerName_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_StreamSocketGetPeerNameResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_StreamSocketGetPeerNameResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 144;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 144;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetPeerNameRequest = ::fidl::AnyZeroArgMessage;

  struct SetSockOptResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::posix::socket::BaseSocket_SetSockOpt_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_StreamSocketSetSockOptResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_StreamSocketSetSockOptResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SetSockOptRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t level;
    int16_t optname;
    ::fidl::VectorView<uint8_t> optval;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_StreamSocketSetSockOptRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_StreamSocketSetSockOptRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 904;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 904;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SetSockOptResponse;
  };

  struct GetSockOptResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::posix::socket::BaseSocket_GetSockOpt_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_StreamSocketGetSockOptResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_StreamSocketGetSockOptResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 920;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 920;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct GetSockOptRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t level;
    int16_t optname;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_StreamSocketGetSockOptRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_StreamSocketGetSockOptRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = GetSockOptResponse;
  };

  struct ListenResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::posix::socket::StreamSocket_Listen_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_StreamSocketListenResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_StreamSocketListenResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct ListenRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t backlog;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_StreamSocketListenRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_StreamSocketListenRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = ListenResponse;
  };

  struct AcceptResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::posix::socket::StreamSocket_Accept_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_StreamSocketAcceptResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_StreamSocketAcceptResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct AcceptRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t flags;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_StreamSocketAcceptRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_StreamSocketAcceptRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = AcceptResponse;
  };


  struct EventHandlers {
    // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
    //
    // Indicates the success or failure of the open operation, and optionally describes the
    // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
    // (the same as would be returned by `Describe`).
    fit::callback<zx_status_t(int32_t s, ::llcpp::fuchsia::io::NodeInfo info)> on_open;

    // Fallback handler when an unknown ordinal is received.
    // Caller may put custom error handling logic here.
    fit::callback<zx_status_t()> unknown;
  };

  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    class Clone_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Clone_Impl(::zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object);
      ~Clone_Impl() = default;
      Clone_Impl(Clone_Impl&& other) = default;
      Clone_Impl& operator=(Clone_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class Close_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Close_Impl(::zx::unowned_channel _client_end);
      ~Close_Impl() = default;
      Close_Impl(Close_Impl&& other) = default;
      Close_Impl& operator=(Close_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Describe_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Describe_Impl(::zx::unowned_channel _client_end);
      ~Describe_Impl() = default;
      Describe_Impl(Describe_Impl&& other) = default;
      Describe_Impl& operator=(Describe_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Sync_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Sync_Impl(::zx::unowned_channel _client_end);
      ~Sync_Impl() = default;
      Sync_Impl(Sync_Impl&& other) = default;
      Sync_Impl& operator=(Sync_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetAttr_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetAttr_Impl(::zx::unowned_channel _client_end);
      ~GetAttr_Impl() = default;
      GetAttr_Impl(GetAttr_Impl&& other) = default;
      GetAttr_Impl& operator=(GetAttr_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetAttr_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      SetAttr_Impl(::zx::unowned_channel _client_end, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes);
      ~SetAttr_Impl() = default;
      SetAttr_Impl(SetAttr_Impl&& other) = default;
      SetAttr_Impl& operator=(SetAttr_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class NodeGetFlags_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      NodeGetFlags_Impl(::zx::unowned_channel _client_end);
      ~NodeGetFlags_Impl() = default;
      NodeGetFlags_Impl(NodeGetFlags_Impl&& other) = default;
      NodeGetFlags_Impl& operator=(NodeGetFlags_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class NodeSetFlags_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      NodeSetFlags_Impl(::zx::unowned_channel _client_end, uint32_t flags);
      ~NodeSetFlags_Impl() = default;
      NodeSetFlags_Impl(NodeSetFlags_Impl&& other) = default;
      NodeSetFlags_Impl& operator=(NodeSetFlags_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Bind_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Bind_Impl(::zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> addr);
      ~Bind_Impl() = default;
      Bind_Impl(Bind_Impl&& other) = default;
      Bind_Impl& operator=(Bind_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Connect_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Connect_Impl(::zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> addr);
      ~Connect_Impl() = default;
      Connect_Impl(Connect_Impl&& other) = default;
      Connect_Impl& operator=(Connect_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetSockName_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetSockName_Impl(::zx::unowned_channel _client_end);
      ~GetSockName_Impl() = default;
      GetSockName_Impl(GetSockName_Impl&& other) = default;
      GetSockName_Impl& operator=(GetSockName_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetPeerName_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetPeerName_Impl(::zx::unowned_channel _client_end);
      ~GetPeerName_Impl() = default;
      GetPeerName_Impl(GetPeerName_Impl&& other) = default;
      GetPeerName_Impl& operator=(GetPeerName_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetSockOpt_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      SetSockOpt_Impl(::zx::unowned_channel _client_end, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval);
      ~SetSockOpt_Impl() = default;
      SetSockOpt_Impl(SetSockOpt_Impl&& other) = default;
      SetSockOpt_Impl& operator=(SetSockOpt_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetSockOpt_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetSockOpt_Impl(::zx::unowned_channel _client_end, int16_t level, int16_t optname);
      ~GetSockOpt_Impl() = default;
      GetSockOpt_Impl(GetSockOpt_Impl&& other) = default;
      GetSockOpt_Impl& operator=(GetSockOpt_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Listen_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Listen_Impl(::zx::unowned_channel _client_end, int16_t backlog);
      ~Listen_Impl() = default;
      Listen_Impl(Listen_Impl&& other) = default;
      Listen_Impl& operator=(Listen_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Accept_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Accept_Impl(::zx::unowned_channel _client_end, int16_t flags);
      ~Accept_Impl() = default;
      Accept_Impl(Accept_Impl&& other) = default;
      Accept_Impl& operator=(Accept_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Clone = Clone_Impl;
    using Close = Close_Impl<CloseResponse>;
    using Describe = Describe_Impl<DescribeResponse>;
    using Sync = Sync_Impl<SyncResponse>;
    using GetAttr = GetAttr_Impl<GetAttrResponse>;
    using SetAttr = SetAttr_Impl<SetAttrResponse>;
    using NodeGetFlags = NodeGetFlags_Impl<NodeGetFlagsResponse>;
    using NodeSetFlags = NodeSetFlags_Impl<NodeSetFlagsResponse>;
    using Bind = Bind_Impl<BindResponse>;
    using Connect = Connect_Impl<ConnectResponse>;
    using GetSockName = GetSockName_Impl<GetSockNameResponse>;
    using GetPeerName = GetPeerName_Impl<GetPeerNameResponse>;
    using SetSockOpt = SetSockOpt_Impl<SetSockOptResponse>;
    using GetSockOpt = GetSockOpt_Impl<GetSockOptResponse>;
    using Listen = Listen_Impl<ListenResponse>;
    using Accept = Accept_Impl<AcceptResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    class Clone_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Clone_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);
      ~Clone_Impl() = default;
      Clone_Impl(Clone_Impl&& other) = default;
      Clone_Impl& operator=(Clone_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class Close_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Close_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Close_Impl() = default;
      Close_Impl(Close_Impl&& other) = default;
      Close_Impl& operator=(Close_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Describe_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Describe_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Describe_Impl() = default;
      Describe_Impl(Describe_Impl&& other) = default;
      Describe_Impl& operator=(Describe_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Sync_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Sync_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Sync_Impl() = default;
      Sync_Impl(Sync_Impl&& other) = default;
      Sync_Impl& operator=(Sync_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetAttr_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetAttr_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetAttr_Impl() = default;
      GetAttr_Impl(GetAttr_Impl&& other) = default;
      GetAttr_Impl& operator=(GetAttr_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetAttr_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      SetAttr_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer);
      ~SetAttr_Impl() = default;
      SetAttr_Impl(SetAttr_Impl&& other) = default;
      SetAttr_Impl& operator=(SetAttr_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class NodeGetFlags_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      NodeGetFlags_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~NodeGetFlags_Impl() = default;
      NodeGetFlags_Impl(NodeGetFlags_Impl&& other) = default;
      NodeGetFlags_Impl& operator=(NodeGetFlags_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class NodeSetFlags_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      NodeSetFlags_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer);
      ~NodeSetFlags_Impl() = default;
      NodeSetFlags_Impl(NodeSetFlags_Impl&& other) = default;
      NodeSetFlags_Impl& operator=(NodeSetFlags_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Bind_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Bind_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);
      ~Bind_Impl() = default;
      Bind_Impl(Bind_Impl&& other) = default;
      Bind_Impl& operator=(Bind_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Connect_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Connect_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);
      ~Connect_Impl() = default;
      Connect_Impl(Connect_Impl&& other) = default;
      Connect_Impl& operator=(Connect_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetSockName_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetSockName_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetSockName_Impl() = default;
      GetSockName_Impl(GetSockName_Impl&& other) = default;
      GetSockName_Impl& operator=(GetSockName_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetPeerName_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetPeerName_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetPeerName_Impl() = default;
      GetPeerName_Impl(GetPeerName_Impl&& other) = default;
      GetPeerName_Impl& operator=(GetPeerName_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetSockOpt_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      SetSockOpt_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, ::fidl::BytePart _response_buffer);
      ~SetSockOpt_Impl() = default;
      SetSockOpt_Impl(SetSockOpt_Impl&& other) = default;
      SetSockOpt_Impl& operator=(SetSockOpt_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetSockOpt_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetSockOpt_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::BytePart _response_buffer);
      ~GetSockOpt_Impl() = default;
      GetSockOpt_Impl(GetSockOpt_Impl&& other) = default;
      GetSockOpt_Impl& operator=(GetSockOpt_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Listen_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Listen_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t backlog, ::fidl::BytePart _response_buffer);
      ~Listen_Impl() = default;
      Listen_Impl(Listen_Impl&& other) = default;
      Listen_Impl& operator=(Listen_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Accept_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Accept_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t flags, ::fidl::BytePart _response_buffer);
      ~Accept_Impl() = default;
      Accept_Impl(Accept_Impl&& other) = default;
      Accept_Impl& operator=(Accept_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Clone = Clone_Impl;
    using Close = Close_Impl<CloseResponse>;
    using Describe = Describe_Impl<DescribeResponse>;
    using Sync = Sync_Impl<SyncResponse>;
    using GetAttr = GetAttr_Impl<GetAttrResponse>;
    using SetAttr = SetAttr_Impl<SetAttrResponse>;
    using NodeGetFlags = NodeGetFlags_Impl<NodeGetFlagsResponse>;
    using NodeSetFlags = NodeSetFlags_Impl<NodeSetFlagsResponse>;
    using Bind = Bind_Impl<BindResponse>;
    using Connect = Connect_Impl<ConnectResponse>;
    using GetSockName = GetSockName_Impl<GetSockNameResponse>;
    using GetPeerName = GetPeerName_Impl<GetPeerNameResponse>;
    using SetSockOpt = SetSockOpt_Impl<SetSockOptResponse>;
    using GetSockOpt = GetSockOpt_Impl<GetSockOptResponse>;
    using Listen = Listen_Impl<ListenResponse>;
    using Accept = Accept_Impl<AcceptResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    //
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with
    // `CLONE_FLAG_SAME_RIGHTS`.
    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Clone Clone(uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    //
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with
    // `CLONE_FLAG_SAME_RIGHTS`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Clone Clone(::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Close Close();

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Close Close(::fidl::BytePart _response_buffer);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Allocates 88 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Describe Describe();

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Describe Describe(::fidl::BytePart _response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Sync Sync();

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Sync Sync(::fidl::BytePart _response_buffer);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Allocates 96 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetAttr GetAttr();

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetAttr GetAttr(::fidl::BytePart _response_buffer);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Allocates 104 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::SetAttr SetAttr(uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetAttr SetAttr(::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer);

    // Acquires the `Directory.Open` rights and flags used to access this file.
    //
    // This method does not require any rights.
    // This method has the same functionality as GetFlags for File and is
    // meant as an in-progress replacement.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::NodeGetFlags NodeGetFlags();

    // Acquires the `Directory.Open` rights and flags used to access this file.
    //
    // This method does not require any rights.
    // This method has the same functionality as GetFlags for File and is
    // meant as an in-progress replacement.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::NodeGetFlags NodeGetFlags(::fidl::BytePart _response_buffer);

    // Changes the `Directory.Open` flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // This method has the same functionality as SetFlags for File and is
    // meant as an in-progress replacement.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::NodeSetFlags NodeSetFlags(uint32_t flags);

    // Changes the `Directory.Open` flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // This method has the same functionality as SetFlags for File and is
    // meant as an in-progress replacement.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::NodeSetFlags NodeSetFlags(::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer);

    // Sets the local address used for the socket.
    // Allocates 192 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Bind Bind(::fidl::VectorView<uint8_t> addr);

    // Sets the local address used for the socket.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Bind Bind(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);

    // Initiates a connection to a remote address.
    // Allocates 192 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Connect Connect(::fidl::VectorView<uint8_t> addr);

    // Initiates a connection to a remote address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Connect Connect(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);

    // Retrieves the local socket address.
    // Allocates 200 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetSockName GetSockName();

    // Retrieves the local socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetSockName GetSockName(::fidl::BytePart _response_buffer);

    // Retrieves the remote socket address.
    // Allocates 200 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetPeerName GetPeerName();

    // Retrieves the remote socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetPeerName GetPeerName(::fidl::BytePart _response_buffer);

    // Sets the value of a socket option.
    // Allocates 32 bytes of response buffer on the stack. Request is heap-allocated.
    ResultOf::SetSockOpt SetSockOpt(int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval);

    // Sets the value of a socket option.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetSockOpt SetSockOpt(::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, ::fidl::BytePart _response_buffer);

    // Retrieves the value of a socket option.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::GetSockOpt GetSockOpt(int16_t level, int16_t optname);

    // Retrieves the value of a socket option.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetSockOpt GetSockOpt(::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::BytePart _response_buffer);

    // Begins listening for new incoming connections. At most `backlog` connections will be
    // buffered.
    // Allocates 56 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Listen Listen(int16_t backlog);

    // Begins listening for new incoming connections. At most `backlog` connections will be
    // buffered.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Listen Listen(::fidl::BytePart _request_buffer, int16_t backlog, ::fidl::BytePart _response_buffer);

    // Accepts a buffered incoming connection.
    // Allocates 56 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Accept Accept(int16_t flags);

    // Accepts a buffered incoming connection.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Accept Accept(::fidl::BytePart _request_buffer, int16_t flags, ::fidl::BytePart _response_buffer);

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    zx_status_t HandleEvents(EventHandlers handlers);
   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    //
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with
    // `CLONE_FLAG_SAME_RIGHTS`.
    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Clone Clone(::zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    //
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with
    // `CLONE_FLAG_SAME_RIGHTS`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Clone Clone(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Close Close(::zx::unowned_channel _client_end);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Close Close(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Allocates 88 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Describe Describe(::zx::unowned_channel _client_end);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Describe Describe(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Sync Sync(::zx::unowned_channel _client_end);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Sync Sync(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Allocates 96 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetAttr GetAttr(::zx::unowned_channel _client_end);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetAttr GetAttr(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Allocates 104 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::SetAttr SetAttr(::zx::unowned_channel _client_end, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetAttr SetAttr(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer);

    // Acquires the `Directory.Open` rights and flags used to access this file.
    //
    // This method does not require any rights.
    // This method has the same functionality as GetFlags for File and is
    // meant as an in-progress replacement.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::NodeGetFlags NodeGetFlags(::zx::unowned_channel _client_end);

    // Acquires the `Directory.Open` rights and flags used to access this file.
    //
    // This method does not require any rights.
    // This method has the same functionality as GetFlags for File and is
    // meant as an in-progress replacement.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::NodeGetFlags NodeGetFlags(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Changes the `Directory.Open` flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // This method has the same functionality as SetFlags for File and is
    // meant as an in-progress replacement.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::NodeSetFlags NodeSetFlags(::zx::unowned_channel _client_end, uint32_t flags);

    // Changes the `Directory.Open` flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // This method has the same functionality as SetFlags for File and is
    // meant as an in-progress replacement.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::NodeSetFlags NodeSetFlags(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer);

    // Sets the local address used for the socket.
    // Allocates 192 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Bind Bind(::zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> addr);

    // Sets the local address used for the socket.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Bind Bind(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);

    // Initiates a connection to a remote address.
    // Allocates 192 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Connect Connect(::zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> addr);

    // Initiates a connection to a remote address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Connect Connect(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);

    // Retrieves the local socket address.
    // Allocates 200 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetSockName GetSockName(::zx::unowned_channel _client_end);

    // Retrieves the local socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetSockName GetSockName(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Retrieves the remote socket address.
    // Allocates 200 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetPeerName GetPeerName(::zx::unowned_channel _client_end);

    // Retrieves the remote socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetPeerName GetPeerName(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Sets the value of a socket option.
    // Allocates 32 bytes of response buffer on the stack. Request is heap-allocated.
    static ResultOf::SetSockOpt SetSockOpt(::zx::unowned_channel _client_end, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval);

    // Sets the value of a socket option.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetSockOpt SetSockOpt(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, ::fidl::BytePart _response_buffer);

    // Retrieves the value of a socket option.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::GetSockOpt GetSockOpt(::zx::unowned_channel _client_end, int16_t level, int16_t optname);

    // Retrieves the value of a socket option.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetSockOpt GetSockOpt(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::BytePart _response_buffer);

    // Begins listening for new incoming connections. At most `backlog` connections will be
    // buffered.
    // Allocates 56 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Listen Listen(::zx::unowned_channel _client_end, int16_t backlog);

    // Begins listening for new incoming connections. At most `backlog` connections will be
    // buffered.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Listen Listen(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t backlog, ::fidl::BytePart _response_buffer);

    // Accepts a buffered incoming connection.
    // Allocates 56 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Accept Accept(::zx::unowned_channel _client_end, int16_t flags);

    // Accepts a buffered incoming connection.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Accept Accept(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t flags, ::fidl::BytePart _response_buffer);

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    static zx_status_t HandleEvents(::zx::unowned_channel client_end, EventHandlers handlers);
  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    //
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with
    // `CLONE_FLAG_SAME_RIGHTS`.
    static ::fidl::internal::StatusAndError Clone(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<CloneRequest> params);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<CloseResponse> Close(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<DescribeResponse> Describe(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<SyncResponse> Sync(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<GetAttrResponse> GetAttr(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    static ::fidl::DecodeResult<SetAttrResponse> SetAttr(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetAttrRequest> params, ::fidl::BytePart response_buffer);

    // Acquires the `Directory.Open` rights and flags used to access this file.
    //
    // This method does not require any rights.
    // This method has the same functionality as GetFlags for File and is
    // meant as an in-progress replacement.
    static ::fidl::DecodeResult<NodeGetFlagsResponse> NodeGetFlags(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Changes the `Directory.Open` flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // This method has the same functionality as SetFlags for File and is
    // meant as an in-progress replacement.
    static ::fidl::DecodeResult<NodeSetFlagsResponse> NodeSetFlags(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<NodeSetFlagsRequest> params, ::fidl::BytePart response_buffer);

    // Sets the local address used for the socket.
    static ::fidl::DecodeResult<BindResponse> Bind(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<BindRequest> params, ::fidl::BytePart response_buffer);

    // Initiates a connection to a remote address.
    static ::fidl::DecodeResult<ConnectResponse> Connect(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ConnectRequest> params, ::fidl::BytePart response_buffer);

    // Retrieves the local socket address.
    static ::fidl::DecodeResult<GetSockNameResponse> GetSockName(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Retrieves the remote socket address.
    static ::fidl::DecodeResult<GetPeerNameResponse> GetPeerName(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Sets the value of a socket option.
    static ::fidl::DecodeResult<SetSockOptResponse> SetSockOpt(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetSockOptRequest> params, ::fidl::BytePart response_buffer);

    // Retrieves the value of a socket option.
    static ::fidl::DecodeResult<GetSockOptResponse> GetSockOpt(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetSockOptRequest> params, ::fidl::BytePart response_buffer);

    // Begins listening for new incoming connections. At most `backlog` connections will be
    // buffered.
    static ::fidl::DecodeResult<ListenResponse> Listen(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ListenRequest> params, ::fidl::BytePart response_buffer);

    // Accepts a buffered incoming connection.
    static ::fidl::DecodeResult<AcceptResponse> Accept(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<AcceptRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = StreamSocket;
    using _Base = ::fidl::CompleterBase;

    using CloneCompleter = ::fidl::Completer<>;

    virtual void Clone(uint32_t flags, ::zx::channel object, CloneCompleter::Sync _completer) = 0;

    class CloseCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<CloseResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using CloseCompleter = ::fidl::Completer<CloseCompleterBase>;

    virtual void Close(CloseCompleter::Sync _completer) = 0;

    class DescribeCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io::NodeInfo info);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io::NodeInfo info);
      void Reply(::fidl::DecodedMessage<DescribeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using DescribeCompleter = ::fidl::Completer<DescribeCompleterBase>;

    virtual void Describe(DescribeCompleter::Sync _completer) = 0;

    class SyncCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<SyncResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SyncCompleter = ::fidl::Completer<SyncCompleterBase>;

    virtual void Sync(SyncCompleter::Sync _completer) = 0;

    class GetAttrCompleterBase : public _Base {
     public:
      void Reply(int32_t s, ::llcpp::fuchsia::io::NodeAttributes attributes);
      void Reply(::fidl::BytePart _buffer, int32_t s, ::llcpp::fuchsia::io::NodeAttributes attributes);
      void Reply(::fidl::DecodedMessage<GetAttrResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetAttrCompleter = ::fidl::Completer<GetAttrCompleterBase>;

    virtual void GetAttr(GetAttrCompleter::Sync _completer) = 0;

    class SetAttrCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<SetAttrResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetAttrCompleter = ::fidl::Completer<SetAttrCompleterBase>;

    virtual void SetAttr(uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, SetAttrCompleter::Sync _completer) = 0;

    class NodeGetFlagsCompleterBase : public _Base {
     public:
      void Reply(int32_t s, uint32_t flags);
      void Reply(::fidl::BytePart _buffer, int32_t s, uint32_t flags);
      void Reply(::fidl::DecodedMessage<NodeGetFlagsResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using NodeGetFlagsCompleter = ::fidl::Completer<NodeGetFlagsCompleterBase>;

    virtual void NodeGetFlags(NodeGetFlagsCompleter::Sync _completer) { _completer.Close(ZX_ERR_NOT_SUPPORTED); }

    class NodeSetFlagsCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<NodeSetFlagsResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using NodeSetFlagsCompleter = ::fidl::Completer<NodeSetFlagsCompleterBase>;

    virtual void NodeSetFlags(uint32_t flags, NodeSetFlagsCompleter::Sync _completer) { _completer.Close(ZX_ERR_NOT_SUPPORTED); }

    class BindCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::posix::socket::BaseSocket_Bind_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::posix::socket::BaseSocket_Bind_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<BindResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using BindCompleter = ::fidl::Completer<BindCompleterBase>;

    virtual void Bind(::fidl::VectorView<uint8_t> addr, BindCompleter::Sync _completer) = 0;

    class ConnectCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::posix::socket::BaseSocket_Connect_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::posix::socket::BaseSocket_Connect_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<ConnectResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ConnectCompleter = ::fidl::Completer<ConnectCompleterBase>;

    virtual void Connect(::fidl::VectorView<uint8_t> addr, ConnectCompleter::Sync _completer) = 0;

    class GetSockNameCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::posix::socket::BaseSocket_GetSockName_Result result);
      void ReplySuccess(::fidl::VectorView<uint8_t> addr);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::posix::socket::BaseSocket_GetSockName_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, ::fidl::VectorView<uint8_t> addr);
      void Reply(::fidl::DecodedMessage<GetSockNameResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetSockNameCompleter = ::fidl::Completer<GetSockNameCompleterBase>;

    virtual void GetSockName(GetSockNameCompleter::Sync _completer) = 0;

    class GetPeerNameCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::posix::socket::BaseSocket_GetPeerName_Result result);
      void ReplySuccess(::fidl::VectorView<uint8_t> addr);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::posix::socket::BaseSocket_GetPeerName_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, ::fidl::VectorView<uint8_t> addr);
      void Reply(::fidl::DecodedMessage<GetPeerNameResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetPeerNameCompleter = ::fidl::Completer<GetPeerNameCompleterBase>;

    virtual void GetPeerName(GetPeerNameCompleter::Sync _completer) = 0;

    class SetSockOptCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::posix::socket::BaseSocket_SetSockOpt_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::posix::socket::BaseSocket_SetSockOpt_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<SetSockOptResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetSockOptCompleter = ::fidl::Completer<SetSockOptCompleterBase>;

    virtual void SetSockOpt(int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, SetSockOptCompleter::Sync _completer) = 0;

    class GetSockOptCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::posix::socket::BaseSocket_GetSockOpt_Result result);
      void ReplySuccess(::fidl::VectorView<uint8_t> optval);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::posix::socket::BaseSocket_GetSockOpt_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, ::fidl::VectorView<uint8_t> optval);
      void Reply(::fidl::DecodedMessage<GetSockOptResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetSockOptCompleter = ::fidl::Completer<GetSockOptCompleterBase>;

    virtual void GetSockOpt(int16_t level, int16_t optname, GetSockOptCompleter::Sync _completer) = 0;

    class ListenCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::posix::socket::StreamSocket_Listen_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::posix::socket::StreamSocket_Listen_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<ListenResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ListenCompleter = ::fidl::Completer<ListenCompleterBase>;

    virtual void Listen(int16_t backlog, ListenCompleter::Sync _completer) = 0;

    class AcceptCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::posix::socket::StreamSocket_Accept_Result result);
      void ReplySuccess(::zx::channel s);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::posix::socket::StreamSocket_Accept_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, ::zx::channel s);
      void Reply(::fidl::DecodedMessage<AcceptResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using AcceptCompleter = ::fidl::Completer<AcceptCompleterBase>;

    virtual void Accept(int16_t flags, AcceptCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

  // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
  // (the same as would be returned by `Describe`).
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, int32_t s, ::llcpp::fuchsia::io::NodeInfo info);

  // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
  // (the same as would be returned by `Describe`).
  // Caller provides the backing storage for FIDL message via response buffers.
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, int32_t s, ::llcpp::fuchsia::io::NodeInfo info);

  // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
  // (the same as would be returned by `Describe`).
  // Messages are encoded in-place.
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnOpenResponse> params);


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void CloneRequest(const ::fidl::DecodedMessage<StreamSocket::CloneRequest>& _msg);
    static void CloseRequest(const ::fidl::DecodedMessage<StreamSocket::CloseRequest>& _msg);
    static void CloseResponse(const ::fidl::DecodedMessage<StreamSocket::CloseResponse>& _msg);
    static void DescribeRequest(const ::fidl::DecodedMessage<StreamSocket::DescribeRequest>& _msg);
    static void DescribeResponse(const ::fidl::DecodedMessage<StreamSocket::DescribeResponse>& _msg);
    static void OnOpenResponse(const ::fidl::DecodedMessage<StreamSocket::OnOpenResponse>& _msg);
    static void SyncRequest(const ::fidl::DecodedMessage<StreamSocket::SyncRequest>& _msg);
    static void SyncResponse(const ::fidl::DecodedMessage<StreamSocket::SyncResponse>& _msg);
    static void GetAttrRequest(const ::fidl::DecodedMessage<StreamSocket::GetAttrRequest>& _msg);
    static void GetAttrResponse(const ::fidl::DecodedMessage<StreamSocket::GetAttrResponse>& _msg);
    static void SetAttrRequest(const ::fidl::DecodedMessage<StreamSocket::SetAttrRequest>& _msg);
    static void SetAttrResponse(const ::fidl::DecodedMessage<StreamSocket::SetAttrResponse>& _msg);
    static void NodeGetFlagsRequest(const ::fidl::DecodedMessage<StreamSocket::NodeGetFlagsRequest>& _msg);
    static void NodeGetFlagsResponse(const ::fidl::DecodedMessage<StreamSocket::NodeGetFlagsResponse>& _msg);
    static void NodeSetFlagsRequest(const ::fidl::DecodedMessage<StreamSocket::NodeSetFlagsRequest>& _msg);
    static void NodeSetFlagsResponse(const ::fidl::DecodedMessage<StreamSocket::NodeSetFlagsResponse>& _msg);
    static void BindRequest(const ::fidl::DecodedMessage<StreamSocket::BindRequest>& _msg);
    static void BindResponse(const ::fidl::DecodedMessage<StreamSocket::BindResponse>& _msg);
    static void ConnectRequest(const ::fidl::DecodedMessage<StreamSocket::ConnectRequest>& _msg);
    static void ConnectResponse(const ::fidl::DecodedMessage<StreamSocket::ConnectResponse>& _msg);
    static void GetSockNameRequest(const ::fidl::DecodedMessage<StreamSocket::GetSockNameRequest>& _msg);
    static void GetSockNameResponse(const ::fidl::DecodedMessage<StreamSocket::GetSockNameResponse>& _msg);
    static void GetPeerNameRequest(const ::fidl::DecodedMessage<StreamSocket::GetPeerNameRequest>& _msg);
    static void GetPeerNameResponse(const ::fidl::DecodedMessage<StreamSocket::GetPeerNameResponse>& _msg);
    static void SetSockOptRequest(const ::fidl::DecodedMessage<StreamSocket::SetSockOptRequest>& _msg);
    static void SetSockOptResponse(const ::fidl::DecodedMessage<StreamSocket::SetSockOptResponse>& _msg);
    static void GetSockOptRequest(const ::fidl::DecodedMessage<StreamSocket::GetSockOptRequest>& _msg);
    static void GetSockOptResponse(const ::fidl::DecodedMessage<StreamSocket::GetSockOptResponse>& _msg);
    static void ListenRequest(const ::fidl::DecodedMessage<StreamSocket::ListenRequest>& _msg);
    static void ListenResponse(const ::fidl::DecodedMessage<StreamSocket::ListenResponse>& _msg);
    static void AcceptRequest(const ::fidl::DecodedMessage<StreamSocket::AcceptRequest>& _msg);
    static void AcceptResponse(const ::fidl::DecodedMessage<StreamSocket::AcceptResponse>& _msg);
  };
};

extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketCloneRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketCloneRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketCloneResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketCloneResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketCloseRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketCloseRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketCloseResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketCloseResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketDescribeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketDescribeRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketDescribeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketDescribeResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketOnOpenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketOnOpenRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketOnOpenEventTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketOnOpenEventTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketSyncRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketSyncRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketSyncResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketSyncResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketGetAttrRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketGetAttrRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketGetAttrResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketGetAttrResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketSetAttrRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketSetAttrRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketSetAttrResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketSetAttrResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketNodeGetFlagsRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketNodeGetFlagsRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketNodeGetFlagsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketNodeGetFlagsResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketNodeSetFlagsRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketNodeSetFlagsRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketNodeSetFlagsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketNodeSetFlagsResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketBindRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketBindRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketBindResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketBindResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketConnectRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketConnectRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketConnectResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketConnectResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketGetSockNameRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketGetSockNameRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketGetSockNameResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketGetSockNameResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketGetPeerNameRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketGetPeerNameRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketGetPeerNameResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketGetPeerNameResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketSetSockOptRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketSetSockOptRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketSetSockOptResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketSetSockOptResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketGetSockOptRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketGetSockOptRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketGetSockOptResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketGetSockOptResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketShutdownRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketShutdownRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketShutdownResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketShutdownResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketRecvMsgRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketRecvMsgRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketRecvMsgResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketRecvMsgResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketSendMsgRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketSendMsgRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_DatagramSocketSendMsgResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_DatagramSocketSendMsgResponseTable;

// A datagram socket.
//
// This type's [`fuchsia.io.Node/Describe`] method returns an eventpair which is used to signal
// additional information about the state of the socket such as readiness or shutdown-ness.
//
// All methods on this type are nonblocking; their exact behaviors match their Linux counterparts.
class DatagramSocket final {
  DatagramSocket() = delete;
 public:

  struct CloneRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;
    ::zx::channel object;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_DatagramSocketCloneRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_DatagramSocketCloneRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct CloseResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_DatagramSocketCloseResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_DatagramSocketCloseResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using CloseRequest = ::fidl::AnyZeroArgMessage;

  struct DescribeResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io::NodeInfo info;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_DatagramSocketDescribeResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_DatagramSocketDescribeResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 24;
    static constexpr uint32_t AltPrimarySize = 48;
    static constexpr uint32_t AltMaxOutOfLine = 24;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using DescribeRequest = ::fidl::AnyZeroArgMessage;

  struct OnOpenResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::llcpp::fuchsia::io::NodeInfo info;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_DatagramSocketOnOpenEventTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_DatagramSocketOnOpenEventTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 24;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 24;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SyncResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_DatagramSocketSyncResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_DatagramSocketSyncResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using SyncRequest = ::fidl::AnyZeroArgMessage;

  struct GetAttrResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::llcpp::fuchsia::io::NodeAttributes attributes;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_DatagramSocketGetAttrResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_DatagramSocketGetAttrResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 80;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 80;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetAttrRequest = ::fidl::AnyZeroArgMessage;

  struct SetAttrResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_DatagramSocketSetAttrResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_DatagramSocketSetAttrResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SetAttrRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;
    ::llcpp::fuchsia::io::NodeAttributes attributes;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_DatagramSocketSetAttrRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_DatagramSocketSetAttrRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 80;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 80;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SetAttrResponse;
  };

  struct NodeGetFlagsResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    uint32_t flags;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_DatagramSocketNodeGetFlagsResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_DatagramSocketNodeGetFlagsResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using NodeGetFlagsRequest = ::fidl::AnyZeroArgMessage;

  struct NodeSetFlagsResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_DatagramSocketNodeSetFlagsResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_DatagramSocketNodeSetFlagsResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct NodeSetFlagsRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_DatagramSocketNodeSetFlagsRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_DatagramSocketNodeSetFlagsRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = NodeSetFlagsResponse;
  };

  struct BindResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::posix::socket::BaseSocket_Bind_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_DatagramSocketBindResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_DatagramSocketBindResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct BindRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::VectorView<uint8_t> addr;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_DatagramSocketBindRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_DatagramSocketBindRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 128;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 128;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = BindResponse;
  };

  struct ConnectResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::posix::socket::BaseSocket_Connect_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_DatagramSocketConnectResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_DatagramSocketConnectResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct ConnectRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::VectorView<uint8_t> addr;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_DatagramSocketConnectRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_DatagramSocketConnectRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 128;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 128;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = ConnectResponse;
  };

  struct GetSockNameResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::posix::socket::BaseSocket_GetSockName_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_DatagramSocketGetSockNameResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_DatagramSocketGetSockNameResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 144;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 144;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetSockNameRequest = ::fidl::AnyZeroArgMessage;

  struct GetPeerNameResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::posix::socket::BaseSocket_GetPeerName_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_DatagramSocketGetPeerNameResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_DatagramSocketGetPeerNameResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 144;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 144;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetPeerNameRequest = ::fidl::AnyZeroArgMessage;

  struct SetSockOptResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::posix::socket::BaseSocket_SetSockOpt_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_DatagramSocketSetSockOptResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_DatagramSocketSetSockOptResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SetSockOptRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t level;
    int16_t optname;
    ::fidl::VectorView<uint8_t> optval;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_DatagramSocketSetSockOptRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_DatagramSocketSetSockOptRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 904;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 904;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SetSockOptResponse;
  };

  struct GetSockOptResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::posix::socket::BaseSocket_GetSockOpt_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_DatagramSocketGetSockOptResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_DatagramSocketGetSockOptResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 920;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 920;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct GetSockOptRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t level;
    int16_t optname;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_DatagramSocketGetSockOptRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_DatagramSocketGetSockOptRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = GetSockOptResponse;
  };

  struct ShutdownResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::posix::socket::DatagramSocket_Shutdown_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_DatagramSocketShutdownResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_DatagramSocketShutdownResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct ShutdownRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t how;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_DatagramSocketShutdownRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_DatagramSocketShutdownRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = ShutdownResponse;
  };

  struct RecvMsgResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::posix::socket::DatagramSocket_RecvMsg_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_DatagramSocketRecvMsgResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_DatagramSocketRecvMsgResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 4294967295;
    static constexpr uint32_t AltPrimarySize = 80;
    static constexpr uint32_t AltMaxOutOfLine = 4294967295;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct RecvMsgRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t addr_len;
    uint32_t data_len;
    uint32_t control_len;
    int16_t flags;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_DatagramSocketRecvMsgRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_DatagramSocketRecvMsgRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = RecvMsgResponse;
  };

  struct SendMsgResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::posix::socket::DatagramSocket_SendMsg_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_DatagramSocketSendMsgResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_DatagramSocketSendMsgResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SendMsgRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::VectorView<uint8_t> addr;
    ::fidl::VectorView<::fidl::VectorView<uint8_t>> data;
    ::fidl::VectorView<uint8_t> control;
    int16_t flags;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_posix_socket_DatagramSocketSendMsgRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_posix_socket_DatagramSocketSendMsgRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 72;
    static constexpr uint32_t MaxOutOfLine = 4294967295;
    static constexpr uint32_t AltPrimarySize = 72;
    static constexpr uint32_t AltMaxOutOfLine = 4294967295;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SendMsgResponse;
  };


  struct EventHandlers {
    // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
    //
    // Indicates the success or failure of the open operation, and optionally describes the
    // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
    // (the same as would be returned by `Describe`).
    fit::callback<zx_status_t(int32_t s, ::llcpp::fuchsia::io::NodeInfo info)> on_open;

    // Fallback handler when an unknown ordinal is received.
    // Caller may put custom error handling logic here.
    fit::callback<zx_status_t()> unknown;
  };

  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    class Clone_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Clone_Impl(::zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object);
      ~Clone_Impl() = default;
      Clone_Impl(Clone_Impl&& other) = default;
      Clone_Impl& operator=(Clone_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class Close_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Close_Impl(::zx::unowned_channel _client_end);
      ~Close_Impl() = default;
      Close_Impl(Close_Impl&& other) = default;
      Close_Impl& operator=(Close_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Describe_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Describe_Impl(::zx::unowned_channel _client_end);
      ~Describe_Impl() = default;
      Describe_Impl(Describe_Impl&& other) = default;
      Describe_Impl& operator=(Describe_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Sync_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Sync_Impl(::zx::unowned_channel _client_end);
      ~Sync_Impl() = default;
      Sync_Impl(Sync_Impl&& other) = default;
      Sync_Impl& operator=(Sync_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetAttr_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetAttr_Impl(::zx::unowned_channel _client_end);
      ~GetAttr_Impl() = default;
      GetAttr_Impl(GetAttr_Impl&& other) = default;
      GetAttr_Impl& operator=(GetAttr_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetAttr_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      SetAttr_Impl(::zx::unowned_channel _client_end, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes);
      ~SetAttr_Impl() = default;
      SetAttr_Impl(SetAttr_Impl&& other) = default;
      SetAttr_Impl& operator=(SetAttr_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class NodeGetFlags_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      NodeGetFlags_Impl(::zx::unowned_channel _client_end);
      ~NodeGetFlags_Impl() = default;
      NodeGetFlags_Impl(NodeGetFlags_Impl&& other) = default;
      NodeGetFlags_Impl& operator=(NodeGetFlags_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class NodeSetFlags_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      NodeSetFlags_Impl(::zx::unowned_channel _client_end, uint32_t flags);
      ~NodeSetFlags_Impl() = default;
      NodeSetFlags_Impl(NodeSetFlags_Impl&& other) = default;
      NodeSetFlags_Impl& operator=(NodeSetFlags_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Bind_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Bind_Impl(::zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> addr);
      ~Bind_Impl() = default;
      Bind_Impl(Bind_Impl&& other) = default;
      Bind_Impl& operator=(Bind_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Connect_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Connect_Impl(::zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> addr);
      ~Connect_Impl() = default;
      Connect_Impl(Connect_Impl&& other) = default;
      Connect_Impl& operator=(Connect_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetSockName_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetSockName_Impl(::zx::unowned_channel _client_end);
      ~GetSockName_Impl() = default;
      GetSockName_Impl(GetSockName_Impl&& other) = default;
      GetSockName_Impl& operator=(GetSockName_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetPeerName_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetPeerName_Impl(::zx::unowned_channel _client_end);
      ~GetPeerName_Impl() = default;
      GetPeerName_Impl(GetPeerName_Impl&& other) = default;
      GetPeerName_Impl& operator=(GetPeerName_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetSockOpt_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      SetSockOpt_Impl(::zx::unowned_channel _client_end, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval);
      ~SetSockOpt_Impl() = default;
      SetSockOpt_Impl(SetSockOpt_Impl&& other) = default;
      SetSockOpt_Impl& operator=(SetSockOpt_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetSockOpt_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetSockOpt_Impl(::zx::unowned_channel _client_end, int16_t level, int16_t optname);
      ~GetSockOpt_Impl() = default;
      GetSockOpt_Impl(GetSockOpt_Impl&& other) = default;
      GetSockOpt_Impl& operator=(GetSockOpt_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Shutdown_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Shutdown_Impl(::zx::unowned_channel _client_end, int16_t how);
      ~Shutdown_Impl() = default;
      Shutdown_Impl(Shutdown_Impl&& other) = default;
      Shutdown_Impl& operator=(Shutdown_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class RecvMsg_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      RecvMsg_Impl(::zx::unowned_channel _client_end, uint32_t addr_len, uint32_t data_len, uint32_t control_len, int16_t flags);
      ~RecvMsg_Impl() = default;
      RecvMsg_Impl(RecvMsg_Impl&& other) = default;
      RecvMsg_Impl& operator=(RecvMsg_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SendMsg_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      SendMsg_Impl(::zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> addr, ::fidl::VectorView<::fidl::VectorView<uint8_t>> data, ::fidl::VectorView<uint8_t> control, int16_t flags);
      ~SendMsg_Impl() = default;
      SendMsg_Impl(SendMsg_Impl&& other) = default;
      SendMsg_Impl& operator=(SendMsg_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Clone = Clone_Impl;
    using Close = Close_Impl<CloseResponse>;
    using Describe = Describe_Impl<DescribeResponse>;
    using Sync = Sync_Impl<SyncResponse>;
    using GetAttr = GetAttr_Impl<GetAttrResponse>;
    using SetAttr = SetAttr_Impl<SetAttrResponse>;
    using NodeGetFlags = NodeGetFlags_Impl<NodeGetFlagsResponse>;
    using NodeSetFlags = NodeSetFlags_Impl<NodeSetFlagsResponse>;
    using Bind = Bind_Impl<BindResponse>;
    using Connect = Connect_Impl<ConnectResponse>;
    using GetSockName = GetSockName_Impl<GetSockNameResponse>;
    using GetPeerName = GetPeerName_Impl<GetPeerNameResponse>;
    using SetSockOpt = SetSockOpt_Impl<SetSockOptResponse>;
    using GetSockOpt = GetSockOpt_Impl<GetSockOptResponse>;
    using Shutdown = Shutdown_Impl<ShutdownResponse>;
    using RecvMsg = RecvMsg_Impl<RecvMsgResponse>;
    using SendMsg = SendMsg_Impl<SendMsgResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    class Clone_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Clone_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);
      ~Clone_Impl() = default;
      Clone_Impl(Clone_Impl&& other) = default;
      Clone_Impl& operator=(Clone_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class Close_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Close_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Close_Impl() = default;
      Close_Impl(Close_Impl&& other) = default;
      Close_Impl& operator=(Close_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Describe_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Describe_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Describe_Impl() = default;
      Describe_Impl(Describe_Impl&& other) = default;
      Describe_Impl& operator=(Describe_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Sync_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Sync_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Sync_Impl() = default;
      Sync_Impl(Sync_Impl&& other) = default;
      Sync_Impl& operator=(Sync_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetAttr_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetAttr_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetAttr_Impl() = default;
      GetAttr_Impl(GetAttr_Impl&& other) = default;
      GetAttr_Impl& operator=(GetAttr_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetAttr_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      SetAttr_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer);
      ~SetAttr_Impl() = default;
      SetAttr_Impl(SetAttr_Impl&& other) = default;
      SetAttr_Impl& operator=(SetAttr_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class NodeGetFlags_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      NodeGetFlags_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~NodeGetFlags_Impl() = default;
      NodeGetFlags_Impl(NodeGetFlags_Impl&& other) = default;
      NodeGetFlags_Impl& operator=(NodeGetFlags_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class NodeSetFlags_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      NodeSetFlags_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer);
      ~NodeSetFlags_Impl() = default;
      NodeSetFlags_Impl(NodeSetFlags_Impl&& other) = default;
      NodeSetFlags_Impl& operator=(NodeSetFlags_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Bind_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Bind_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);
      ~Bind_Impl() = default;
      Bind_Impl(Bind_Impl&& other) = default;
      Bind_Impl& operator=(Bind_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Connect_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Connect_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);
      ~Connect_Impl() = default;
      Connect_Impl(Connect_Impl&& other) = default;
      Connect_Impl& operator=(Connect_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetSockName_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetSockName_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetSockName_Impl() = default;
      GetSockName_Impl(GetSockName_Impl&& other) = default;
      GetSockName_Impl& operator=(GetSockName_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetPeerName_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetPeerName_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetPeerName_Impl() = default;
      GetPeerName_Impl(GetPeerName_Impl&& other) = default;
      GetPeerName_Impl& operator=(GetPeerName_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetSockOpt_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      SetSockOpt_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, ::fidl::BytePart _response_buffer);
      ~SetSockOpt_Impl() = default;
      SetSockOpt_Impl(SetSockOpt_Impl&& other) = default;
      SetSockOpt_Impl& operator=(SetSockOpt_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetSockOpt_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetSockOpt_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::BytePart _response_buffer);
      ~GetSockOpt_Impl() = default;
      GetSockOpt_Impl(GetSockOpt_Impl&& other) = default;
      GetSockOpt_Impl& operator=(GetSockOpt_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Shutdown_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Shutdown_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t how, ::fidl::BytePart _response_buffer);
      ~Shutdown_Impl() = default;
      Shutdown_Impl(Shutdown_Impl&& other) = default;
      Shutdown_Impl& operator=(Shutdown_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class RecvMsg_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      RecvMsg_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t addr_len, uint32_t data_len, uint32_t control_len, int16_t flags, ::fidl::BytePart _response_buffer);
      ~RecvMsg_Impl() = default;
      RecvMsg_Impl(RecvMsg_Impl&& other) = default;
      RecvMsg_Impl& operator=(RecvMsg_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SendMsg_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      SendMsg_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::VectorView<::fidl::VectorView<uint8_t>> data, ::fidl::VectorView<uint8_t> control, int16_t flags, ::fidl::BytePart _response_buffer);
      ~SendMsg_Impl() = default;
      SendMsg_Impl(SendMsg_Impl&& other) = default;
      SendMsg_Impl& operator=(SendMsg_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Clone = Clone_Impl;
    using Close = Close_Impl<CloseResponse>;
    using Describe = Describe_Impl<DescribeResponse>;
    using Sync = Sync_Impl<SyncResponse>;
    using GetAttr = GetAttr_Impl<GetAttrResponse>;
    using SetAttr = SetAttr_Impl<SetAttrResponse>;
    using NodeGetFlags = NodeGetFlags_Impl<NodeGetFlagsResponse>;
    using NodeSetFlags = NodeSetFlags_Impl<NodeSetFlagsResponse>;
    using Bind = Bind_Impl<BindResponse>;
    using Connect = Connect_Impl<ConnectResponse>;
    using GetSockName = GetSockName_Impl<GetSockNameResponse>;
    using GetPeerName = GetPeerName_Impl<GetPeerNameResponse>;
    using SetSockOpt = SetSockOpt_Impl<SetSockOptResponse>;
    using GetSockOpt = GetSockOpt_Impl<GetSockOptResponse>;
    using Shutdown = Shutdown_Impl<ShutdownResponse>;
    using RecvMsg = RecvMsg_Impl<RecvMsgResponse>;
    using SendMsg = SendMsg_Impl<SendMsgResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    //
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with
    // `CLONE_FLAG_SAME_RIGHTS`.
    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Clone Clone(uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    //
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with
    // `CLONE_FLAG_SAME_RIGHTS`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Clone Clone(::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Close Close();

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Close Close(::fidl::BytePart _response_buffer);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Allocates 88 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Describe Describe();

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Describe Describe(::fidl::BytePart _response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Sync Sync();

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Sync Sync(::fidl::BytePart _response_buffer);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Allocates 96 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetAttr GetAttr();

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetAttr GetAttr(::fidl::BytePart _response_buffer);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Allocates 104 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::SetAttr SetAttr(uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetAttr SetAttr(::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer);

    // Acquires the `Directory.Open` rights and flags used to access this file.
    //
    // This method does not require any rights.
    // This method has the same functionality as GetFlags for File and is
    // meant as an in-progress replacement.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::NodeGetFlags NodeGetFlags();

    // Acquires the `Directory.Open` rights and flags used to access this file.
    //
    // This method does not require any rights.
    // This method has the same functionality as GetFlags for File and is
    // meant as an in-progress replacement.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::NodeGetFlags NodeGetFlags(::fidl::BytePart _response_buffer);

    // Changes the `Directory.Open` flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // This method has the same functionality as SetFlags for File and is
    // meant as an in-progress replacement.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::NodeSetFlags NodeSetFlags(uint32_t flags);

    // Changes the `Directory.Open` flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // This method has the same functionality as SetFlags for File and is
    // meant as an in-progress replacement.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::NodeSetFlags NodeSetFlags(::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer);

    // Sets the local address used for the socket.
    // Allocates 192 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Bind Bind(::fidl::VectorView<uint8_t> addr);

    // Sets the local address used for the socket.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Bind Bind(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);

    // Initiates a connection to a remote address.
    // Allocates 192 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Connect Connect(::fidl::VectorView<uint8_t> addr);

    // Initiates a connection to a remote address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Connect Connect(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);

    // Retrieves the local socket address.
    // Allocates 200 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetSockName GetSockName();

    // Retrieves the local socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetSockName GetSockName(::fidl::BytePart _response_buffer);

    // Retrieves the remote socket address.
    // Allocates 200 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetPeerName GetPeerName();

    // Retrieves the remote socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetPeerName GetPeerName(::fidl::BytePart _response_buffer);

    // Sets the value of a socket option.
    // Allocates 32 bytes of response buffer on the stack. Request is heap-allocated.
    ResultOf::SetSockOpt SetSockOpt(int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval);

    // Sets the value of a socket option.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetSockOpt SetSockOpt(::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, ::fidl::BytePart _response_buffer);

    // Retrieves the value of a socket option.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::GetSockOpt GetSockOpt(int16_t level, int16_t optname);

    // Retrieves the value of a socket option.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetSockOpt GetSockOpt(::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::BytePart _response_buffer);

    // Shuts down part of the socket.
    // Allocates 56 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Shutdown Shutdown(int16_t how);

    // Shuts down part of the socket.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Shutdown Shutdown(::fidl::BytePart _request_buffer, int16_t how, ::fidl::BytePart _response_buffer);

    // Receives a message from the socket.
    // Allocates 32 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::RecvMsg RecvMsg(uint32_t addr_len, uint32_t data_len, uint32_t control_len, int16_t flags);

    // Receives a message from the socket.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::RecvMsg RecvMsg(::fidl::BytePart _request_buffer, uint32_t addr_len, uint32_t data_len, uint32_t control_len, int16_t flags, ::fidl::BytePart _response_buffer);

    // Sends a message on the socket.
    // Allocates 40 bytes of response buffer on the stack. Request is heap-allocated.
    ResultOf::SendMsg SendMsg(::fidl::VectorView<uint8_t> addr, ::fidl::VectorView<::fidl::VectorView<uint8_t>> data, ::fidl::VectorView<uint8_t> control, int16_t flags);

    // Sends a message on the socket.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SendMsg SendMsg(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::VectorView<::fidl::VectorView<uint8_t>> data, ::fidl::VectorView<uint8_t> control, int16_t flags, ::fidl::BytePart _response_buffer);

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    zx_status_t HandleEvents(EventHandlers handlers);
   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    //
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with
    // `CLONE_FLAG_SAME_RIGHTS`.
    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Clone Clone(::zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    //
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with
    // `CLONE_FLAG_SAME_RIGHTS`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Clone Clone(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Close Close(::zx::unowned_channel _client_end);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Close Close(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Allocates 88 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Describe Describe(::zx::unowned_channel _client_end);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Describe Describe(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Sync Sync(::zx::unowned_channel _client_end);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Sync Sync(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Allocates 96 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetAttr GetAttr(::zx::unowned_channel _client_end);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetAttr GetAttr(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Allocates 104 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::SetAttr SetAttr(::zx::unowned_channel _client_end, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetAttr SetAttr(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer);

    // Acquires the `Directory.Open` rights and flags used to access this file.
    //
    // This method does not require any rights.
    // This method has the same functionality as GetFlags for File and is
    // meant as an in-progress replacement.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::NodeGetFlags NodeGetFlags(::zx::unowned_channel _client_end);

    // Acquires the `Directory.Open` rights and flags used to access this file.
    //
    // This method does not require any rights.
    // This method has the same functionality as GetFlags for File and is
    // meant as an in-progress replacement.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::NodeGetFlags NodeGetFlags(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Changes the `Directory.Open` flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // This method has the same functionality as SetFlags for File and is
    // meant as an in-progress replacement.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::NodeSetFlags NodeSetFlags(::zx::unowned_channel _client_end, uint32_t flags);

    // Changes the `Directory.Open` flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // This method has the same functionality as SetFlags for File and is
    // meant as an in-progress replacement.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::NodeSetFlags NodeSetFlags(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer);

    // Sets the local address used for the socket.
    // Allocates 192 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Bind Bind(::zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> addr);

    // Sets the local address used for the socket.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Bind Bind(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);

    // Initiates a connection to a remote address.
    // Allocates 192 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Connect Connect(::zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> addr);

    // Initiates a connection to a remote address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Connect Connect(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);

    // Retrieves the local socket address.
    // Allocates 200 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetSockName GetSockName(::zx::unowned_channel _client_end);

    // Retrieves the local socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetSockName GetSockName(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Retrieves the remote socket address.
    // Allocates 200 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetPeerName GetPeerName(::zx::unowned_channel _client_end);

    // Retrieves the remote socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetPeerName GetPeerName(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Sets the value of a socket option.
    // Allocates 32 bytes of response buffer on the stack. Request is heap-allocated.
    static ResultOf::SetSockOpt SetSockOpt(::zx::unowned_channel _client_end, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval);

    // Sets the value of a socket option.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetSockOpt SetSockOpt(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, ::fidl::BytePart _response_buffer);

    // Retrieves the value of a socket option.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::GetSockOpt GetSockOpt(::zx::unowned_channel _client_end, int16_t level, int16_t optname);

    // Retrieves the value of a socket option.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetSockOpt GetSockOpt(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::BytePart _response_buffer);

    // Shuts down part of the socket.
    // Allocates 56 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Shutdown Shutdown(::zx::unowned_channel _client_end, int16_t how);

    // Shuts down part of the socket.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Shutdown Shutdown(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t how, ::fidl::BytePart _response_buffer);

    // Receives a message from the socket.
    // Allocates 32 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::RecvMsg RecvMsg(::zx::unowned_channel _client_end, uint32_t addr_len, uint32_t data_len, uint32_t control_len, int16_t flags);

    // Receives a message from the socket.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::RecvMsg RecvMsg(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t addr_len, uint32_t data_len, uint32_t control_len, int16_t flags, ::fidl::BytePart _response_buffer);

    // Sends a message on the socket.
    // Allocates 40 bytes of response buffer on the stack. Request is heap-allocated.
    static ResultOf::SendMsg SendMsg(::zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> addr, ::fidl::VectorView<::fidl::VectorView<uint8_t>> data, ::fidl::VectorView<uint8_t> control, int16_t flags);

    // Sends a message on the socket.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SendMsg SendMsg(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::VectorView<::fidl::VectorView<uint8_t>> data, ::fidl::VectorView<uint8_t> control, int16_t flags, ::fidl::BytePart _response_buffer);

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    static zx_status_t HandleEvents(::zx::unowned_channel client_end, EventHandlers handlers);
  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    //
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with
    // `CLONE_FLAG_SAME_RIGHTS`.
    static ::fidl::internal::StatusAndError Clone(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<CloneRequest> params);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<CloseResponse> Close(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<DescribeResponse> Describe(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<SyncResponse> Sync(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<GetAttrResponse> GetAttr(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    static ::fidl::DecodeResult<SetAttrResponse> SetAttr(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetAttrRequest> params, ::fidl::BytePart response_buffer);

    // Acquires the `Directory.Open` rights and flags used to access this file.
    //
    // This method does not require any rights.
    // This method has the same functionality as GetFlags for File and is
    // meant as an in-progress replacement.
    static ::fidl::DecodeResult<NodeGetFlagsResponse> NodeGetFlags(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Changes the `Directory.Open` flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // This method has the same functionality as SetFlags for File and is
    // meant as an in-progress replacement.
    static ::fidl::DecodeResult<NodeSetFlagsResponse> NodeSetFlags(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<NodeSetFlagsRequest> params, ::fidl::BytePart response_buffer);

    // Sets the local address used for the socket.
    static ::fidl::DecodeResult<BindResponse> Bind(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<BindRequest> params, ::fidl::BytePart response_buffer);

    // Initiates a connection to a remote address.
    static ::fidl::DecodeResult<ConnectResponse> Connect(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ConnectRequest> params, ::fidl::BytePart response_buffer);

    // Retrieves the local socket address.
    static ::fidl::DecodeResult<GetSockNameResponse> GetSockName(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Retrieves the remote socket address.
    static ::fidl::DecodeResult<GetPeerNameResponse> GetPeerName(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Sets the value of a socket option.
    static ::fidl::DecodeResult<SetSockOptResponse> SetSockOpt(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetSockOptRequest> params, ::fidl::BytePart response_buffer);

    // Retrieves the value of a socket option.
    static ::fidl::DecodeResult<GetSockOptResponse> GetSockOpt(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetSockOptRequest> params, ::fidl::BytePart response_buffer);

    // Shuts down part of the socket.
    static ::fidl::DecodeResult<ShutdownResponse> Shutdown(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ShutdownRequest> params, ::fidl::BytePart response_buffer);

    // Receives a message from the socket.
    static ::fidl::DecodeResult<RecvMsgResponse> RecvMsg(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<RecvMsgRequest> params, ::fidl::BytePart response_buffer);

    // Sends a message on the socket.
    static ::fidl::DecodeResult<SendMsgResponse> SendMsg(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SendMsgRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = DatagramSocket;
    using _Base = ::fidl::CompleterBase;

    using CloneCompleter = ::fidl::Completer<>;

    virtual void Clone(uint32_t flags, ::zx::channel object, CloneCompleter::Sync _completer) = 0;

    class CloseCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<CloseResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using CloseCompleter = ::fidl::Completer<CloseCompleterBase>;

    virtual void Close(CloseCompleter::Sync _completer) = 0;

    class DescribeCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io::NodeInfo info);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io::NodeInfo info);
      void Reply(::fidl::DecodedMessage<DescribeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using DescribeCompleter = ::fidl::Completer<DescribeCompleterBase>;

    virtual void Describe(DescribeCompleter::Sync _completer) = 0;

    class SyncCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<SyncResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SyncCompleter = ::fidl::Completer<SyncCompleterBase>;

    virtual void Sync(SyncCompleter::Sync _completer) = 0;

    class GetAttrCompleterBase : public _Base {
     public:
      void Reply(int32_t s, ::llcpp::fuchsia::io::NodeAttributes attributes);
      void Reply(::fidl::BytePart _buffer, int32_t s, ::llcpp::fuchsia::io::NodeAttributes attributes);
      void Reply(::fidl::DecodedMessage<GetAttrResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetAttrCompleter = ::fidl::Completer<GetAttrCompleterBase>;

    virtual void GetAttr(GetAttrCompleter::Sync _completer) = 0;

    class SetAttrCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<SetAttrResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetAttrCompleter = ::fidl::Completer<SetAttrCompleterBase>;

    virtual void SetAttr(uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, SetAttrCompleter::Sync _completer) = 0;

    class NodeGetFlagsCompleterBase : public _Base {
     public:
      void Reply(int32_t s, uint32_t flags);
      void Reply(::fidl::BytePart _buffer, int32_t s, uint32_t flags);
      void Reply(::fidl::DecodedMessage<NodeGetFlagsResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using NodeGetFlagsCompleter = ::fidl::Completer<NodeGetFlagsCompleterBase>;

    virtual void NodeGetFlags(NodeGetFlagsCompleter::Sync _completer) { _completer.Close(ZX_ERR_NOT_SUPPORTED); }

    class NodeSetFlagsCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<NodeSetFlagsResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using NodeSetFlagsCompleter = ::fidl::Completer<NodeSetFlagsCompleterBase>;

    virtual void NodeSetFlags(uint32_t flags, NodeSetFlagsCompleter::Sync _completer) { _completer.Close(ZX_ERR_NOT_SUPPORTED); }

    class BindCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::posix::socket::BaseSocket_Bind_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::posix::socket::BaseSocket_Bind_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<BindResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using BindCompleter = ::fidl::Completer<BindCompleterBase>;

    virtual void Bind(::fidl::VectorView<uint8_t> addr, BindCompleter::Sync _completer) = 0;

    class ConnectCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::posix::socket::BaseSocket_Connect_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::posix::socket::BaseSocket_Connect_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<ConnectResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ConnectCompleter = ::fidl::Completer<ConnectCompleterBase>;

    virtual void Connect(::fidl::VectorView<uint8_t> addr, ConnectCompleter::Sync _completer) = 0;

    class GetSockNameCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::posix::socket::BaseSocket_GetSockName_Result result);
      void ReplySuccess(::fidl::VectorView<uint8_t> addr);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::posix::socket::BaseSocket_GetSockName_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, ::fidl::VectorView<uint8_t> addr);
      void Reply(::fidl::DecodedMessage<GetSockNameResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetSockNameCompleter = ::fidl::Completer<GetSockNameCompleterBase>;

    virtual void GetSockName(GetSockNameCompleter::Sync _completer) = 0;

    class GetPeerNameCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::posix::socket::BaseSocket_GetPeerName_Result result);
      void ReplySuccess(::fidl::VectorView<uint8_t> addr);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::posix::socket::BaseSocket_GetPeerName_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, ::fidl::VectorView<uint8_t> addr);
      void Reply(::fidl::DecodedMessage<GetPeerNameResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetPeerNameCompleter = ::fidl::Completer<GetPeerNameCompleterBase>;

    virtual void GetPeerName(GetPeerNameCompleter::Sync _completer) = 0;

    class SetSockOptCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::posix::socket::BaseSocket_SetSockOpt_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::posix::socket::BaseSocket_SetSockOpt_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<SetSockOptResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetSockOptCompleter = ::fidl::Completer<SetSockOptCompleterBase>;

    virtual void SetSockOpt(int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, SetSockOptCompleter::Sync _completer) = 0;

    class GetSockOptCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::posix::socket::BaseSocket_GetSockOpt_Result result);
      void ReplySuccess(::fidl::VectorView<uint8_t> optval);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::posix::socket::BaseSocket_GetSockOpt_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, ::fidl::VectorView<uint8_t> optval);
      void Reply(::fidl::DecodedMessage<GetSockOptResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetSockOptCompleter = ::fidl::Completer<GetSockOptCompleterBase>;

    virtual void GetSockOpt(int16_t level, int16_t optname, GetSockOptCompleter::Sync _completer) = 0;

    class ShutdownCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::posix::socket::DatagramSocket_Shutdown_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::posix::socket::DatagramSocket_Shutdown_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<ShutdownResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ShutdownCompleter = ::fidl::Completer<ShutdownCompleterBase>;

    virtual void Shutdown(int16_t how, ShutdownCompleter::Sync _completer) = 0;

    class RecvMsgCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::posix::socket::DatagramSocket_RecvMsg_Result result);
      void ReplySuccess(::fidl::VectorView<uint8_t> addr, ::fidl::VectorView<uint8_t> data, ::fidl::VectorView<uint8_t> control, uint32_t truncated);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::posix::socket::DatagramSocket_RecvMsg_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::VectorView<uint8_t> data, ::fidl::VectorView<uint8_t> control, uint32_t truncated);
      void Reply(::fidl::DecodedMessage<RecvMsgResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using RecvMsgCompleter = ::fidl::Completer<RecvMsgCompleterBase>;

    virtual void RecvMsg(uint32_t addr_len, uint32_t data_len, uint32_t control_len, int16_t flags, RecvMsgCompleter::Sync _completer) = 0;

    class SendMsgCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::posix::socket::DatagramSocket_SendMsg_Result result);
      void ReplySuccess(int64_t len);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::posix::socket::DatagramSocket_SendMsg_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, int64_t len);
      void Reply(::fidl::DecodedMessage<SendMsgResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SendMsgCompleter = ::fidl::Completer<SendMsgCompleterBase>;

    virtual void SendMsg(::fidl::VectorView<uint8_t> addr, ::fidl::VectorView<::fidl::VectorView<uint8_t>> data, ::fidl::VectorView<uint8_t> control, int16_t flags, SendMsgCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

  // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
  // (the same as would be returned by `Describe`).
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, int32_t s, ::llcpp::fuchsia::io::NodeInfo info);

  // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
  // (the same as would be returned by `Describe`).
  // Caller provides the backing storage for FIDL message via response buffers.
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, int32_t s, ::llcpp::fuchsia::io::NodeInfo info);

  // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
  // (the same as would be returned by `Describe`).
  // Messages are encoded in-place.
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnOpenResponse> params);


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void CloneRequest(const ::fidl::DecodedMessage<DatagramSocket::CloneRequest>& _msg);
    static void CloseRequest(const ::fidl::DecodedMessage<DatagramSocket::CloseRequest>& _msg);
    static void CloseResponse(const ::fidl::DecodedMessage<DatagramSocket::CloseResponse>& _msg);
    static void DescribeRequest(const ::fidl::DecodedMessage<DatagramSocket::DescribeRequest>& _msg);
    static void DescribeResponse(const ::fidl::DecodedMessage<DatagramSocket::DescribeResponse>& _msg);
    static void OnOpenResponse(const ::fidl::DecodedMessage<DatagramSocket::OnOpenResponse>& _msg);
    static void SyncRequest(const ::fidl::DecodedMessage<DatagramSocket::SyncRequest>& _msg);
    static void SyncResponse(const ::fidl::DecodedMessage<DatagramSocket::SyncResponse>& _msg);
    static void GetAttrRequest(const ::fidl::DecodedMessage<DatagramSocket::GetAttrRequest>& _msg);
    static void GetAttrResponse(const ::fidl::DecodedMessage<DatagramSocket::GetAttrResponse>& _msg);
    static void SetAttrRequest(const ::fidl::DecodedMessage<DatagramSocket::SetAttrRequest>& _msg);
    static void SetAttrResponse(const ::fidl::DecodedMessage<DatagramSocket::SetAttrResponse>& _msg);
    static void NodeGetFlagsRequest(const ::fidl::DecodedMessage<DatagramSocket::NodeGetFlagsRequest>& _msg);
    static void NodeGetFlagsResponse(const ::fidl::DecodedMessage<DatagramSocket::NodeGetFlagsResponse>& _msg);
    static void NodeSetFlagsRequest(const ::fidl::DecodedMessage<DatagramSocket::NodeSetFlagsRequest>& _msg);
    static void NodeSetFlagsResponse(const ::fidl::DecodedMessage<DatagramSocket::NodeSetFlagsResponse>& _msg);
    static void BindRequest(const ::fidl::DecodedMessage<DatagramSocket::BindRequest>& _msg);
    static void BindResponse(const ::fidl::DecodedMessage<DatagramSocket::BindResponse>& _msg);
    static void ConnectRequest(const ::fidl::DecodedMessage<DatagramSocket::ConnectRequest>& _msg);
    static void ConnectResponse(const ::fidl::DecodedMessage<DatagramSocket::ConnectResponse>& _msg);
    static void GetSockNameRequest(const ::fidl::DecodedMessage<DatagramSocket::GetSockNameRequest>& _msg);
    static void GetSockNameResponse(const ::fidl::DecodedMessage<DatagramSocket::GetSockNameResponse>& _msg);
    static void GetPeerNameRequest(const ::fidl::DecodedMessage<DatagramSocket::GetPeerNameRequest>& _msg);
    static void GetPeerNameResponse(const ::fidl::DecodedMessage<DatagramSocket::GetPeerNameResponse>& _msg);
    static void SetSockOptRequest(const ::fidl::DecodedMessage<DatagramSocket::SetSockOptRequest>& _msg);
    static void SetSockOptResponse(const ::fidl::DecodedMessage<DatagramSocket::SetSockOptResponse>& _msg);
    static void GetSockOptRequest(const ::fidl::DecodedMessage<DatagramSocket::GetSockOptRequest>& _msg);
    static void GetSockOptResponse(const ::fidl::DecodedMessage<DatagramSocket::GetSockOptResponse>& _msg);
    static void ShutdownRequest(const ::fidl::DecodedMessage<DatagramSocket::ShutdownRequest>& _msg);
    static void ShutdownResponse(const ::fidl::DecodedMessage<DatagramSocket::ShutdownResponse>& _msg);
    static void RecvMsgRequest(const ::fidl::DecodedMessage<DatagramSocket::RecvMsgRequest>& _msg);
    static void RecvMsgResponse(const ::fidl::DecodedMessage<DatagramSocket::RecvMsgResponse>& _msg);
    static void SendMsgRequest(const ::fidl::DecodedMessage<DatagramSocket::SendMsgRequest>& _msg);
    static void SendMsgResponse(const ::fidl::DecodedMessage<DatagramSocket::SendMsgResponse>& _msg);
  };
};

}  // namespace socket
}  // namespace posix
}  // namespace fuchsia
}  // namespace llcpp

namespace fidl {

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::BaseSocket_GetSockOpt_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::posix::socket::BaseSocket_GetSockOpt_Response>);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket_GetSockOpt_Response, optval) == 0);
static_assert(sizeof(::llcpp::fuchsia::posix::socket::BaseSocket_GetSockOpt_Response) == ::llcpp::fuchsia::posix::socket::BaseSocket_GetSockOpt_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::BaseSocket_GetSockOpt_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::posix::socket::BaseSocket_GetSockOpt_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::DatagramSocket_RecvMsg_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::posix::socket::DatagramSocket_RecvMsg_Response>);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket_RecvMsg_Response, addr) == 0);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket_RecvMsg_Response, data) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket_RecvMsg_Response, control) == 32);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket_RecvMsg_Response, truncated) == 48);
static_assert(sizeof(::llcpp::fuchsia::posix::socket::DatagramSocket_RecvMsg_Response) == ::llcpp::fuchsia::posix::socket::DatagramSocket_RecvMsg_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::DatagramSocket_RecvMsg_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::posix::socket::DatagramSocket_RecvMsg_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::BaseSocket_GetSockName_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::posix::socket::BaseSocket_GetSockName_Response>);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket_GetSockName_Response, addr) == 0);
static_assert(sizeof(::llcpp::fuchsia::posix::socket::BaseSocket_GetSockName_Response) == ::llcpp::fuchsia::posix::socket::BaseSocket_GetSockName_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::BaseSocket_GetSockName_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::posix::socket::BaseSocket_GetSockName_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::BaseSocket_GetPeerName_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::posix::socket::BaseSocket_GetPeerName_Response>);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket_GetPeerName_Response, addr) == 0);
static_assert(sizeof(::llcpp::fuchsia::posix::socket::BaseSocket_GetPeerName_Response) == ::llcpp::fuchsia::posix::socket::BaseSocket_GetPeerName_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::BaseSocket_GetPeerName_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::posix::socket::BaseSocket_GetPeerName_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::StreamSocket_Listen_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::posix::socket::StreamSocket_Listen_Response>);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket_Listen_Response, __reserved) == 0);
static_assert(sizeof(::llcpp::fuchsia::posix::socket::StreamSocket_Listen_Response) == ::llcpp::fuchsia::posix::socket::StreamSocket_Listen_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::StreamSocket_Listen_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::posix::socket::StreamSocket_Listen_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::StreamSocket_Accept_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::posix::socket::StreamSocket_Accept_Response>);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket_Accept_Response, s) == 0);
static_assert(sizeof(::llcpp::fuchsia::posix::socket::StreamSocket_Accept_Response) == ::llcpp::fuchsia::posix::socket::StreamSocket_Accept_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::StreamSocket_Accept_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::posix::socket::StreamSocket_Accept_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Provider_Socket2_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::posix::socket::Provider_Socket2_Response>);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Provider_Socket2_Response, s) == 0);
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Provider_Socket2_Response) == ::llcpp::fuchsia::posix::socket::Provider_Socket2_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Provider_Socket2_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::posix::socket::Provider_Socket2_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Provider::SocketRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Provider::SocketRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Provider::SocketRequest)
    == ::llcpp::fuchsia::posix::socket::Provider::SocketRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Provider::SocketRequest, domain) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Provider::SocketRequest, type) == 18);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Provider::SocketRequest, protocol) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Provider::SocketResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Provider::SocketResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Provider::SocketResponse)
    == ::llcpp::fuchsia::posix::socket::Provider::SocketResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Provider::SocketResponse, code) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Provider::SocketResponse, s) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Provider::Socket2Request> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Provider::Socket2Request> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Provider::Socket2Request)
    == ::llcpp::fuchsia::posix::socket::Provider::Socket2Request::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Provider::Socket2Request, domain) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Provider::Socket2Request, type) == 18);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Provider::Socket2Request, protocol) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Provider::Socket2Response> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Provider::Socket2Response> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Provider::Socket2Response)
    == ::llcpp::fuchsia::posix::socket::Provider::Socket2Response::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Provider::Socket2Response, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::DatagramSocket_Shutdown_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::posix::socket::DatagramSocket_Shutdown_Response>);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket_Shutdown_Response, __reserved) == 0);
static_assert(sizeof(::llcpp::fuchsia::posix::socket::DatagramSocket_Shutdown_Response) == ::llcpp::fuchsia::posix::socket::DatagramSocket_Shutdown_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::DatagramSocket_Shutdown_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::posix::socket::DatagramSocket_Shutdown_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::DatagramSocket_SendMsg_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::posix::socket::DatagramSocket_SendMsg_Response>);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket_SendMsg_Response, len) == 0);
static_assert(sizeof(::llcpp::fuchsia::posix::socket::DatagramSocket_SendMsg_Response) == ::llcpp::fuchsia::posix::socket::DatagramSocket_SendMsg_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::DatagramSocket_SendMsg_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::posix::socket::DatagramSocket_SendMsg_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::BaseSocket_SetSockOpt_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::posix::socket::BaseSocket_SetSockOpt_Response>);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket_SetSockOpt_Response, __reserved) == 0);
static_assert(sizeof(::llcpp::fuchsia::posix::socket::BaseSocket_SetSockOpt_Response) == ::llcpp::fuchsia::posix::socket::BaseSocket_SetSockOpt_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::BaseSocket_SetSockOpt_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::posix::socket::BaseSocket_SetSockOpt_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::BaseSocket_Connect_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::posix::socket::BaseSocket_Connect_Response>);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket_Connect_Response, __reserved) == 0);
static_assert(sizeof(::llcpp::fuchsia::posix::socket::BaseSocket_Connect_Response) == ::llcpp::fuchsia::posix::socket::BaseSocket_Connect_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::BaseSocket_Connect_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::posix::socket::BaseSocket_Connect_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::BaseSocket_Bind_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::posix::socket::BaseSocket_Bind_Response>);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket_Bind_Response, __reserved) == 0);
static_assert(sizeof(::llcpp::fuchsia::posix::socket::BaseSocket_Bind_Response) == ::llcpp::fuchsia::posix::socket::BaseSocket_Bind_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::BaseSocket_Bind_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::posix::socket::BaseSocket_Bind_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::CloneRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::CloneRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::CloneRequest)
    == ::llcpp::fuchsia::posix::socket::Control::CloneRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::CloneRequest, flags) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::CloneRequest, object) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::CloseResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::CloseResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::CloseResponse)
    == ::llcpp::fuchsia::posix::socket::Control::CloseResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::CloseResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::DescribeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::DescribeResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::DescribeResponse)
    == ::llcpp::fuchsia::posix::socket::Control::DescribeResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::DescribeResponse, info) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::OnOpenResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::OnOpenResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::OnOpenResponse)
    == ::llcpp::fuchsia::posix::socket::Control::OnOpenResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::OnOpenResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::OnOpenResponse, info) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::SyncResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::SyncResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::SyncResponse)
    == ::llcpp::fuchsia::posix::socket::Control::SyncResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::SyncResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::GetAttrResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::GetAttrResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::GetAttrResponse)
    == ::llcpp::fuchsia::posix::socket::Control::GetAttrResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetAttrResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetAttrResponse, attributes) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::SetAttrRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::SetAttrRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::SetAttrRequest)
    == ::llcpp::fuchsia::posix::socket::Control::SetAttrRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::SetAttrRequest, flags) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::SetAttrRequest, attributes) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::SetAttrResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::SetAttrResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::SetAttrResponse)
    == ::llcpp::fuchsia::posix::socket::Control::SetAttrResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::SetAttrResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::NodeGetFlagsResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::NodeGetFlagsResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::NodeGetFlagsResponse)
    == ::llcpp::fuchsia::posix::socket::Control::NodeGetFlagsResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::NodeGetFlagsResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::NodeGetFlagsResponse, flags) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::NodeSetFlagsRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::NodeSetFlagsRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::NodeSetFlagsRequest)
    == ::llcpp::fuchsia::posix::socket::Control::NodeSetFlagsRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::NodeSetFlagsRequest, flags) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::NodeSetFlagsResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::NodeSetFlagsResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::NodeSetFlagsResponse)
    == ::llcpp::fuchsia::posix::socket::Control::NodeSetFlagsResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::NodeSetFlagsResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::BindRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::BindRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::BindRequest)
    == ::llcpp::fuchsia::posix::socket::Control::BindRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::BindRequest, addr) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::BindResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::BindResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::BindResponse)
    == ::llcpp::fuchsia::posix::socket::Control::BindResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::BindResponse, code) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::ConnectRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::ConnectRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::ConnectRequest)
    == ::llcpp::fuchsia::posix::socket::Control::ConnectRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::ConnectRequest, addr) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::ConnectResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::ConnectResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::ConnectResponse)
    == ::llcpp::fuchsia::posix::socket::Control::ConnectResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::ConnectResponse, code) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::ListenRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::ListenRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::ListenRequest)
    == ::llcpp::fuchsia::posix::socket::Control::ListenRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::ListenRequest, backlog) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::ListenResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::ListenResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::ListenResponse)
    == ::llcpp::fuchsia::posix::socket::Control::ListenResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::ListenResponse, code) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::AcceptRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::AcceptRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::AcceptRequest)
    == ::llcpp::fuchsia::posix::socket::Control::AcceptRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::AcceptRequest, flags) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::AcceptResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::AcceptResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::AcceptResponse)
    == ::llcpp::fuchsia::posix::socket::Control::AcceptResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::AcceptResponse, code) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::AcceptResponse, s) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::GetSockNameResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::GetSockNameResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::GetSockNameResponse)
    == ::llcpp::fuchsia::posix::socket::Control::GetSockNameResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetSockNameResponse, code) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetSockNameResponse, addr) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::GetPeerNameResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::GetPeerNameResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::GetPeerNameResponse)
    == ::llcpp::fuchsia::posix::socket::Control::GetPeerNameResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetPeerNameResponse, code) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetPeerNameResponse, addr) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::SetSockOptRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::SetSockOptRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::SetSockOptRequest)
    == ::llcpp::fuchsia::posix::socket::Control::SetSockOptRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::SetSockOptRequest, level) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::SetSockOptRequest, optname) == 18);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::SetSockOptRequest, optval) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::SetSockOptResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::SetSockOptResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::SetSockOptResponse)
    == ::llcpp::fuchsia::posix::socket::Control::SetSockOptResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::SetSockOptResponse, code) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::GetSockOptRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::GetSockOptRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::GetSockOptRequest)
    == ::llcpp::fuchsia::posix::socket::Control::GetSockOptRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetSockOptRequest, level) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetSockOptRequest, optname) == 18);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::GetSockOptResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::GetSockOptResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::GetSockOptResponse)
    == ::llcpp::fuchsia::posix::socket::Control::GetSockOptResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetSockOptResponse, code) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetSockOptResponse, optval) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::BaseSocket::CloneRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::BaseSocket::CloneRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::BaseSocket::CloneRequest)
    == ::llcpp::fuchsia::posix::socket::BaseSocket::CloneRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket::CloneRequest, flags) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket::CloneRequest, object) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::BaseSocket::CloseResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::BaseSocket::CloseResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::BaseSocket::CloseResponse)
    == ::llcpp::fuchsia::posix::socket::BaseSocket::CloseResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket::CloseResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::BaseSocket::DescribeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::BaseSocket::DescribeResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::BaseSocket::DescribeResponse)
    == ::llcpp::fuchsia::posix::socket::BaseSocket::DescribeResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket::DescribeResponse, info) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::BaseSocket::OnOpenResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::BaseSocket::OnOpenResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::BaseSocket::OnOpenResponse)
    == ::llcpp::fuchsia::posix::socket::BaseSocket::OnOpenResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket::OnOpenResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket::OnOpenResponse, info) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::BaseSocket::SyncResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::BaseSocket::SyncResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::BaseSocket::SyncResponse)
    == ::llcpp::fuchsia::posix::socket::BaseSocket::SyncResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket::SyncResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::BaseSocket::GetAttrResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::BaseSocket::GetAttrResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::BaseSocket::GetAttrResponse)
    == ::llcpp::fuchsia::posix::socket::BaseSocket::GetAttrResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket::GetAttrResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket::GetAttrResponse, attributes) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::BaseSocket::SetAttrRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::BaseSocket::SetAttrRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::BaseSocket::SetAttrRequest)
    == ::llcpp::fuchsia::posix::socket::BaseSocket::SetAttrRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket::SetAttrRequest, flags) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket::SetAttrRequest, attributes) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::BaseSocket::SetAttrResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::BaseSocket::SetAttrResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::BaseSocket::SetAttrResponse)
    == ::llcpp::fuchsia::posix::socket::BaseSocket::SetAttrResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket::SetAttrResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::BaseSocket::NodeGetFlagsResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::BaseSocket::NodeGetFlagsResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::BaseSocket::NodeGetFlagsResponse)
    == ::llcpp::fuchsia::posix::socket::BaseSocket::NodeGetFlagsResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket::NodeGetFlagsResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket::NodeGetFlagsResponse, flags) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::BaseSocket::NodeSetFlagsRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::BaseSocket::NodeSetFlagsRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::BaseSocket::NodeSetFlagsRequest)
    == ::llcpp::fuchsia::posix::socket::BaseSocket::NodeSetFlagsRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket::NodeSetFlagsRequest, flags) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::BaseSocket::NodeSetFlagsResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::BaseSocket::NodeSetFlagsResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::BaseSocket::NodeSetFlagsResponse)
    == ::llcpp::fuchsia::posix::socket::BaseSocket::NodeSetFlagsResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket::NodeSetFlagsResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::BaseSocket::BindRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::BaseSocket::BindRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::BaseSocket::BindRequest)
    == ::llcpp::fuchsia::posix::socket::BaseSocket::BindRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket::BindRequest, addr) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::BaseSocket::BindResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::BaseSocket::BindResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::BaseSocket::BindResponse)
    == ::llcpp::fuchsia::posix::socket::BaseSocket::BindResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket::BindResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::BaseSocket::ConnectRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::BaseSocket::ConnectRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::BaseSocket::ConnectRequest)
    == ::llcpp::fuchsia::posix::socket::BaseSocket::ConnectRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket::ConnectRequest, addr) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::BaseSocket::ConnectResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::BaseSocket::ConnectResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::BaseSocket::ConnectResponse)
    == ::llcpp::fuchsia::posix::socket::BaseSocket::ConnectResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket::ConnectResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::BaseSocket::GetSockNameResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::BaseSocket::GetSockNameResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::BaseSocket::GetSockNameResponse)
    == ::llcpp::fuchsia::posix::socket::BaseSocket::GetSockNameResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket::GetSockNameResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::BaseSocket::GetPeerNameResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::BaseSocket::GetPeerNameResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::BaseSocket::GetPeerNameResponse)
    == ::llcpp::fuchsia::posix::socket::BaseSocket::GetPeerNameResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket::GetPeerNameResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::BaseSocket::SetSockOptRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::BaseSocket::SetSockOptRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::BaseSocket::SetSockOptRequest)
    == ::llcpp::fuchsia::posix::socket::BaseSocket::SetSockOptRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket::SetSockOptRequest, level) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket::SetSockOptRequest, optname) == 18);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket::SetSockOptRequest, optval) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::BaseSocket::SetSockOptResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::BaseSocket::SetSockOptResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::BaseSocket::SetSockOptResponse)
    == ::llcpp::fuchsia::posix::socket::BaseSocket::SetSockOptResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket::SetSockOptResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::BaseSocket::GetSockOptRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::BaseSocket::GetSockOptRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::BaseSocket::GetSockOptRequest)
    == ::llcpp::fuchsia::posix::socket::BaseSocket::GetSockOptRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket::GetSockOptRequest, level) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket::GetSockOptRequest, optname) == 18);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::BaseSocket::GetSockOptResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::BaseSocket::GetSockOptResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::BaseSocket::GetSockOptResponse)
    == ::llcpp::fuchsia::posix::socket::BaseSocket::GetSockOptResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::BaseSocket::GetSockOptResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::StreamSocket::CloneRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::StreamSocket::CloneRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::StreamSocket::CloneRequest)
    == ::llcpp::fuchsia::posix::socket::StreamSocket::CloneRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket::CloneRequest, flags) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket::CloneRequest, object) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::StreamSocket::CloseResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::StreamSocket::CloseResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::StreamSocket::CloseResponse)
    == ::llcpp::fuchsia::posix::socket::StreamSocket::CloseResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket::CloseResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::StreamSocket::DescribeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::StreamSocket::DescribeResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::StreamSocket::DescribeResponse)
    == ::llcpp::fuchsia::posix::socket::StreamSocket::DescribeResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket::DescribeResponse, info) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::StreamSocket::OnOpenResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::StreamSocket::OnOpenResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::StreamSocket::OnOpenResponse)
    == ::llcpp::fuchsia::posix::socket::StreamSocket::OnOpenResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket::OnOpenResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket::OnOpenResponse, info) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::StreamSocket::SyncResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::StreamSocket::SyncResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::StreamSocket::SyncResponse)
    == ::llcpp::fuchsia::posix::socket::StreamSocket::SyncResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket::SyncResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::StreamSocket::GetAttrResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::StreamSocket::GetAttrResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::StreamSocket::GetAttrResponse)
    == ::llcpp::fuchsia::posix::socket::StreamSocket::GetAttrResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket::GetAttrResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket::GetAttrResponse, attributes) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::StreamSocket::SetAttrRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::StreamSocket::SetAttrRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::StreamSocket::SetAttrRequest)
    == ::llcpp::fuchsia::posix::socket::StreamSocket::SetAttrRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket::SetAttrRequest, flags) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket::SetAttrRequest, attributes) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::StreamSocket::SetAttrResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::StreamSocket::SetAttrResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::StreamSocket::SetAttrResponse)
    == ::llcpp::fuchsia::posix::socket::StreamSocket::SetAttrResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket::SetAttrResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::StreamSocket::NodeGetFlagsResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::StreamSocket::NodeGetFlagsResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::StreamSocket::NodeGetFlagsResponse)
    == ::llcpp::fuchsia::posix::socket::StreamSocket::NodeGetFlagsResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket::NodeGetFlagsResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket::NodeGetFlagsResponse, flags) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::StreamSocket::NodeSetFlagsRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::StreamSocket::NodeSetFlagsRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::StreamSocket::NodeSetFlagsRequest)
    == ::llcpp::fuchsia::posix::socket::StreamSocket::NodeSetFlagsRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket::NodeSetFlagsRequest, flags) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::StreamSocket::NodeSetFlagsResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::StreamSocket::NodeSetFlagsResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::StreamSocket::NodeSetFlagsResponse)
    == ::llcpp::fuchsia::posix::socket::StreamSocket::NodeSetFlagsResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket::NodeSetFlagsResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::StreamSocket::BindRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::StreamSocket::BindRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::StreamSocket::BindRequest)
    == ::llcpp::fuchsia::posix::socket::StreamSocket::BindRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket::BindRequest, addr) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::StreamSocket::BindResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::StreamSocket::BindResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::StreamSocket::BindResponse)
    == ::llcpp::fuchsia::posix::socket::StreamSocket::BindResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket::BindResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::StreamSocket::ConnectRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::StreamSocket::ConnectRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::StreamSocket::ConnectRequest)
    == ::llcpp::fuchsia::posix::socket::StreamSocket::ConnectRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket::ConnectRequest, addr) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::StreamSocket::ConnectResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::StreamSocket::ConnectResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::StreamSocket::ConnectResponse)
    == ::llcpp::fuchsia::posix::socket::StreamSocket::ConnectResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket::ConnectResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::StreamSocket::GetSockNameResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::StreamSocket::GetSockNameResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::StreamSocket::GetSockNameResponse)
    == ::llcpp::fuchsia::posix::socket::StreamSocket::GetSockNameResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket::GetSockNameResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::StreamSocket::GetPeerNameResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::StreamSocket::GetPeerNameResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::StreamSocket::GetPeerNameResponse)
    == ::llcpp::fuchsia::posix::socket::StreamSocket::GetPeerNameResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket::GetPeerNameResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::StreamSocket::SetSockOptRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::StreamSocket::SetSockOptRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::StreamSocket::SetSockOptRequest)
    == ::llcpp::fuchsia::posix::socket::StreamSocket::SetSockOptRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket::SetSockOptRequest, level) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket::SetSockOptRequest, optname) == 18);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket::SetSockOptRequest, optval) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::StreamSocket::SetSockOptResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::StreamSocket::SetSockOptResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::StreamSocket::SetSockOptResponse)
    == ::llcpp::fuchsia::posix::socket::StreamSocket::SetSockOptResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket::SetSockOptResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::StreamSocket::GetSockOptRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::StreamSocket::GetSockOptRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::StreamSocket::GetSockOptRequest)
    == ::llcpp::fuchsia::posix::socket::StreamSocket::GetSockOptRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket::GetSockOptRequest, level) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket::GetSockOptRequest, optname) == 18);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::StreamSocket::GetSockOptResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::StreamSocket::GetSockOptResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::StreamSocket::GetSockOptResponse)
    == ::llcpp::fuchsia::posix::socket::StreamSocket::GetSockOptResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket::GetSockOptResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::StreamSocket::ListenRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::StreamSocket::ListenRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::StreamSocket::ListenRequest)
    == ::llcpp::fuchsia::posix::socket::StreamSocket::ListenRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket::ListenRequest, backlog) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::StreamSocket::ListenResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::StreamSocket::ListenResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::StreamSocket::ListenResponse)
    == ::llcpp::fuchsia::posix::socket::StreamSocket::ListenResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket::ListenResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::StreamSocket::AcceptRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::StreamSocket::AcceptRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::StreamSocket::AcceptRequest)
    == ::llcpp::fuchsia::posix::socket::StreamSocket::AcceptRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket::AcceptRequest, flags) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::StreamSocket::AcceptResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::StreamSocket::AcceptResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::StreamSocket::AcceptResponse)
    == ::llcpp::fuchsia::posix::socket::StreamSocket::AcceptResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::StreamSocket::AcceptResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::DatagramSocket::CloneRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::DatagramSocket::CloneRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::DatagramSocket::CloneRequest)
    == ::llcpp::fuchsia::posix::socket::DatagramSocket::CloneRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::CloneRequest, flags) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::CloneRequest, object) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::DatagramSocket::CloseResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::DatagramSocket::CloseResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::DatagramSocket::CloseResponse)
    == ::llcpp::fuchsia::posix::socket::DatagramSocket::CloseResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::CloseResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::DatagramSocket::DescribeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::DatagramSocket::DescribeResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::DatagramSocket::DescribeResponse)
    == ::llcpp::fuchsia::posix::socket::DatagramSocket::DescribeResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::DescribeResponse, info) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::DatagramSocket::OnOpenResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::DatagramSocket::OnOpenResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::DatagramSocket::OnOpenResponse)
    == ::llcpp::fuchsia::posix::socket::DatagramSocket::OnOpenResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::OnOpenResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::OnOpenResponse, info) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::DatagramSocket::SyncResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::DatagramSocket::SyncResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::DatagramSocket::SyncResponse)
    == ::llcpp::fuchsia::posix::socket::DatagramSocket::SyncResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::SyncResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::DatagramSocket::GetAttrResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::DatagramSocket::GetAttrResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::DatagramSocket::GetAttrResponse)
    == ::llcpp::fuchsia::posix::socket::DatagramSocket::GetAttrResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::GetAttrResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::GetAttrResponse, attributes) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::DatagramSocket::SetAttrRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::DatagramSocket::SetAttrRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::DatagramSocket::SetAttrRequest)
    == ::llcpp::fuchsia::posix::socket::DatagramSocket::SetAttrRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::SetAttrRequest, flags) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::SetAttrRequest, attributes) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::DatagramSocket::SetAttrResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::DatagramSocket::SetAttrResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::DatagramSocket::SetAttrResponse)
    == ::llcpp::fuchsia::posix::socket::DatagramSocket::SetAttrResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::SetAttrResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::DatagramSocket::NodeGetFlagsResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::DatagramSocket::NodeGetFlagsResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::DatagramSocket::NodeGetFlagsResponse)
    == ::llcpp::fuchsia::posix::socket::DatagramSocket::NodeGetFlagsResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::NodeGetFlagsResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::NodeGetFlagsResponse, flags) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::DatagramSocket::NodeSetFlagsRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::DatagramSocket::NodeSetFlagsRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::DatagramSocket::NodeSetFlagsRequest)
    == ::llcpp::fuchsia::posix::socket::DatagramSocket::NodeSetFlagsRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::NodeSetFlagsRequest, flags) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::DatagramSocket::NodeSetFlagsResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::DatagramSocket::NodeSetFlagsResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::DatagramSocket::NodeSetFlagsResponse)
    == ::llcpp::fuchsia::posix::socket::DatagramSocket::NodeSetFlagsResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::NodeSetFlagsResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::DatagramSocket::BindRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::DatagramSocket::BindRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::DatagramSocket::BindRequest)
    == ::llcpp::fuchsia::posix::socket::DatagramSocket::BindRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::BindRequest, addr) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::DatagramSocket::BindResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::DatagramSocket::BindResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::DatagramSocket::BindResponse)
    == ::llcpp::fuchsia::posix::socket::DatagramSocket::BindResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::BindResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::DatagramSocket::ConnectRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::DatagramSocket::ConnectRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::DatagramSocket::ConnectRequest)
    == ::llcpp::fuchsia::posix::socket::DatagramSocket::ConnectRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::ConnectRequest, addr) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::DatagramSocket::ConnectResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::DatagramSocket::ConnectResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::DatagramSocket::ConnectResponse)
    == ::llcpp::fuchsia::posix::socket::DatagramSocket::ConnectResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::ConnectResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::DatagramSocket::GetSockNameResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::DatagramSocket::GetSockNameResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::DatagramSocket::GetSockNameResponse)
    == ::llcpp::fuchsia::posix::socket::DatagramSocket::GetSockNameResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::GetSockNameResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::DatagramSocket::GetPeerNameResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::DatagramSocket::GetPeerNameResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::DatagramSocket::GetPeerNameResponse)
    == ::llcpp::fuchsia::posix::socket::DatagramSocket::GetPeerNameResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::GetPeerNameResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::DatagramSocket::SetSockOptRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::DatagramSocket::SetSockOptRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::DatagramSocket::SetSockOptRequest)
    == ::llcpp::fuchsia::posix::socket::DatagramSocket::SetSockOptRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::SetSockOptRequest, level) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::SetSockOptRequest, optname) == 18);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::SetSockOptRequest, optval) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::DatagramSocket::SetSockOptResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::DatagramSocket::SetSockOptResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::DatagramSocket::SetSockOptResponse)
    == ::llcpp::fuchsia::posix::socket::DatagramSocket::SetSockOptResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::SetSockOptResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::DatagramSocket::GetSockOptRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::DatagramSocket::GetSockOptRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::DatagramSocket::GetSockOptRequest)
    == ::llcpp::fuchsia::posix::socket::DatagramSocket::GetSockOptRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::GetSockOptRequest, level) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::GetSockOptRequest, optname) == 18);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::DatagramSocket::GetSockOptResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::DatagramSocket::GetSockOptResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::DatagramSocket::GetSockOptResponse)
    == ::llcpp::fuchsia::posix::socket::DatagramSocket::GetSockOptResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::GetSockOptResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::DatagramSocket::ShutdownRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::DatagramSocket::ShutdownRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::DatagramSocket::ShutdownRequest)
    == ::llcpp::fuchsia::posix::socket::DatagramSocket::ShutdownRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::ShutdownRequest, how) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::DatagramSocket::ShutdownResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::DatagramSocket::ShutdownResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::DatagramSocket::ShutdownResponse)
    == ::llcpp::fuchsia::posix::socket::DatagramSocket::ShutdownResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::ShutdownResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::DatagramSocket::RecvMsgRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::DatagramSocket::RecvMsgRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::DatagramSocket::RecvMsgRequest)
    == ::llcpp::fuchsia::posix::socket::DatagramSocket::RecvMsgRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::RecvMsgRequest, addr_len) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::RecvMsgRequest, data_len) == 20);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::RecvMsgRequest, control_len) == 24);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::RecvMsgRequest, flags) == 28);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::DatagramSocket::RecvMsgResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::DatagramSocket::RecvMsgResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::DatagramSocket::RecvMsgResponse)
    == ::llcpp::fuchsia::posix::socket::DatagramSocket::RecvMsgResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::RecvMsgResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::DatagramSocket::SendMsgRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::DatagramSocket::SendMsgRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::DatagramSocket::SendMsgRequest)
    == ::llcpp::fuchsia::posix::socket::DatagramSocket::SendMsgRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::SendMsgRequest, addr) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::SendMsgRequest, data) == 32);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::SendMsgRequest, control) == 48);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::SendMsgRequest, flags) == 64);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::DatagramSocket::SendMsgResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::DatagramSocket::SendMsgResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::DatagramSocket::SendMsgResponse)
    == ::llcpp::fuchsia::posix::socket::DatagramSocket::SendMsgResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::DatagramSocket::SendMsgResponse, result) == 16);

}  // namespace fidl

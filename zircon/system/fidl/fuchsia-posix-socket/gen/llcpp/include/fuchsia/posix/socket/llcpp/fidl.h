// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/cpp/vector_view.h>
#include <lib/fidl/cpp/string_view.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/fit/function.h>
#include <lib/zx/channel.h>
#include <lib/zx/handle.h>
#include <zircon/fidl.h>

#include <fuchsia/io/llcpp/fidl.h>

namespace llcpp {

namespace fuchsia {
namespace posix {
namespace socket {

class Provider;
class Control;

extern "C" const fidl_type_t fuchsia_posix_socket_ProviderSocketRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ProviderSocketResponseTable;

// Provider implements the POSIX sockets API.
class Provider final {
 public:
  static constexpr char Name_[] = "fuchsia.posix.socket.Provider";

  struct SocketResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;
    ::zx::channel s;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ProviderSocketResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct SocketRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t domain;
    int16_t type;
    int16_t protocol;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ProviderSocketRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = SocketResponse;
  };


  class SyncClient final {
   public:
    SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}

    SyncClient(SyncClient&&) = default;

    SyncClient& operator=(SyncClient&&) = default;

    ~SyncClient() {}

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Requests a socket with the specified parameters. Values for `code` are defined in
    // errno.h.
    zx_status_t Socket(int16_t domain, int16_t type, int16_t protocol, int16_t* out_code, ::zx::channel* out_s);

    // Requests a socket with the specified parameters. Values for `code` are defined in
    // errno.h.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<SocketResponse> Socket(::fidl::BytePart _request_buffer, int16_t domain, int16_t type, int16_t protocol, ::fidl::BytePart _response_buffer, int16_t* out_code, ::zx::channel* out_s);

    // Requests a socket with the specified parameters. Values for `code` are defined in
    // errno.h.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<SocketResponse> Socket(::fidl::DecodedMessage<SocketRequest> params, ::fidl::BytePart response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
   public:

    // Requests a socket with the specified parameters. Values for `code` are defined in
    // errno.h.
    static zx_status_t Socket(zx::unowned_channel _client_end, int16_t domain, int16_t type, int16_t protocol, int16_t* out_code, ::zx::channel* out_s);

    // Requests a socket with the specified parameters. Values for `code` are defined in
    // errno.h.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<SocketResponse> Socket(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t domain, int16_t type, int16_t protocol, ::fidl::BytePart _response_buffer, int16_t* out_code, ::zx::channel* out_s);

    // Requests a socket with the specified parameters. Values for `code` are defined in
    // errno.h.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<SocketResponse> Socket(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SocketRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Provider;
    using _Base = ::fidl::CompleterBase;

    class SocketCompleterBase : public _Base {
     public:
      void Reply(int16_t code, ::zx::channel s);
      void Reply(::fidl::BytePart _buffer, int16_t code, ::zx::channel s);
      void Reply(::fidl::DecodedMessage<SocketResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SocketCompleter = ::fidl::Completer<SocketCompleterBase>;

    virtual void Socket(int16_t domain, int16_t type, int16_t protocol, SocketCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

};

extern "C" const fidl_type_t fuchsia_posix_socket_ControlCloneRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlCloseResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlDescribeResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlOnOpenEventTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlSyncResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlGetAttrResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlSetAttrRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlSetAttrResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlIoctlRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlIoctlResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlBindRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlBindResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlConnectRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlConnectResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlListenRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlListenResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlAcceptRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlAcceptResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlGetSockNameResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlGetPeerNameResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlSetSockOptRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlSetSockOptResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlGetSockOptRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlGetSockOptResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlIoctlPOSIXRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlIoctlPOSIXResponseTable;

// The control plane for a network socket. Once a socket has been retrieved from a
// `Provider`, this interface is then used to further configure and use the socket.
// This interface is essentially POSIX. Its implementation must support Linux-specific arguments
// to {Get,Set}SockOpt.
class Control final {
 public:

  struct CloneRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;
    ::zx::channel object;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlCloneRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };

  struct CloseResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlCloseResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using CloseRequest = ::fidl::AnyZeroArgMessage;

  struct DescribeResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io::NodeInfo info;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlDescribeResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using DescribeRequest = ::fidl::AnyZeroArgMessage;

  struct OnOpenResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::llcpp::fuchsia::io::NodeInfo* info;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlOnOpenEventTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 32;
  };
  struct SyncResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlSyncResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using SyncRequest = ::fidl::AnyZeroArgMessage;

  struct GetAttrResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::llcpp::fuchsia::io::NodeAttributes attributes;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlGetAttrResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 80;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using GetAttrRequest = ::fidl::AnyZeroArgMessage;

  struct SetAttrResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlSetAttrResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct SetAttrRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;
    ::llcpp::fuchsia::io::NodeAttributes attributes;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlSetAttrRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 80;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = SetAttrResponse;
  };

  struct IoctlResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::fidl::VectorView<::zx::handle> handles;
    ::fidl::VectorView<uint8_t> out;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlIoctlResponseTable;
    static constexpr uint32_t MaxNumHandles = 2;
    static constexpr uint32_t PrimarySize = 56;
    static constexpr uint32_t MaxOutOfLine = 8200;
  };
  struct IoctlRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t opcode;
    uint64_t max_out;
    ::fidl::VectorView<::zx::handle> handles;
    ::fidl::VectorView<uint8_t> in;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlIoctlRequestTable;
    static constexpr uint32_t MaxNumHandles = 2;
    static constexpr uint32_t PrimarySize = 64;
    static constexpr uint32_t MaxOutOfLine = 8200;
    using ResponseType = IoctlResponse;
  };

  struct BindResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlBindResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct BindRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::VectorView<uint8_t> addr;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlBindRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 4294967295;
    using ResponseType = BindResponse;
  };

  struct ConnectResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlConnectResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct ConnectRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::VectorView<uint8_t> addr;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlConnectRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 4294967295;
    using ResponseType = ConnectResponse;
  };

  struct ListenResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlListenResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct ListenRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t backlog;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlListenRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = ListenResponse;
  };

  struct AcceptResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;
    ::zx::channel s;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlAcceptResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct AcceptRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t flags;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlAcceptRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = AcceptResponse;
  };

  struct GetSockNameResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;
    ::fidl::VectorView<uint8_t> addr;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlGetSockNameResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 4294967295;
  };
  using GetSockNameRequest = ::fidl::AnyZeroArgMessage;

  struct GetPeerNameResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;
    ::fidl::VectorView<uint8_t> addr;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlGetPeerNameResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 4294967295;
  };
  using GetPeerNameRequest = ::fidl::AnyZeroArgMessage;

  struct SetSockOptResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlSetSockOptResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct SetSockOptRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t level;
    int16_t optname;
    ::fidl::VectorView<uint8_t> optval;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlSetSockOptRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 4294967295;
    using ResponseType = SetSockOptResponse;
  };

  struct GetSockOptResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;
    ::fidl::VectorView<uint8_t> optval;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlGetSockOptResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 4294967295;
  };
  struct GetSockOptRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t level;
    int16_t optname;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlGetSockOptRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = GetSockOptResponse;
  };

  struct IoctlPOSIXResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;
    ::fidl::VectorView<uint8_t> out;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlIoctlPOSIXResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 4294967295;
  };
  struct IoctlPOSIXRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t req;
    ::fidl::VectorView<uint8_t> in;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlIoctlPOSIXRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 4294967295;
    using ResponseType = IoctlPOSIXResponse;
  };


  struct EventHandlers {
    // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
    //
    // Indicates the success or failure of the open operation, and optionally describes the
    // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
    // (the same as would be returned by `Describe`).
    fit::function<zx_status_t(int32_t s, ::llcpp::fuchsia::io::NodeInfo* info)> on_open;

    // Fallback handler when an unknown ordinal is received.
    // Caller may put custom error handling logic here.
    fit::function<zx_status_t()> unknown;
  };

  class SyncClient final {
   public:
    SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}

    SyncClient(SyncClient&&) = default;

    SyncClient& operator=(SyncClient&&) = default;

    ~SyncClient() {}

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    // - OPEN_RIGHT_*
    // - OPEN_FLAG_APPEND
    // - OPEN_FLAG_NO_REMOTE
    // - OPEN_FLAG_DESCRIBE
    // - CLONE_FLAG_SAME_RIGHTS
    //
    // All other flags are ignored.
    //
    // The OPEN_RIGHT_* bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass CLONE_FLAG_SAME_RIGHTS to inherit the rights on the source connection.
    // It is invalid to pass any of the OPEN_RIGHT_* flags together with CLONE_FLAG_SAME_RIGHTS.
    zx_status_t Clone(uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    // - OPEN_RIGHT_*
    // - OPEN_FLAG_APPEND
    // - OPEN_FLAG_NO_REMOTE
    // - OPEN_FLAG_DESCRIBE
    // - CLONE_FLAG_SAME_RIGHTS
    //
    // All other flags are ignored.
    //
    // The OPEN_RIGHT_* bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass CLONE_FLAG_SAME_RIGHTS to inherit the rights on the source connection.
    // It is invalid to pass any of the OPEN_RIGHT_* flags together with CLONE_FLAG_SAME_RIGHTS.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Clone(::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    // - OPEN_RIGHT_*
    // - OPEN_FLAG_APPEND
    // - OPEN_FLAG_NO_REMOTE
    // - OPEN_FLAG_DESCRIBE
    // - CLONE_FLAG_SAME_RIGHTS
    //
    // All other flags are ignored.
    //
    // The OPEN_RIGHT_* bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass CLONE_FLAG_SAME_RIGHTS to inherit the rights on the source connection.
    // It is invalid to pass any of the OPEN_RIGHT_* flags together with CLONE_FLAG_SAME_RIGHTS.
    // Messages are encoded and decoded in-place.
    zx_status_t Clone(::fidl::DecodedMessage<CloneRequest> params);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    zx_status_t Close(int32_t* out_s);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<CloseResponse> Close(::fidl::BytePart _response_buffer, int32_t* out_s);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<CloseResponse> Close(::fidl::BytePart response_buffer);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    zx_status_t Describe(::llcpp::fuchsia::io::NodeInfo* out_info);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<DescribeResponse> Describe(::fidl::BytePart _response_buffer, ::llcpp::fuchsia::io::NodeInfo* out_info);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<DescribeResponse> Describe(::fidl::BytePart response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    zx_status_t Sync(int32_t* out_s);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<SyncResponse> Sync(::fidl::BytePart _response_buffer, int32_t* out_s);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<SyncResponse> Sync(::fidl::BytePart response_buffer);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    zx_status_t GetAttr(int32_t* out_s, ::llcpp::fuchsia::io::NodeAttributes* out_attributes);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<GetAttrResponse> GetAttr(::fidl::BytePart _response_buffer, int32_t* out_s, ::llcpp::fuchsia::io::NodeAttributes* out_attributes);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<GetAttrResponse> GetAttr(::fidl::BytePart response_buffer);

    // Updates information about the node.
    // `flags` may be any of NODE_ATTRIBUTE_FLAG_*.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    zx_status_t SetAttr(uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, int32_t* out_s);

    // Updates information about the node.
    // `flags` may be any of NODE_ATTRIBUTE_FLAG_*.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<SetAttrResponse> SetAttr(::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Updates information about the node.
    // `flags` may be any of NODE_ATTRIBUTE_FLAG_*.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<SetAttrResponse> SetAttr(::fidl::DecodedMessage<SetAttrRequest> params, ::fidl::BytePart response_buffer);


    // Deprecated. Only for use with compatibility with devhost.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<IoctlResponse> Ioctl(::fidl::BytePart _request_buffer, uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<::zx::handle>* out_handles, ::fidl::VectorView<uint8_t>* out_out);

    // Deprecated. Only for use with compatibility with devhost.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<IoctlResponse> Ioctl(::fidl::DecodedMessage<IoctlRequest> params, ::fidl::BytePart response_buffer);

    // Sets the local address used for the socket.
    zx_status_t Bind(::fidl::VectorView<uint8_t> addr, int16_t* out_code);

    // Sets the local address used for the socket.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<BindResponse> Bind(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer, int16_t* out_code);

    // Sets the local address used for the socket.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<BindResponse> Bind(::fidl::DecodedMessage<BindRequest> params, ::fidl::BytePart response_buffer);

    // Initiates a connection to a network endpoint.
    zx_status_t Connect(::fidl::VectorView<uint8_t> addr, int16_t* out_code);

    // Initiates a connection to a network endpoint.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<ConnectResponse> Connect(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer, int16_t* out_code);

    // Initiates a connection to a network endpoint.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<ConnectResponse> Connect(::fidl::DecodedMessage<ConnectRequest> params, ::fidl::BytePart response_buffer);

    // Begin listening for new connections from network endpoints. At most `backlog` connections
    // will be buffered.
    zx_status_t Listen(int16_t backlog, int16_t* out_code);

    // Begin listening for new connections from network endpoints. At most `backlog` connections
    // will be buffered.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<ListenResponse> Listen(::fidl::BytePart _request_buffer, int16_t backlog, ::fidl::BytePart _response_buffer, int16_t* out_code);

    // Begin listening for new connections from network endpoints. At most `backlog` connections
    // will be buffered.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<ListenResponse> Listen(::fidl::DecodedMessage<ListenRequest> params, ::fidl::BytePart response_buffer);

    // Accepts an incoming connection from a network endpoint.
    zx_status_t Accept(int16_t flags, int16_t* out_code, ::zx::channel* out_s);

    // Accepts an incoming connection from a network endpoint.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<AcceptResponse> Accept(::fidl::BytePart _request_buffer, int16_t flags, ::fidl::BytePart _response_buffer, int16_t* out_code, ::zx::channel* out_s);

    // Accepts an incoming connection from a network endpoint.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<AcceptResponse> Accept(::fidl::DecodedMessage<AcceptRequest> params, ::fidl::BytePart response_buffer);


    // Retrieves the local socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<GetSockNameResponse> GetSockName(::fidl::BytePart _response_buffer, int16_t* out_code, ::fidl::VectorView<uint8_t>* out_addr);

    // Retrieves the local socket address.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<GetSockNameResponse> GetSockName(::fidl::BytePart response_buffer);


    // Retrieves the remote socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<GetPeerNameResponse> GetPeerName(::fidl::BytePart _response_buffer, int16_t* out_code, ::fidl::VectorView<uint8_t>* out_addr);

    // Retrieves the remote socket address.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<GetPeerNameResponse> GetPeerName(::fidl::BytePart response_buffer);

    // Sets a socket option. TODO(NET-1699): link to description of supported socket options.
    zx_status_t SetSockOpt(int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, int16_t* out_code);

    // Sets a socket option. TODO(NET-1699): link to description of supported socket options.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<SetSockOptResponse> SetSockOpt(::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, ::fidl::BytePart _response_buffer, int16_t* out_code);

    // Sets a socket option. TODO(NET-1699): link to description of supported socket options.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<SetSockOptResponse> SetSockOpt(::fidl::DecodedMessage<SetSockOptRequest> params, ::fidl::BytePart response_buffer);


    // Retrieves the current value of a socket option.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<GetSockOptResponse> GetSockOpt(::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::BytePart _response_buffer, int16_t* out_code, ::fidl::VectorView<uint8_t>* out_optval);

    // Retrieves the current value of a socket option.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<GetSockOptResponse> GetSockOpt(::fidl::DecodedMessage<GetSockOptRequest> params, ::fidl::BytePart response_buffer);


    // Runs operations (e.g., get the receive timestamp of the last packet) on the socket.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<IoctlPOSIXResponse> IoctlPOSIX(::fidl::BytePart _request_buffer, int16_t req, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer, int16_t* out_code, ::fidl::VectorView<uint8_t>* out_out);

    // Runs operations (e.g., get the receive timestamp of the last packet) on the socket.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<IoctlPOSIXResponse> IoctlPOSIX(::fidl::DecodedMessage<IoctlPOSIXRequest> params, ::fidl::BytePart response_buffer);

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    zx_status_t HandleEvents(EventHandlers handlers);
   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
   public:

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    // - OPEN_RIGHT_*
    // - OPEN_FLAG_APPEND
    // - OPEN_FLAG_NO_REMOTE
    // - OPEN_FLAG_DESCRIBE
    // - CLONE_FLAG_SAME_RIGHTS
    //
    // All other flags are ignored.
    //
    // The OPEN_RIGHT_* bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass CLONE_FLAG_SAME_RIGHTS to inherit the rights on the source connection.
    // It is invalid to pass any of the OPEN_RIGHT_* flags together with CLONE_FLAG_SAME_RIGHTS.
    static zx_status_t Clone(zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    // - OPEN_RIGHT_*
    // - OPEN_FLAG_APPEND
    // - OPEN_FLAG_NO_REMOTE
    // - OPEN_FLAG_DESCRIBE
    // - CLONE_FLAG_SAME_RIGHTS
    //
    // All other flags are ignored.
    //
    // The OPEN_RIGHT_* bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass CLONE_FLAG_SAME_RIGHTS to inherit the rights on the source connection.
    // It is invalid to pass any of the OPEN_RIGHT_* flags together with CLONE_FLAG_SAME_RIGHTS.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Clone(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    // - OPEN_RIGHT_*
    // - OPEN_FLAG_APPEND
    // - OPEN_FLAG_NO_REMOTE
    // - OPEN_FLAG_DESCRIBE
    // - CLONE_FLAG_SAME_RIGHTS
    //
    // All other flags are ignored.
    //
    // The OPEN_RIGHT_* bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass CLONE_FLAG_SAME_RIGHTS to inherit the rights on the source connection.
    // It is invalid to pass any of the OPEN_RIGHT_* flags together with CLONE_FLAG_SAME_RIGHTS.
    // Messages are encoded and decoded in-place.
    static zx_status_t Clone(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CloneRequest> params);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    static zx_status_t Close(zx::unowned_channel _client_end, int32_t* out_s);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<CloseResponse> Close(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<CloseResponse> Close(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    static zx_status_t Describe(zx::unowned_channel _client_end, ::llcpp::fuchsia::io::NodeInfo* out_info);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<DescribeResponse> Describe(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, ::llcpp::fuchsia::io::NodeInfo* out_info);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<DescribeResponse> Describe(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    static zx_status_t Sync(zx::unowned_channel _client_end, int32_t* out_s);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<SyncResponse> Sync(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<SyncResponse> Sync(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    static zx_status_t GetAttr(zx::unowned_channel _client_end, int32_t* out_s, ::llcpp::fuchsia::io::NodeAttributes* out_attributes);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<GetAttrResponse> GetAttr(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s, ::llcpp::fuchsia::io::NodeAttributes* out_attributes);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<GetAttrResponse> GetAttr(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Updates information about the node.
    // `flags` may be any of NODE_ATTRIBUTE_FLAG_*.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    static zx_status_t SetAttr(zx::unowned_channel _client_end, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, int32_t* out_s);

    // Updates information about the node.
    // `flags` may be any of NODE_ATTRIBUTE_FLAG_*.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<SetAttrResponse> SetAttr(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Updates information about the node.
    // `flags` may be any of NODE_ATTRIBUTE_FLAG_*.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<SetAttrResponse> SetAttr(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetAttrRequest> params, ::fidl::BytePart response_buffer);


    // Deprecated. Only for use with compatibility with devhost.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<IoctlResponse> Ioctl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<::zx::handle>* out_handles, ::fidl::VectorView<uint8_t>* out_out);

    // Deprecated. Only for use with compatibility with devhost.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<IoctlResponse> Ioctl(zx::unowned_channel _client_end, ::fidl::DecodedMessage<IoctlRequest> params, ::fidl::BytePart response_buffer);

    // Sets the local address used for the socket.
    static zx_status_t Bind(zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> addr, int16_t* out_code);

    // Sets the local address used for the socket.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<BindResponse> Bind(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer, int16_t* out_code);

    // Sets the local address used for the socket.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<BindResponse> Bind(zx::unowned_channel _client_end, ::fidl::DecodedMessage<BindRequest> params, ::fidl::BytePart response_buffer);

    // Initiates a connection to a network endpoint.
    static zx_status_t Connect(zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> addr, int16_t* out_code);

    // Initiates a connection to a network endpoint.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<ConnectResponse> Connect(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer, int16_t* out_code);

    // Initiates a connection to a network endpoint.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<ConnectResponse> Connect(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ConnectRequest> params, ::fidl::BytePart response_buffer);

    // Begin listening for new connections from network endpoints. At most `backlog` connections
    // will be buffered.
    static zx_status_t Listen(zx::unowned_channel _client_end, int16_t backlog, int16_t* out_code);

    // Begin listening for new connections from network endpoints. At most `backlog` connections
    // will be buffered.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<ListenResponse> Listen(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t backlog, ::fidl::BytePart _response_buffer, int16_t* out_code);

    // Begin listening for new connections from network endpoints. At most `backlog` connections
    // will be buffered.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<ListenResponse> Listen(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ListenRequest> params, ::fidl::BytePart response_buffer);

    // Accepts an incoming connection from a network endpoint.
    static zx_status_t Accept(zx::unowned_channel _client_end, int16_t flags, int16_t* out_code, ::zx::channel* out_s);

    // Accepts an incoming connection from a network endpoint.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<AcceptResponse> Accept(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t flags, ::fidl::BytePart _response_buffer, int16_t* out_code, ::zx::channel* out_s);

    // Accepts an incoming connection from a network endpoint.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<AcceptResponse> Accept(zx::unowned_channel _client_end, ::fidl::DecodedMessage<AcceptRequest> params, ::fidl::BytePart response_buffer);


    // Retrieves the local socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<GetSockNameResponse> GetSockName(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int16_t* out_code, ::fidl::VectorView<uint8_t>* out_addr);

    // Retrieves the local socket address.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<GetSockNameResponse> GetSockName(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);


    // Retrieves the remote socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<GetPeerNameResponse> GetPeerName(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int16_t* out_code, ::fidl::VectorView<uint8_t>* out_addr);

    // Retrieves the remote socket address.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<GetPeerNameResponse> GetPeerName(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Sets a socket option. TODO(NET-1699): link to description of supported socket options.
    static zx_status_t SetSockOpt(zx::unowned_channel _client_end, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, int16_t* out_code);

    // Sets a socket option. TODO(NET-1699): link to description of supported socket options.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<SetSockOptResponse> SetSockOpt(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, ::fidl::BytePart _response_buffer, int16_t* out_code);

    // Sets a socket option. TODO(NET-1699): link to description of supported socket options.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<SetSockOptResponse> SetSockOpt(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetSockOptRequest> params, ::fidl::BytePart response_buffer);


    // Retrieves the current value of a socket option.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<GetSockOptResponse> GetSockOpt(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::BytePart _response_buffer, int16_t* out_code, ::fidl::VectorView<uint8_t>* out_optval);

    // Retrieves the current value of a socket option.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<GetSockOptResponse> GetSockOpt(zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetSockOptRequest> params, ::fidl::BytePart response_buffer);


    // Runs operations (e.g., get the receive timestamp of the last packet) on the socket.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<IoctlPOSIXResponse> IoctlPOSIX(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t req, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer, int16_t* out_code, ::fidl::VectorView<uint8_t>* out_out);

    // Runs operations (e.g., get the receive timestamp of the last packet) on the socket.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<IoctlPOSIXResponse> IoctlPOSIX(zx::unowned_channel _client_end, ::fidl::DecodedMessage<IoctlPOSIXRequest> params, ::fidl::BytePart response_buffer);

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    static zx_status_t HandleEvents(zx::unowned_channel client_end, EventHandlers handlers);
  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Control;
    using _Base = ::fidl::CompleterBase;

    using CloneCompleter = ::fidl::Completer<>;

    virtual void Clone(uint32_t flags, ::zx::channel object, CloneCompleter::Sync _completer) = 0;

    class CloseCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<CloseResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using CloseCompleter = ::fidl::Completer<CloseCompleterBase>;

    virtual void Close(CloseCompleter::Sync _completer) = 0;

    class DescribeCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io::NodeInfo info);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io::NodeInfo info);
      void Reply(::fidl::DecodedMessage<DescribeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using DescribeCompleter = ::fidl::Completer<DescribeCompleterBase>;

    virtual void Describe(DescribeCompleter::Sync _completer) = 0;

    class SyncCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<SyncResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SyncCompleter = ::fidl::Completer<SyncCompleterBase>;

    virtual void Sync(SyncCompleter::Sync _completer) = 0;

    class GetAttrCompleterBase : public _Base {
     public:
      void Reply(int32_t s, ::llcpp::fuchsia::io::NodeAttributes attributes);
      void Reply(::fidl::BytePart _buffer, int32_t s, ::llcpp::fuchsia::io::NodeAttributes attributes);
      void Reply(::fidl::DecodedMessage<GetAttrResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetAttrCompleter = ::fidl::Completer<GetAttrCompleterBase>;

    virtual void GetAttr(GetAttrCompleter::Sync _completer) = 0;

    class SetAttrCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<SetAttrResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetAttrCompleter = ::fidl::Completer<SetAttrCompleterBase>;

    virtual void SetAttr(uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, SetAttrCompleter::Sync _completer) = 0;

    class IoctlCompleterBase : public _Base {
     public:
      void Reply(int32_t s, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> out);
      void Reply(::fidl::BytePart _buffer, int32_t s, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> out);
      void Reply(::fidl::DecodedMessage<IoctlResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using IoctlCompleter = ::fidl::Completer<IoctlCompleterBase>;

    virtual void Ioctl(uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, IoctlCompleter::Sync _completer) = 0;

    class BindCompleterBase : public _Base {
     public:
      void Reply(int16_t code);
      void Reply(::fidl::BytePart _buffer, int16_t code);
      void Reply(::fidl::DecodedMessage<BindResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using BindCompleter = ::fidl::Completer<BindCompleterBase>;

    virtual void Bind(::fidl::VectorView<uint8_t> addr, BindCompleter::Sync _completer) = 0;

    class ConnectCompleterBase : public _Base {
     public:
      void Reply(int16_t code);
      void Reply(::fidl::BytePart _buffer, int16_t code);
      void Reply(::fidl::DecodedMessage<ConnectResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ConnectCompleter = ::fidl::Completer<ConnectCompleterBase>;

    virtual void Connect(::fidl::VectorView<uint8_t> addr, ConnectCompleter::Sync _completer) = 0;

    class ListenCompleterBase : public _Base {
     public:
      void Reply(int16_t code);
      void Reply(::fidl::BytePart _buffer, int16_t code);
      void Reply(::fidl::DecodedMessage<ListenResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ListenCompleter = ::fidl::Completer<ListenCompleterBase>;

    virtual void Listen(int16_t backlog, ListenCompleter::Sync _completer) = 0;

    class AcceptCompleterBase : public _Base {
     public:
      void Reply(int16_t code, ::zx::channel s);
      void Reply(::fidl::BytePart _buffer, int16_t code, ::zx::channel s);
      void Reply(::fidl::DecodedMessage<AcceptResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using AcceptCompleter = ::fidl::Completer<AcceptCompleterBase>;

    virtual void Accept(int16_t flags, AcceptCompleter::Sync _completer) = 0;

    class GetSockNameCompleterBase : public _Base {
     public:
      void Reply(int16_t code, ::fidl::VectorView<uint8_t> addr);
      void Reply(::fidl::BytePart _buffer, int16_t code, ::fidl::VectorView<uint8_t> addr);
      void Reply(::fidl::DecodedMessage<GetSockNameResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetSockNameCompleter = ::fidl::Completer<GetSockNameCompleterBase>;

    virtual void GetSockName(GetSockNameCompleter::Sync _completer) = 0;

    class GetPeerNameCompleterBase : public _Base {
     public:
      void Reply(int16_t code, ::fidl::VectorView<uint8_t> addr);
      void Reply(::fidl::BytePart _buffer, int16_t code, ::fidl::VectorView<uint8_t> addr);
      void Reply(::fidl::DecodedMessage<GetPeerNameResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetPeerNameCompleter = ::fidl::Completer<GetPeerNameCompleterBase>;

    virtual void GetPeerName(GetPeerNameCompleter::Sync _completer) = 0;

    class SetSockOptCompleterBase : public _Base {
     public:
      void Reply(int16_t code);
      void Reply(::fidl::BytePart _buffer, int16_t code);
      void Reply(::fidl::DecodedMessage<SetSockOptResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetSockOptCompleter = ::fidl::Completer<SetSockOptCompleterBase>;

    virtual void SetSockOpt(int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, SetSockOptCompleter::Sync _completer) = 0;

    class GetSockOptCompleterBase : public _Base {
     public:
      void Reply(int16_t code, ::fidl::VectorView<uint8_t> optval);
      void Reply(::fidl::BytePart _buffer, int16_t code, ::fidl::VectorView<uint8_t> optval);
      void Reply(::fidl::DecodedMessage<GetSockOptResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetSockOptCompleter = ::fidl::Completer<GetSockOptCompleterBase>;

    virtual void GetSockOpt(int16_t level, int16_t optname, GetSockOptCompleter::Sync _completer) = 0;

    class IoctlPOSIXCompleterBase : public _Base {
     public:
      void Reply(int16_t code, ::fidl::VectorView<uint8_t> out);
      void Reply(::fidl::BytePart _buffer, int16_t code, ::fidl::VectorView<uint8_t> out);
      void Reply(::fidl::DecodedMessage<IoctlPOSIXResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using IoctlPOSIXCompleter = ::fidl::Completer<IoctlPOSIXCompleterBase>;

    virtual void IoctlPOSIX(int16_t req, ::fidl::VectorView<uint8_t> in, IoctlPOSIXCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

  // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
  // (the same as would be returned by `Describe`).
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, int32_t s, ::llcpp::fuchsia::io::NodeInfo* info);

  // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
  // (the same as would be returned by `Describe`).
  // Caller provides the backing storage for FIDL message via response buffers.
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, int32_t s, ::llcpp::fuchsia::io::NodeInfo* info);

  // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
  // (the same as would be returned by `Describe`).
  // Messages are encoded in-place.
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnOpenResponse> params);

};

}  // namespace socket
}  // namespace posix
}  // namespace fuchsia
}  // namespace llcpp

namespace fidl {

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Provider::SocketRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Provider::SocketRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Provider::SocketRequest)
    == ::llcpp::fuchsia::posix::socket::Provider::SocketRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Provider::SocketRequest, domain) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Provider::SocketRequest, type) == 18);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Provider::SocketRequest, protocol) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Provider::SocketResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Provider::SocketResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Provider::SocketResponse)
    == ::llcpp::fuchsia::posix::socket::Provider::SocketResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Provider::SocketResponse, code) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Provider::SocketResponse, s) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::CloneRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::CloneRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::CloneRequest)
    == ::llcpp::fuchsia::posix::socket::Control::CloneRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::CloneRequest, flags) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::CloneRequest, object) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::CloseResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::CloseResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::CloseResponse)
    == ::llcpp::fuchsia::posix::socket::Control::CloseResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::CloseResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::DescribeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::DescribeResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::DescribeResponse)
    == ::llcpp::fuchsia::posix::socket::Control::DescribeResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::DescribeResponse, info) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::OnOpenResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::OnOpenResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::OnOpenResponse)
    == ::llcpp::fuchsia::posix::socket::Control::OnOpenResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::OnOpenResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::OnOpenResponse, info) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::SyncResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::SyncResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::SyncResponse)
    == ::llcpp::fuchsia::posix::socket::Control::SyncResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::SyncResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::GetAttrResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::GetAttrResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::GetAttrResponse)
    == ::llcpp::fuchsia::posix::socket::Control::GetAttrResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetAttrResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetAttrResponse, attributes) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::SetAttrRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::SetAttrRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::SetAttrRequest)
    == ::llcpp::fuchsia::posix::socket::Control::SetAttrRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::SetAttrRequest, flags) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::SetAttrRequest, attributes) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::SetAttrResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::SetAttrResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::SetAttrResponse)
    == ::llcpp::fuchsia::posix::socket::Control::SetAttrResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::SetAttrResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::IoctlRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::IoctlRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::IoctlRequest)
    == ::llcpp::fuchsia::posix::socket::Control::IoctlRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::IoctlRequest, opcode) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::IoctlRequest, max_out) == 24);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::IoctlRequest, handles) == 32);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::IoctlRequest, in) == 48);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::IoctlResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::IoctlResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::IoctlResponse)
    == ::llcpp::fuchsia::posix::socket::Control::IoctlResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::IoctlResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::IoctlResponse, handles) == 24);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::IoctlResponse, out) == 40);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::BindRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::BindRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::BindRequest)
    == ::llcpp::fuchsia::posix::socket::Control::BindRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::BindRequest, addr) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::BindResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::BindResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::BindResponse)
    == ::llcpp::fuchsia::posix::socket::Control::BindResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::BindResponse, code) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::ConnectRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::ConnectRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::ConnectRequest)
    == ::llcpp::fuchsia::posix::socket::Control::ConnectRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::ConnectRequest, addr) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::ConnectResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::ConnectResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::ConnectResponse)
    == ::llcpp::fuchsia::posix::socket::Control::ConnectResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::ConnectResponse, code) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::ListenRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::ListenRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::ListenRequest)
    == ::llcpp::fuchsia::posix::socket::Control::ListenRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::ListenRequest, backlog) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::ListenResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::ListenResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::ListenResponse)
    == ::llcpp::fuchsia::posix::socket::Control::ListenResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::ListenResponse, code) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::AcceptRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::AcceptRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::AcceptRequest)
    == ::llcpp::fuchsia::posix::socket::Control::AcceptRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::AcceptRequest, flags) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::AcceptResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::AcceptResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::AcceptResponse)
    == ::llcpp::fuchsia::posix::socket::Control::AcceptResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::AcceptResponse, code) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::AcceptResponse, s) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::GetSockNameResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::GetSockNameResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::GetSockNameResponse)
    == ::llcpp::fuchsia::posix::socket::Control::GetSockNameResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetSockNameResponse, code) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetSockNameResponse, addr) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::GetPeerNameResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::GetPeerNameResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::GetPeerNameResponse)
    == ::llcpp::fuchsia::posix::socket::Control::GetPeerNameResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetPeerNameResponse, code) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetPeerNameResponse, addr) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::SetSockOptRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::SetSockOptRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::SetSockOptRequest)
    == ::llcpp::fuchsia::posix::socket::Control::SetSockOptRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::SetSockOptRequest, level) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::SetSockOptRequest, optname) == 18);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::SetSockOptRequest, optval) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::SetSockOptResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::SetSockOptResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::SetSockOptResponse)
    == ::llcpp::fuchsia::posix::socket::Control::SetSockOptResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::SetSockOptResponse, code) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::GetSockOptRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::GetSockOptRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::GetSockOptRequest)
    == ::llcpp::fuchsia::posix::socket::Control::GetSockOptRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetSockOptRequest, level) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetSockOptRequest, optname) == 18);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::GetSockOptResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::GetSockOptResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::GetSockOptResponse)
    == ::llcpp::fuchsia::posix::socket::Control::GetSockOptResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetSockOptResponse, code) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetSockOptResponse, optval) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::IoctlPOSIXRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::IoctlPOSIXRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::IoctlPOSIXRequest)
    == ::llcpp::fuchsia::posix::socket::Control::IoctlPOSIXRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::IoctlPOSIXRequest, req) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::IoctlPOSIXRequest, in) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::IoctlPOSIXResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::IoctlPOSIXResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::IoctlPOSIXResponse)
    == ::llcpp::fuchsia::posix::socket::Control::IoctlPOSIXResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::IoctlPOSIXResponse, code) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::IoctlPOSIXResponse, out) == 24);

}  // namespace fidl

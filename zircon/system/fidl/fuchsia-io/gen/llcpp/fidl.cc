// WARNING: This file is machine generated by fidlgen.

#include <fuchsia/io/llcpp/fidl.h>
#include <memory>

namespace llcpp {

namespace fuchsia {
namespace io {

namespace {

[[maybe_unused]]
constexpr uint64_t kDirectoryWatcher_OnEvent_Ordinal = 0x208bcc9d00000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectoryWatcher_OnEvent_GenOrdinal = 0x3937a088fe53412alu;
extern "C" const fidl_type_t fuchsia_io_DirectoryWatcherOnEventRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryWatcherOnEventResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryWatcherOnEventResponseTable;

}  // namespace

DirectoryWatcher::ResultOf::OnEvent_Impl::OnEvent_Impl(zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> events) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OnEventRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  OnEventRequest _request = {};
  _request.events = std::move(events);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<OnEventRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      DirectoryWatcher::InPlace::OnEvent(std::move(_client_end), std::move(_decoded_request)));
}

DirectoryWatcher::ResultOf::OnEvent DirectoryWatcher::SyncClient::OnEvent(::fidl::VectorView<uint8_t> events) {
  return ResultOf::OnEvent(zx::unowned_channel(this->channel_), std::move(events));
}

DirectoryWatcher::ResultOf::OnEvent DirectoryWatcher::Call::OnEvent(zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> events) {
  return ResultOf::OnEvent(std::move(_client_end), std::move(events));
}


DirectoryWatcher::UnownedResultOf::OnEvent_Impl::OnEvent_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> events) {
  if (_request_buffer.capacity() < OnEventRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  OnEventRequest _request = {};
  _request.events = std::move(events);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<OnEventRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      DirectoryWatcher::InPlace::OnEvent(std::move(_client_end), std::move(_decoded_request)));
}

DirectoryWatcher::UnownedResultOf::OnEvent DirectoryWatcher::SyncClient::OnEvent(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> events) {
  return UnownedResultOf::OnEvent(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(events));
}

DirectoryWatcher::UnownedResultOf::OnEvent DirectoryWatcher::Call::OnEvent(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> events) {
  return UnownedResultOf::OnEvent(std::move(_client_end), std::move(_request_buffer), std::move(events));
}

::fidl::internal::StatusAndError DirectoryWatcher::InPlace::OnEvent(zx::unowned_channel _client_end, ::fidl::DecodedMessage<OnEventRequest> params) {
  DirectoryWatcher::SetTransactionHeaderFor::OnEventRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


bool DirectoryWatcher::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kDirectoryWatcher_OnEvent_Ordinal:
    case kDirectoryWatcher_OnEvent_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<OnEventRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->OnEvent(std::move(message->events),
          Interface::OnEventCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool DirectoryWatcher::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}



void DirectoryWatcher::SetTransactionHeaderFor::OnEventRequest(const ::fidl::DecodedMessage<DirectoryWatcher::OnEventRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryWatcher_OnEvent_Ordinal);
}

::llcpp::fuchsia::io::NodeInfo::NodeInfo() {
  tag_ = Tag::Invalid;
}

::llcpp::fuchsia::io::NodeInfo::~NodeInfo() {
  Destroy();
}

void ::llcpp::fuchsia::io::NodeInfo::Destroy() {
  switch (which()) {
  case Tag::kService:
    service_.~Service();
    break;
  case Tag::kFile:
    file_.~FileObject();
    break;
  case Tag::kDirectory:
    directory_.~DirectoryObject();
    break;
  case Tag::kPipe:
    pipe_.~Pipe();
    break;
  case Tag::kVmofile:
    vmofile_.~Vmofile();
    break;
  case Tag::kDevice:
    device_.~Device();
    break;
  case Tag::kTty:
    tty_.~Tty();
    break;
  case Tag::kSocket:
    socket_.~Socket();
    break;
  default:
    break;
  }
  tag_ = Tag::Invalid;
}

void ::llcpp::fuchsia::io::NodeInfo::MoveImpl_(NodeInfo&& other) {
  switch (other.which()) {
  case Tag::kService:
    mutable_service() = std::move(other.mutable_service());
    break;
  case Tag::kFile:
    mutable_file() = std::move(other.mutable_file());
    break;
  case Tag::kDirectory:
    mutable_directory() = std::move(other.mutable_directory());
    break;
  case Tag::kPipe:
    mutable_pipe() = std::move(other.mutable_pipe());
    break;
  case Tag::kVmofile:
    mutable_vmofile() = std::move(other.mutable_vmofile());
    break;
  case Tag::kDevice:
    mutable_device() = std::move(other.mutable_device());
    break;
  case Tag::kTty:
    mutable_tty() = std::move(other.mutable_tty());
    break;
  case Tag::kSocket:
    mutable_socket() = std::move(other.mutable_socket());
    break;
  default:
    break;
  }
  other.Destroy();
}

void ::llcpp::fuchsia::io::NodeInfo::SizeAndOffsetAssertionHelper() {
  static_assert(offsetof(::llcpp::fuchsia::io::NodeInfo, service_) == 8);
  static_assert(offsetof(::llcpp::fuchsia::io::NodeInfo, file_) == 8);
  static_assert(offsetof(::llcpp::fuchsia::io::NodeInfo, directory_) == 8);
  static_assert(offsetof(::llcpp::fuchsia::io::NodeInfo, pipe_) == 8);
  static_assert(offsetof(::llcpp::fuchsia::io::NodeInfo, vmofile_) == 8);
  static_assert(offsetof(::llcpp::fuchsia::io::NodeInfo, device_) == 8);
  static_assert(offsetof(::llcpp::fuchsia::io::NodeInfo, tty_) == 8);
  static_assert(offsetof(::llcpp::fuchsia::io::NodeInfo, socket_) == 8);
  static_assert(sizeof(::llcpp::fuchsia::io::NodeInfo) == ::llcpp::fuchsia::io::NodeInfo::PrimarySize);
}


::llcpp::fuchsia::io::Service& ::llcpp::fuchsia::io::NodeInfo::mutable_service() {
  if (which() != Tag::kService) {
    Destroy();
    new (&service_) ::llcpp::fuchsia::io::Service;
  }
  tag_ = Tag::kService;
  return service_;
}

::llcpp::fuchsia::io::FileObject& ::llcpp::fuchsia::io::NodeInfo::mutable_file() {
  if (which() != Tag::kFile) {
    Destroy();
    new (&file_) ::llcpp::fuchsia::io::FileObject;
  }
  tag_ = Tag::kFile;
  return file_;
}

::llcpp::fuchsia::io::DirectoryObject& ::llcpp::fuchsia::io::NodeInfo::mutable_directory() {
  if (which() != Tag::kDirectory) {
    Destroy();
    new (&directory_) ::llcpp::fuchsia::io::DirectoryObject;
  }
  tag_ = Tag::kDirectory;
  return directory_;
}

::llcpp::fuchsia::io::Pipe& ::llcpp::fuchsia::io::NodeInfo::mutable_pipe() {
  if (which() != Tag::kPipe) {
    Destroy();
    new (&pipe_) ::llcpp::fuchsia::io::Pipe;
  }
  tag_ = Tag::kPipe;
  return pipe_;
}

::llcpp::fuchsia::io::Vmofile& ::llcpp::fuchsia::io::NodeInfo::mutable_vmofile() {
  if (which() != Tag::kVmofile) {
    Destroy();
    new (&vmofile_) ::llcpp::fuchsia::io::Vmofile;
  }
  tag_ = Tag::kVmofile;
  return vmofile_;
}

::llcpp::fuchsia::io::Device& ::llcpp::fuchsia::io::NodeInfo::mutable_device() {
  if (which() != Tag::kDevice) {
    Destroy();
    new (&device_) ::llcpp::fuchsia::io::Device;
  }
  tag_ = Tag::kDevice;
  return device_;
}

::llcpp::fuchsia::io::Tty& ::llcpp::fuchsia::io::NodeInfo::mutable_tty() {
  if (which() != Tag::kTty) {
    Destroy();
    new (&tty_) ::llcpp::fuchsia::io::Tty;
  }
  tag_ = Tag::kTty;
  return tty_;
}

::llcpp::fuchsia::io::Socket& ::llcpp::fuchsia::io::NodeInfo::mutable_socket() {
  if (which() != Tag::kSocket) {
    Destroy();
    new (&socket_) ::llcpp::fuchsia::io::Socket;
  }
  tag_ = Tag::kSocket;
  return socket_;
}


namespace {

[[maybe_unused]]
constexpr uint64_t kNode_Clone_Ordinal = 0x17fe6a4c00000000lu;
[[maybe_unused]]
constexpr uint64_t kNode_Clone_GenOrdinal = 0x5a61678f293ce16flu;
extern "C" const fidl_type_t fuchsia_io_NodeCloneRequestTable;
extern "C" const fidl_type_t fuchsia_io_NodeCloneResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_NodeCloneResponseTable;
[[maybe_unused]]
constexpr uint64_t kNode_Close_Ordinal = 0x52b9568700000000lu;
[[maybe_unused]]
constexpr uint64_t kNode_Close_GenOrdinal = 0x5309c5bd1c33dc44lu;
extern "C" const fidl_type_t fuchsia_io_NodeCloseRequestTable;
extern "C" const fidl_type_t fuchsia_io_NodeCloseResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_NodeCloseResponseTable;
[[maybe_unused]]
constexpr uint64_t kNode_Describe_Ordinal = 0x1f62df5e00000000lu;
[[maybe_unused]]
constexpr uint64_t kNode_Describe_GenOrdinal = 0xffcec215078dea0lu;
extern "C" const fidl_type_t fuchsia_io_NodeDescribeRequestTable;
extern "C" const fidl_type_t fuchsia_io_NodeDescribeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_NodeDescribeResponseTable;
[[maybe_unused]]
constexpr uint64_t kNode_OnOpen_Ordinal = 0x4700a7bd00000000lu;
[[maybe_unused]]
constexpr uint64_t kNode_OnOpen_GenOrdinal = 0x7fc7bbb1dbfd1972lu;
extern "C" const fidl_type_t fuchsia_io_NodeOnOpenRequestTable;
extern "C" const fidl_type_t fuchsia_io_NodeOnOpenEventTable;
extern "C" const fidl_type_t v1_fuchsia_io_NodeOnOpenEventTable;
[[maybe_unused]]
constexpr uint64_t kNode_Sync_Ordinal = 0x62423faa00000000lu;
[[maybe_unused]]
constexpr uint64_t kNode_Sync_GenOrdinal = 0x189d88326c18b519lu;
extern "C" const fidl_type_t fuchsia_io_NodeSyncRequestTable;
extern "C" const fidl_type_t fuchsia_io_NodeSyncResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_NodeSyncResponseTable;
[[maybe_unused]]
constexpr uint64_t kNode_GetAttr_Ordinal = 0x4585e7c800000000lu;
[[maybe_unused]]
constexpr uint64_t kNode_GetAttr_GenOrdinal = 0x78985e216314dafdlu;
extern "C" const fidl_type_t fuchsia_io_NodeGetAttrRequestTable;
extern "C" const fidl_type_t fuchsia_io_NodeGetAttrResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_NodeGetAttrResponseTable;
[[maybe_unused]]
constexpr uint64_t kNode_SetAttr_Ordinal = 0xbd5559a00000000lu;
[[maybe_unused]]
constexpr uint64_t kNode_SetAttr_GenOrdinal = 0x4186c0f40d938f46lu;
extern "C" const fidl_type_t fuchsia_io_NodeSetAttrRequestTable;
extern "C" const fidl_type_t fuchsia_io_NodeSetAttrResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_NodeSetAttrResponseTable;
[[maybe_unused]]
constexpr uint64_t kNode_NodeGetFlags_Ordinal = 0x3c24c22300000000lu;
[[maybe_unused]]
constexpr uint64_t kNode_NodeGetFlags_GenOrdinal = 0x5b88fffb8eda3aa1lu;
extern "C" const fidl_type_t fuchsia_io_NodeNodeGetFlagsRequestTable;
extern "C" const fidl_type_t fuchsia_io_NodeNodeGetFlagsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_NodeNodeGetFlagsResponseTable;
[[maybe_unused]]
constexpr uint64_t kNode_NodeSetFlags_Ordinal = 0x46940c1600000000lu;
[[maybe_unused]]
constexpr uint64_t kNode_NodeSetFlags_GenOrdinal = 0x5295b76c71fde733lu;
extern "C" const fidl_type_t fuchsia_io_NodeNodeSetFlagsRequestTable;
extern "C" const fidl_type_t fuchsia_io_NodeNodeSetFlagsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_NodeNodeSetFlagsResponseTable;

}  // namespace

Node::ResultOf::Clone_Impl::Clone_Impl(zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloneRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CloneRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CloneRequest*>(_write_bytes);
  _request.flags = std::move(flags);
  _request.object = std::move(object);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloneRequest));
  ::fidl::DecodedMessage<CloneRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Node::InPlace::Clone(std::move(_client_end), std::move(_decoded_request)));
}

Node::ResultOf::Clone Node::SyncClient::Clone(uint32_t flags, ::zx::channel object) {
  return ResultOf::Clone(zx::unowned_channel(this->channel_), std::move(flags), std::move(object));
}

Node::ResultOf::Clone Node::Call::Clone(zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object) {
  return ResultOf::Clone(std::move(_client_end), std::move(flags), std::move(object));
}


Node::UnownedResultOf::Clone_Impl::Clone_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object) {
  if (_request_buffer.capacity() < CloneRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, CloneRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CloneRequest*>(_request_buffer.data());
  _request.flags = std::move(flags);
  _request.object = std::move(object);
  _request_buffer.set_actual(sizeof(CloneRequest));
  ::fidl::DecodedMessage<CloneRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Node::InPlace::Clone(std::move(_client_end), std::move(_decoded_request)));
}

Node::UnownedResultOf::Clone Node::SyncClient::Clone(::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object) {
  return UnownedResultOf::Clone(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(flags), std::move(object));
}

Node::UnownedResultOf::Clone Node::Call::Clone(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object) {
  return UnownedResultOf::Clone(std::move(_client_end), std::move(_request_buffer), std::move(flags), std::move(object));
}

::fidl::internal::StatusAndError Node::InPlace::Clone(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CloneRequest> params) {
  Node::SetTransactionHeaderFor::CloneRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
Node::ResultOf::Close_Impl<Node::CloseResponse>::Close_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CloseRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseRequest));
  ::fidl::DecodedMessage<CloseRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Node::InPlace::Close(std::move(_client_end), Super::response_buffer()));
}

Node::ResultOf::Close Node::SyncClient::Close() {
  return ResultOf::Close(zx::unowned_channel(this->channel_));
}

Node::ResultOf::Close Node::Call::Close(zx::unowned_channel _client_end) {
  return ResultOf::Close(std::move(_client_end));
}

template <>
Node::UnownedResultOf::Close_Impl<Node::CloseResponse>::Close_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(CloseRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, CloseRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(CloseRequest));
  ::fidl::DecodedMessage<CloseRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Node::InPlace::Close(std::move(_client_end), std::move(_response_buffer)));
}

Node::UnownedResultOf::Close Node::SyncClient::Close(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Close(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Node::UnownedResultOf::Close Node::Call::Close(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Close(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Node::CloseResponse> Node::InPlace::Close(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(CloseRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<CloseRequest> params(std::move(_request_buffer));
  Node::SetTransactionHeaderFor::CloseRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::CloseResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<CloseRequest, CloseResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::CloseResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Node::ResultOf::Describe_Impl<Node::DescribeResponse>::Describe_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DescribeRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, DescribeRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(DescribeRequest));
  ::fidl::DecodedMessage<DescribeRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Node::InPlace::Describe(std::move(_client_end), Super::response_buffer()));
}

Node::ResultOf::Describe Node::SyncClient::Describe() {
  return ResultOf::Describe(zx::unowned_channel(this->channel_));
}

Node::ResultOf::Describe Node::Call::Describe(zx::unowned_channel _client_end) {
  return ResultOf::Describe(std::move(_client_end));
}

template <>
Node::UnownedResultOf::Describe_Impl<Node::DescribeResponse>::Describe_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(DescribeRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, DescribeRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(DescribeRequest));
  ::fidl::DecodedMessage<DescribeRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Node::InPlace::Describe(std::move(_client_end), std::move(_response_buffer)));
}

Node::UnownedResultOf::Describe Node::SyncClient::Describe(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Describe(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Node::UnownedResultOf::Describe Node::Call::Describe(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Describe(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Node::DescribeResponse> Node::InPlace::Describe(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(DescribeRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<DescribeRequest> params(std::move(_request_buffer));
  Node::SetTransactionHeaderFor::DescribeRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::DescribeResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<DescribeRequest, DescribeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::DescribeResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Node::ResultOf::Sync_Impl<Node::SyncResponse>::Sync_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SyncRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Node::InPlace::Sync(std::move(_client_end), Super::response_buffer()));
}

Node::ResultOf::Sync Node::SyncClient::Sync() {
  return ResultOf::Sync(zx::unowned_channel(this->channel_));
}

Node::ResultOf::Sync Node::Call::Sync(zx::unowned_channel _client_end) {
  return ResultOf::Sync(std::move(_client_end));
}

template <>
Node::UnownedResultOf::Sync_Impl<Node::SyncResponse>::Sync_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(SyncRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, SyncRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Node::InPlace::Sync(std::move(_client_end), std::move(_response_buffer)));
}

Node::UnownedResultOf::Sync Node::SyncClient::Sync(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Sync(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Node::UnownedResultOf::Sync Node::Call::Sync(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Sync(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Node::SyncResponse> Node::InPlace::Sync(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(SyncRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<SyncRequest> params(std::move(_request_buffer));
  Node::SetTransactionHeaderFor::SyncRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::SyncResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SyncRequest, SyncResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::SyncResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Node::ResultOf::GetAttr_Impl<Node::GetAttrResponse>::GetAttr_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetAttrRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetAttrRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetAttrRequest));
  ::fidl::DecodedMessage<GetAttrRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Node::InPlace::GetAttr(std::move(_client_end), Super::response_buffer()));
}

Node::ResultOf::GetAttr Node::SyncClient::GetAttr() {
  return ResultOf::GetAttr(zx::unowned_channel(this->channel_));
}

Node::ResultOf::GetAttr Node::Call::GetAttr(zx::unowned_channel _client_end) {
  return ResultOf::GetAttr(std::move(_client_end));
}

template <>
Node::UnownedResultOf::GetAttr_Impl<Node::GetAttrResponse>::GetAttr_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetAttrRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetAttrRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetAttrRequest));
  ::fidl::DecodedMessage<GetAttrRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Node::InPlace::GetAttr(std::move(_client_end), std::move(_response_buffer)));
}

Node::UnownedResultOf::GetAttr Node::SyncClient::GetAttr(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetAttr(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Node::UnownedResultOf::GetAttr Node::Call::GetAttr(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetAttr(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Node::GetAttrResponse> Node::InPlace::GetAttr(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetAttrRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetAttrRequest> params(std::move(_request_buffer));
  Node::SetTransactionHeaderFor::GetAttrRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::GetAttrResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetAttrRequest, GetAttrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::GetAttrResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Node::ResultOf::SetAttr_Impl<Node::SetAttrResponse>::SetAttr_Impl(zx::unowned_channel _client_end, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetAttrRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetAttrRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetAttrRequest*>(_write_bytes);
  _request.flags = std::move(flags);
  _request.attributes = std::move(attributes);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetAttrRequest));
  ::fidl::DecodedMessage<SetAttrRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Node::InPlace::SetAttr(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Node::ResultOf::SetAttr Node::SyncClient::SetAttr(uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes) {
  return ResultOf::SetAttr(zx::unowned_channel(this->channel_), std::move(flags), std::move(attributes));
}

Node::ResultOf::SetAttr Node::Call::SetAttr(zx::unowned_channel _client_end, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes) {
  return ResultOf::SetAttr(std::move(_client_end), std::move(flags), std::move(attributes));
}

template <>
Node::UnownedResultOf::SetAttr_Impl<Node::SetAttrResponse>::SetAttr_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < SetAttrRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<SetAttrResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, SetAttrRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetAttrRequest*>(_request_buffer.data());
  _request.flags = std::move(flags);
  _request.attributes = std::move(attributes);
  _request_buffer.set_actual(sizeof(SetAttrRequest));
  ::fidl::DecodedMessage<SetAttrRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Node::InPlace::SetAttr(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Node::UnownedResultOf::SetAttr Node::SyncClient::SetAttr(::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetAttr(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(flags), std::move(attributes), std::move(_response_buffer));
}

Node::UnownedResultOf::SetAttr Node::Call::SetAttr(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetAttr(std::move(_client_end), std::move(_request_buffer), std::move(flags), std::move(attributes), std::move(_response_buffer));
}

::fidl::DecodeResult<Node::SetAttrResponse> Node::InPlace::SetAttr(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetAttrRequest> params, ::fidl::BytePart response_buffer) {
  Node::SetTransactionHeaderFor::SetAttrRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::SetAttrResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SetAttrRequest, SetAttrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::SetAttrResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Node::ResultOf::NodeGetFlags_Impl<Node::NodeGetFlagsResponse>::NodeGetFlags_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<NodeGetFlagsRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, NodeGetFlagsRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(NodeGetFlagsRequest));
  ::fidl::DecodedMessage<NodeGetFlagsRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Node::InPlace::NodeGetFlags(std::move(_client_end), Super::response_buffer()));
}

Node::ResultOf::NodeGetFlags Node::SyncClient::NodeGetFlags() {
  return ResultOf::NodeGetFlags(zx::unowned_channel(this->channel_));
}

Node::ResultOf::NodeGetFlags Node::Call::NodeGetFlags(zx::unowned_channel _client_end) {
  return ResultOf::NodeGetFlags(std::move(_client_end));
}

template <>
Node::UnownedResultOf::NodeGetFlags_Impl<Node::NodeGetFlagsResponse>::NodeGetFlags_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(NodeGetFlagsRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, NodeGetFlagsRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(NodeGetFlagsRequest));
  ::fidl::DecodedMessage<NodeGetFlagsRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Node::InPlace::NodeGetFlags(std::move(_client_end), std::move(_response_buffer)));
}

Node::UnownedResultOf::NodeGetFlags Node::SyncClient::NodeGetFlags(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::NodeGetFlags(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Node::UnownedResultOf::NodeGetFlags Node::Call::NodeGetFlags(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::NodeGetFlags(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Node::NodeGetFlagsResponse> Node::InPlace::NodeGetFlags(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(NodeGetFlagsRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<NodeGetFlagsRequest> params(std::move(_request_buffer));
  Node::SetTransactionHeaderFor::NodeGetFlagsRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::NodeGetFlagsResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<NodeGetFlagsRequest, NodeGetFlagsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::NodeGetFlagsResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Node::ResultOf::NodeSetFlags_Impl<Node::NodeSetFlagsResponse>::NodeSetFlags_Impl(zx::unowned_channel _client_end, uint32_t flags) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<NodeSetFlagsRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, NodeSetFlagsRequest::PrimarySize);
  auto& _request = *reinterpret_cast<NodeSetFlagsRequest*>(_write_bytes);
  _request.flags = std::move(flags);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(NodeSetFlagsRequest));
  ::fidl::DecodedMessage<NodeSetFlagsRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Node::InPlace::NodeSetFlags(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Node::ResultOf::NodeSetFlags Node::SyncClient::NodeSetFlags(uint32_t flags) {
  return ResultOf::NodeSetFlags(zx::unowned_channel(this->channel_), std::move(flags));
}

Node::ResultOf::NodeSetFlags Node::Call::NodeSetFlags(zx::unowned_channel _client_end, uint32_t flags) {
  return ResultOf::NodeSetFlags(std::move(_client_end), std::move(flags));
}

template <>
Node::UnownedResultOf::NodeSetFlags_Impl<Node::NodeSetFlagsResponse>::NodeSetFlags_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < NodeSetFlagsRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<NodeSetFlagsResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, NodeSetFlagsRequest::PrimarySize);
  auto& _request = *reinterpret_cast<NodeSetFlagsRequest*>(_request_buffer.data());
  _request.flags = std::move(flags);
  _request_buffer.set_actual(sizeof(NodeSetFlagsRequest));
  ::fidl::DecodedMessage<NodeSetFlagsRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Node::InPlace::NodeSetFlags(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Node::UnownedResultOf::NodeSetFlags Node::SyncClient::NodeSetFlags(::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::NodeSetFlags(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(flags), std::move(_response_buffer));
}

Node::UnownedResultOf::NodeSetFlags Node::Call::NodeSetFlags(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::NodeSetFlags(std::move(_client_end), std::move(_request_buffer), std::move(flags), std::move(_response_buffer));
}

::fidl::DecodeResult<Node::NodeSetFlagsResponse> Node::InPlace::NodeSetFlags(zx::unowned_channel _client_end, ::fidl::DecodedMessage<NodeSetFlagsRequest> params, ::fidl::BytePart response_buffer) {
  Node::SetTransactionHeaderFor::NodeSetFlagsRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::NodeSetFlagsResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<NodeSetFlagsRequest, NodeSetFlagsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::NodeSetFlagsResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

zx_status_t Node::SyncClient::HandleEvents(Node::EventHandlers handlers) {
  return Node::Call::HandleEvents(zx::unowned_channel(channel_), std::move(handlers));
}

zx_status_t Node::Call::HandleEvents(zx::unowned_channel client_end, Node::EventHandlers handlers) {
  zx_status_t status = client_end->wait_one(ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED,
                                            zx::time::infinite(),
                                            nullptr);
  if (status != ZX_OK) {
    return status;
  }
  constexpr uint32_t kReadAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::internal::ClampedMessageSize<OnOpenResponse, ::fidl::MessageDirection::kReceiving>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<OnOpenResponse, ::fidl::MessageDirection::kReceiving>();
    }
    if (::fidl::internal::ClampedMessageSize<OnOpenResponse, ::fidl::MessageDirection::kReceiving, ::fidl::internal::WireFormatGuide::kAlternate>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<OnOpenResponse, ::fidl::MessageDirection::kReceiving, ::fidl::internal::WireFormatGuide::kAlternate>();
    }
    return x;
  })();
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (OnOpenResponse::MaxNumHandles >= x) {
      x = OnOpenResponse::MaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  ::fidl::internal::ByteStorage<kReadAllocSize> read_storage;
  uint8_t* read_bytes = read_storage.buffer().data();
  zx_handle_t read_handles[kHandleAllocSize];
  uint32_t actual_bytes;
  uint32_t actual_handles;
  status = client_end->read(ZX_CHANNEL_READ_MAY_DISCARD,
                            read_bytes, read_handles,
                            kReadAllocSize, kHandleAllocSize,
                            &actual_bytes, &actual_handles);
  if (status == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new event,
    // whose size exceeds the maximum of known events in the current protocol.
    return handlers.unknown();
  }
  if (status != ZX_OK) {
    return status;
  }
  if (actual_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(read_handles, actual_handles);
    return ZX_ERR_INVALID_ARGS;
  }
  auto msg = fidl_msg_t {
      .bytes = read_bytes,
      .handles = read_handles,
      .num_bytes = actual_bytes,
      .num_handles = actual_handles
  };
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg.bytes);
  status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    return status;
  }
  switch (hdr->ordinal) {
    case kNode_OnOpen_Ordinal:
    case kNode_OnOpen_GenOrdinal:
    {
      constexpr uint32_t kTransformerDestSize = ::fidl::internal::ClampedMessageSize<OnOpenResponse, ::fidl::MessageDirection::kReceiving>();
      ::fidl::internal::ByteStorage<kTransformerDestSize> transformer_dest_storage(::fidl::internal::DelayAllocation);
      if (fidl_should_decode_union_from_xunion(hdr)) {
        transformer_dest_storage.Allocate();
        uint8_t* transformer_dest = transformer_dest_storage.buffer().data();
        zx_status_t transform_status = fidl_transform(FIDL_TRANSFORMATION_V1_TO_OLD,
                                                      OnOpenResponse::AltType,
                                                      reinterpret_cast<uint8_t*>(msg.bytes),
                                                      msg.num_bytes,
                                                      transformer_dest,
                                                      kTransformerDestSize,
                                                      &msg.num_bytes,
                                                      nullptr);
        if (transform_status != ZX_OK) {
          zx_handle_close_many(msg.handles, msg.num_handles);
          return ZX_ERR_INVALID_ARGS;
        }
        msg.bytes = transformer_dest;
      }
      auto result = ::fidl::DecodeAs<OnOpenResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      auto message = result.message.message();
      return handlers.on_open(std::move(message->s), std::move(message->info));
    }
    default:
      zx_handle_close_many(read_handles, actual_handles);
      return handlers.unknown();
  }
}

bool Node::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kNode_Clone_Ordinal:
    case kNode_Clone_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<CloneRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Clone(std::move(message->flags), std::move(message->object),
          Interface::CloneCompleter::Sync(txn));
      return true;
    }
    case kNode_Close_Ordinal:
    case kNode_Close_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<CloseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Close(
          Interface::CloseCompleter::Sync(txn));
      return true;
    }
    case kNode_Describe_Ordinal:
    case kNode_Describe_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<DescribeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Describe(
          Interface::DescribeCompleter::Sync(txn));
      return true;
    }
    case kNode_Sync_Ordinal:
    case kNode_Sync_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SyncRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Sync(
          Interface::SyncCompleter::Sync(txn));
      return true;
    }
    case kNode_GetAttr_Ordinal:
    case kNode_GetAttr_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetAttrRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetAttr(
          Interface::GetAttrCompleter::Sync(txn));
      return true;
    }
    case kNode_SetAttr_Ordinal:
    case kNode_SetAttr_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetAttrRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetAttr(std::move(message->flags), std::move(message->attributes),
          Interface::SetAttrCompleter::Sync(txn));
      return true;
    }
    case kNode_NodeGetFlags_Ordinal:
    case kNode_NodeGetFlags_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<NodeGetFlagsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->NodeGetFlags(
          Interface::NodeGetFlagsCompleter::Sync(txn));
      return true;
    }
    case kNode_NodeSetFlags_Ordinal:
    case kNode_NodeSetFlags_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<NodeSetFlagsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->NodeSetFlags(std::move(message->flags),
          Interface::NodeSetFlagsCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Node::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void Node::Interface::CloseCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<CloseResponse*>(_write_bytes);
  Node::SetTransactionHeaderFor::CloseResponse(
      ::fidl::DecodedMessage<CloseResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              CloseResponse::PrimarySize,
              CloseResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CloseResponse>(std::move(_response_bytes)));
}

void Node::Interface::CloseCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < CloseResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<CloseResponse*>(_buffer.data());
  Node::SetTransactionHeaderFor::CloseResponse(
      ::fidl::DecodedMessage<CloseResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              CloseResponse::PrimarySize,
              CloseResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(CloseResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CloseResponse>(std::move(_buffer)));
}

void Node::Interface::CloseCompleterBase::Reply(::fidl::DecodedMessage<CloseResponse> params) {
  Node::SetTransactionHeaderFor::CloseResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Node::Interface::DescribeCompleterBase::Reply(::llcpp::fuchsia::io::NodeInfo info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DescribeResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<DescribeResponse*>(_write_bytes);
  Node::SetTransactionHeaderFor::DescribeResponse(
      ::fidl::DecodedMessage<DescribeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              DescribeResponse::PrimarySize,
              DescribeResponse::PrimarySize)));
  _response.info = std::move(info);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(DescribeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<DescribeResponse>(std::move(_response_bytes)));
}

void Node::Interface::DescribeCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io::NodeInfo info) {
  if (_buffer.capacity() < DescribeResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<DescribeResponse*>(_buffer.data());
  Node::SetTransactionHeaderFor::DescribeResponse(
      ::fidl::DecodedMessage<DescribeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              DescribeResponse::PrimarySize,
              DescribeResponse::PrimarySize)));
  _response.info = std::move(info);
  _buffer.set_actual(sizeof(DescribeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<DescribeResponse>(std::move(_buffer)));
}

void Node::Interface::DescribeCompleterBase::Reply(::fidl::DecodedMessage<DescribeResponse> params) {
  Node::SetTransactionHeaderFor::DescribeResponse(params);
  CompleterBase::SendReply(std::move(params));
}


zx_status_t Node::SendOnOpenEvent(::zx::unowned_channel _chan, int32_t s, ::llcpp::fuchsia::io::NodeInfo* info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OnOpenResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  OnOpenResponse _response = {};
  Node::SetTransactionHeaderFor::OnOpenResponse(
      ::fidl::DecodedMessage<OnOpenResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OnOpenResponse::PrimarySize,
              OnOpenResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t Node::SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, int32_t s, ::llcpp::fuchsia::io::NodeInfo* info) {
  if (_buffer.capacity() < OnOpenResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  OnOpenResponse _response = {};
  Node::SetTransactionHeaderFor::OnOpenResponse(
      ::fidl::DecodedMessage<OnOpenResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OnOpenResponse::PrimarySize,
              OnOpenResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
	return _linearize_result.status;
  }
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t Node::SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnOpenResponse> params) {
  Node::SetTransactionHeaderFor::OnOpenResponse(params);
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(params));
}


void Node::Interface::SyncCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SyncResponse*>(_write_bytes);
  Node::SetTransactionHeaderFor::SyncResponse(
      ::fidl::DecodedMessage<SyncResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SyncResponse::PrimarySize,
              SyncResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SyncResponse>(std::move(_response_bytes)));
}

void Node::Interface::SyncCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < SyncResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SyncResponse*>(_buffer.data());
  Node::SetTransactionHeaderFor::SyncResponse(
      ::fidl::DecodedMessage<SyncResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SyncResponse::PrimarySize,
              SyncResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(SyncResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SyncResponse>(std::move(_buffer)));
}

void Node::Interface::SyncCompleterBase::Reply(::fidl::DecodedMessage<SyncResponse> params) {
  Node::SetTransactionHeaderFor::SyncResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Node::Interface::GetAttrCompleterBase::Reply(int32_t s, ::llcpp::fuchsia::io::NodeAttributes attributes) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetAttrResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetAttrResponse*>(_write_bytes);
  Node::SetTransactionHeaderFor::GetAttrResponse(
      ::fidl::DecodedMessage<GetAttrResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetAttrResponse::PrimarySize,
              GetAttrResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.attributes = std::move(attributes);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetAttrResponse>(std::move(_response_bytes)));
}

void Node::Interface::GetAttrCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, ::llcpp::fuchsia::io::NodeAttributes attributes) {
  if (_buffer.capacity() < GetAttrResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetAttrResponse*>(_buffer.data());
  Node::SetTransactionHeaderFor::GetAttrResponse(
      ::fidl::DecodedMessage<GetAttrResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetAttrResponse::PrimarySize,
              GetAttrResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.attributes = std::move(attributes);
  _buffer.set_actual(sizeof(GetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetAttrResponse>(std::move(_buffer)));
}

void Node::Interface::GetAttrCompleterBase::Reply(::fidl::DecodedMessage<GetAttrResponse> params) {
  Node::SetTransactionHeaderFor::GetAttrResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Node::Interface::SetAttrCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetAttrResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SetAttrResponse*>(_write_bytes);
  Node::SetTransactionHeaderFor::SetAttrResponse(
      ::fidl::DecodedMessage<SetAttrResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetAttrResponse::PrimarySize,
              SetAttrResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetAttrResponse>(std::move(_response_bytes)));
}

void Node::Interface::SetAttrCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < SetAttrResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SetAttrResponse*>(_buffer.data());
  Node::SetTransactionHeaderFor::SetAttrResponse(
      ::fidl::DecodedMessage<SetAttrResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetAttrResponse::PrimarySize,
              SetAttrResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(SetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetAttrResponse>(std::move(_buffer)));
}

void Node::Interface::SetAttrCompleterBase::Reply(::fidl::DecodedMessage<SetAttrResponse> params) {
  Node::SetTransactionHeaderFor::SetAttrResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Node::Interface::NodeGetFlagsCompleterBase::Reply(int32_t s, uint32_t flags) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<NodeGetFlagsResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<NodeGetFlagsResponse*>(_write_bytes);
  Node::SetTransactionHeaderFor::NodeGetFlagsResponse(
      ::fidl::DecodedMessage<NodeGetFlagsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              NodeGetFlagsResponse::PrimarySize,
              NodeGetFlagsResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.flags = std::move(flags);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(NodeGetFlagsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<NodeGetFlagsResponse>(std::move(_response_bytes)));
}

void Node::Interface::NodeGetFlagsCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, uint32_t flags) {
  if (_buffer.capacity() < NodeGetFlagsResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<NodeGetFlagsResponse*>(_buffer.data());
  Node::SetTransactionHeaderFor::NodeGetFlagsResponse(
      ::fidl::DecodedMessage<NodeGetFlagsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              NodeGetFlagsResponse::PrimarySize,
              NodeGetFlagsResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.flags = std::move(flags);
  _buffer.set_actual(sizeof(NodeGetFlagsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<NodeGetFlagsResponse>(std::move(_buffer)));
}

void Node::Interface::NodeGetFlagsCompleterBase::Reply(::fidl::DecodedMessage<NodeGetFlagsResponse> params) {
  Node::SetTransactionHeaderFor::NodeGetFlagsResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Node::Interface::NodeSetFlagsCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<NodeSetFlagsResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<NodeSetFlagsResponse*>(_write_bytes);
  Node::SetTransactionHeaderFor::NodeSetFlagsResponse(
      ::fidl::DecodedMessage<NodeSetFlagsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              NodeSetFlagsResponse::PrimarySize,
              NodeSetFlagsResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(NodeSetFlagsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<NodeSetFlagsResponse>(std::move(_response_bytes)));
}

void Node::Interface::NodeSetFlagsCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < NodeSetFlagsResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<NodeSetFlagsResponse*>(_buffer.data());
  Node::SetTransactionHeaderFor::NodeSetFlagsResponse(
      ::fidl::DecodedMessage<NodeSetFlagsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              NodeSetFlagsResponse::PrimarySize,
              NodeSetFlagsResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(NodeSetFlagsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<NodeSetFlagsResponse>(std::move(_buffer)));
}

void Node::Interface::NodeSetFlagsCompleterBase::Reply(::fidl::DecodedMessage<NodeSetFlagsResponse> params) {
  Node::SetTransactionHeaderFor::NodeSetFlagsResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void Node::SetTransactionHeaderFor::CloneRequest(const ::fidl::DecodedMessage<Node::CloneRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kNode_Clone_Ordinal);
}

void Node::SetTransactionHeaderFor::CloseRequest(const ::fidl::DecodedMessage<Node::CloseRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kNode_Close_Ordinal);
}
void Node::SetTransactionHeaderFor::CloseResponse(const ::fidl::DecodedMessage<Node::CloseResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kNode_Close_Ordinal);
}

void Node::SetTransactionHeaderFor::DescribeRequest(const ::fidl::DecodedMessage<Node::DescribeRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kNode_Describe_Ordinal);
}
void Node::SetTransactionHeaderFor::DescribeResponse(const ::fidl::DecodedMessage<Node::DescribeResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kNode_Describe_Ordinal);
}

void Node::SetTransactionHeaderFor::OnOpenResponse(const ::fidl::DecodedMessage<Node::OnOpenResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kNode_OnOpen_Ordinal);
}

void Node::SetTransactionHeaderFor::SyncRequest(const ::fidl::DecodedMessage<Node::SyncRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kNode_Sync_Ordinal);
}
void Node::SetTransactionHeaderFor::SyncResponse(const ::fidl::DecodedMessage<Node::SyncResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kNode_Sync_Ordinal);
}

void Node::SetTransactionHeaderFor::GetAttrRequest(const ::fidl::DecodedMessage<Node::GetAttrRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kNode_GetAttr_Ordinal);
}
void Node::SetTransactionHeaderFor::GetAttrResponse(const ::fidl::DecodedMessage<Node::GetAttrResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kNode_GetAttr_Ordinal);
}

void Node::SetTransactionHeaderFor::SetAttrRequest(const ::fidl::DecodedMessage<Node::SetAttrRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kNode_SetAttr_Ordinal);
}
void Node::SetTransactionHeaderFor::SetAttrResponse(const ::fidl::DecodedMessage<Node::SetAttrResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kNode_SetAttr_Ordinal);
}

void Node::SetTransactionHeaderFor::NodeGetFlagsRequest(const ::fidl::DecodedMessage<Node::NodeGetFlagsRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kNode_NodeGetFlags_Ordinal);
}
void Node::SetTransactionHeaderFor::NodeGetFlagsResponse(const ::fidl::DecodedMessage<Node::NodeGetFlagsResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kNode_NodeGetFlags_Ordinal);
}

void Node::SetTransactionHeaderFor::NodeSetFlagsRequest(const ::fidl::DecodedMessage<Node::NodeSetFlagsRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kNode_NodeSetFlags_Ordinal);
}
void Node::SetTransactionHeaderFor::NodeSetFlagsResponse(const ::fidl::DecodedMessage<Node::NodeSetFlagsResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kNode_NodeSetFlags_Ordinal);
}

namespace {

[[maybe_unused]]
constexpr uint64_t kFile_Clone_Ordinal = 0x17fe6a4c00000000lu;
[[maybe_unused]]
constexpr uint64_t kFile_Clone_GenOrdinal = 0x5a61678f293ce16flu;
extern "C" const fidl_type_t fuchsia_io_FileCloneRequestTable;
extern "C" const fidl_type_t fuchsia_io_FileCloneResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_FileCloneResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_Close_Ordinal = 0x52b9568700000000lu;
[[maybe_unused]]
constexpr uint64_t kFile_Close_GenOrdinal = 0x5309c5bd1c33dc44lu;
extern "C" const fidl_type_t fuchsia_io_FileCloseRequestTable;
extern "C" const fidl_type_t fuchsia_io_FileCloseResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_FileCloseResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_Describe_Ordinal = 0x1f62df5e00000000lu;
[[maybe_unused]]
constexpr uint64_t kFile_Describe_GenOrdinal = 0xffcec215078dea0lu;
extern "C" const fidl_type_t fuchsia_io_FileDescribeRequestTable;
extern "C" const fidl_type_t fuchsia_io_FileDescribeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_FileDescribeResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_OnOpen_Ordinal = 0x4700a7bd00000000lu;
[[maybe_unused]]
constexpr uint64_t kFile_OnOpen_GenOrdinal = 0x7fc7bbb1dbfd1972lu;
extern "C" const fidl_type_t fuchsia_io_FileOnOpenRequestTable;
extern "C" const fidl_type_t fuchsia_io_FileOnOpenEventTable;
extern "C" const fidl_type_t v1_fuchsia_io_FileOnOpenEventTable;
[[maybe_unused]]
constexpr uint64_t kFile_Sync_Ordinal = 0x62423faa00000000lu;
[[maybe_unused]]
constexpr uint64_t kFile_Sync_GenOrdinal = 0x189d88326c18b519lu;
extern "C" const fidl_type_t fuchsia_io_FileSyncRequestTable;
extern "C" const fidl_type_t fuchsia_io_FileSyncResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_FileSyncResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_GetAttr_Ordinal = 0x4585e7c800000000lu;
[[maybe_unused]]
constexpr uint64_t kFile_GetAttr_GenOrdinal = 0x78985e216314dafdlu;
extern "C" const fidl_type_t fuchsia_io_FileGetAttrRequestTable;
extern "C" const fidl_type_t fuchsia_io_FileGetAttrResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_FileGetAttrResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_SetAttr_Ordinal = 0xbd5559a00000000lu;
[[maybe_unused]]
constexpr uint64_t kFile_SetAttr_GenOrdinal = 0x4186c0f40d938f46lu;
extern "C" const fidl_type_t fuchsia_io_FileSetAttrRequestTable;
extern "C" const fidl_type_t fuchsia_io_FileSetAttrResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_FileSetAttrResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_NodeGetFlags_Ordinal = 0x3c24c22300000000lu;
[[maybe_unused]]
constexpr uint64_t kFile_NodeGetFlags_GenOrdinal = 0x5b88fffb8eda3aa1lu;
extern "C" const fidl_type_t fuchsia_io_FileNodeGetFlagsRequestTable;
extern "C" const fidl_type_t fuchsia_io_FileNodeGetFlagsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_FileNodeGetFlagsResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_NodeSetFlags_Ordinal = 0x46940c1600000000lu;
[[maybe_unused]]
constexpr uint64_t kFile_NodeSetFlags_GenOrdinal = 0x5295b76c71fde733lu;
extern "C" const fidl_type_t fuchsia_io_FileNodeSetFlagsRequestTable;
extern "C" const fidl_type_t fuchsia_io_FileNodeSetFlagsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_FileNodeSetFlagsResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_Read_Ordinal = 0x25f7418400000000lu;
[[maybe_unused]]
constexpr uint64_t kFile_Read_GenOrdinal = 0x29b2b7074c95208clu;
extern "C" const fidl_type_t fuchsia_io_FileReadRequestTable;
extern "C" const fidl_type_t fuchsia_io_FileReadResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_FileReadResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_ReadAt_Ordinal = 0x7c724dc400000000lu;
[[maybe_unused]]
constexpr uint64_t kFile_ReadAt_GenOrdinal = 0x6527ee3fbc9c5749lu;
extern "C" const fidl_type_t fuchsia_io_FileReadAtRequestTable;
extern "C" const fidl_type_t fuchsia_io_FileReadAtResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_FileReadAtResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_Write_Ordinal = 0x512e7a000000000lu;
[[maybe_unused]]
constexpr uint64_t kFile_Write_GenOrdinal = 0x3b6432f57914225blu;
extern "C" const fidl_type_t fuchsia_io_FileWriteRequestTable;
extern "C" const fidl_type_t fuchsia_io_FileWriteResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_FileWriteResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_WriteAt_Ordinal = 0x3e5522e500000000lu;
[[maybe_unused]]
constexpr uint64_t kFile_WriteAt_GenOrdinal = 0x4b29e1582ab379e4lu;
extern "C" const fidl_type_t fuchsia_io_FileWriteAtRequestTable;
extern "C" const fidl_type_t fuchsia_io_FileWriteAtResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_FileWriteAtResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_Seek_Ordinal = 0x782a774500000000lu;
[[maybe_unused]]
constexpr uint64_t kFile_Seek_GenOrdinal = 0x324968e9b8a0e394lu;
extern "C" const fidl_type_t fuchsia_io_FileSeekRequestTable;
extern "C" const fidl_type_t fuchsia_io_FileSeekResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_FileSeekResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_Truncate_Ordinal = 0x42ab3a3a00000000lu;
[[maybe_unused]]
constexpr uint64_t kFile_Truncate_GenOrdinal = 0x5ec8f337359a2ddblu;
extern "C" const fidl_type_t fuchsia_io_FileTruncateRequestTable;
extern "C" const fidl_type_t fuchsia_io_FileTruncateResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_FileTruncateResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_GetFlags_Ordinal = 0x6416a3f600000000lu;
[[maybe_unused]]
constexpr uint64_t kFile_GetFlags_GenOrdinal = 0x200be82ca523ab96lu;
extern "C" const fidl_type_t fuchsia_io_FileGetFlagsRequestTable;
extern "C" const fidl_type_t fuchsia_io_FileGetFlagsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_FileGetFlagsResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_SetFlags_Ordinal = 0x3f23cc7600000000lu;
[[maybe_unused]]
constexpr uint64_t kFile_SetFlags_GenOrdinal = 0x713f375258671141lu;
extern "C" const fidl_type_t fuchsia_io_FileSetFlagsRequestTable;
extern "C" const fidl_type_t fuchsia_io_FileSetFlagsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_FileSetFlagsResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_GetBuffer_Ordinal = 0x74c3097300000000lu;
[[maybe_unused]]
constexpr uint64_t kFile_GetBuffer_GenOrdinal = 0x4b93b8486666d951lu;
extern "C" const fidl_type_t fuchsia_io_FileGetBufferRequestTable;
extern "C" const fidl_type_t fuchsia_io_FileGetBufferResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_FileGetBufferResponseTable;

}  // namespace

File::ResultOf::Clone_Impl::Clone_Impl(zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloneRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CloneRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CloneRequest*>(_write_bytes);
  _request.flags = std::move(flags);
  _request.object = std::move(object);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloneRequest));
  ::fidl::DecodedMessage<CloneRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      File::InPlace::Clone(std::move(_client_end), std::move(_decoded_request)));
}

File::ResultOf::Clone File::SyncClient::Clone(uint32_t flags, ::zx::channel object) {
  return ResultOf::Clone(zx::unowned_channel(this->channel_), std::move(flags), std::move(object));
}

File::ResultOf::Clone File::Call::Clone(zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object) {
  return ResultOf::Clone(std::move(_client_end), std::move(flags), std::move(object));
}


File::UnownedResultOf::Clone_Impl::Clone_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object) {
  if (_request_buffer.capacity() < CloneRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, CloneRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CloneRequest*>(_request_buffer.data());
  _request.flags = std::move(flags);
  _request.object = std::move(object);
  _request_buffer.set_actual(sizeof(CloneRequest));
  ::fidl::DecodedMessage<CloneRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      File::InPlace::Clone(std::move(_client_end), std::move(_decoded_request)));
}

File::UnownedResultOf::Clone File::SyncClient::Clone(::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object) {
  return UnownedResultOf::Clone(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(flags), std::move(object));
}

File::UnownedResultOf::Clone File::Call::Clone(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object) {
  return UnownedResultOf::Clone(std::move(_client_end), std::move(_request_buffer), std::move(flags), std::move(object));
}

::fidl::internal::StatusAndError File::InPlace::Clone(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CloneRequest> params) {
  File::SetTransactionHeaderFor::CloneRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
File::ResultOf::Close_Impl<File::CloseResponse>::Close_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CloseRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseRequest));
  ::fidl::DecodedMessage<CloseRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      File::InPlace::Close(std::move(_client_end), Super::response_buffer()));
}

File::ResultOf::Close File::SyncClient::Close() {
  return ResultOf::Close(zx::unowned_channel(this->channel_));
}

File::ResultOf::Close File::Call::Close(zx::unowned_channel _client_end) {
  return ResultOf::Close(std::move(_client_end));
}

template <>
File::UnownedResultOf::Close_Impl<File::CloseResponse>::Close_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(CloseRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, CloseRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(CloseRequest));
  ::fidl::DecodedMessage<CloseRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      File::InPlace::Close(std::move(_client_end), std::move(_response_buffer)));
}

File::UnownedResultOf::Close File::SyncClient::Close(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Close(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

File::UnownedResultOf::Close File::Call::Close(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Close(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<File::CloseResponse> File::InPlace::Close(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(CloseRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<CloseRequest> params(std::move(_request_buffer));
  File::SetTransactionHeaderFor::CloseRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::CloseResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<CloseRequest, CloseResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::CloseResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
File::ResultOf::Describe_Impl<File::DescribeResponse>::Describe_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DescribeRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, DescribeRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(DescribeRequest));
  ::fidl::DecodedMessage<DescribeRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      File::InPlace::Describe(std::move(_client_end), Super::response_buffer()));
}

File::ResultOf::Describe File::SyncClient::Describe() {
  return ResultOf::Describe(zx::unowned_channel(this->channel_));
}

File::ResultOf::Describe File::Call::Describe(zx::unowned_channel _client_end) {
  return ResultOf::Describe(std::move(_client_end));
}

template <>
File::UnownedResultOf::Describe_Impl<File::DescribeResponse>::Describe_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(DescribeRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, DescribeRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(DescribeRequest));
  ::fidl::DecodedMessage<DescribeRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      File::InPlace::Describe(std::move(_client_end), std::move(_response_buffer)));
}

File::UnownedResultOf::Describe File::SyncClient::Describe(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Describe(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

File::UnownedResultOf::Describe File::Call::Describe(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Describe(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<File::DescribeResponse> File::InPlace::Describe(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(DescribeRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<DescribeRequest> params(std::move(_request_buffer));
  File::SetTransactionHeaderFor::DescribeRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::DescribeResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<DescribeRequest, DescribeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::DescribeResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
File::ResultOf::Sync_Impl<File::SyncResponse>::Sync_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SyncRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      File::InPlace::Sync(std::move(_client_end), Super::response_buffer()));
}

File::ResultOf::Sync File::SyncClient::Sync() {
  return ResultOf::Sync(zx::unowned_channel(this->channel_));
}

File::ResultOf::Sync File::Call::Sync(zx::unowned_channel _client_end) {
  return ResultOf::Sync(std::move(_client_end));
}

template <>
File::UnownedResultOf::Sync_Impl<File::SyncResponse>::Sync_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(SyncRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, SyncRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      File::InPlace::Sync(std::move(_client_end), std::move(_response_buffer)));
}

File::UnownedResultOf::Sync File::SyncClient::Sync(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Sync(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

File::UnownedResultOf::Sync File::Call::Sync(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Sync(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<File::SyncResponse> File::InPlace::Sync(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(SyncRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<SyncRequest> params(std::move(_request_buffer));
  File::SetTransactionHeaderFor::SyncRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::SyncResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SyncRequest, SyncResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::SyncResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
File::ResultOf::GetAttr_Impl<File::GetAttrResponse>::GetAttr_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetAttrRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetAttrRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetAttrRequest));
  ::fidl::DecodedMessage<GetAttrRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      File::InPlace::GetAttr(std::move(_client_end), Super::response_buffer()));
}

File::ResultOf::GetAttr File::SyncClient::GetAttr() {
  return ResultOf::GetAttr(zx::unowned_channel(this->channel_));
}

File::ResultOf::GetAttr File::Call::GetAttr(zx::unowned_channel _client_end) {
  return ResultOf::GetAttr(std::move(_client_end));
}

template <>
File::UnownedResultOf::GetAttr_Impl<File::GetAttrResponse>::GetAttr_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetAttrRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetAttrRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetAttrRequest));
  ::fidl::DecodedMessage<GetAttrRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      File::InPlace::GetAttr(std::move(_client_end), std::move(_response_buffer)));
}

File::UnownedResultOf::GetAttr File::SyncClient::GetAttr(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetAttr(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

File::UnownedResultOf::GetAttr File::Call::GetAttr(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetAttr(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<File::GetAttrResponse> File::InPlace::GetAttr(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetAttrRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetAttrRequest> params(std::move(_request_buffer));
  File::SetTransactionHeaderFor::GetAttrRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::GetAttrResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetAttrRequest, GetAttrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::GetAttrResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
File::ResultOf::SetAttr_Impl<File::SetAttrResponse>::SetAttr_Impl(zx::unowned_channel _client_end, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetAttrRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetAttrRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetAttrRequest*>(_write_bytes);
  _request.flags = std::move(flags);
  _request.attributes = std::move(attributes);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetAttrRequest));
  ::fidl::DecodedMessage<SetAttrRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      File::InPlace::SetAttr(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

File::ResultOf::SetAttr File::SyncClient::SetAttr(uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes) {
  return ResultOf::SetAttr(zx::unowned_channel(this->channel_), std::move(flags), std::move(attributes));
}

File::ResultOf::SetAttr File::Call::SetAttr(zx::unowned_channel _client_end, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes) {
  return ResultOf::SetAttr(std::move(_client_end), std::move(flags), std::move(attributes));
}

template <>
File::UnownedResultOf::SetAttr_Impl<File::SetAttrResponse>::SetAttr_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < SetAttrRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<SetAttrResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, SetAttrRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetAttrRequest*>(_request_buffer.data());
  _request.flags = std::move(flags);
  _request.attributes = std::move(attributes);
  _request_buffer.set_actual(sizeof(SetAttrRequest));
  ::fidl::DecodedMessage<SetAttrRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      File::InPlace::SetAttr(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

File::UnownedResultOf::SetAttr File::SyncClient::SetAttr(::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetAttr(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(flags), std::move(attributes), std::move(_response_buffer));
}

File::UnownedResultOf::SetAttr File::Call::SetAttr(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetAttr(std::move(_client_end), std::move(_request_buffer), std::move(flags), std::move(attributes), std::move(_response_buffer));
}

::fidl::DecodeResult<File::SetAttrResponse> File::InPlace::SetAttr(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetAttrRequest> params, ::fidl::BytePart response_buffer) {
  File::SetTransactionHeaderFor::SetAttrRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::SetAttrResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SetAttrRequest, SetAttrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::SetAttrResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
File::ResultOf::NodeGetFlags_Impl<File::NodeGetFlagsResponse>::NodeGetFlags_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<NodeGetFlagsRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, NodeGetFlagsRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(NodeGetFlagsRequest));
  ::fidl::DecodedMessage<NodeGetFlagsRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      File::InPlace::NodeGetFlags(std::move(_client_end), Super::response_buffer()));
}

File::ResultOf::NodeGetFlags File::SyncClient::NodeGetFlags() {
  return ResultOf::NodeGetFlags(zx::unowned_channel(this->channel_));
}

File::ResultOf::NodeGetFlags File::Call::NodeGetFlags(zx::unowned_channel _client_end) {
  return ResultOf::NodeGetFlags(std::move(_client_end));
}

template <>
File::UnownedResultOf::NodeGetFlags_Impl<File::NodeGetFlagsResponse>::NodeGetFlags_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(NodeGetFlagsRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, NodeGetFlagsRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(NodeGetFlagsRequest));
  ::fidl::DecodedMessage<NodeGetFlagsRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      File::InPlace::NodeGetFlags(std::move(_client_end), std::move(_response_buffer)));
}

File::UnownedResultOf::NodeGetFlags File::SyncClient::NodeGetFlags(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::NodeGetFlags(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

File::UnownedResultOf::NodeGetFlags File::Call::NodeGetFlags(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::NodeGetFlags(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<File::NodeGetFlagsResponse> File::InPlace::NodeGetFlags(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(NodeGetFlagsRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<NodeGetFlagsRequest> params(std::move(_request_buffer));
  File::SetTransactionHeaderFor::NodeGetFlagsRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::NodeGetFlagsResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<NodeGetFlagsRequest, NodeGetFlagsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::NodeGetFlagsResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
File::ResultOf::NodeSetFlags_Impl<File::NodeSetFlagsResponse>::NodeSetFlags_Impl(zx::unowned_channel _client_end, uint32_t flags) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<NodeSetFlagsRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, NodeSetFlagsRequest::PrimarySize);
  auto& _request = *reinterpret_cast<NodeSetFlagsRequest*>(_write_bytes);
  _request.flags = std::move(flags);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(NodeSetFlagsRequest));
  ::fidl::DecodedMessage<NodeSetFlagsRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      File::InPlace::NodeSetFlags(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

File::ResultOf::NodeSetFlags File::SyncClient::NodeSetFlags(uint32_t flags) {
  return ResultOf::NodeSetFlags(zx::unowned_channel(this->channel_), std::move(flags));
}

File::ResultOf::NodeSetFlags File::Call::NodeSetFlags(zx::unowned_channel _client_end, uint32_t flags) {
  return ResultOf::NodeSetFlags(std::move(_client_end), std::move(flags));
}

template <>
File::UnownedResultOf::NodeSetFlags_Impl<File::NodeSetFlagsResponse>::NodeSetFlags_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < NodeSetFlagsRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<NodeSetFlagsResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, NodeSetFlagsRequest::PrimarySize);
  auto& _request = *reinterpret_cast<NodeSetFlagsRequest*>(_request_buffer.data());
  _request.flags = std::move(flags);
  _request_buffer.set_actual(sizeof(NodeSetFlagsRequest));
  ::fidl::DecodedMessage<NodeSetFlagsRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      File::InPlace::NodeSetFlags(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

File::UnownedResultOf::NodeSetFlags File::SyncClient::NodeSetFlags(::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::NodeSetFlags(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(flags), std::move(_response_buffer));
}

File::UnownedResultOf::NodeSetFlags File::Call::NodeSetFlags(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::NodeSetFlags(std::move(_client_end), std::move(_request_buffer), std::move(flags), std::move(_response_buffer));
}

::fidl::DecodeResult<File::NodeSetFlagsResponse> File::InPlace::NodeSetFlags(zx::unowned_channel _client_end, ::fidl::DecodedMessage<NodeSetFlagsRequest> params, ::fidl::BytePart response_buffer) {
  File::SetTransactionHeaderFor::NodeSetFlagsRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::NodeSetFlagsResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<NodeSetFlagsRequest, NodeSetFlagsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::NodeSetFlagsResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
File::ResultOf::Read_Impl<File::ReadResponse>::Read_Impl(zx::unowned_channel _client_end, uint64_t count) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReadRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ReadRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReadRequest*>(_write_bytes);
  _request.count = std::move(count);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ReadRequest));
  ::fidl::DecodedMessage<ReadRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      File::InPlace::Read(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

File::ResultOf::Read File::SyncClient::Read(uint64_t count) {
  return ResultOf::Read(zx::unowned_channel(this->channel_), std::move(count));
}

File::ResultOf::Read File::Call::Read(zx::unowned_channel _client_end, uint64_t count) {
  return ResultOf::Read(std::move(_client_end), std::move(count));
}

template <>
File::UnownedResultOf::Read_Impl<File::ReadResponse>::Read_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t count, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < ReadRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<ReadResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, ReadRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReadRequest*>(_request_buffer.data());
  _request.count = std::move(count);
  _request_buffer.set_actual(sizeof(ReadRequest));
  ::fidl::DecodedMessage<ReadRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      File::InPlace::Read(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

File::UnownedResultOf::Read File::SyncClient::Read(::fidl::BytePart _request_buffer, uint64_t count, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Read(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(count), std::move(_response_buffer));
}

File::UnownedResultOf::Read File::Call::Read(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t count, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Read(std::move(_client_end), std::move(_request_buffer), std::move(count), std::move(_response_buffer));
}

::fidl::DecodeResult<File::ReadResponse> File::InPlace::Read(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReadRequest> params, ::fidl::BytePart response_buffer) {
  File::SetTransactionHeaderFor::ReadRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::ReadResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ReadRequest, ReadResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::ReadResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
File::ResultOf::ReadAt_Impl<File::ReadAtResponse>::ReadAt_Impl(zx::unowned_channel _client_end, uint64_t count, uint64_t offset) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReadAtRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ReadAtRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReadAtRequest*>(_write_bytes);
  _request.count = std::move(count);
  _request.offset = std::move(offset);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ReadAtRequest));
  ::fidl::DecodedMessage<ReadAtRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      File::InPlace::ReadAt(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

File::ResultOf::ReadAt File::SyncClient::ReadAt(uint64_t count, uint64_t offset) {
  return ResultOf::ReadAt(zx::unowned_channel(this->channel_), std::move(count), std::move(offset));
}

File::ResultOf::ReadAt File::Call::ReadAt(zx::unowned_channel _client_end, uint64_t count, uint64_t offset) {
  return ResultOf::ReadAt(std::move(_client_end), std::move(count), std::move(offset));
}

template <>
File::UnownedResultOf::ReadAt_Impl<File::ReadAtResponse>::ReadAt_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t count, uint64_t offset, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < ReadAtRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<ReadAtResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, ReadAtRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReadAtRequest*>(_request_buffer.data());
  _request.count = std::move(count);
  _request.offset = std::move(offset);
  _request_buffer.set_actual(sizeof(ReadAtRequest));
  ::fidl::DecodedMessage<ReadAtRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      File::InPlace::ReadAt(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

File::UnownedResultOf::ReadAt File::SyncClient::ReadAt(::fidl::BytePart _request_buffer, uint64_t count, uint64_t offset, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ReadAt(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(count), std::move(offset), std::move(_response_buffer));
}

File::UnownedResultOf::ReadAt File::Call::ReadAt(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t count, uint64_t offset, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ReadAt(std::move(_client_end), std::move(_request_buffer), std::move(count), std::move(offset), std::move(_response_buffer));
}

::fidl::DecodeResult<File::ReadAtResponse> File::InPlace::ReadAt(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReadAtRequest> params, ::fidl::BytePart response_buffer) {
  File::SetTransactionHeaderFor::ReadAtRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::ReadAtResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ReadAtRequest, ReadAtResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::ReadAtResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
File::ResultOf::Write_Impl<File::WriteResponse>::Write_Impl(zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> data) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WriteRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  WriteRequest _request = {};
  _request.data = std::move(data);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<WriteRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      File::InPlace::Write(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

File::ResultOf::Write File::SyncClient::Write(::fidl::VectorView<uint8_t> data) {
  return ResultOf::Write(zx::unowned_channel(this->channel_), std::move(data));
}

File::ResultOf::Write File::Call::Write(zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> data) {
  return ResultOf::Write(std::move(_client_end), std::move(data));
}

template <>
File::UnownedResultOf::Write_Impl<File::WriteResponse>::Write_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < WriteRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<WriteResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  WriteRequest _request = {};
  _request.data = std::move(data);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<WriteRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      File::InPlace::Write(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

File::UnownedResultOf::Write File::SyncClient::Write(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Write(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(data), std::move(_response_buffer));
}

File::UnownedResultOf::Write File::Call::Write(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Write(std::move(_client_end), std::move(_request_buffer), std::move(data), std::move(_response_buffer));
}

::fidl::DecodeResult<File::WriteResponse> File::InPlace::Write(zx::unowned_channel _client_end, ::fidl::DecodedMessage<WriteRequest> params, ::fidl::BytePart response_buffer) {
  File::SetTransactionHeaderFor::WriteRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::WriteResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<WriteRequest, WriteResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::WriteResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
File::ResultOf::WriteAt_Impl<File::WriteAtResponse>::WriteAt_Impl(zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> data, uint64_t offset) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WriteAtRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  WriteAtRequest _request = {};
  _request.data = std::move(data);
  _request.offset = std::move(offset);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<WriteAtRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      File::InPlace::WriteAt(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

File::ResultOf::WriteAt File::SyncClient::WriteAt(::fidl::VectorView<uint8_t> data, uint64_t offset) {
  return ResultOf::WriteAt(zx::unowned_channel(this->channel_), std::move(data), std::move(offset));
}

File::ResultOf::WriteAt File::Call::WriteAt(zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> data, uint64_t offset) {
  return ResultOf::WriteAt(std::move(_client_end), std::move(data), std::move(offset));
}

template <>
File::UnownedResultOf::WriteAt_Impl<File::WriteAtResponse>::WriteAt_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, uint64_t offset, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < WriteAtRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<WriteAtResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  WriteAtRequest _request = {};
  _request.data = std::move(data);
  _request.offset = std::move(offset);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<WriteAtRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      File::InPlace::WriteAt(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

File::UnownedResultOf::WriteAt File::SyncClient::WriteAt(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, uint64_t offset, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WriteAt(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(data), std::move(offset), std::move(_response_buffer));
}

File::UnownedResultOf::WriteAt File::Call::WriteAt(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, uint64_t offset, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WriteAt(std::move(_client_end), std::move(_request_buffer), std::move(data), std::move(offset), std::move(_response_buffer));
}

::fidl::DecodeResult<File::WriteAtResponse> File::InPlace::WriteAt(zx::unowned_channel _client_end, ::fidl::DecodedMessage<WriteAtRequest> params, ::fidl::BytePart response_buffer) {
  File::SetTransactionHeaderFor::WriteAtRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::WriteAtResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<WriteAtRequest, WriteAtResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::WriteAtResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
File::ResultOf::Seek_Impl<File::SeekResponse>::Seek_Impl(zx::unowned_channel _client_end, int64_t offset, ::llcpp::fuchsia::io::SeekOrigin start) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SeekRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SeekRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SeekRequest*>(_write_bytes);
  _request.offset = std::move(offset);
  _request.start = std::move(start);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SeekRequest));
  ::fidl::DecodedMessage<SeekRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      File::InPlace::Seek(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

File::ResultOf::Seek File::SyncClient::Seek(int64_t offset, ::llcpp::fuchsia::io::SeekOrigin start) {
  return ResultOf::Seek(zx::unowned_channel(this->channel_), std::move(offset), std::move(start));
}

File::ResultOf::Seek File::Call::Seek(zx::unowned_channel _client_end, int64_t offset, ::llcpp::fuchsia::io::SeekOrigin start) {
  return ResultOf::Seek(std::move(_client_end), std::move(offset), std::move(start));
}

template <>
File::UnownedResultOf::Seek_Impl<File::SeekResponse>::Seek_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int64_t offset, ::llcpp::fuchsia::io::SeekOrigin start, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < SeekRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<SeekResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, SeekRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SeekRequest*>(_request_buffer.data());
  _request.offset = std::move(offset);
  _request.start = std::move(start);
  _request_buffer.set_actual(sizeof(SeekRequest));
  ::fidl::DecodedMessage<SeekRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      File::InPlace::Seek(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

File::UnownedResultOf::Seek File::SyncClient::Seek(::fidl::BytePart _request_buffer, int64_t offset, ::llcpp::fuchsia::io::SeekOrigin start, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Seek(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(offset), std::move(start), std::move(_response_buffer));
}

File::UnownedResultOf::Seek File::Call::Seek(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int64_t offset, ::llcpp::fuchsia::io::SeekOrigin start, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Seek(std::move(_client_end), std::move(_request_buffer), std::move(offset), std::move(start), std::move(_response_buffer));
}

::fidl::DecodeResult<File::SeekResponse> File::InPlace::Seek(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SeekRequest> params, ::fidl::BytePart response_buffer) {
  File::SetTransactionHeaderFor::SeekRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::SeekResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SeekRequest, SeekResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::SeekResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
File::ResultOf::Truncate_Impl<File::TruncateResponse>::Truncate_Impl(zx::unowned_channel _client_end, uint64_t length) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<TruncateRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, TruncateRequest::PrimarySize);
  auto& _request = *reinterpret_cast<TruncateRequest*>(_write_bytes);
  _request.length = std::move(length);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(TruncateRequest));
  ::fidl::DecodedMessage<TruncateRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      File::InPlace::Truncate(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

File::ResultOf::Truncate File::SyncClient::Truncate(uint64_t length) {
  return ResultOf::Truncate(zx::unowned_channel(this->channel_), std::move(length));
}

File::ResultOf::Truncate File::Call::Truncate(zx::unowned_channel _client_end, uint64_t length) {
  return ResultOf::Truncate(std::move(_client_end), std::move(length));
}

template <>
File::UnownedResultOf::Truncate_Impl<File::TruncateResponse>::Truncate_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t length, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < TruncateRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<TruncateResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, TruncateRequest::PrimarySize);
  auto& _request = *reinterpret_cast<TruncateRequest*>(_request_buffer.data());
  _request.length = std::move(length);
  _request_buffer.set_actual(sizeof(TruncateRequest));
  ::fidl::DecodedMessage<TruncateRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      File::InPlace::Truncate(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

File::UnownedResultOf::Truncate File::SyncClient::Truncate(::fidl::BytePart _request_buffer, uint64_t length, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Truncate(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(length), std::move(_response_buffer));
}

File::UnownedResultOf::Truncate File::Call::Truncate(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t length, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Truncate(std::move(_client_end), std::move(_request_buffer), std::move(length), std::move(_response_buffer));
}

::fidl::DecodeResult<File::TruncateResponse> File::InPlace::Truncate(zx::unowned_channel _client_end, ::fidl::DecodedMessage<TruncateRequest> params, ::fidl::BytePart response_buffer) {
  File::SetTransactionHeaderFor::TruncateRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::TruncateResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<TruncateRequest, TruncateResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::TruncateResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
File::ResultOf::GetFlags_Impl<File::GetFlagsResponse>::GetFlags_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetFlagsRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetFlagsRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetFlagsRequest));
  ::fidl::DecodedMessage<GetFlagsRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      File::InPlace::GetFlags(std::move(_client_end), Super::response_buffer()));
}

File::ResultOf::GetFlags File::SyncClient::GetFlags() {
  return ResultOf::GetFlags(zx::unowned_channel(this->channel_));
}

File::ResultOf::GetFlags File::Call::GetFlags(zx::unowned_channel _client_end) {
  return ResultOf::GetFlags(std::move(_client_end));
}

template <>
File::UnownedResultOf::GetFlags_Impl<File::GetFlagsResponse>::GetFlags_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetFlagsRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetFlagsRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetFlagsRequest));
  ::fidl::DecodedMessage<GetFlagsRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      File::InPlace::GetFlags(std::move(_client_end), std::move(_response_buffer)));
}

File::UnownedResultOf::GetFlags File::SyncClient::GetFlags(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetFlags(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

File::UnownedResultOf::GetFlags File::Call::GetFlags(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetFlags(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<File::GetFlagsResponse> File::InPlace::GetFlags(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetFlagsRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetFlagsRequest> params(std::move(_request_buffer));
  File::SetTransactionHeaderFor::GetFlagsRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::GetFlagsResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetFlagsRequest, GetFlagsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::GetFlagsResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
File::ResultOf::SetFlags_Impl<File::SetFlagsResponse>::SetFlags_Impl(zx::unowned_channel _client_end, uint32_t flags) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetFlagsRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetFlagsRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetFlagsRequest*>(_write_bytes);
  _request.flags = std::move(flags);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetFlagsRequest));
  ::fidl::DecodedMessage<SetFlagsRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      File::InPlace::SetFlags(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

File::ResultOf::SetFlags File::SyncClient::SetFlags(uint32_t flags) {
  return ResultOf::SetFlags(zx::unowned_channel(this->channel_), std::move(flags));
}

File::ResultOf::SetFlags File::Call::SetFlags(zx::unowned_channel _client_end, uint32_t flags) {
  return ResultOf::SetFlags(std::move(_client_end), std::move(flags));
}

template <>
File::UnownedResultOf::SetFlags_Impl<File::SetFlagsResponse>::SetFlags_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < SetFlagsRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<SetFlagsResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, SetFlagsRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetFlagsRequest*>(_request_buffer.data());
  _request.flags = std::move(flags);
  _request_buffer.set_actual(sizeof(SetFlagsRequest));
  ::fidl::DecodedMessage<SetFlagsRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      File::InPlace::SetFlags(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

File::UnownedResultOf::SetFlags File::SyncClient::SetFlags(::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetFlags(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(flags), std::move(_response_buffer));
}

File::UnownedResultOf::SetFlags File::Call::SetFlags(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetFlags(std::move(_client_end), std::move(_request_buffer), std::move(flags), std::move(_response_buffer));
}

::fidl::DecodeResult<File::SetFlagsResponse> File::InPlace::SetFlags(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetFlagsRequest> params, ::fidl::BytePart response_buffer) {
  File::SetTransactionHeaderFor::SetFlagsRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::SetFlagsResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SetFlagsRequest, SetFlagsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::SetFlagsResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
File::ResultOf::GetBuffer_Impl<File::GetBufferResponse>::GetBuffer_Impl(zx::unowned_channel _client_end, uint32_t flags) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetBufferRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetBufferRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetBufferRequest*>(_write_bytes);
  _request.flags = std::move(flags);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetBufferRequest));
  ::fidl::DecodedMessage<GetBufferRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      File::InPlace::GetBuffer(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

File::ResultOf::GetBuffer File::SyncClient::GetBuffer(uint32_t flags) {
  return ResultOf::GetBuffer(zx::unowned_channel(this->channel_), std::move(flags));
}

File::ResultOf::GetBuffer File::Call::GetBuffer(zx::unowned_channel _client_end, uint32_t flags) {
  return ResultOf::GetBuffer(std::move(_client_end), std::move(flags));
}

template <>
File::UnownedResultOf::GetBuffer_Impl<File::GetBufferResponse>::GetBuffer_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < GetBufferRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<GetBufferResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, GetBufferRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetBufferRequest*>(_request_buffer.data());
  _request.flags = std::move(flags);
  _request_buffer.set_actual(sizeof(GetBufferRequest));
  ::fidl::DecodedMessage<GetBufferRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      File::InPlace::GetBuffer(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

File::UnownedResultOf::GetBuffer File::SyncClient::GetBuffer(::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetBuffer(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(flags), std::move(_response_buffer));
}

File::UnownedResultOf::GetBuffer File::Call::GetBuffer(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetBuffer(std::move(_client_end), std::move(_request_buffer), std::move(flags), std::move(_response_buffer));
}

::fidl::DecodeResult<File::GetBufferResponse> File::InPlace::GetBuffer(zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetBufferRequest> params, ::fidl::BytePart response_buffer) {
  File::SetTransactionHeaderFor::GetBufferRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::GetBufferResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetBufferRequest, GetBufferResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::GetBufferResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

zx_status_t File::SyncClient::HandleEvents(File::EventHandlers handlers) {
  return File::Call::HandleEvents(zx::unowned_channel(channel_), std::move(handlers));
}

zx_status_t File::Call::HandleEvents(zx::unowned_channel client_end, File::EventHandlers handlers) {
  zx_status_t status = client_end->wait_one(ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED,
                                            zx::time::infinite(),
                                            nullptr);
  if (status != ZX_OK) {
    return status;
  }
  constexpr uint32_t kReadAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::internal::ClampedMessageSize<OnOpenResponse, ::fidl::MessageDirection::kReceiving>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<OnOpenResponse, ::fidl::MessageDirection::kReceiving>();
    }
    if (::fidl::internal::ClampedMessageSize<OnOpenResponse, ::fidl::MessageDirection::kReceiving, ::fidl::internal::WireFormatGuide::kAlternate>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<OnOpenResponse, ::fidl::MessageDirection::kReceiving, ::fidl::internal::WireFormatGuide::kAlternate>();
    }
    return x;
  })();
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (OnOpenResponse::MaxNumHandles >= x) {
      x = OnOpenResponse::MaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  ::fidl::internal::ByteStorage<kReadAllocSize> read_storage;
  uint8_t* read_bytes = read_storage.buffer().data();
  zx_handle_t read_handles[kHandleAllocSize];
  uint32_t actual_bytes;
  uint32_t actual_handles;
  status = client_end->read(ZX_CHANNEL_READ_MAY_DISCARD,
                            read_bytes, read_handles,
                            kReadAllocSize, kHandleAllocSize,
                            &actual_bytes, &actual_handles);
  if (status == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new event,
    // whose size exceeds the maximum of known events in the current protocol.
    return handlers.unknown();
  }
  if (status != ZX_OK) {
    return status;
  }
  if (actual_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(read_handles, actual_handles);
    return ZX_ERR_INVALID_ARGS;
  }
  auto msg = fidl_msg_t {
      .bytes = read_bytes,
      .handles = read_handles,
      .num_bytes = actual_bytes,
      .num_handles = actual_handles
  };
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg.bytes);
  status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    return status;
  }
  switch (hdr->ordinal) {
    case kFile_OnOpen_Ordinal:
    case kFile_OnOpen_GenOrdinal:
    {
      constexpr uint32_t kTransformerDestSize = ::fidl::internal::ClampedMessageSize<OnOpenResponse, ::fidl::MessageDirection::kReceiving>();
      ::fidl::internal::ByteStorage<kTransformerDestSize> transformer_dest_storage(::fidl::internal::DelayAllocation);
      if (fidl_should_decode_union_from_xunion(hdr)) {
        transformer_dest_storage.Allocate();
        uint8_t* transformer_dest = transformer_dest_storage.buffer().data();
        zx_status_t transform_status = fidl_transform(FIDL_TRANSFORMATION_V1_TO_OLD,
                                                      OnOpenResponse::AltType,
                                                      reinterpret_cast<uint8_t*>(msg.bytes),
                                                      msg.num_bytes,
                                                      transformer_dest,
                                                      kTransformerDestSize,
                                                      &msg.num_bytes,
                                                      nullptr);
        if (transform_status != ZX_OK) {
          zx_handle_close_many(msg.handles, msg.num_handles);
          return ZX_ERR_INVALID_ARGS;
        }
        msg.bytes = transformer_dest;
      }
      auto result = ::fidl::DecodeAs<OnOpenResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      auto message = result.message.message();
      return handlers.on_open(std::move(message->s), std::move(message->info));
    }
    default:
      zx_handle_close_many(read_handles, actual_handles);
      return handlers.unknown();
  }
}

bool File::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kFile_Clone_Ordinal:
    case kFile_Clone_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<CloneRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Clone(std::move(message->flags), std::move(message->object),
          Interface::CloneCompleter::Sync(txn));
      return true;
    }
    case kFile_Close_Ordinal:
    case kFile_Close_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<CloseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Close(
          Interface::CloseCompleter::Sync(txn));
      return true;
    }
    case kFile_Describe_Ordinal:
    case kFile_Describe_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<DescribeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Describe(
          Interface::DescribeCompleter::Sync(txn));
      return true;
    }
    case kFile_Sync_Ordinal:
    case kFile_Sync_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SyncRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Sync(
          Interface::SyncCompleter::Sync(txn));
      return true;
    }
    case kFile_GetAttr_Ordinal:
    case kFile_GetAttr_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetAttrRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetAttr(
          Interface::GetAttrCompleter::Sync(txn));
      return true;
    }
    case kFile_SetAttr_Ordinal:
    case kFile_SetAttr_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetAttrRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetAttr(std::move(message->flags), std::move(message->attributes),
          Interface::SetAttrCompleter::Sync(txn));
      return true;
    }
    case kFile_NodeGetFlags_Ordinal:
    case kFile_NodeGetFlags_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<NodeGetFlagsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->NodeGetFlags(
          Interface::NodeGetFlagsCompleter::Sync(txn));
      return true;
    }
    case kFile_NodeSetFlags_Ordinal:
    case kFile_NodeSetFlags_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<NodeSetFlagsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->NodeSetFlags(std::move(message->flags),
          Interface::NodeSetFlagsCompleter::Sync(txn));
      return true;
    }
    case kFile_Read_Ordinal:
    case kFile_Read_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ReadRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Read(std::move(message->count),
          Interface::ReadCompleter::Sync(txn));
      return true;
    }
    case kFile_ReadAt_Ordinal:
    case kFile_ReadAt_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ReadAtRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->ReadAt(std::move(message->count), std::move(message->offset),
          Interface::ReadAtCompleter::Sync(txn));
      return true;
    }
    case kFile_Write_Ordinal:
    case kFile_Write_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<WriteRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Write(std::move(message->data),
          Interface::WriteCompleter::Sync(txn));
      return true;
    }
    case kFile_WriteAt_Ordinal:
    case kFile_WriteAt_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<WriteAtRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->WriteAt(std::move(message->data), std::move(message->offset),
          Interface::WriteAtCompleter::Sync(txn));
      return true;
    }
    case kFile_Seek_Ordinal:
    case kFile_Seek_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SeekRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Seek(std::move(message->offset), std::move(message->start),
          Interface::SeekCompleter::Sync(txn));
      return true;
    }
    case kFile_Truncate_Ordinal:
    case kFile_Truncate_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<TruncateRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Truncate(std::move(message->length),
          Interface::TruncateCompleter::Sync(txn));
      return true;
    }
    case kFile_GetFlags_Ordinal:
    case kFile_GetFlags_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetFlagsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetFlags(
          Interface::GetFlagsCompleter::Sync(txn));
      return true;
    }
    case kFile_SetFlags_Ordinal:
    case kFile_SetFlags_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetFlagsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetFlags(std::move(message->flags),
          Interface::SetFlagsCompleter::Sync(txn));
      return true;
    }
    case kFile_GetBuffer_Ordinal:
    case kFile_GetBuffer_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetBufferRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->GetBuffer(std::move(message->flags),
          Interface::GetBufferCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool File::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void File::Interface::CloseCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<CloseResponse*>(_write_bytes);
  File::SetTransactionHeaderFor::CloseResponse(
      ::fidl::DecodedMessage<CloseResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              CloseResponse::PrimarySize,
              CloseResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CloseResponse>(std::move(_response_bytes)));
}

void File::Interface::CloseCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < CloseResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<CloseResponse*>(_buffer.data());
  File::SetTransactionHeaderFor::CloseResponse(
      ::fidl::DecodedMessage<CloseResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              CloseResponse::PrimarySize,
              CloseResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(CloseResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CloseResponse>(std::move(_buffer)));
}

void File::Interface::CloseCompleterBase::Reply(::fidl::DecodedMessage<CloseResponse> params) {
  File::SetTransactionHeaderFor::CloseResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::DescribeCompleterBase::Reply(::llcpp::fuchsia::io::NodeInfo info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DescribeResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<DescribeResponse*>(_write_bytes);
  File::SetTransactionHeaderFor::DescribeResponse(
      ::fidl::DecodedMessage<DescribeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              DescribeResponse::PrimarySize,
              DescribeResponse::PrimarySize)));
  _response.info = std::move(info);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(DescribeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<DescribeResponse>(std::move(_response_bytes)));
}

void File::Interface::DescribeCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io::NodeInfo info) {
  if (_buffer.capacity() < DescribeResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<DescribeResponse*>(_buffer.data());
  File::SetTransactionHeaderFor::DescribeResponse(
      ::fidl::DecodedMessage<DescribeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              DescribeResponse::PrimarySize,
              DescribeResponse::PrimarySize)));
  _response.info = std::move(info);
  _buffer.set_actual(sizeof(DescribeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<DescribeResponse>(std::move(_buffer)));
}

void File::Interface::DescribeCompleterBase::Reply(::fidl::DecodedMessage<DescribeResponse> params) {
  File::SetTransactionHeaderFor::DescribeResponse(params);
  CompleterBase::SendReply(std::move(params));
}


zx_status_t File::SendOnOpenEvent(::zx::unowned_channel _chan, int32_t s, ::llcpp::fuchsia::io::NodeInfo* info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OnOpenResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  OnOpenResponse _response = {};
  File::SetTransactionHeaderFor::OnOpenResponse(
      ::fidl::DecodedMessage<OnOpenResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OnOpenResponse::PrimarySize,
              OnOpenResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t File::SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, int32_t s, ::llcpp::fuchsia::io::NodeInfo* info) {
  if (_buffer.capacity() < OnOpenResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  OnOpenResponse _response = {};
  File::SetTransactionHeaderFor::OnOpenResponse(
      ::fidl::DecodedMessage<OnOpenResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OnOpenResponse::PrimarySize,
              OnOpenResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
	return _linearize_result.status;
  }
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t File::SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnOpenResponse> params) {
  File::SetTransactionHeaderFor::OnOpenResponse(params);
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(params));
}


void File::Interface::SyncCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SyncResponse*>(_write_bytes);
  File::SetTransactionHeaderFor::SyncResponse(
      ::fidl::DecodedMessage<SyncResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SyncResponse::PrimarySize,
              SyncResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SyncResponse>(std::move(_response_bytes)));
}

void File::Interface::SyncCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < SyncResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SyncResponse*>(_buffer.data());
  File::SetTransactionHeaderFor::SyncResponse(
      ::fidl::DecodedMessage<SyncResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SyncResponse::PrimarySize,
              SyncResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(SyncResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SyncResponse>(std::move(_buffer)));
}

void File::Interface::SyncCompleterBase::Reply(::fidl::DecodedMessage<SyncResponse> params) {
  File::SetTransactionHeaderFor::SyncResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::GetAttrCompleterBase::Reply(int32_t s, ::llcpp::fuchsia::io::NodeAttributes attributes) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetAttrResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetAttrResponse*>(_write_bytes);
  File::SetTransactionHeaderFor::GetAttrResponse(
      ::fidl::DecodedMessage<GetAttrResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetAttrResponse::PrimarySize,
              GetAttrResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.attributes = std::move(attributes);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetAttrResponse>(std::move(_response_bytes)));
}

void File::Interface::GetAttrCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, ::llcpp::fuchsia::io::NodeAttributes attributes) {
  if (_buffer.capacity() < GetAttrResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetAttrResponse*>(_buffer.data());
  File::SetTransactionHeaderFor::GetAttrResponse(
      ::fidl::DecodedMessage<GetAttrResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetAttrResponse::PrimarySize,
              GetAttrResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.attributes = std::move(attributes);
  _buffer.set_actual(sizeof(GetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetAttrResponse>(std::move(_buffer)));
}

void File::Interface::GetAttrCompleterBase::Reply(::fidl::DecodedMessage<GetAttrResponse> params) {
  File::SetTransactionHeaderFor::GetAttrResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::SetAttrCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetAttrResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SetAttrResponse*>(_write_bytes);
  File::SetTransactionHeaderFor::SetAttrResponse(
      ::fidl::DecodedMessage<SetAttrResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetAttrResponse::PrimarySize,
              SetAttrResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetAttrResponse>(std::move(_response_bytes)));
}

void File::Interface::SetAttrCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < SetAttrResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SetAttrResponse*>(_buffer.data());
  File::SetTransactionHeaderFor::SetAttrResponse(
      ::fidl::DecodedMessage<SetAttrResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetAttrResponse::PrimarySize,
              SetAttrResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(SetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetAttrResponse>(std::move(_buffer)));
}

void File::Interface::SetAttrCompleterBase::Reply(::fidl::DecodedMessage<SetAttrResponse> params) {
  File::SetTransactionHeaderFor::SetAttrResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::NodeGetFlagsCompleterBase::Reply(int32_t s, uint32_t flags) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<NodeGetFlagsResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<NodeGetFlagsResponse*>(_write_bytes);
  File::SetTransactionHeaderFor::NodeGetFlagsResponse(
      ::fidl::DecodedMessage<NodeGetFlagsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              NodeGetFlagsResponse::PrimarySize,
              NodeGetFlagsResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.flags = std::move(flags);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(NodeGetFlagsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<NodeGetFlagsResponse>(std::move(_response_bytes)));
}

void File::Interface::NodeGetFlagsCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, uint32_t flags) {
  if (_buffer.capacity() < NodeGetFlagsResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<NodeGetFlagsResponse*>(_buffer.data());
  File::SetTransactionHeaderFor::NodeGetFlagsResponse(
      ::fidl::DecodedMessage<NodeGetFlagsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              NodeGetFlagsResponse::PrimarySize,
              NodeGetFlagsResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.flags = std::move(flags);
  _buffer.set_actual(sizeof(NodeGetFlagsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<NodeGetFlagsResponse>(std::move(_buffer)));
}

void File::Interface::NodeGetFlagsCompleterBase::Reply(::fidl::DecodedMessage<NodeGetFlagsResponse> params) {
  File::SetTransactionHeaderFor::NodeGetFlagsResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::NodeSetFlagsCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<NodeSetFlagsResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<NodeSetFlagsResponse*>(_write_bytes);
  File::SetTransactionHeaderFor::NodeSetFlagsResponse(
      ::fidl::DecodedMessage<NodeSetFlagsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              NodeSetFlagsResponse::PrimarySize,
              NodeSetFlagsResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(NodeSetFlagsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<NodeSetFlagsResponse>(std::move(_response_bytes)));
}

void File::Interface::NodeSetFlagsCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < NodeSetFlagsResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<NodeSetFlagsResponse*>(_buffer.data());
  File::SetTransactionHeaderFor::NodeSetFlagsResponse(
      ::fidl::DecodedMessage<NodeSetFlagsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              NodeSetFlagsResponse::PrimarySize,
              NodeSetFlagsResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(NodeSetFlagsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<NodeSetFlagsResponse>(std::move(_buffer)));
}

void File::Interface::NodeSetFlagsCompleterBase::Reply(::fidl::DecodedMessage<NodeSetFlagsResponse> params) {
  File::SetTransactionHeaderFor::NodeSetFlagsResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::ReadCompleterBase::Reply(int32_t s, ::fidl::VectorView<uint8_t> data) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReadResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  ReadResponse _response = {};
  File::SetTransactionHeaderFor::ReadResponse(
      ::fidl::DecodedMessage<ReadResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ReadResponse::PrimarySize,
              ReadResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.data = std::move(data);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void File::Interface::ReadCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, ::fidl::VectorView<uint8_t> data) {
  if (_buffer.capacity() < ReadResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  ReadResponse _response = {};
  File::SetTransactionHeaderFor::ReadResponse(
      ::fidl::DecodedMessage<ReadResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ReadResponse::PrimarySize,
              ReadResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.data = std::move(data);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void File::Interface::ReadCompleterBase::Reply(::fidl::DecodedMessage<ReadResponse> params) {
  File::SetTransactionHeaderFor::ReadResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::ReadAtCompleterBase::Reply(int32_t s, ::fidl::VectorView<uint8_t> data) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReadAtResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  ReadAtResponse _response = {};
  File::SetTransactionHeaderFor::ReadAtResponse(
      ::fidl::DecodedMessage<ReadAtResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ReadAtResponse::PrimarySize,
              ReadAtResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.data = std::move(data);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void File::Interface::ReadAtCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, ::fidl::VectorView<uint8_t> data) {
  if (_buffer.capacity() < ReadAtResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  ReadAtResponse _response = {};
  File::SetTransactionHeaderFor::ReadAtResponse(
      ::fidl::DecodedMessage<ReadAtResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ReadAtResponse::PrimarySize,
              ReadAtResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.data = std::move(data);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void File::Interface::ReadAtCompleterBase::Reply(::fidl::DecodedMessage<ReadAtResponse> params) {
  File::SetTransactionHeaderFor::ReadAtResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::WriteCompleterBase::Reply(int32_t s, uint64_t actual) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WriteResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<WriteResponse*>(_write_bytes);
  File::SetTransactionHeaderFor::WriteResponse(
      ::fidl::DecodedMessage<WriteResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WriteResponse::PrimarySize,
              WriteResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.actual = std::move(actual);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(WriteResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WriteResponse>(std::move(_response_bytes)));
}

void File::Interface::WriteCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, uint64_t actual) {
  if (_buffer.capacity() < WriteResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<WriteResponse*>(_buffer.data());
  File::SetTransactionHeaderFor::WriteResponse(
      ::fidl::DecodedMessage<WriteResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WriteResponse::PrimarySize,
              WriteResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.actual = std::move(actual);
  _buffer.set_actual(sizeof(WriteResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WriteResponse>(std::move(_buffer)));
}

void File::Interface::WriteCompleterBase::Reply(::fidl::DecodedMessage<WriteResponse> params) {
  File::SetTransactionHeaderFor::WriteResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::WriteAtCompleterBase::Reply(int32_t s, uint64_t actual) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WriteAtResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<WriteAtResponse*>(_write_bytes);
  File::SetTransactionHeaderFor::WriteAtResponse(
      ::fidl::DecodedMessage<WriteAtResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WriteAtResponse::PrimarySize,
              WriteAtResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.actual = std::move(actual);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(WriteAtResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WriteAtResponse>(std::move(_response_bytes)));
}

void File::Interface::WriteAtCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, uint64_t actual) {
  if (_buffer.capacity() < WriteAtResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<WriteAtResponse*>(_buffer.data());
  File::SetTransactionHeaderFor::WriteAtResponse(
      ::fidl::DecodedMessage<WriteAtResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WriteAtResponse::PrimarySize,
              WriteAtResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.actual = std::move(actual);
  _buffer.set_actual(sizeof(WriteAtResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WriteAtResponse>(std::move(_buffer)));
}

void File::Interface::WriteAtCompleterBase::Reply(::fidl::DecodedMessage<WriteAtResponse> params) {
  File::SetTransactionHeaderFor::WriteAtResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::SeekCompleterBase::Reply(int32_t s, uint64_t offset) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SeekResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SeekResponse*>(_write_bytes);
  File::SetTransactionHeaderFor::SeekResponse(
      ::fidl::DecodedMessage<SeekResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SeekResponse::PrimarySize,
              SeekResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.offset = std::move(offset);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SeekResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SeekResponse>(std::move(_response_bytes)));
}

void File::Interface::SeekCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, uint64_t offset) {
  if (_buffer.capacity() < SeekResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SeekResponse*>(_buffer.data());
  File::SetTransactionHeaderFor::SeekResponse(
      ::fidl::DecodedMessage<SeekResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SeekResponse::PrimarySize,
              SeekResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.offset = std::move(offset);
  _buffer.set_actual(sizeof(SeekResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SeekResponse>(std::move(_buffer)));
}

void File::Interface::SeekCompleterBase::Reply(::fidl::DecodedMessage<SeekResponse> params) {
  File::SetTransactionHeaderFor::SeekResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::TruncateCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<TruncateResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<TruncateResponse*>(_write_bytes);
  File::SetTransactionHeaderFor::TruncateResponse(
      ::fidl::DecodedMessage<TruncateResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              TruncateResponse::PrimarySize,
              TruncateResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(TruncateResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<TruncateResponse>(std::move(_response_bytes)));
}

void File::Interface::TruncateCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < TruncateResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<TruncateResponse*>(_buffer.data());
  File::SetTransactionHeaderFor::TruncateResponse(
      ::fidl::DecodedMessage<TruncateResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              TruncateResponse::PrimarySize,
              TruncateResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(TruncateResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<TruncateResponse>(std::move(_buffer)));
}

void File::Interface::TruncateCompleterBase::Reply(::fidl::DecodedMessage<TruncateResponse> params) {
  File::SetTransactionHeaderFor::TruncateResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::GetFlagsCompleterBase::Reply(int32_t s, uint32_t flags) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetFlagsResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetFlagsResponse*>(_write_bytes);
  File::SetTransactionHeaderFor::GetFlagsResponse(
      ::fidl::DecodedMessage<GetFlagsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetFlagsResponse::PrimarySize,
              GetFlagsResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.flags = std::move(flags);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetFlagsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetFlagsResponse>(std::move(_response_bytes)));
}

void File::Interface::GetFlagsCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, uint32_t flags) {
  if (_buffer.capacity() < GetFlagsResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetFlagsResponse*>(_buffer.data());
  File::SetTransactionHeaderFor::GetFlagsResponse(
      ::fidl::DecodedMessage<GetFlagsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetFlagsResponse::PrimarySize,
              GetFlagsResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.flags = std::move(flags);
  _buffer.set_actual(sizeof(GetFlagsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetFlagsResponse>(std::move(_buffer)));
}

void File::Interface::GetFlagsCompleterBase::Reply(::fidl::DecodedMessage<GetFlagsResponse> params) {
  File::SetTransactionHeaderFor::GetFlagsResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::SetFlagsCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetFlagsResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SetFlagsResponse*>(_write_bytes);
  File::SetTransactionHeaderFor::SetFlagsResponse(
      ::fidl::DecodedMessage<SetFlagsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetFlagsResponse::PrimarySize,
              SetFlagsResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetFlagsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetFlagsResponse>(std::move(_response_bytes)));
}

void File::Interface::SetFlagsCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < SetFlagsResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SetFlagsResponse*>(_buffer.data());
  File::SetTransactionHeaderFor::SetFlagsResponse(
      ::fidl::DecodedMessage<SetFlagsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetFlagsResponse::PrimarySize,
              SetFlagsResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(SetFlagsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetFlagsResponse>(std::move(_buffer)));
}

void File::Interface::SetFlagsCompleterBase::Reply(::fidl::DecodedMessage<SetFlagsResponse> params) {
  File::SetTransactionHeaderFor::SetFlagsResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::GetBufferCompleterBase::Reply(int32_t s, ::llcpp::fuchsia::mem::Buffer* buffer) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetBufferResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  GetBufferResponse _response = {};
  File::SetTransactionHeaderFor::GetBufferResponse(
      ::fidl::DecodedMessage<GetBufferResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetBufferResponse::PrimarySize,
              GetBufferResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.buffer = std::move(buffer);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void File::Interface::GetBufferCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, ::llcpp::fuchsia::mem::Buffer* buffer) {
  if (_buffer.capacity() < GetBufferResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetBufferResponse _response = {};
  File::SetTransactionHeaderFor::GetBufferResponse(
      ::fidl::DecodedMessage<GetBufferResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetBufferResponse::PrimarySize,
              GetBufferResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.buffer = std::move(buffer);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void File::Interface::GetBufferCompleterBase::Reply(::fidl::DecodedMessage<GetBufferResponse> params) {
  File::SetTransactionHeaderFor::GetBufferResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void File::SetTransactionHeaderFor::CloneRequest(const ::fidl::DecodedMessage<File::CloneRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_Clone_Ordinal);
}

void File::SetTransactionHeaderFor::CloseRequest(const ::fidl::DecodedMessage<File::CloseRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_Close_Ordinal);
}
void File::SetTransactionHeaderFor::CloseResponse(const ::fidl::DecodedMessage<File::CloseResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_Close_Ordinal);
}

void File::SetTransactionHeaderFor::DescribeRequest(const ::fidl::DecodedMessage<File::DescribeRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_Describe_Ordinal);
}
void File::SetTransactionHeaderFor::DescribeResponse(const ::fidl::DecodedMessage<File::DescribeResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_Describe_Ordinal);
}

void File::SetTransactionHeaderFor::OnOpenResponse(const ::fidl::DecodedMessage<File::OnOpenResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_OnOpen_Ordinal);
}

void File::SetTransactionHeaderFor::SyncRequest(const ::fidl::DecodedMessage<File::SyncRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_Sync_Ordinal);
}
void File::SetTransactionHeaderFor::SyncResponse(const ::fidl::DecodedMessage<File::SyncResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_Sync_Ordinal);
}

void File::SetTransactionHeaderFor::GetAttrRequest(const ::fidl::DecodedMessage<File::GetAttrRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_GetAttr_Ordinal);
}
void File::SetTransactionHeaderFor::GetAttrResponse(const ::fidl::DecodedMessage<File::GetAttrResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_GetAttr_Ordinal);
}

void File::SetTransactionHeaderFor::SetAttrRequest(const ::fidl::DecodedMessage<File::SetAttrRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_SetAttr_Ordinal);
}
void File::SetTransactionHeaderFor::SetAttrResponse(const ::fidl::DecodedMessage<File::SetAttrResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_SetAttr_Ordinal);
}

void File::SetTransactionHeaderFor::NodeGetFlagsRequest(const ::fidl::DecodedMessage<File::NodeGetFlagsRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_NodeGetFlags_Ordinal);
}
void File::SetTransactionHeaderFor::NodeGetFlagsResponse(const ::fidl::DecodedMessage<File::NodeGetFlagsResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_NodeGetFlags_Ordinal);
}

void File::SetTransactionHeaderFor::NodeSetFlagsRequest(const ::fidl::DecodedMessage<File::NodeSetFlagsRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_NodeSetFlags_Ordinal);
}
void File::SetTransactionHeaderFor::NodeSetFlagsResponse(const ::fidl::DecodedMessage<File::NodeSetFlagsResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_NodeSetFlags_Ordinal);
}

void File::SetTransactionHeaderFor::ReadRequest(const ::fidl::DecodedMessage<File::ReadRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_Read_Ordinal);
}
void File::SetTransactionHeaderFor::ReadResponse(const ::fidl::DecodedMessage<File::ReadResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_Read_Ordinal);
}

void File::SetTransactionHeaderFor::ReadAtRequest(const ::fidl::DecodedMessage<File::ReadAtRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_ReadAt_Ordinal);
}
void File::SetTransactionHeaderFor::ReadAtResponse(const ::fidl::DecodedMessage<File::ReadAtResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_ReadAt_Ordinal);
}

void File::SetTransactionHeaderFor::WriteRequest(const ::fidl::DecodedMessage<File::WriteRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_Write_Ordinal);
}
void File::SetTransactionHeaderFor::WriteResponse(const ::fidl::DecodedMessage<File::WriteResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_Write_Ordinal);
}

void File::SetTransactionHeaderFor::WriteAtRequest(const ::fidl::DecodedMessage<File::WriteAtRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_WriteAt_Ordinal);
}
void File::SetTransactionHeaderFor::WriteAtResponse(const ::fidl::DecodedMessage<File::WriteAtResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_WriteAt_Ordinal);
}

void File::SetTransactionHeaderFor::SeekRequest(const ::fidl::DecodedMessage<File::SeekRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_Seek_Ordinal);
}
void File::SetTransactionHeaderFor::SeekResponse(const ::fidl::DecodedMessage<File::SeekResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_Seek_Ordinal);
}

void File::SetTransactionHeaderFor::TruncateRequest(const ::fidl::DecodedMessage<File::TruncateRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_Truncate_Ordinal);
}
void File::SetTransactionHeaderFor::TruncateResponse(const ::fidl::DecodedMessage<File::TruncateResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_Truncate_Ordinal);
}

void File::SetTransactionHeaderFor::GetFlagsRequest(const ::fidl::DecodedMessage<File::GetFlagsRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_GetFlags_Ordinal);
}
void File::SetTransactionHeaderFor::GetFlagsResponse(const ::fidl::DecodedMessage<File::GetFlagsResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_GetFlags_Ordinal);
}

void File::SetTransactionHeaderFor::SetFlagsRequest(const ::fidl::DecodedMessage<File::SetFlagsRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_SetFlags_Ordinal);
}
void File::SetTransactionHeaderFor::SetFlagsResponse(const ::fidl::DecodedMessage<File::SetFlagsResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_SetFlags_Ordinal);
}

void File::SetTransactionHeaderFor::GetBufferRequest(const ::fidl::DecodedMessage<File::GetBufferRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_GetBuffer_Ordinal);
}
void File::SetTransactionHeaderFor::GetBufferResponse(const ::fidl::DecodedMessage<File::GetBufferResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_GetBuffer_Ordinal);
}

namespace {

[[maybe_unused]]
constexpr uint64_t kDirectory_Clone_Ordinal = 0x17fe6a4c00000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectory_Clone_GenOrdinal = 0x5a61678f293ce16flu;
extern "C" const fidl_type_t fuchsia_io_DirectoryCloneRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryCloneResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryCloneResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_Close_Ordinal = 0x52b9568700000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectory_Close_GenOrdinal = 0x5309c5bd1c33dc44lu;
extern "C" const fidl_type_t fuchsia_io_DirectoryCloseRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryCloseResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryCloseResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_Describe_Ordinal = 0x1f62df5e00000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectory_Describe_GenOrdinal = 0xffcec215078dea0lu;
extern "C" const fidl_type_t fuchsia_io_DirectoryDescribeRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryDescribeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryDescribeResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_OnOpen_Ordinal = 0x4700a7bd00000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectory_OnOpen_GenOrdinal = 0x7fc7bbb1dbfd1972lu;
extern "C" const fidl_type_t fuchsia_io_DirectoryOnOpenRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryOnOpenEventTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryOnOpenEventTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_Sync_Ordinal = 0x62423faa00000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectory_Sync_GenOrdinal = 0x189d88326c18b519lu;
extern "C" const fidl_type_t fuchsia_io_DirectorySyncRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectorySyncResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectorySyncResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_GetAttr_Ordinal = 0x4585e7c800000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectory_GetAttr_GenOrdinal = 0x78985e216314dafdlu;
extern "C" const fidl_type_t fuchsia_io_DirectoryGetAttrRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryGetAttrResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryGetAttrResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_SetAttr_Ordinal = 0xbd5559a00000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectory_SetAttr_GenOrdinal = 0x4186c0f40d938f46lu;
extern "C" const fidl_type_t fuchsia_io_DirectorySetAttrRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectorySetAttrResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectorySetAttrResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_NodeGetFlags_Ordinal = 0x3c24c22300000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectory_NodeGetFlags_GenOrdinal = 0x5b88fffb8eda3aa1lu;
extern "C" const fidl_type_t fuchsia_io_DirectoryNodeGetFlagsRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryNodeGetFlagsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryNodeGetFlagsResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_NodeSetFlags_Ordinal = 0x46940c1600000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectory_NodeSetFlags_GenOrdinal = 0x5295b76c71fde733lu;
extern "C" const fidl_type_t fuchsia_io_DirectoryNodeSetFlagsRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryNodeSetFlagsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryNodeSetFlagsResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_Open_Ordinal = 0x77e4cceb00000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectory_Open_GenOrdinal = 0x2c5044561d685ec0lu;
extern "C" const fidl_type_t fuchsia_io_DirectoryOpenRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryOpenResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryOpenResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_Unlink_Ordinal = 0x2cbadb1900000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectory_Unlink_GenOrdinal = 0x5a0ff90760a8bc23lu;
extern "C" const fidl_type_t fuchsia_io_DirectoryUnlinkRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryUnlinkResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryUnlinkResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_ReadDirents_Ordinal = 0x2ea53c2d00000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectory_ReadDirents_GenOrdinal = 0x3582806bf27faa0alu;
extern "C" const fidl_type_t fuchsia_io_DirectoryReadDirentsRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryReadDirentsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryReadDirentsResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_Rewind_Ordinal = 0x7072fd8700000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectory_Rewind_GenOrdinal = 0x16b1202af0f34c71lu;
extern "C" const fidl_type_t fuchsia_io_DirectoryRewindRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryRewindResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryRewindResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_GetToken_Ordinal = 0x3217bced00000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectory_GetToken_GenOrdinal = 0x26ae9d18763c8655lu;
extern "C" const fidl_type_t fuchsia_io_DirectoryGetTokenRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryGetTokenResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryGetTokenResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_Rename_Ordinal = 0x4a94b0ac00000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectory_Rename_GenOrdinal = 0xa8e00a247f3c905lu;
extern "C" const fidl_type_t fuchsia_io_DirectoryRenameRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryRenameResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryRenameResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_Link_Ordinal = 0x1b8a5e6400000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectory_Link_GenOrdinal = 0x740604c0c7c930e7lu;
extern "C" const fidl_type_t fuchsia_io_DirectoryLinkRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryLinkResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryLinkResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_Watch_Ordinal = 0x5ac28f3400000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectory_Watch_GenOrdinal = 0x5717193a59d66d91lu;
extern "C" const fidl_type_t fuchsia_io_DirectoryWatchRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryWatchResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryWatchResponseTable;

}  // namespace

Directory::ResultOf::Clone_Impl::Clone_Impl(zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloneRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CloneRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CloneRequest*>(_write_bytes);
  _request.flags = std::move(flags);
  _request.object = std::move(object);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloneRequest));
  ::fidl::DecodedMessage<CloneRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Directory::InPlace::Clone(std::move(_client_end), std::move(_decoded_request)));
}

Directory::ResultOf::Clone Directory::SyncClient::Clone(uint32_t flags, ::zx::channel object) {
  return ResultOf::Clone(zx::unowned_channel(this->channel_), std::move(flags), std::move(object));
}

Directory::ResultOf::Clone Directory::Call::Clone(zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object) {
  return ResultOf::Clone(std::move(_client_end), std::move(flags), std::move(object));
}


Directory::UnownedResultOf::Clone_Impl::Clone_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object) {
  if (_request_buffer.capacity() < CloneRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, CloneRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CloneRequest*>(_request_buffer.data());
  _request.flags = std::move(flags);
  _request.object = std::move(object);
  _request_buffer.set_actual(sizeof(CloneRequest));
  ::fidl::DecodedMessage<CloneRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Directory::InPlace::Clone(std::move(_client_end), std::move(_decoded_request)));
}

Directory::UnownedResultOf::Clone Directory::SyncClient::Clone(::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object) {
  return UnownedResultOf::Clone(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(flags), std::move(object));
}

Directory::UnownedResultOf::Clone Directory::Call::Clone(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object) {
  return UnownedResultOf::Clone(std::move(_client_end), std::move(_request_buffer), std::move(flags), std::move(object));
}

::fidl::internal::StatusAndError Directory::InPlace::Clone(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CloneRequest> params) {
  Directory::SetTransactionHeaderFor::CloneRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
Directory::ResultOf::Close_Impl<Directory::CloseResponse>::Close_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CloseRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseRequest));
  ::fidl::DecodedMessage<CloseRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Directory::InPlace::Close(std::move(_client_end), Super::response_buffer()));
}

Directory::ResultOf::Close Directory::SyncClient::Close() {
  return ResultOf::Close(zx::unowned_channel(this->channel_));
}

Directory::ResultOf::Close Directory::Call::Close(zx::unowned_channel _client_end) {
  return ResultOf::Close(std::move(_client_end));
}

template <>
Directory::UnownedResultOf::Close_Impl<Directory::CloseResponse>::Close_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(CloseRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, CloseRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(CloseRequest));
  ::fidl::DecodedMessage<CloseRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Directory::InPlace::Close(std::move(_client_end), std::move(_response_buffer)));
}

Directory::UnownedResultOf::Close Directory::SyncClient::Close(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Close(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Directory::UnownedResultOf::Close Directory::Call::Close(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Close(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Directory::CloseResponse> Directory::InPlace::Close(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(CloseRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<CloseRequest> params(std::move(_request_buffer));
  Directory::SetTransactionHeaderFor::CloseRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::CloseResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<CloseRequest, CloseResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::CloseResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Directory::ResultOf::Describe_Impl<Directory::DescribeResponse>::Describe_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DescribeRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, DescribeRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(DescribeRequest));
  ::fidl::DecodedMessage<DescribeRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Directory::InPlace::Describe(std::move(_client_end), Super::response_buffer()));
}

Directory::ResultOf::Describe Directory::SyncClient::Describe() {
  return ResultOf::Describe(zx::unowned_channel(this->channel_));
}

Directory::ResultOf::Describe Directory::Call::Describe(zx::unowned_channel _client_end) {
  return ResultOf::Describe(std::move(_client_end));
}

template <>
Directory::UnownedResultOf::Describe_Impl<Directory::DescribeResponse>::Describe_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(DescribeRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, DescribeRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(DescribeRequest));
  ::fidl::DecodedMessage<DescribeRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Directory::InPlace::Describe(std::move(_client_end), std::move(_response_buffer)));
}

Directory::UnownedResultOf::Describe Directory::SyncClient::Describe(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Describe(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Directory::UnownedResultOf::Describe Directory::Call::Describe(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Describe(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Directory::DescribeResponse> Directory::InPlace::Describe(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(DescribeRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<DescribeRequest> params(std::move(_request_buffer));
  Directory::SetTransactionHeaderFor::DescribeRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::DescribeResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<DescribeRequest, DescribeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::DescribeResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Directory::ResultOf::Sync_Impl<Directory::SyncResponse>::Sync_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SyncRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Directory::InPlace::Sync(std::move(_client_end), Super::response_buffer()));
}

Directory::ResultOf::Sync Directory::SyncClient::Sync() {
  return ResultOf::Sync(zx::unowned_channel(this->channel_));
}

Directory::ResultOf::Sync Directory::Call::Sync(zx::unowned_channel _client_end) {
  return ResultOf::Sync(std::move(_client_end));
}

template <>
Directory::UnownedResultOf::Sync_Impl<Directory::SyncResponse>::Sync_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(SyncRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, SyncRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Directory::InPlace::Sync(std::move(_client_end), std::move(_response_buffer)));
}

Directory::UnownedResultOf::Sync Directory::SyncClient::Sync(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Sync(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Directory::UnownedResultOf::Sync Directory::Call::Sync(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Sync(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Directory::SyncResponse> Directory::InPlace::Sync(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(SyncRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<SyncRequest> params(std::move(_request_buffer));
  Directory::SetTransactionHeaderFor::SyncRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::SyncResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SyncRequest, SyncResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::SyncResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Directory::ResultOf::GetAttr_Impl<Directory::GetAttrResponse>::GetAttr_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetAttrRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetAttrRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetAttrRequest));
  ::fidl::DecodedMessage<GetAttrRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Directory::InPlace::GetAttr(std::move(_client_end), Super::response_buffer()));
}

Directory::ResultOf::GetAttr Directory::SyncClient::GetAttr() {
  return ResultOf::GetAttr(zx::unowned_channel(this->channel_));
}

Directory::ResultOf::GetAttr Directory::Call::GetAttr(zx::unowned_channel _client_end) {
  return ResultOf::GetAttr(std::move(_client_end));
}

template <>
Directory::UnownedResultOf::GetAttr_Impl<Directory::GetAttrResponse>::GetAttr_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetAttrRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetAttrRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetAttrRequest));
  ::fidl::DecodedMessage<GetAttrRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Directory::InPlace::GetAttr(std::move(_client_end), std::move(_response_buffer)));
}

Directory::UnownedResultOf::GetAttr Directory::SyncClient::GetAttr(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetAttr(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Directory::UnownedResultOf::GetAttr Directory::Call::GetAttr(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetAttr(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Directory::GetAttrResponse> Directory::InPlace::GetAttr(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetAttrRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetAttrRequest> params(std::move(_request_buffer));
  Directory::SetTransactionHeaderFor::GetAttrRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::GetAttrResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetAttrRequest, GetAttrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::GetAttrResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Directory::ResultOf::SetAttr_Impl<Directory::SetAttrResponse>::SetAttr_Impl(zx::unowned_channel _client_end, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetAttrRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetAttrRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetAttrRequest*>(_write_bytes);
  _request.flags = std::move(flags);
  _request.attributes = std::move(attributes);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetAttrRequest));
  ::fidl::DecodedMessage<SetAttrRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Directory::InPlace::SetAttr(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Directory::ResultOf::SetAttr Directory::SyncClient::SetAttr(uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes) {
  return ResultOf::SetAttr(zx::unowned_channel(this->channel_), std::move(flags), std::move(attributes));
}

Directory::ResultOf::SetAttr Directory::Call::SetAttr(zx::unowned_channel _client_end, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes) {
  return ResultOf::SetAttr(std::move(_client_end), std::move(flags), std::move(attributes));
}

template <>
Directory::UnownedResultOf::SetAttr_Impl<Directory::SetAttrResponse>::SetAttr_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < SetAttrRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<SetAttrResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, SetAttrRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetAttrRequest*>(_request_buffer.data());
  _request.flags = std::move(flags);
  _request.attributes = std::move(attributes);
  _request_buffer.set_actual(sizeof(SetAttrRequest));
  ::fidl::DecodedMessage<SetAttrRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Directory::InPlace::SetAttr(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Directory::UnownedResultOf::SetAttr Directory::SyncClient::SetAttr(::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetAttr(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(flags), std::move(attributes), std::move(_response_buffer));
}

Directory::UnownedResultOf::SetAttr Directory::Call::SetAttr(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetAttr(std::move(_client_end), std::move(_request_buffer), std::move(flags), std::move(attributes), std::move(_response_buffer));
}

::fidl::DecodeResult<Directory::SetAttrResponse> Directory::InPlace::SetAttr(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetAttrRequest> params, ::fidl::BytePart response_buffer) {
  Directory::SetTransactionHeaderFor::SetAttrRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::SetAttrResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SetAttrRequest, SetAttrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::SetAttrResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Directory::ResultOf::NodeGetFlags_Impl<Directory::NodeGetFlagsResponse>::NodeGetFlags_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<NodeGetFlagsRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, NodeGetFlagsRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(NodeGetFlagsRequest));
  ::fidl::DecodedMessage<NodeGetFlagsRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Directory::InPlace::NodeGetFlags(std::move(_client_end), Super::response_buffer()));
}

Directory::ResultOf::NodeGetFlags Directory::SyncClient::NodeGetFlags() {
  return ResultOf::NodeGetFlags(zx::unowned_channel(this->channel_));
}

Directory::ResultOf::NodeGetFlags Directory::Call::NodeGetFlags(zx::unowned_channel _client_end) {
  return ResultOf::NodeGetFlags(std::move(_client_end));
}

template <>
Directory::UnownedResultOf::NodeGetFlags_Impl<Directory::NodeGetFlagsResponse>::NodeGetFlags_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(NodeGetFlagsRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, NodeGetFlagsRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(NodeGetFlagsRequest));
  ::fidl::DecodedMessage<NodeGetFlagsRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Directory::InPlace::NodeGetFlags(std::move(_client_end), std::move(_response_buffer)));
}

Directory::UnownedResultOf::NodeGetFlags Directory::SyncClient::NodeGetFlags(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::NodeGetFlags(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Directory::UnownedResultOf::NodeGetFlags Directory::Call::NodeGetFlags(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::NodeGetFlags(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Directory::NodeGetFlagsResponse> Directory::InPlace::NodeGetFlags(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(NodeGetFlagsRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<NodeGetFlagsRequest> params(std::move(_request_buffer));
  Directory::SetTransactionHeaderFor::NodeGetFlagsRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::NodeGetFlagsResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<NodeGetFlagsRequest, NodeGetFlagsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::NodeGetFlagsResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Directory::ResultOf::NodeSetFlags_Impl<Directory::NodeSetFlagsResponse>::NodeSetFlags_Impl(zx::unowned_channel _client_end, uint32_t flags) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<NodeSetFlagsRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, NodeSetFlagsRequest::PrimarySize);
  auto& _request = *reinterpret_cast<NodeSetFlagsRequest*>(_write_bytes);
  _request.flags = std::move(flags);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(NodeSetFlagsRequest));
  ::fidl::DecodedMessage<NodeSetFlagsRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Directory::InPlace::NodeSetFlags(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Directory::ResultOf::NodeSetFlags Directory::SyncClient::NodeSetFlags(uint32_t flags) {
  return ResultOf::NodeSetFlags(zx::unowned_channel(this->channel_), std::move(flags));
}

Directory::ResultOf::NodeSetFlags Directory::Call::NodeSetFlags(zx::unowned_channel _client_end, uint32_t flags) {
  return ResultOf::NodeSetFlags(std::move(_client_end), std::move(flags));
}

template <>
Directory::UnownedResultOf::NodeSetFlags_Impl<Directory::NodeSetFlagsResponse>::NodeSetFlags_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < NodeSetFlagsRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<NodeSetFlagsResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, NodeSetFlagsRequest::PrimarySize);
  auto& _request = *reinterpret_cast<NodeSetFlagsRequest*>(_request_buffer.data());
  _request.flags = std::move(flags);
  _request_buffer.set_actual(sizeof(NodeSetFlagsRequest));
  ::fidl::DecodedMessage<NodeSetFlagsRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Directory::InPlace::NodeSetFlags(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Directory::UnownedResultOf::NodeSetFlags Directory::SyncClient::NodeSetFlags(::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::NodeSetFlags(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(flags), std::move(_response_buffer));
}

Directory::UnownedResultOf::NodeSetFlags Directory::Call::NodeSetFlags(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::NodeSetFlags(std::move(_client_end), std::move(_request_buffer), std::move(flags), std::move(_response_buffer));
}

::fidl::DecodeResult<Directory::NodeSetFlagsResponse> Directory::InPlace::NodeSetFlags(zx::unowned_channel _client_end, ::fidl::DecodedMessage<NodeSetFlagsRequest> params, ::fidl::BytePart response_buffer) {
  Directory::SetTransactionHeaderFor::NodeSetFlagsRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::NodeSetFlagsResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<NodeSetFlagsRequest, NodeSetFlagsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::NodeSetFlagsResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


Directory::ResultOf::Open_Impl::Open_Impl(zx::unowned_channel _client_end, uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OpenRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  OpenRequest _request = {};
  _request.flags = std::move(flags);
  _request.mode = std::move(mode);
  _request.path = std::move(path);
  _request.object = std::move(object);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<OpenRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      Directory::InPlace::Open(std::move(_client_end), std::move(_decoded_request)));
}

Directory::ResultOf::Open Directory::SyncClient::Open(uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object) {
  return ResultOf::Open(zx::unowned_channel(this->channel_), std::move(flags), std::move(mode), std::move(path), std::move(object));
}

Directory::ResultOf::Open Directory::Call::Open(zx::unowned_channel _client_end, uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object) {
  return ResultOf::Open(std::move(_client_end), std::move(flags), std::move(mode), std::move(path), std::move(object));
}


Directory::UnownedResultOf::Open_Impl::Open_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object) {
  if (_request_buffer.capacity() < OpenRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  OpenRequest _request = {};
  _request.flags = std::move(flags);
  _request.mode = std::move(mode);
  _request.path = std::move(path);
  _request.object = std::move(object);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<OpenRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      Directory::InPlace::Open(std::move(_client_end), std::move(_decoded_request)));
}

Directory::UnownedResultOf::Open Directory::SyncClient::Open(::fidl::BytePart _request_buffer, uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object) {
  return UnownedResultOf::Open(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(flags), std::move(mode), std::move(path), std::move(object));
}

Directory::UnownedResultOf::Open Directory::Call::Open(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object) {
  return UnownedResultOf::Open(std::move(_client_end), std::move(_request_buffer), std::move(flags), std::move(mode), std::move(path), std::move(object));
}

::fidl::internal::StatusAndError Directory::InPlace::Open(zx::unowned_channel _client_end, ::fidl::DecodedMessage<OpenRequest> params) {
  Directory::SetTransactionHeaderFor::OpenRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
Directory::ResultOf::Unlink_Impl<Directory::UnlinkResponse>::Unlink_Impl(zx::unowned_channel _client_end, ::fidl::StringView path) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UnlinkRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  UnlinkRequest _request = {};
  _request.path = std::move(path);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<UnlinkRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Directory::InPlace::Unlink(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Directory::ResultOf::Unlink Directory::SyncClient::Unlink(::fidl::StringView path) {
  return ResultOf::Unlink(zx::unowned_channel(this->channel_), std::move(path));
}

Directory::ResultOf::Unlink Directory::Call::Unlink(zx::unowned_channel _client_end, ::fidl::StringView path) {
  return ResultOf::Unlink(std::move(_client_end), std::move(path));
}

template <>
Directory::UnownedResultOf::Unlink_Impl<Directory::UnlinkResponse>::Unlink_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView path, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < UnlinkRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<UnlinkResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  UnlinkRequest _request = {};
  _request.path = std::move(path);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<UnlinkRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Directory::InPlace::Unlink(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Directory::UnownedResultOf::Unlink Directory::SyncClient::Unlink(::fidl::BytePart _request_buffer, ::fidl::StringView path, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Unlink(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(path), std::move(_response_buffer));
}

Directory::UnownedResultOf::Unlink Directory::Call::Unlink(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView path, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Unlink(std::move(_client_end), std::move(_request_buffer), std::move(path), std::move(_response_buffer));
}

::fidl::DecodeResult<Directory::UnlinkResponse> Directory::InPlace::Unlink(zx::unowned_channel _client_end, ::fidl::DecodedMessage<UnlinkRequest> params, ::fidl::BytePart response_buffer) {
  Directory::SetTransactionHeaderFor::UnlinkRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::UnlinkResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<UnlinkRequest, UnlinkResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::UnlinkResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Directory::ResultOf::ReadDirents_Impl<Directory::ReadDirentsResponse>::ReadDirents_Impl(zx::unowned_channel _client_end, uint64_t max_bytes) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReadDirentsRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ReadDirentsRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReadDirentsRequest*>(_write_bytes);
  _request.max_bytes = std::move(max_bytes);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ReadDirentsRequest));
  ::fidl::DecodedMessage<ReadDirentsRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Directory::InPlace::ReadDirents(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Directory::ResultOf::ReadDirents Directory::SyncClient::ReadDirents(uint64_t max_bytes) {
  return ResultOf::ReadDirents(zx::unowned_channel(this->channel_), std::move(max_bytes));
}

Directory::ResultOf::ReadDirents Directory::Call::ReadDirents(zx::unowned_channel _client_end, uint64_t max_bytes) {
  return ResultOf::ReadDirents(std::move(_client_end), std::move(max_bytes));
}

template <>
Directory::UnownedResultOf::ReadDirents_Impl<Directory::ReadDirentsResponse>::ReadDirents_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t max_bytes, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < ReadDirentsRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<ReadDirentsResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, ReadDirentsRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReadDirentsRequest*>(_request_buffer.data());
  _request.max_bytes = std::move(max_bytes);
  _request_buffer.set_actual(sizeof(ReadDirentsRequest));
  ::fidl::DecodedMessage<ReadDirentsRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Directory::InPlace::ReadDirents(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Directory::UnownedResultOf::ReadDirents Directory::SyncClient::ReadDirents(::fidl::BytePart _request_buffer, uint64_t max_bytes, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ReadDirents(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(max_bytes), std::move(_response_buffer));
}

Directory::UnownedResultOf::ReadDirents Directory::Call::ReadDirents(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t max_bytes, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ReadDirents(std::move(_client_end), std::move(_request_buffer), std::move(max_bytes), std::move(_response_buffer));
}

::fidl::DecodeResult<Directory::ReadDirentsResponse> Directory::InPlace::ReadDirents(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReadDirentsRequest> params, ::fidl::BytePart response_buffer) {
  Directory::SetTransactionHeaderFor::ReadDirentsRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::ReadDirentsResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ReadDirentsRequest, ReadDirentsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::ReadDirentsResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Directory::ResultOf::Rewind_Impl<Directory::RewindResponse>::Rewind_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RewindRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, RewindRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(RewindRequest));
  ::fidl::DecodedMessage<RewindRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Directory::InPlace::Rewind(std::move(_client_end), Super::response_buffer()));
}

Directory::ResultOf::Rewind Directory::SyncClient::Rewind() {
  return ResultOf::Rewind(zx::unowned_channel(this->channel_));
}

Directory::ResultOf::Rewind Directory::Call::Rewind(zx::unowned_channel _client_end) {
  return ResultOf::Rewind(std::move(_client_end));
}

template <>
Directory::UnownedResultOf::Rewind_Impl<Directory::RewindResponse>::Rewind_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(RewindRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, RewindRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(RewindRequest));
  ::fidl::DecodedMessage<RewindRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Directory::InPlace::Rewind(std::move(_client_end), std::move(_response_buffer)));
}

Directory::UnownedResultOf::Rewind Directory::SyncClient::Rewind(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Rewind(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Directory::UnownedResultOf::Rewind Directory::Call::Rewind(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Rewind(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Directory::RewindResponse> Directory::InPlace::Rewind(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(RewindRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<RewindRequest> params(std::move(_request_buffer));
  Directory::SetTransactionHeaderFor::RewindRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::RewindResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<RewindRequest, RewindResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::RewindResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Directory::ResultOf::GetToken_Impl<Directory::GetTokenResponse>::GetToken_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetTokenRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetTokenRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetTokenRequest));
  ::fidl::DecodedMessage<GetTokenRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Directory::InPlace::GetToken(std::move(_client_end), Super::response_buffer()));
}

Directory::ResultOf::GetToken Directory::SyncClient::GetToken() {
  return ResultOf::GetToken(zx::unowned_channel(this->channel_));
}

Directory::ResultOf::GetToken Directory::Call::GetToken(zx::unowned_channel _client_end) {
  return ResultOf::GetToken(std::move(_client_end));
}

template <>
Directory::UnownedResultOf::GetToken_Impl<Directory::GetTokenResponse>::GetToken_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetTokenRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetTokenRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetTokenRequest));
  ::fidl::DecodedMessage<GetTokenRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Directory::InPlace::GetToken(std::move(_client_end), std::move(_response_buffer)));
}

Directory::UnownedResultOf::GetToken Directory::SyncClient::GetToken(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetToken(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Directory::UnownedResultOf::GetToken Directory::Call::GetToken(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetToken(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Directory::GetTokenResponse> Directory::InPlace::GetToken(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetTokenRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetTokenRequest> params(std::move(_request_buffer));
  Directory::SetTransactionHeaderFor::GetTokenRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::GetTokenResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetTokenRequest, GetTokenResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::GetTokenResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Directory::ResultOf::Rename_Impl<Directory::RenameResponse>::Rename_Impl(zx::unowned_channel _client_end, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RenameRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  RenameRequest _request = {};
  _request.src = std::move(src);
  _request.dst_parent_token = std::move(dst_parent_token);
  _request.dst = std::move(dst);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<RenameRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Directory::InPlace::Rename(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Directory::ResultOf::Rename Directory::SyncClient::Rename(::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst) {
  return ResultOf::Rename(zx::unowned_channel(this->channel_), std::move(src), std::move(dst_parent_token), std::move(dst));
}

Directory::ResultOf::Rename Directory::Call::Rename(zx::unowned_channel _client_end, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst) {
  return ResultOf::Rename(std::move(_client_end), std::move(src), std::move(dst_parent_token), std::move(dst));
}

template <>
Directory::UnownedResultOf::Rename_Impl<Directory::RenameResponse>::Rename_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < RenameRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<RenameResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  RenameRequest _request = {};
  _request.src = std::move(src);
  _request.dst_parent_token = std::move(dst_parent_token);
  _request.dst = std::move(dst);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<RenameRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Directory::InPlace::Rename(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Directory::UnownedResultOf::Rename Directory::SyncClient::Rename(::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Rename(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(src), std::move(dst_parent_token), std::move(dst), std::move(_response_buffer));
}

Directory::UnownedResultOf::Rename Directory::Call::Rename(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Rename(std::move(_client_end), std::move(_request_buffer), std::move(src), std::move(dst_parent_token), std::move(dst), std::move(_response_buffer));
}

::fidl::DecodeResult<Directory::RenameResponse> Directory::InPlace::Rename(zx::unowned_channel _client_end, ::fidl::DecodedMessage<RenameRequest> params, ::fidl::BytePart response_buffer) {
  Directory::SetTransactionHeaderFor::RenameRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::RenameResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<RenameRequest, RenameResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::RenameResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Directory::ResultOf::Link_Impl<Directory::LinkResponse>::Link_Impl(zx::unowned_channel _client_end, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LinkRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  LinkRequest _request = {};
  _request.src = std::move(src);
  _request.dst_parent_token = std::move(dst_parent_token);
  _request.dst = std::move(dst);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LinkRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Directory::InPlace::Link(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Directory::ResultOf::Link Directory::SyncClient::Link(::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst) {
  return ResultOf::Link(zx::unowned_channel(this->channel_), std::move(src), std::move(dst_parent_token), std::move(dst));
}

Directory::ResultOf::Link Directory::Call::Link(zx::unowned_channel _client_end, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst) {
  return ResultOf::Link(std::move(_client_end), std::move(src), std::move(dst_parent_token), std::move(dst));
}

template <>
Directory::UnownedResultOf::Link_Impl<Directory::LinkResponse>::Link_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < LinkRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<LinkResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  LinkRequest _request = {};
  _request.src = std::move(src);
  _request.dst_parent_token = std::move(dst_parent_token);
  _request.dst = std::move(dst);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LinkRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Directory::InPlace::Link(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Directory::UnownedResultOf::Link Directory::SyncClient::Link(::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Link(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(src), std::move(dst_parent_token), std::move(dst), std::move(_response_buffer));
}

Directory::UnownedResultOf::Link Directory::Call::Link(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Link(std::move(_client_end), std::move(_request_buffer), std::move(src), std::move(dst_parent_token), std::move(dst), std::move(_response_buffer));
}

::fidl::DecodeResult<Directory::LinkResponse> Directory::InPlace::Link(zx::unowned_channel _client_end, ::fidl::DecodedMessage<LinkRequest> params, ::fidl::BytePart response_buffer) {
  Directory::SetTransactionHeaderFor::LinkRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::LinkResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<LinkRequest, LinkResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::LinkResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Directory::ResultOf::Watch_Impl<Directory::WatchResponse>::Watch_Impl(zx::unowned_channel _client_end, uint32_t mask, uint32_t options, ::zx::channel watcher) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WatchRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, WatchRequest::PrimarySize);
  auto& _request = *reinterpret_cast<WatchRequest*>(_write_bytes);
  _request.mask = std::move(mask);
  _request.options = std::move(options);
  _request.watcher = std::move(watcher);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(WatchRequest));
  ::fidl::DecodedMessage<WatchRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Directory::InPlace::Watch(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Directory::ResultOf::Watch Directory::SyncClient::Watch(uint32_t mask, uint32_t options, ::zx::channel watcher) {
  return ResultOf::Watch(zx::unowned_channel(this->channel_), std::move(mask), std::move(options), std::move(watcher));
}

Directory::ResultOf::Watch Directory::Call::Watch(zx::unowned_channel _client_end, uint32_t mask, uint32_t options, ::zx::channel watcher) {
  return ResultOf::Watch(std::move(_client_end), std::move(mask), std::move(options), std::move(watcher));
}

template <>
Directory::UnownedResultOf::Watch_Impl<Directory::WatchResponse>::Watch_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t mask, uint32_t options, ::zx::channel watcher, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < WatchRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<WatchResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, WatchRequest::PrimarySize);
  auto& _request = *reinterpret_cast<WatchRequest*>(_request_buffer.data());
  _request.mask = std::move(mask);
  _request.options = std::move(options);
  _request.watcher = std::move(watcher);
  _request_buffer.set_actual(sizeof(WatchRequest));
  ::fidl::DecodedMessage<WatchRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Directory::InPlace::Watch(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Directory::UnownedResultOf::Watch Directory::SyncClient::Watch(::fidl::BytePart _request_buffer, uint32_t mask, uint32_t options, ::zx::channel watcher, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Watch(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(mask), std::move(options), std::move(watcher), std::move(_response_buffer));
}

Directory::UnownedResultOf::Watch Directory::Call::Watch(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t mask, uint32_t options, ::zx::channel watcher, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Watch(std::move(_client_end), std::move(_request_buffer), std::move(mask), std::move(options), std::move(watcher), std::move(_response_buffer));
}

::fidl::DecodeResult<Directory::WatchResponse> Directory::InPlace::Watch(zx::unowned_channel _client_end, ::fidl::DecodedMessage<WatchRequest> params, ::fidl::BytePart response_buffer) {
  Directory::SetTransactionHeaderFor::WatchRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::WatchResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<WatchRequest, WatchResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::WatchResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

zx_status_t Directory::SyncClient::HandleEvents(Directory::EventHandlers handlers) {
  return Directory::Call::HandleEvents(zx::unowned_channel(channel_), std::move(handlers));
}

zx_status_t Directory::Call::HandleEvents(zx::unowned_channel client_end, Directory::EventHandlers handlers) {
  zx_status_t status = client_end->wait_one(ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED,
                                            zx::time::infinite(),
                                            nullptr);
  if (status != ZX_OK) {
    return status;
  }
  constexpr uint32_t kReadAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::internal::ClampedMessageSize<OnOpenResponse, ::fidl::MessageDirection::kReceiving>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<OnOpenResponse, ::fidl::MessageDirection::kReceiving>();
    }
    if (::fidl::internal::ClampedMessageSize<OnOpenResponse, ::fidl::MessageDirection::kReceiving, ::fidl::internal::WireFormatGuide::kAlternate>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<OnOpenResponse, ::fidl::MessageDirection::kReceiving, ::fidl::internal::WireFormatGuide::kAlternate>();
    }
    return x;
  })();
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (OnOpenResponse::MaxNumHandles >= x) {
      x = OnOpenResponse::MaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  ::fidl::internal::ByteStorage<kReadAllocSize> read_storage;
  uint8_t* read_bytes = read_storage.buffer().data();
  zx_handle_t read_handles[kHandleAllocSize];
  uint32_t actual_bytes;
  uint32_t actual_handles;
  status = client_end->read(ZX_CHANNEL_READ_MAY_DISCARD,
                            read_bytes, read_handles,
                            kReadAllocSize, kHandleAllocSize,
                            &actual_bytes, &actual_handles);
  if (status == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new event,
    // whose size exceeds the maximum of known events in the current protocol.
    return handlers.unknown();
  }
  if (status != ZX_OK) {
    return status;
  }
  if (actual_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(read_handles, actual_handles);
    return ZX_ERR_INVALID_ARGS;
  }
  auto msg = fidl_msg_t {
      .bytes = read_bytes,
      .handles = read_handles,
      .num_bytes = actual_bytes,
      .num_handles = actual_handles
  };
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg.bytes);
  status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    return status;
  }
  switch (hdr->ordinal) {
    case kDirectory_OnOpen_Ordinal:
    case kDirectory_OnOpen_GenOrdinal:
    {
      constexpr uint32_t kTransformerDestSize = ::fidl::internal::ClampedMessageSize<OnOpenResponse, ::fidl::MessageDirection::kReceiving>();
      ::fidl::internal::ByteStorage<kTransformerDestSize> transformer_dest_storage(::fidl::internal::DelayAllocation);
      if (fidl_should_decode_union_from_xunion(hdr)) {
        transformer_dest_storage.Allocate();
        uint8_t* transformer_dest = transformer_dest_storage.buffer().data();
        zx_status_t transform_status = fidl_transform(FIDL_TRANSFORMATION_V1_TO_OLD,
                                                      OnOpenResponse::AltType,
                                                      reinterpret_cast<uint8_t*>(msg.bytes),
                                                      msg.num_bytes,
                                                      transformer_dest,
                                                      kTransformerDestSize,
                                                      &msg.num_bytes,
                                                      nullptr);
        if (transform_status != ZX_OK) {
          zx_handle_close_many(msg.handles, msg.num_handles);
          return ZX_ERR_INVALID_ARGS;
        }
        msg.bytes = transformer_dest;
      }
      auto result = ::fidl::DecodeAs<OnOpenResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      auto message = result.message.message();
      return handlers.on_open(std::move(message->s), std::move(message->info));
    }
    default:
      zx_handle_close_many(read_handles, actual_handles);
      return handlers.unknown();
  }
}

bool Directory::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kDirectory_Clone_Ordinal:
    case kDirectory_Clone_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<CloneRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Clone(std::move(message->flags), std::move(message->object),
          Interface::CloneCompleter::Sync(txn));
      return true;
    }
    case kDirectory_Close_Ordinal:
    case kDirectory_Close_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<CloseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Close(
          Interface::CloseCompleter::Sync(txn));
      return true;
    }
    case kDirectory_Describe_Ordinal:
    case kDirectory_Describe_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<DescribeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Describe(
          Interface::DescribeCompleter::Sync(txn));
      return true;
    }
    case kDirectory_Sync_Ordinal:
    case kDirectory_Sync_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SyncRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Sync(
          Interface::SyncCompleter::Sync(txn));
      return true;
    }
    case kDirectory_GetAttr_Ordinal:
    case kDirectory_GetAttr_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetAttrRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetAttr(
          Interface::GetAttrCompleter::Sync(txn));
      return true;
    }
    case kDirectory_SetAttr_Ordinal:
    case kDirectory_SetAttr_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetAttrRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetAttr(std::move(message->flags), std::move(message->attributes),
          Interface::SetAttrCompleter::Sync(txn));
      return true;
    }
    case kDirectory_NodeGetFlags_Ordinal:
    case kDirectory_NodeGetFlags_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<NodeGetFlagsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->NodeGetFlags(
          Interface::NodeGetFlagsCompleter::Sync(txn));
      return true;
    }
    case kDirectory_NodeSetFlags_Ordinal:
    case kDirectory_NodeSetFlags_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<NodeSetFlagsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->NodeSetFlags(std::move(message->flags),
          Interface::NodeSetFlagsCompleter::Sync(txn));
      return true;
    }
    case kDirectory_Open_Ordinal:
    case kDirectory_Open_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<OpenRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Open(std::move(message->flags), std::move(message->mode), std::move(message->path), std::move(message->object),
          Interface::OpenCompleter::Sync(txn));
      return true;
    }
    case kDirectory_Unlink_Ordinal:
    case kDirectory_Unlink_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<UnlinkRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Unlink(std::move(message->path),
          Interface::UnlinkCompleter::Sync(txn));
      return true;
    }
    case kDirectory_ReadDirents_Ordinal:
    case kDirectory_ReadDirents_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ReadDirentsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->ReadDirents(std::move(message->max_bytes),
          Interface::ReadDirentsCompleter::Sync(txn));
      return true;
    }
    case kDirectory_Rewind_Ordinal:
    case kDirectory_Rewind_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<RewindRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Rewind(
          Interface::RewindCompleter::Sync(txn));
      return true;
    }
    case kDirectory_GetToken_Ordinal:
    case kDirectory_GetToken_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetTokenRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetToken(
          Interface::GetTokenCompleter::Sync(txn));
      return true;
    }
    case kDirectory_Rename_Ordinal:
    case kDirectory_Rename_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<RenameRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Rename(std::move(message->src), std::move(message->dst_parent_token), std::move(message->dst),
          Interface::RenameCompleter::Sync(txn));
      return true;
    }
    case kDirectory_Link_Ordinal:
    case kDirectory_Link_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<LinkRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Link(std::move(message->src), std::move(message->dst_parent_token), std::move(message->dst),
          Interface::LinkCompleter::Sync(txn));
      return true;
    }
    case kDirectory_Watch_Ordinal:
    case kDirectory_Watch_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<WatchRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Watch(std::move(message->mask), std::move(message->options), std::move(message->watcher),
          Interface::WatchCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Directory::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void Directory::Interface::CloseCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<CloseResponse*>(_write_bytes);
  Directory::SetTransactionHeaderFor::CloseResponse(
      ::fidl::DecodedMessage<CloseResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              CloseResponse::PrimarySize,
              CloseResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CloseResponse>(std::move(_response_bytes)));
}

void Directory::Interface::CloseCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < CloseResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<CloseResponse*>(_buffer.data());
  Directory::SetTransactionHeaderFor::CloseResponse(
      ::fidl::DecodedMessage<CloseResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              CloseResponse::PrimarySize,
              CloseResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(CloseResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CloseResponse>(std::move(_buffer)));
}

void Directory::Interface::CloseCompleterBase::Reply(::fidl::DecodedMessage<CloseResponse> params) {
  Directory::SetTransactionHeaderFor::CloseResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Directory::Interface::DescribeCompleterBase::Reply(::llcpp::fuchsia::io::NodeInfo info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DescribeResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<DescribeResponse*>(_write_bytes);
  Directory::SetTransactionHeaderFor::DescribeResponse(
      ::fidl::DecodedMessage<DescribeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              DescribeResponse::PrimarySize,
              DescribeResponse::PrimarySize)));
  _response.info = std::move(info);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(DescribeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<DescribeResponse>(std::move(_response_bytes)));
}

void Directory::Interface::DescribeCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io::NodeInfo info) {
  if (_buffer.capacity() < DescribeResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<DescribeResponse*>(_buffer.data());
  Directory::SetTransactionHeaderFor::DescribeResponse(
      ::fidl::DecodedMessage<DescribeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              DescribeResponse::PrimarySize,
              DescribeResponse::PrimarySize)));
  _response.info = std::move(info);
  _buffer.set_actual(sizeof(DescribeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<DescribeResponse>(std::move(_buffer)));
}

void Directory::Interface::DescribeCompleterBase::Reply(::fidl::DecodedMessage<DescribeResponse> params) {
  Directory::SetTransactionHeaderFor::DescribeResponse(params);
  CompleterBase::SendReply(std::move(params));
}


zx_status_t Directory::SendOnOpenEvent(::zx::unowned_channel _chan, int32_t s, ::llcpp::fuchsia::io::NodeInfo* info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OnOpenResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  OnOpenResponse _response = {};
  Directory::SetTransactionHeaderFor::OnOpenResponse(
      ::fidl::DecodedMessage<OnOpenResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OnOpenResponse::PrimarySize,
              OnOpenResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t Directory::SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, int32_t s, ::llcpp::fuchsia::io::NodeInfo* info) {
  if (_buffer.capacity() < OnOpenResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  OnOpenResponse _response = {};
  Directory::SetTransactionHeaderFor::OnOpenResponse(
      ::fidl::DecodedMessage<OnOpenResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OnOpenResponse::PrimarySize,
              OnOpenResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
	return _linearize_result.status;
  }
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t Directory::SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnOpenResponse> params) {
  Directory::SetTransactionHeaderFor::OnOpenResponse(params);
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(params));
}


void Directory::Interface::SyncCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SyncResponse*>(_write_bytes);
  Directory::SetTransactionHeaderFor::SyncResponse(
      ::fidl::DecodedMessage<SyncResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SyncResponse::PrimarySize,
              SyncResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SyncResponse>(std::move(_response_bytes)));
}

void Directory::Interface::SyncCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < SyncResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SyncResponse*>(_buffer.data());
  Directory::SetTransactionHeaderFor::SyncResponse(
      ::fidl::DecodedMessage<SyncResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SyncResponse::PrimarySize,
              SyncResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(SyncResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SyncResponse>(std::move(_buffer)));
}

void Directory::Interface::SyncCompleterBase::Reply(::fidl::DecodedMessage<SyncResponse> params) {
  Directory::SetTransactionHeaderFor::SyncResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Directory::Interface::GetAttrCompleterBase::Reply(int32_t s, ::llcpp::fuchsia::io::NodeAttributes attributes) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetAttrResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetAttrResponse*>(_write_bytes);
  Directory::SetTransactionHeaderFor::GetAttrResponse(
      ::fidl::DecodedMessage<GetAttrResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetAttrResponse::PrimarySize,
              GetAttrResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.attributes = std::move(attributes);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetAttrResponse>(std::move(_response_bytes)));
}

void Directory::Interface::GetAttrCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, ::llcpp::fuchsia::io::NodeAttributes attributes) {
  if (_buffer.capacity() < GetAttrResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetAttrResponse*>(_buffer.data());
  Directory::SetTransactionHeaderFor::GetAttrResponse(
      ::fidl::DecodedMessage<GetAttrResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetAttrResponse::PrimarySize,
              GetAttrResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.attributes = std::move(attributes);
  _buffer.set_actual(sizeof(GetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetAttrResponse>(std::move(_buffer)));
}

void Directory::Interface::GetAttrCompleterBase::Reply(::fidl::DecodedMessage<GetAttrResponse> params) {
  Directory::SetTransactionHeaderFor::GetAttrResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Directory::Interface::SetAttrCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetAttrResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SetAttrResponse*>(_write_bytes);
  Directory::SetTransactionHeaderFor::SetAttrResponse(
      ::fidl::DecodedMessage<SetAttrResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetAttrResponse::PrimarySize,
              SetAttrResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetAttrResponse>(std::move(_response_bytes)));
}

void Directory::Interface::SetAttrCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < SetAttrResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SetAttrResponse*>(_buffer.data());
  Directory::SetTransactionHeaderFor::SetAttrResponse(
      ::fidl::DecodedMessage<SetAttrResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetAttrResponse::PrimarySize,
              SetAttrResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(SetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetAttrResponse>(std::move(_buffer)));
}

void Directory::Interface::SetAttrCompleterBase::Reply(::fidl::DecodedMessage<SetAttrResponse> params) {
  Directory::SetTransactionHeaderFor::SetAttrResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Directory::Interface::NodeGetFlagsCompleterBase::Reply(int32_t s, uint32_t flags) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<NodeGetFlagsResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<NodeGetFlagsResponse*>(_write_bytes);
  Directory::SetTransactionHeaderFor::NodeGetFlagsResponse(
      ::fidl::DecodedMessage<NodeGetFlagsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              NodeGetFlagsResponse::PrimarySize,
              NodeGetFlagsResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.flags = std::move(flags);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(NodeGetFlagsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<NodeGetFlagsResponse>(std::move(_response_bytes)));
}

void Directory::Interface::NodeGetFlagsCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, uint32_t flags) {
  if (_buffer.capacity() < NodeGetFlagsResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<NodeGetFlagsResponse*>(_buffer.data());
  Directory::SetTransactionHeaderFor::NodeGetFlagsResponse(
      ::fidl::DecodedMessage<NodeGetFlagsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              NodeGetFlagsResponse::PrimarySize,
              NodeGetFlagsResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.flags = std::move(flags);
  _buffer.set_actual(sizeof(NodeGetFlagsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<NodeGetFlagsResponse>(std::move(_buffer)));
}

void Directory::Interface::NodeGetFlagsCompleterBase::Reply(::fidl::DecodedMessage<NodeGetFlagsResponse> params) {
  Directory::SetTransactionHeaderFor::NodeGetFlagsResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Directory::Interface::NodeSetFlagsCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<NodeSetFlagsResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<NodeSetFlagsResponse*>(_write_bytes);
  Directory::SetTransactionHeaderFor::NodeSetFlagsResponse(
      ::fidl::DecodedMessage<NodeSetFlagsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              NodeSetFlagsResponse::PrimarySize,
              NodeSetFlagsResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(NodeSetFlagsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<NodeSetFlagsResponse>(std::move(_response_bytes)));
}

void Directory::Interface::NodeSetFlagsCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < NodeSetFlagsResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<NodeSetFlagsResponse*>(_buffer.data());
  Directory::SetTransactionHeaderFor::NodeSetFlagsResponse(
      ::fidl::DecodedMessage<NodeSetFlagsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              NodeSetFlagsResponse::PrimarySize,
              NodeSetFlagsResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(NodeSetFlagsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<NodeSetFlagsResponse>(std::move(_buffer)));
}

void Directory::Interface::NodeSetFlagsCompleterBase::Reply(::fidl::DecodedMessage<NodeSetFlagsResponse> params) {
  Directory::SetTransactionHeaderFor::NodeSetFlagsResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Directory::Interface::UnlinkCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UnlinkResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<UnlinkResponse*>(_write_bytes);
  Directory::SetTransactionHeaderFor::UnlinkResponse(
      ::fidl::DecodedMessage<UnlinkResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              UnlinkResponse::PrimarySize,
              UnlinkResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(UnlinkResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<UnlinkResponse>(std::move(_response_bytes)));
}

void Directory::Interface::UnlinkCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < UnlinkResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<UnlinkResponse*>(_buffer.data());
  Directory::SetTransactionHeaderFor::UnlinkResponse(
      ::fidl::DecodedMessage<UnlinkResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              UnlinkResponse::PrimarySize,
              UnlinkResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(UnlinkResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<UnlinkResponse>(std::move(_buffer)));
}

void Directory::Interface::UnlinkCompleterBase::Reply(::fidl::DecodedMessage<UnlinkResponse> params) {
  Directory::SetTransactionHeaderFor::UnlinkResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Directory::Interface::ReadDirentsCompleterBase::Reply(int32_t s, ::fidl::VectorView<uint8_t> dirents) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReadDirentsResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  ReadDirentsResponse _response = {};
  Directory::SetTransactionHeaderFor::ReadDirentsResponse(
      ::fidl::DecodedMessage<ReadDirentsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ReadDirentsResponse::PrimarySize,
              ReadDirentsResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.dirents = std::move(dirents);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Directory::Interface::ReadDirentsCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, ::fidl::VectorView<uint8_t> dirents) {
  if (_buffer.capacity() < ReadDirentsResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  ReadDirentsResponse _response = {};
  Directory::SetTransactionHeaderFor::ReadDirentsResponse(
      ::fidl::DecodedMessage<ReadDirentsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ReadDirentsResponse::PrimarySize,
              ReadDirentsResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.dirents = std::move(dirents);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Directory::Interface::ReadDirentsCompleterBase::Reply(::fidl::DecodedMessage<ReadDirentsResponse> params) {
  Directory::SetTransactionHeaderFor::ReadDirentsResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Directory::Interface::RewindCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RewindResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<RewindResponse*>(_write_bytes);
  Directory::SetTransactionHeaderFor::RewindResponse(
      ::fidl::DecodedMessage<RewindResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              RewindResponse::PrimarySize,
              RewindResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(RewindResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<RewindResponse>(std::move(_response_bytes)));
}

void Directory::Interface::RewindCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < RewindResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<RewindResponse*>(_buffer.data());
  Directory::SetTransactionHeaderFor::RewindResponse(
      ::fidl::DecodedMessage<RewindResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              RewindResponse::PrimarySize,
              RewindResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(RewindResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<RewindResponse>(std::move(_buffer)));
}

void Directory::Interface::RewindCompleterBase::Reply(::fidl::DecodedMessage<RewindResponse> params) {
  Directory::SetTransactionHeaderFor::RewindResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Directory::Interface::GetTokenCompleterBase::Reply(int32_t s, ::zx::handle token) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetTokenResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetTokenResponse*>(_write_bytes);
  Directory::SetTransactionHeaderFor::GetTokenResponse(
      ::fidl::DecodedMessage<GetTokenResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetTokenResponse::PrimarySize,
              GetTokenResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.token = std::move(token);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetTokenResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetTokenResponse>(std::move(_response_bytes)));
}

void Directory::Interface::GetTokenCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, ::zx::handle token) {
  if (_buffer.capacity() < GetTokenResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetTokenResponse*>(_buffer.data());
  Directory::SetTransactionHeaderFor::GetTokenResponse(
      ::fidl::DecodedMessage<GetTokenResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetTokenResponse::PrimarySize,
              GetTokenResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.token = std::move(token);
  _buffer.set_actual(sizeof(GetTokenResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetTokenResponse>(std::move(_buffer)));
}

void Directory::Interface::GetTokenCompleterBase::Reply(::fidl::DecodedMessage<GetTokenResponse> params) {
  Directory::SetTransactionHeaderFor::GetTokenResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Directory::Interface::RenameCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RenameResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<RenameResponse*>(_write_bytes);
  Directory::SetTransactionHeaderFor::RenameResponse(
      ::fidl::DecodedMessage<RenameResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              RenameResponse::PrimarySize,
              RenameResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(RenameResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<RenameResponse>(std::move(_response_bytes)));
}

void Directory::Interface::RenameCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < RenameResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<RenameResponse*>(_buffer.data());
  Directory::SetTransactionHeaderFor::RenameResponse(
      ::fidl::DecodedMessage<RenameResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              RenameResponse::PrimarySize,
              RenameResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(RenameResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<RenameResponse>(std::move(_buffer)));
}

void Directory::Interface::RenameCompleterBase::Reply(::fidl::DecodedMessage<RenameResponse> params) {
  Directory::SetTransactionHeaderFor::RenameResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Directory::Interface::LinkCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LinkResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<LinkResponse*>(_write_bytes);
  Directory::SetTransactionHeaderFor::LinkResponse(
      ::fidl::DecodedMessage<LinkResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LinkResponse::PrimarySize,
              LinkResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(LinkResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LinkResponse>(std::move(_response_bytes)));
}

void Directory::Interface::LinkCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < LinkResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<LinkResponse*>(_buffer.data());
  Directory::SetTransactionHeaderFor::LinkResponse(
      ::fidl::DecodedMessage<LinkResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LinkResponse::PrimarySize,
              LinkResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(LinkResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LinkResponse>(std::move(_buffer)));
}

void Directory::Interface::LinkCompleterBase::Reply(::fidl::DecodedMessage<LinkResponse> params) {
  Directory::SetTransactionHeaderFor::LinkResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Directory::Interface::WatchCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WatchResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<WatchResponse*>(_write_bytes);
  Directory::SetTransactionHeaderFor::WatchResponse(
      ::fidl::DecodedMessage<WatchResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WatchResponse::PrimarySize,
              WatchResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(WatchResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WatchResponse>(std::move(_response_bytes)));
}

void Directory::Interface::WatchCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < WatchResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<WatchResponse*>(_buffer.data());
  Directory::SetTransactionHeaderFor::WatchResponse(
      ::fidl::DecodedMessage<WatchResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WatchResponse::PrimarySize,
              WatchResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(WatchResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WatchResponse>(std::move(_buffer)));
}

void Directory::Interface::WatchCompleterBase::Reply(::fidl::DecodedMessage<WatchResponse> params) {
  Directory::SetTransactionHeaderFor::WatchResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void Directory::SetTransactionHeaderFor::CloneRequest(const ::fidl::DecodedMessage<Directory::CloneRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_Clone_Ordinal);
}

void Directory::SetTransactionHeaderFor::CloseRequest(const ::fidl::DecodedMessage<Directory::CloseRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_Close_Ordinal);
}
void Directory::SetTransactionHeaderFor::CloseResponse(const ::fidl::DecodedMessage<Directory::CloseResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_Close_Ordinal);
}

void Directory::SetTransactionHeaderFor::DescribeRequest(const ::fidl::DecodedMessage<Directory::DescribeRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_Describe_Ordinal);
}
void Directory::SetTransactionHeaderFor::DescribeResponse(const ::fidl::DecodedMessage<Directory::DescribeResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_Describe_Ordinal);
}

void Directory::SetTransactionHeaderFor::OnOpenResponse(const ::fidl::DecodedMessage<Directory::OnOpenResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_OnOpen_Ordinal);
}

void Directory::SetTransactionHeaderFor::SyncRequest(const ::fidl::DecodedMessage<Directory::SyncRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_Sync_Ordinal);
}
void Directory::SetTransactionHeaderFor::SyncResponse(const ::fidl::DecodedMessage<Directory::SyncResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_Sync_Ordinal);
}

void Directory::SetTransactionHeaderFor::GetAttrRequest(const ::fidl::DecodedMessage<Directory::GetAttrRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_GetAttr_Ordinal);
}
void Directory::SetTransactionHeaderFor::GetAttrResponse(const ::fidl::DecodedMessage<Directory::GetAttrResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_GetAttr_Ordinal);
}

void Directory::SetTransactionHeaderFor::SetAttrRequest(const ::fidl::DecodedMessage<Directory::SetAttrRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_SetAttr_Ordinal);
}
void Directory::SetTransactionHeaderFor::SetAttrResponse(const ::fidl::DecodedMessage<Directory::SetAttrResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_SetAttr_Ordinal);
}

void Directory::SetTransactionHeaderFor::NodeGetFlagsRequest(const ::fidl::DecodedMessage<Directory::NodeGetFlagsRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_NodeGetFlags_Ordinal);
}
void Directory::SetTransactionHeaderFor::NodeGetFlagsResponse(const ::fidl::DecodedMessage<Directory::NodeGetFlagsResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_NodeGetFlags_Ordinal);
}

void Directory::SetTransactionHeaderFor::NodeSetFlagsRequest(const ::fidl::DecodedMessage<Directory::NodeSetFlagsRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_NodeSetFlags_Ordinal);
}
void Directory::SetTransactionHeaderFor::NodeSetFlagsResponse(const ::fidl::DecodedMessage<Directory::NodeSetFlagsResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_NodeSetFlags_Ordinal);
}

void Directory::SetTransactionHeaderFor::OpenRequest(const ::fidl::DecodedMessage<Directory::OpenRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_Open_Ordinal);
}

void Directory::SetTransactionHeaderFor::UnlinkRequest(const ::fidl::DecodedMessage<Directory::UnlinkRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_Unlink_Ordinal);
}
void Directory::SetTransactionHeaderFor::UnlinkResponse(const ::fidl::DecodedMessage<Directory::UnlinkResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_Unlink_Ordinal);
}

void Directory::SetTransactionHeaderFor::ReadDirentsRequest(const ::fidl::DecodedMessage<Directory::ReadDirentsRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_ReadDirents_Ordinal);
}
void Directory::SetTransactionHeaderFor::ReadDirentsResponse(const ::fidl::DecodedMessage<Directory::ReadDirentsResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_ReadDirents_Ordinal);
}

void Directory::SetTransactionHeaderFor::RewindRequest(const ::fidl::DecodedMessage<Directory::RewindRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_Rewind_Ordinal);
}
void Directory::SetTransactionHeaderFor::RewindResponse(const ::fidl::DecodedMessage<Directory::RewindResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_Rewind_Ordinal);
}

void Directory::SetTransactionHeaderFor::GetTokenRequest(const ::fidl::DecodedMessage<Directory::GetTokenRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_GetToken_Ordinal);
}
void Directory::SetTransactionHeaderFor::GetTokenResponse(const ::fidl::DecodedMessage<Directory::GetTokenResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_GetToken_Ordinal);
}

void Directory::SetTransactionHeaderFor::RenameRequest(const ::fidl::DecodedMessage<Directory::RenameRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_Rename_Ordinal);
}
void Directory::SetTransactionHeaderFor::RenameResponse(const ::fidl::DecodedMessage<Directory::RenameResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_Rename_Ordinal);
}

void Directory::SetTransactionHeaderFor::LinkRequest(const ::fidl::DecodedMessage<Directory::LinkRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_Link_Ordinal);
}
void Directory::SetTransactionHeaderFor::LinkResponse(const ::fidl::DecodedMessage<Directory::LinkResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_Link_Ordinal);
}

void Directory::SetTransactionHeaderFor::WatchRequest(const ::fidl::DecodedMessage<Directory::WatchRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_Watch_Ordinal);
}
void Directory::SetTransactionHeaderFor::WatchResponse(const ::fidl::DecodedMessage<Directory::WatchResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_Watch_Ordinal);
}

namespace {

[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Clone_Ordinal = 0x17fe6a4c00000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Clone_GenOrdinal = 0x5a61678f293ce16flu;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminCloneRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminCloneResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryAdminCloneResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Close_Ordinal = 0x52b9568700000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Close_GenOrdinal = 0x5309c5bd1c33dc44lu;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminCloseRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminCloseResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryAdminCloseResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Describe_Ordinal = 0x1f62df5e00000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Describe_GenOrdinal = 0xffcec215078dea0lu;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminDescribeRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminDescribeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryAdminDescribeResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_OnOpen_Ordinal = 0x4700a7bd00000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_OnOpen_GenOrdinal = 0x7fc7bbb1dbfd1972lu;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminOnOpenRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminOnOpenEventTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryAdminOnOpenEventTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Sync_Ordinal = 0x62423faa00000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Sync_GenOrdinal = 0x189d88326c18b519lu;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminSyncRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminSyncResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryAdminSyncResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_GetAttr_Ordinal = 0x4585e7c800000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_GetAttr_GenOrdinal = 0x78985e216314dafdlu;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminGetAttrRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminGetAttrResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryAdminGetAttrResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_SetAttr_Ordinal = 0xbd5559a00000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_SetAttr_GenOrdinal = 0x4186c0f40d938f46lu;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminSetAttrRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminSetAttrResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryAdminSetAttrResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_NodeGetFlags_Ordinal = 0x3c24c22300000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_NodeGetFlags_GenOrdinal = 0x5b88fffb8eda3aa1lu;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminNodeGetFlagsRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminNodeGetFlagsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryAdminNodeGetFlagsResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_NodeSetFlags_Ordinal = 0x46940c1600000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_NodeSetFlags_GenOrdinal = 0x5295b76c71fde733lu;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminNodeSetFlagsRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminNodeSetFlagsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryAdminNodeSetFlagsResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Open_Ordinal = 0x77e4cceb00000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Open_GenOrdinal = 0x2c5044561d685ec0lu;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminOpenRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminOpenResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryAdminOpenResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Unlink_Ordinal = 0x2cbadb1900000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Unlink_GenOrdinal = 0x5a0ff90760a8bc23lu;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminUnlinkRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminUnlinkResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryAdminUnlinkResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_ReadDirents_Ordinal = 0x2ea53c2d00000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_ReadDirents_GenOrdinal = 0x3582806bf27faa0alu;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminReadDirentsRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminReadDirentsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryAdminReadDirentsResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Rewind_Ordinal = 0x7072fd8700000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Rewind_GenOrdinal = 0x16b1202af0f34c71lu;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminRewindRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminRewindResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryAdminRewindResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_GetToken_Ordinal = 0x3217bced00000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_GetToken_GenOrdinal = 0x26ae9d18763c8655lu;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminGetTokenRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminGetTokenResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryAdminGetTokenResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Rename_Ordinal = 0x4a94b0ac00000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Rename_GenOrdinal = 0xa8e00a247f3c905lu;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminRenameRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminRenameResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryAdminRenameResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Link_Ordinal = 0x1b8a5e6400000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Link_GenOrdinal = 0x740604c0c7c930e7lu;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminLinkRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminLinkResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryAdminLinkResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Watch_Ordinal = 0x5ac28f3400000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Watch_GenOrdinal = 0x5717193a59d66d91lu;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminWatchRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminWatchResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryAdminWatchResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Mount_Ordinal = 0x7e5f12e600000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Mount_GenOrdinal = 0xfa166d1522c27d0lu;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminMountRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminMountResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryAdminMountResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_MountAndCreate_Ordinal = 0x3225f69100000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_MountAndCreate_GenOrdinal = 0x7bc782242022b3b3lu;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminMountAndCreateRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminMountAndCreateResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryAdminMountAndCreateResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Unmount_Ordinal = 0x2502275400000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Unmount_GenOrdinal = 0x7da45d654c35c9a4lu;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminUnmountRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminUnmountResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryAdminUnmountResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_UnmountNode_Ordinal = 0x16da38a700000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_UnmountNode_GenOrdinal = 0x26b9d90ebe5f93dblu;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminUnmountNodeRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminUnmountNodeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryAdminUnmountNodeResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_QueryFilesystem_Ordinal = 0x66298d9200000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_QueryFilesystem_GenOrdinal = 0x4a879480f1d7875dlu;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminQueryFilesystemRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminQueryFilesystemResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryAdminQueryFilesystemResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_GetDevicePath_Ordinal = 0x2ef70eb800000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_GetDevicePath_GenOrdinal = 0x76f2e3c7331f815blu;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminGetDevicePathRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminGetDevicePathResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io_DirectoryAdminGetDevicePathResponseTable;

}  // namespace

DirectoryAdmin::ResultOf::Clone_Impl::Clone_Impl(zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloneRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CloneRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CloneRequest*>(_write_bytes);
  _request.flags = std::move(flags);
  _request.object = std::move(object);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloneRequest));
  ::fidl::DecodedMessage<CloneRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      DirectoryAdmin::InPlace::Clone(std::move(_client_end), std::move(_decoded_request)));
}

DirectoryAdmin::ResultOf::Clone DirectoryAdmin::SyncClient::Clone(uint32_t flags, ::zx::channel object) {
  return ResultOf::Clone(zx::unowned_channel(this->channel_), std::move(flags), std::move(object));
}

DirectoryAdmin::ResultOf::Clone DirectoryAdmin::Call::Clone(zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object) {
  return ResultOf::Clone(std::move(_client_end), std::move(flags), std::move(object));
}


DirectoryAdmin::UnownedResultOf::Clone_Impl::Clone_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object) {
  if (_request_buffer.capacity() < CloneRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, CloneRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CloneRequest*>(_request_buffer.data());
  _request.flags = std::move(flags);
  _request.object = std::move(object);
  _request_buffer.set_actual(sizeof(CloneRequest));
  ::fidl::DecodedMessage<CloneRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      DirectoryAdmin::InPlace::Clone(std::move(_client_end), std::move(_decoded_request)));
}

DirectoryAdmin::UnownedResultOf::Clone DirectoryAdmin::SyncClient::Clone(::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object) {
  return UnownedResultOf::Clone(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(flags), std::move(object));
}

DirectoryAdmin::UnownedResultOf::Clone DirectoryAdmin::Call::Clone(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object) {
  return UnownedResultOf::Clone(std::move(_client_end), std::move(_request_buffer), std::move(flags), std::move(object));
}

::fidl::internal::StatusAndError DirectoryAdmin::InPlace::Clone(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CloneRequest> params) {
  DirectoryAdmin::SetTransactionHeaderFor::CloneRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
DirectoryAdmin::ResultOf::Close_Impl<DirectoryAdmin::CloseResponse>::Close_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CloseRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseRequest));
  ::fidl::DecodedMessage<CloseRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      DirectoryAdmin::InPlace::Close(std::move(_client_end), Super::response_buffer()));
}

DirectoryAdmin::ResultOf::Close DirectoryAdmin::SyncClient::Close() {
  return ResultOf::Close(zx::unowned_channel(this->channel_));
}

DirectoryAdmin::ResultOf::Close DirectoryAdmin::Call::Close(zx::unowned_channel _client_end) {
  return ResultOf::Close(std::move(_client_end));
}

template <>
DirectoryAdmin::UnownedResultOf::Close_Impl<DirectoryAdmin::CloseResponse>::Close_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(CloseRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, CloseRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(CloseRequest));
  ::fidl::DecodedMessage<CloseRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      DirectoryAdmin::InPlace::Close(std::move(_client_end), std::move(_response_buffer)));
}

DirectoryAdmin::UnownedResultOf::Close DirectoryAdmin::SyncClient::Close(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Close(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

DirectoryAdmin::UnownedResultOf::Close DirectoryAdmin::Call::Close(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Close(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::CloseResponse> DirectoryAdmin::InPlace::Close(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(CloseRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<CloseRequest> params(std::move(_request_buffer));
  DirectoryAdmin::SetTransactionHeaderFor::CloseRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::CloseResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<CloseRequest, CloseResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::CloseResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
DirectoryAdmin::ResultOf::Describe_Impl<DirectoryAdmin::DescribeResponse>::Describe_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DescribeRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, DescribeRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(DescribeRequest));
  ::fidl::DecodedMessage<DescribeRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      DirectoryAdmin::InPlace::Describe(std::move(_client_end), Super::response_buffer()));
}

DirectoryAdmin::ResultOf::Describe DirectoryAdmin::SyncClient::Describe() {
  return ResultOf::Describe(zx::unowned_channel(this->channel_));
}

DirectoryAdmin::ResultOf::Describe DirectoryAdmin::Call::Describe(zx::unowned_channel _client_end) {
  return ResultOf::Describe(std::move(_client_end));
}

template <>
DirectoryAdmin::UnownedResultOf::Describe_Impl<DirectoryAdmin::DescribeResponse>::Describe_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(DescribeRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, DescribeRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(DescribeRequest));
  ::fidl::DecodedMessage<DescribeRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      DirectoryAdmin::InPlace::Describe(std::move(_client_end), std::move(_response_buffer)));
}

DirectoryAdmin::UnownedResultOf::Describe DirectoryAdmin::SyncClient::Describe(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Describe(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

DirectoryAdmin::UnownedResultOf::Describe DirectoryAdmin::Call::Describe(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Describe(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::DescribeResponse> DirectoryAdmin::InPlace::Describe(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(DescribeRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<DescribeRequest> params(std::move(_request_buffer));
  DirectoryAdmin::SetTransactionHeaderFor::DescribeRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::DescribeResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<DescribeRequest, DescribeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::DescribeResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
DirectoryAdmin::ResultOf::Sync_Impl<DirectoryAdmin::SyncResponse>::Sync_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SyncRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      DirectoryAdmin::InPlace::Sync(std::move(_client_end), Super::response_buffer()));
}

DirectoryAdmin::ResultOf::Sync DirectoryAdmin::SyncClient::Sync() {
  return ResultOf::Sync(zx::unowned_channel(this->channel_));
}

DirectoryAdmin::ResultOf::Sync DirectoryAdmin::Call::Sync(zx::unowned_channel _client_end) {
  return ResultOf::Sync(std::move(_client_end));
}

template <>
DirectoryAdmin::UnownedResultOf::Sync_Impl<DirectoryAdmin::SyncResponse>::Sync_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(SyncRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, SyncRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      DirectoryAdmin::InPlace::Sync(std::move(_client_end), std::move(_response_buffer)));
}

DirectoryAdmin::UnownedResultOf::Sync DirectoryAdmin::SyncClient::Sync(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Sync(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

DirectoryAdmin::UnownedResultOf::Sync DirectoryAdmin::Call::Sync(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Sync(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::SyncResponse> DirectoryAdmin::InPlace::Sync(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(SyncRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<SyncRequest> params(std::move(_request_buffer));
  DirectoryAdmin::SetTransactionHeaderFor::SyncRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::SyncResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SyncRequest, SyncResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::SyncResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
DirectoryAdmin::ResultOf::GetAttr_Impl<DirectoryAdmin::GetAttrResponse>::GetAttr_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetAttrRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetAttrRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetAttrRequest));
  ::fidl::DecodedMessage<GetAttrRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      DirectoryAdmin::InPlace::GetAttr(std::move(_client_end), Super::response_buffer()));
}

DirectoryAdmin::ResultOf::GetAttr DirectoryAdmin::SyncClient::GetAttr() {
  return ResultOf::GetAttr(zx::unowned_channel(this->channel_));
}

DirectoryAdmin::ResultOf::GetAttr DirectoryAdmin::Call::GetAttr(zx::unowned_channel _client_end) {
  return ResultOf::GetAttr(std::move(_client_end));
}

template <>
DirectoryAdmin::UnownedResultOf::GetAttr_Impl<DirectoryAdmin::GetAttrResponse>::GetAttr_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetAttrRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetAttrRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetAttrRequest));
  ::fidl::DecodedMessage<GetAttrRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      DirectoryAdmin::InPlace::GetAttr(std::move(_client_end), std::move(_response_buffer)));
}

DirectoryAdmin::UnownedResultOf::GetAttr DirectoryAdmin::SyncClient::GetAttr(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetAttr(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

DirectoryAdmin::UnownedResultOf::GetAttr DirectoryAdmin::Call::GetAttr(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetAttr(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::GetAttrResponse> DirectoryAdmin::InPlace::GetAttr(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetAttrRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetAttrRequest> params(std::move(_request_buffer));
  DirectoryAdmin::SetTransactionHeaderFor::GetAttrRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::GetAttrResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetAttrRequest, GetAttrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::GetAttrResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
DirectoryAdmin::ResultOf::SetAttr_Impl<DirectoryAdmin::SetAttrResponse>::SetAttr_Impl(zx::unowned_channel _client_end, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetAttrRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetAttrRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetAttrRequest*>(_write_bytes);
  _request.flags = std::move(flags);
  _request.attributes = std::move(attributes);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetAttrRequest));
  ::fidl::DecodedMessage<SetAttrRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      DirectoryAdmin::InPlace::SetAttr(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

DirectoryAdmin::ResultOf::SetAttr DirectoryAdmin::SyncClient::SetAttr(uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes) {
  return ResultOf::SetAttr(zx::unowned_channel(this->channel_), std::move(flags), std::move(attributes));
}

DirectoryAdmin::ResultOf::SetAttr DirectoryAdmin::Call::SetAttr(zx::unowned_channel _client_end, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes) {
  return ResultOf::SetAttr(std::move(_client_end), std::move(flags), std::move(attributes));
}

template <>
DirectoryAdmin::UnownedResultOf::SetAttr_Impl<DirectoryAdmin::SetAttrResponse>::SetAttr_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < SetAttrRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<SetAttrResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, SetAttrRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetAttrRequest*>(_request_buffer.data());
  _request.flags = std::move(flags);
  _request.attributes = std::move(attributes);
  _request_buffer.set_actual(sizeof(SetAttrRequest));
  ::fidl::DecodedMessage<SetAttrRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      DirectoryAdmin::InPlace::SetAttr(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

DirectoryAdmin::UnownedResultOf::SetAttr DirectoryAdmin::SyncClient::SetAttr(::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetAttr(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(flags), std::move(attributes), std::move(_response_buffer));
}

DirectoryAdmin::UnownedResultOf::SetAttr DirectoryAdmin::Call::SetAttr(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetAttr(std::move(_client_end), std::move(_request_buffer), std::move(flags), std::move(attributes), std::move(_response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::SetAttrResponse> DirectoryAdmin::InPlace::SetAttr(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetAttrRequest> params, ::fidl::BytePart response_buffer) {
  DirectoryAdmin::SetTransactionHeaderFor::SetAttrRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::SetAttrResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SetAttrRequest, SetAttrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::SetAttrResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
DirectoryAdmin::ResultOf::NodeGetFlags_Impl<DirectoryAdmin::NodeGetFlagsResponse>::NodeGetFlags_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<NodeGetFlagsRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, NodeGetFlagsRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(NodeGetFlagsRequest));
  ::fidl::DecodedMessage<NodeGetFlagsRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      DirectoryAdmin::InPlace::NodeGetFlags(std::move(_client_end), Super::response_buffer()));
}

DirectoryAdmin::ResultOf::NodeGetFlags DirectoryAdmin::SyncClient::NodeGetFlags() {
  return ResultOf::NodeGetFlags(zx::unowned_channel(this->channel_));
}

DirectoryAdmin::ResultOf::NodeGetFlags DirectoryAdmin::Call::NodeGetFlags(zx::unowned_channel _client_end) {
  return ResultOf::NodeGetFlags(std::move(_client_end));
}

template <>
DirectoryAdmin::UnownedResultOf::NodeGetFlags_Impl<DirectoryAdmin::NodeGetFlagsResponse>::NodeGetFlags_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(NodeGetFlagsRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, NodeGetFlagsRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(NodeGetFlagsRequest));
  ::fidl::DecodedMessage<NodeGetFlagsRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      DirectoryAdmin::InPlace::NodeGetFlags(std::move(_client_end), std::move(_response_buffer)));
}

DirectoryAdmin::UnownedResultOf::NodeGetFlags DirectoryAdmin::SyncClient::NodeGetFlags(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::NodeGetFlags(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

DirectoryAdmin::UnownedResultOf::NodeGetFlags DirectoryAdmin::Call::NodeGetFlags(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::NodeGetFlags(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::NodeGetFlagsResponse> DirectoryAdmin::InPlace::NodeGetFlags(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(NodeGetFlagsRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<NodeGetFlagsRequest> params(std::move(_request_buffer));
  DirectoryAdmin::SetTransactionHeaderFor::NodeGetFlagsRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::NodeGetFlagsResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<NodeGetFlagsRequest, NodeGetFlagsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::NodeGetFlagsResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
DirectoryAdmin::ResultOf::NodeSetFlags_Impl<DirectoryAdmin::NodeSetFlagsResponse>::NodeSetFlags_Impl(zx::unowned_channel _client_end, uint32_t flags) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<NodeSetFlagsRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, NodeSetFlagsRequest::PrimarySize);
  auto& _request = *reinterpret_cast<NodeSetFlagsRequest*>(_write_bytes);
  _request.flags = std::move(flags);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(NodeSetFlagsRequest));
  ::fidl::DecodedMessage<NodeSetFlagsRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      DirectoryAdmin::InPlace::NodeSetFlags(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

DirectoryAdmin::ResultOf::NodeSetFlags DirectoryAdmin::SyncClient::NodeSetFlags(uint32_t flags) {
  return ResultOf::NodeSetFlags(zx::unowned_channel(this->channel_), std::move(flags));
}

DirectoryAdmin::ResultOf::NodeSetFlags DirectoryAdmin::Call::NodeSetFlags(zx::unowned_channel _client_end, uint32_t flags) {
  return ResultOf::NodeSetFlags(std::move(_client_end), std::move(flags));
}

template <>
DirectoryAdmin::UnownedResultOf::NodeSetFlags_Impl<DirectoryAdmin::NodeSetFlagsResponse>::NodeSetFlags_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < NodeSetFlagsRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<NodeSetFlagsResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, NodeSetFlagsRequest::PrimarySize);
  auto& _request = *reinterpret_cast<NodeSetFlagsRequest*>(_request_buffer.data());
  _request.flags = std::move(flags);
  _request_buffer.set_actual(sizeof(NodeSetFlagsRequest));
  ::fidl::DecodedMessage<NodeSetFlagsRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      DirectoryAdmin::InPlace::NodeSetFlags(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

DirectoryAdmin::UnownedResultOf::NodeSetFlags DirectoryAdmin::SyncClient::NodeSetFlags(::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::NodeSetFlags(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(flags), std::move(_response_buffer));
}

DirectoryAdmin::UnownedResultOf::NodeSetFlags DirectoryAdmin::Call::NodeSetFlags(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::NodeSetFlags(std::move(_client_end), std::move(_request_buffer), std::move(flags), std::move(_response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::NodeSetFlagsResponse> DirectoryAdmin::InPlace::NodeSetFlags(zx::unowned_channel _client_end, ::fidl::DecodedMessage<NodeSetFlagsRequest> params, ::fidl::BytePart response_buffer) {
  DirectoryAdmin::SetTransactionHeaderFor::NodeSetFlagsRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::NodeSetFlagsResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<NodeSetFlagsRequest, NodeSetFlagsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::NodeSetFlagsResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


DirectoryAdmin::ResultOf::Open_Impl::Open_Impl(zx::unowned_channel _client_end, uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OpenRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  OpenRequest _request = {};
  _request.flags = std::move(flags);
  _request.mode = std::move(mode);
  _request.path = std::move(path);
  _request.object = std::move(object);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<OpenRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      DirectoryAdmin::InPlace::Open(std::move(_client_end), std::move(_decoded_request)));
}

DirectoryAdmin::ResultOf::Open DirectoryAdmin::SyncClient::Open(uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object) {
  return ResultOf::Open(zx::unowned_channel(this->channel_), std::move(flags), std::move(mode), std::move(path), std::move(object));
}

DirectoryAdmin::ResultOf::Open DirectoryAdmin::Call::Open(zx::unowned_channel _client_end, uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object) {
  return ResultOf::Open(std::move(_client_end), std::move(flags), std::move(mode), std::move(path), std::move(object));
}


DirectoryAdmin::UnownedResultOf::Open_Impl::Open_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object) {
  if (_request_buffer.capacity() < OpenRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  OpenRequest _request = {};
  _request.flags = std::move(flags);
  _request.mode = std::move(mode);
  _request.path = std::move(path);
  _request.object = std::move(object);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<OpenRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      DirectoryAdmin::InPlace::Open(std::move(_client_end), std::move(_decoded_request)));
}

DirectoryAdmin::UnownedResultOf::Open DirectoryAdmin::SyncClient::Open(::fidl::BytePart _request_buffer, uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object) {
  return UnownedResultOf::Open(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(flags), std::move(mode), std::move(path), std::move(object));
}

DirectoryAdmin::UnownedResultOf::Open DirectoryAdmin::Call::Open(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object) {
  return UnownedResultOf::Open(std::move(_client_end), std::move(_request_buffer), std::move(flags), std::move(mode), std::move(path), std::move(object));
}

::fidl::internal::StatusAndError DirectoryAdmin::InPlace::Open(zx::unowned_channel _client_end, ::fidl::DecodedMessage<OpenRequest> params) {
  DirectoryAdmin::SetTransactionHeaderFor::OpenRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
DirectoryAdmin::ResultOf::Unlink_Impl<DirectoryAdmin::UnlinkResponse>::Unlink_Impl(zx::unowned_channel _client_end, ::fidl::StringView path) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UnlinkRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  UnlinkRequest _request = {};
  _request.path = std::move(path);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<UnlinkRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      DirectoryAdmin::InPlace::Unlink(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

DirectoryAdmin::ResultOf::Unlink DirectoryAdmin::SyncClient::Unlink(::fidl::StringView path) {
  return ResultOf::Unlink(zx::unowned_channel(this->channel_), std::move(path));
}

DirectoryAdmin::ResultOf::Unlink DirectoryAdmin::Call::Unlink(zx::unowned_channel _client_end, ::fidl::StringView path) {
  return ResultOf::Unlink(std::move(_client_end), std::move(path));
}

template <>
DirectoryAdmin::UnownedResultOf::Unlink_Impl<DirectoryAdmin::UnlinkResponse>::Unlink_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView path, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < UnlinkRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<UnlinkResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  UnlinkRequest _request = {};
  _request.path = std::move(path);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<UnlinkRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      DirectoryAdmin::InPlace::Unlink(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

DirectoryAdmin::UnownedResultOf::Unlink DirectoryAdmin::SyncClient::Unlink(::fidl::BytePart _request_buffer, ::fidl::StringView path, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Unlink(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(path), std::move(_response_buffer));
}

DirectoryAdmin::UnownedResultOf::Unlink DirectoryAdmin::Call::Unlink(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView path, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Unlink(std::move(_client_end), std::move(_request_buffer), std::move(path), std::move(_response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::UnlinkResponse> DirectoryAdmin::InPlace::Unlink(zx::unowned_channel _client_end, ::fidl::DecodedMessage<UnlinkRequest> params, ::fidl::BytePart response_buffer) {
  DirectoryAdmin::SetTransactionHeaderFor::UnlinkRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::UnlinkResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<UnlinkRequest, UnlinkResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::UnlinkResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
DirectoryAdmin::ResultOf::ReadDirents_Impl<DirectoryAdmin::ReadDirentsResponse>::ReadDirents_Impl(zx::unowned_channel _client_end, uint64_t max_bytes) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReadDirentsRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ReadDirentsRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReadDirentsRequest*>(_write_bytes);
  _request.max_bytes = std::move(max_bytes);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ReadDirentsRequest));
  ::fidl::DecodedMessage<ReadDirentsRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      DirectoryAdmin::InPlace::ReadDirents(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

DirectoryAdmin::ResultOf::ReadDirents DirectoryAdmin::SyncClient::ReadDirents(uint64_t max_bytes) {
  return ResultOf::ReadDirents(zx::unowned_channel(this->channel_), std::move(max_bytes));
}

DirectoryAdmin::ResultOf::ReadDirents DirectoryAdmin::Call::ReadDirents(zx::unowned_channel _client_end, uint64_t max_bytes) {
  return ResultOf::ReadDirents(std::move(_client_end), std::move(max_bytes));
}

template <>
DirectoryAdmin::UnownedResultOf::ReadDirents_Impl<DirectoryAdmin::ReadDirentsResponse>::ReadDirents_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t max_bytes, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < ReadDirentsRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<ReadDirentsResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, ReadDirentsRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReadDirentsRequest*>(_request_buffer.data());
  _request.max_bytes = std::move(max_bytes);
  _request_buffer.set_actual(sizeof(ReadDirentsRequest));
  ::fidl::DecodedMessage<ReadDirentsRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      DirectoryAdmin::InPlace::ReadDirents(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

DirectoryAdmin::UnownedResultOf::ReadDirents DirectoryAdmin::SyncClient::ReadDirents(::fidl::BytePart _request_buffer, uint64_t max_bytes, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ReadDirents(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(max_bytes), std::move(_response_buffer));
}

DirectoryAdmin::UnownedResultOf::ReadDirents DirectoryAdmin::Call::ReadDirents(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t max_bytes, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ReadDirents(std::move(_client_end), std::move(_request_buffer), std::move(max_bytes), std::move(_response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::ReadDirentsResponse> DirectoryAdmin::InPlace::ReadDirents(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReadDirentsRequest> params, ::fidl::BytePart response_buffer) {
  DirectoryAdmin::SetTransactionHeaderFor::ReadDirentsRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::ReadDirentsResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ReadDirentsRequest, ReadDirentsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::ReadDirentsResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
DirectoryAdmin::ResultOf::Rewind_Impl<DirectoryAdmin::RewindResponse>::Rewind_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RewindRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, RewindRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(RewindRequest));
  ::fidl::DecodedMessage<RewindRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      DirectoryAdmin::InPlace::Rewind(std::move(_client_end), Super::response_buffer()));
}

DirectoryAdmin::ResultOf::Rewind DirectoryAdmin::SyncClient::Rewind() {
  return ResultOf::Rewind(zx::unowned_channel(this->channel_));
}

DirectoryAdmin::ResultOf::Rewind DirectoryAdmin::Call::Rewind(zx::unowned_channel _client_end) {
  return ResultOf::Rewind(std::move(_client_end));
}

template <>
DirectoryAdmin::UnownedResultOf::Rewind_Impl<DirectoryAdmin::RewindResponse>::Rewind_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(RewindRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, RewindRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(RewindRequest));
  ::fidl::DecodedMessage<RewindRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      DirectoryAdmin::InPlace::Rewind(std::move(_client_end), std::move(_response_buffer)));
}

DirectoryAdmin::UnownedResultOf::Rewind DirectoryAdmin::SyncClient::Rewind(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Rewind(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

DirectoryAdmin::UnownedResultOf::Rewind DirectoryAdmin::Call::Rewind(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Rewind(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::RewindResponse> DirectoryAdmin::InPlace::Rewind(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(RewindRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<RewindRequest> params(std::move(_request_buffer));
  DirectoryAdmin::SetTransactionHeaderFor::RewindRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::RewindResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<RewindRequest, RewindResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::RewindResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
DirectoryAdmin::ResultOf::GetToken_Impl<DirectoryAdmin::GetTokenResponse>::GetToken_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetTokenRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetTokenRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetTokenRequest));
  ::fidl::DecodedMessage<GetTokenRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      DirectoryAdmin::InPlace::GetToken(std::move(_client_end), Super::response_buffer()));
}

DirectoryAdmin::ResultOf::GetToken DirectoryAdmin::SyncClient::GetToken() {
  return ResultOf::GetToken(zx::unowned_channel(this->channel_));
}

DirectoryAdmin::ResultOf::GetToken DirectoryAdmin::Call::GetToken(zx::unowned_channel _client_end) {
  return ResultOf::GetToken(std::move(_client_end));
}

template <>
DirectoryAdmin::UnownedResultOf::GetToken_Impl<DirectoryAdmin::GetTokenResponse>::GetToken_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetTokenRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetTokenRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetTokenRequest));
  ::fidl::DecodedMessage<GetTokenRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      DirectoryAdmin::InPlace::GetToken(std::move(_client_end), std::move(_response_buffer)));
}

DirectoryAdmin::UnownedResultOf::GetToken DirectoryAdmin::SyncClient::GetToken(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetToken(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

DirectoryAdmin::UnownedResultOf::GetToken DirectoryAdmin::Call::GetToken(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetToken(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::GetTokenResponse> DirectoryAdmin::InPlace::GetToken(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetTokenRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetTokenRequest> params(std::move(_request_buffer));
  DirectoryAdmin::SetTransactionHeaderFor::GetTokenRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::GetTokenResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetTokenRequest, GetTokenResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::GetTokenResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
DirectoryAdmin::ResultOf::Rename_Impl<DirectoryAdmin::RenameResponse>::Rename_Impl(zx::unowned_channel _client_end, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RenameRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  RenameRequest _request = {};
  _request.src = std::move(src);
  _request.dst_parent_token = std::move(dst_parent_token);
  _request.dst = std::move(dst);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<RenameRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      DirectoryAdmin::InPlace::Rename(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

DirectoryAdmin::ResultOf::Rename DirectoryAdmin::SyncClient::Rename(::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst) {
  return ResultOf::Rename(zx::unowned_channel(this->channel_), std::move(src), std::move(dst_parent_token), std::move(dst));
}

DirectoryAdmin::ResultOf::Rename DirectoryAdmin::Call::Rename(zx::unowned_channel _client_end, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst) {
  return ResultOf::Rename(std::move(_client_end), std::move(src), std::move(dst_parent_token), std::move(dst));
}

template <>
DirectoryAdmin::UnownedResultOf::Rename_Impl<DirectoryAdmin::RenameResponse>::Rename_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < RenameRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<RenameResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  RenameRequest _request = {};
  _request.src = std::move(src);
  _request.dst_parent_token = std::move(dst_parent_token);
  _request.dst = std::move(dst);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<RenameRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      DirectoryAdmin::InPlace::Rename(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

DirectoryAdmin::UnownedResultOf::Rename DirectoryAdmin::SyncClient::Rename(::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Rename(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(src), std::move(dst_parent_token), std::move(dst), std::move(_response_buffer));
}

DirectoryAdmin::UnownedResultOf::Rename DirectoryAdmin::Call::Rename(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Rename(std::move(_client_end), std::move(_request_buffer), std::move(src), std::move(dst_parent_token), std::move(dst), std::move(_response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::RenameResponse> DirectoryAdmin::InPlace::Rename(zx::unowned_channel _client_end, ::fidl::DecodedMessage<RenameRequest> params, ::fidl::BytePart response_buffer) {
  DirectoryAdmin::SetTransactionHeaderFor::RenameRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::RenameResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<RenameRequest, RenameResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::RenameResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
DirectoryAdmin::ResultOf::Link_Impl<DirectoryAdmin::LinkResponse>::Link_Impl(zx::unowned_channel _client_end, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LinkRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  LinkRequest _request = {};
  _request.src = std::move(src);
  _request.dst_parent_token = std::move(dst_parent_token);
  _request.dst = std::move(dst);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LinkRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      DirectoryAdmin::InPlace::Link(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

DirectoryAdmin::ResultOf::Link DirectoryAdmin::SyncClient::Link(::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst) {
  return ResultOf::Link(zx::unowned_channel(this->channel_), std::move(src), std::move(dst_parent_token), std::move(dst));
}

DirectoryAdmin::ResultOf::Link DirectoryAdmin::Call::Link(zx::unowned_channel _client_end, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst) {
  return ResultOf::Link(std::move(_client_end), std::move(src), std::move(dst_parent_token), std::move(dst));
}

template <>
DirectoryAdmin::UnownedResultOf::Link_Impl<DirectoryAdmin::LinkResponse>::Link_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < LinkRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<LinkResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  LinkRequest _request = {};
  _request.src = std::move(src);
  _request.dst_parent_token = std::move(dst_parent_token);
  _request.dst = std::move(dst);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LinkRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      DirectoryAdmin::InPlace::Link(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

DirectoryAdmin::UnownedResultOf::Link DirectoryAdmin::SyncClient::Link(::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Link(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(src), std::move(dst_parent_token), std::move(dst), std::move(_response_buffer));
}

DirectoryAdmin::UnownedResultOf::Link DirectoryAdmin::Call::Link(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Link(std::move(_client_end), std::move(_request_buffer), std::move(src), std::move(dst_parent_token), std::move(dst), std::move(_response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::LinkResponse> DirectoryAdmin::InPlace::Link(zx::unowned_channel _client_end, ::fidl::DecodedMessage<LinkRequest> params, ::fidl::BytePart response_buffer) {
  DirectoryAdmin::SetTransactionHeaderFor::LinkRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::LinkResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<LinkRequest, LinkResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::LinkResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
DirectoryAdmin::ResultOf::Watch_Impl<DirectoryAdmin::WatchResponse>::Watch_Impl(zx::unowned_channel _client_end, uint32_t mask, uint32_t options, ::zx::channel watcher) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WatchRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, WatchRequest::PrimarySize);
  auto& _request = *reinterpret_cast<WatchRequest*>(_write_bytes);
  _request.mask = std::move(mask);
  _request.options = std::move(options);
  _request.watcher = std::move(watcher);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(WatchRequest));
  ::fidl::DecodedMessage<WatchRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      DirectoryAdmin::InPlace::Watch(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

DirectoryAdmin::ResultOf::Watch DirectoryAdmin::SyncClient::Watch(uint32_t mask, uint32_t options, ::zx::channel watcher) {
  return ResultOf::Watch(zx::unowned_channel(this->channel_), std::move(mask), std::move(options), std::move(watcher));
}

DirectoryAdmin::ResultOf::Watch DirectoryAdmin::Call::Watch(zx::unowned_channel _client_end, uint32_t mask, uint32_t options, ::zx::channel watcher) {
  return ResultOf::Watch(std::move(_client_end), std::move(mask), std::move(options), std::move(watcher));
}

template <>
DirectoryAdmin::UnownedResultOf::Watch_Impl<DirectoryAdmin::WatchResponse>::Watch_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t mask, uint32_t options, ::zx::channel watcher, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < WatchRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<WatchResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, WatchRequest::PrimarySize);
  auto& _request = *reinterpret_cast<WatchRequest*>(_request_buffer.data());
  _request.mask = std::move(mask);
  _request.options = std::move(options);
  _request.watcher = std::move(watcher);
  _request_buffer.set_actual(sizeof(WatchRequest));
  ::fidl::DecodedMessage<WatchRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      DirectoryAdmin::InPlace::Watch(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

DirectoryAdmin::UnownedResultOf::Watch DirectoryAdmin::SyncClient::Watch(::fidl::BytePart _request_buffer, uint32_t mask, uint32_t options, ::zx::channel watcher, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Watch(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(mask), std::move(options), std::move(watcher), std::move(_response_buffer));
}

DirectoryAdmin::UnownedResultOf::Watch DirectoryAdmin::Call::Watch(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t mask, uint32_t options, ::zx::channel watcher, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Watch(std::move(_client_end), std::move(_request_buffer), std::move(mask), std::move(options), std::move(watcher), std::move(_response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::WatchResponse> DirectoryAdmin::InPlace::Watch(zx::unowned_channel _client_end, ::fidl::DecodedMessage<WatchRequest> params, ::fidl::BytePart response_buffer) {
  DirectoryAdmin::SetTransactionHeaderFor::WatchRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::WatchResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<WatchRequest, WatchResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::WatchResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
DirectoryAdmin::ResultOf::Mount_Impl<DirectoryAdmin::MountResponse>::Mount_Impl(zx::unowned_channel _client_end, ::zx::channel remote) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MountRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, MountRequest::PrimarySize);
  auto& _request = *reinterpret_cast<MountRequest*>(_write_bytes);
  _request.remote = std::move(remote);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(MountRequest));
  ::fidl::DecodedMessage<MountRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      DirectoryAdmin::InPlace::Mount(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

DirectoryAdmin::ResultOf::Mount DirectoryAdmin::SyncClient::Mount(::zx::channel remote) {
  return ResultOf::Mount(zx::unowned_channel(this->channel_), std::move(remote));
}

DirectoryAdmin::ResultOf::Mount DirectoryAdmin::Call::Mount(zx::unowned_channel _client_end, ::zx::channel remote) {
  return ResultOf::Mount(std::move(_client_end), std::move(remote));
}

template <>
DirectoryAdmin::UnownedResultOf::Mount_Impl<DirectoryAdmin::MountResponse>::Mount_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel remote, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < MountRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<MountResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, MountRequest::PrimarySize);
  auto& _request = *reinterpret_cast<MountRequest*>(_request_buffer.data());
  _request.remote = std::move(remote);
  _request_buffer.set_actual(sizeof(MountRequest));
  ::fidl::DecodedMessage<MountRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      DirectoryAdmin::InPlace::Mount(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

DirectoryAdmin::UnownedResultOf::Mount DirectoryAdmin::SyncClient::Mount(::fidl::BytePart _request_buffer, ::zx::channel remote, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Mount(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(remote), std::move(_response_buffer));
}

DirectoryAdmin::UnownedResultOf::Mount DirectoryAdmin::Call::Mount(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel remote, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Mount(std::move(_client_end), std::move(_request_buffer), std::move(remote), std::move(_response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::MountResponse> DirectoryAdmin::InPlace::Mount(zx::unowned_channel _client_end, ::fidl::DecodedMessage<MountRequest> params, ::fidl::BytePart response_buffer) {
  DirectoryAdmin::SetTransactionHeaderFor::MountRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::MountResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<MountRequest, MountResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::MountResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
DirectoryAdmin::ResultOf::MountAndCreate_Impl<DirectoryAdmin::MountAndCreateResponse>::MountAndCreate_Impl(zx::unowned_channel _client_end, ::zx::channel remote, ::fidl::StringView name, uint32_t flags) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MountAndCreateRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  MountAndCreateRequest _request = {};
  _request.remote = std::move(remote);
  _request.name = std::move(name);
  _request.flags = std::move(flags);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<MountAndCreateRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      DirectoryAdmin::InPlace::MountAndCreate(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

DirectoryAdmin::ResultOf::MountAndCreate DirectoryAdmin::SyncClient::MountAndCreate(::zx::channel remote, ::fidl::StringView name, uint32_t flags) {
  return ResultOf::MountAndCreate(zx::unowned_channel(this->channel_), std::move(remote), std::move(name), std::move(flags));
}

DirectoryAdmin::ResultOf::MountAndCreate DirectoryAdmin::Call::MountAndCreate(zx::unowned_channel _client_end, ::zx::channel remote, ::fidl::StringView name, uint32_t flags) {
  return ResultOf::MountAndCreate(std::move(_client_end), std::move(remote), std::move(name), std::move(flags));
}

template <>
DirectoryAdmin::UnownedResultOf::MountAndCreate_Impl<DirectoryAdmin::MountAndCreateResponse>::MountAndCreate_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel remote, ::fidl::StringView name, uint32_t flags, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < MountAndCreateRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<MountAndCreateResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  MountAndCreateRequest _request = {};
  _request.remote = std::move(remote);
  _request.name = std::move(name);
  _request.flags = std::move(flags);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<MountAndCreateRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      DirectoryAdmin::InPlace::MountAndCreate(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

DirectoryAdmin::UnownedResultOf::MountAndCreate DirectoryAdmin::SyncClient::MountAndCreate(::fidl::BytePart _request_buffer, ::zx::channel remote, ::fidl::StringView name, uint32_t flags, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::MountAndCreate(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(remote), std::move(name), std::move(flags), std::move(_response_buffer));
}

DirectoryAdmin::UnownedResultOf::MountAndCreate DirectoryAdmin::Call::MountAndCreate(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel remote, ::fidl::StringView name, uint32_t flags, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::MountAndCreate(std::move(_client_end), std::move(_request_buffer), std::move(remote), std::move(name), std::move(flags), std::move(_response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::MountAndCreateResponse> DirectoryAdmin::InPlace::MountAndCreate(zx::unowned_channel _client_end, ::fidl::DecodedMessage<MountAndCreateRequest> params, ::fidl::BytePart response_buffer) {
  DirectoryAdmin::SetTransactionHeaderFor::MountAndCreateRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::MountAndCreateResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<MountAndCreateRequest, MountAndCreateResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::MountAndCreateResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
DirectoryAdmin::ResultOf::Unmount_Impl<DirectoryAdmin::UnmountResponse>::Unmount_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UnmountRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, UnmountRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(UnmountRequest));
  ::fidl::DecodedMessage<UnmountRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      DirectoryAdmin::InPlace::Unmount(std::move(_client_end), Super::response_buffer()));
}

DirectoryAdmin::ResultOf::Unmount DirectoryAdmin::SyncClient::Unmount() {
  return ResultOf::Unmount(zx::unowned_channel(this->channel_));
}

DirectoryAdmin::ResultOf::Unmount DirectoryAdmin::Call::Unmount(zx::unowned_channel _client_end) {
  return ResultOf::Unmount(std::move(_client_end));
}

template <>
DirectoryAdmin::UnownedResultOf::Unmount_Impl<DirectoryAdmin::UnmountResponse>::Unmount_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(UnmountRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, UnmountRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(UnmountRequest));
  ::fidl::DecodedMessage<UnmountRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      DirectoryAdmin::InPlace::Unmount(std::move(_client_end), std::move(_response_buffer)));
}

DirectoryAdmin::UnownedResultOf::Unmount DirectoryAdmin::SyncClient::Unmount(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Unmount(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

DirectoryAdmin::UnownedResultOf::Unmount DirectoryAdmin::Call::Unmount(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Unmount(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::UnmountResponse> DirectoryAdmin::InPlace::Unmount(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(UnmountRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<UnmountRequest> params(std::move(_request_buffer));
  DirectoryAdmin::SetTransactionHeaderFor::UnmountRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::UnmountResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<UnmountRequest, UnmountResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::UnmountResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
DirectoryAdmin::ResultOf::UnmountNode_Impl<DirectoryAdmin::UnmountNodeResponse>::UnmountNode_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UnmountNodeRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, UnmountNodeRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(UnmountNodeRequest));
  ::fidl::DecodedMessage<UnmountNodeRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      DirectoryAdmin::InPlace::UnmountNode(std::move(_client_end), Super::response_buffer()));
}

DirectoryAdmin::ResultOf::UnmountNode DirectoryAdmin::SyncClient::UnmountNode() {
  return ResultOf::UnmountNode(zx::unowned_channel(this->channel_));
}

DirectoryAdmin::ResultOf::UnmountNode DirectoryAdmin::Call::UnmountNode(zx::unowned_channel _client_end) {
  return ResultOf::UnmountNode(std::move(_client_end));
}

template <>
DirectoryAdmin::UnownedResultOf::UnmountNode_Impl<DirectoryAdmin::UnmountNodeResponse>::UnmountNode_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(UnmountNodeRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, UnmountNodeRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(UnmountNodeRequest));
  ::fidl::DecodedMessage<UnmountNodeRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      DirectoryAdmin::InPlace::UnmountNode(std::move(_client_end), std::move(_response_buffer)));
}

DirectoryAdmin::UnownedResultOf::UnmountNode DirectoryAdmin::SyncClient::UnmountNode(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::UnmountNode(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

DirectoryAdmin::UnownedResultOf::UnmountNode DirectoryAdmin::Call::UnmountNode(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::UnmountNode(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::UnmountNodeResponse> DirectoryAdmin::InPlace::UnmountNode(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(UnmountNodeRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<UnmountNodeRequest> params(std::move(_request_buffer));
  DirectoryAdmin::SetTransactionHeaderFor::UnmountNodeRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::UnmountNodeResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<UnmountNodeRequest, UnmountNodeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::UnmountNodeResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
DirectoryAdmin::ResultOf::QueryFilesystem_Impl<DirectoryAdmin::QueryFilesystemResponse>::QueryFilesystem_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<QueryFilesystemRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, QueryFilesystemRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(QueryFilesystemRequest));
  ::fidl::DecodedMessage<QueryFilesystemRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      DirectoryAdmin::InPlace::QueryFilesystem(std::move(_client_end), Super::response_buffer()));
}

DirectoryAdmin::ResultOf::QueryFilesystem DirectoryAdmin::SyncClient::QueryFilesystem() {
  return ResultOf::QueryFilesystem(zx::unowned_channel(this->channel_));
}

DirectoryAdmin::ResultOf::QueryFilesystem DirectoryAdmin::Call::QueryFilesystem(zx::unowned_channel _client_end) {
  return ResultOf::QueryFilesystem(std::move(_client_end));
}

template <>
DirectoryAdmin::UnownedResultOf::QueryFilesystem_Impl<DirectoryAdmin::QueryFilesystemResponse>::QueryFilesystem_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(QueryFilesystemRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, QueryFilesystemRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(QueryFilesystemRequest));
  ::fidl::DecodedMessage<QueryFilesystemRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      DirectoryAdmin::InPlace::QueryFilesystem(std::move(_client_end), std::move(_response_buffer)));
}

DirectoryAdmin::UnownedResultOf::QueryFilesystem DirectoryAdmin::SyncClient::QueryFilesystem(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::QueryFilesystem(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

DirectoryAdmin::UnownedResultOf::QueryFilesystem DirectoryAdmin::Call::QueryFilesystem(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::QueryFilesystem(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::QueryFilesystemResponse> DirectoryAdmin::InPlace::QueryFilesystem(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(QueryFilesystemRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<QueryFilesystemRequest> params(std::move(_request_buffer));
  DirectoryAdmin::SetTransactionHeaderFor::QueryFilesystemRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::QueryFilesystemResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<QueryFilesystemRequest, QueryFilesystemResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::QueryFilesystemResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
DirectoryAdmin::ResultOf::GetDevicePath_Impl<DirectoryAdmin::GetDevicePathResponse>::GetDevicePath_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetDevicePathRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetDevicePathRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetDevicePathRequest));
  ::fidl::DecodedMessage<GetDevicePathRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      DirectoryAdmin::InPlace::GetDevicePath(std::move(_client_end), Super::response_buffer()));
}

DirectoryAdmin::ResultOf::GetDevicePath DirectoryAdmin::SyncClient::GetDevicePath() {
  return ResultOf::GetDevicePath(zx::unowned_channel(this->channel_));
}

DirectoryAdmin::ResultOf::GetDevicePath DirectoryAdmin::Call::GetDevicePath(zx::unowned_channel _client_end) {
  return ResultOf::GetDevicePath(std::move(_client_end));
}

template <>
DirectoryAdmin::UnownedResultOf::GetDevicePath_Impl<DirectoryAdmin::GetDevicePathResponse>::GetDevicePath_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetDevicePathRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetDevicePathRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetDevicePathRequest));
  ::fidl::DecodedMessage<GetDevicePathRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      DirectoryAdmin::InPlace::GetDevicePath(std::move(_client_end), std::move(_response_buffer)));
}

DirectoryAdmin::UnownedResultOf::GetDevicePath DirectoryAdmin::SyncClient::GetDevicePath(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetDevicePath(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

DirectoryAdmin::UnownedResultOf::GetDevicePath DirectoryAdmin::Call::GetDevicePath(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetDevicePath(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::GetDevicePathResponse> DirectoryAdmin::InPlace::GetDevicePath(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetDevicePathRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetDevicePathRequest> params(std::move(_request_buffer));
  DirectoryAdmin::SetTransactionHeaderFor::GetDevicePathRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::GetDevicePathResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetDevicePathRequest, GetDevicePathResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::GetDevicePathResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

zx_status_t DirectoryAdmin::SyncClient::HandleEvents(DirectoryAdmin::EventHandlers handlers) {
  return DirectoryAdmin::Call::HandleEvents(zx::unowned_channel(channel_), std::move(handlers));
}

zx_status_t DirectoryAdmin::Call::HandleEvents(zx::unowned_channel client_end, DirectoryAdmin::EventHandlers handlers) {
  zx_status_t status = client_end->wait_one(ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED,
                                            zx::time::infinite(),
                                            nullptr);
  if (status != ZX_OK) {
    return status;
  }
  constexpr uint32_t kReadAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::internal::ClampedMessageSize<OnOpenResponse, ::fidl::MessageDirection::kReceiving>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<OnOpenResponse, ::fidl::MessageDirection::kReceiving>();
    }
    if (::fidl::internal::ClampedMessageSize<OnOpenResponse, ::fidl::MessageDirection::kReceiving, ::fidl::internal::WireFormatGuide::kAlternate>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<OnOpenResponse, ::fidl::MessageDirection::kReceiving, ::fidl::internal::WireFormatGuide::kAlternate>();
    }
    return x;
  })();
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (OnOpenResponse::MaxNumHandles >= x) {
      x = OnOpenResponse::MaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  ::fidl::internal::ByteStorage<kReadAllocSize> read_storage;
  uint8_t* read_bytes = read_storage.buffer().data();
  zx_handle_t read_handles[kHandleAllocSize];
  uint32_t actual_bytes;
  uint32_t actual_handles;
  status = client_end->read(ZX_CHANNEL_READ_MAY_DISCARD,
                            read_bytes, read_handles,
                            kReadAllocSize, kHandleAllocSize,
                            &actual_bytes, &actual_handles);
  if (status == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new event,
    // whose size exceeds the maximum of known events in the current protocol.
    return handlers.unknown();
  }
  if (status != ZX_OK) {
    return status;
  }
  if (actual_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(read_handles, actual_handles);
    return ZX_ERR_INVALID_ARGS;
  }
  auto msg = fidl_msg_t {
      .bytes = read_bytes,
      .handles = read_handles,
      .num_bytes = actual_bytes,
      .num_handles = actual_handles
  };
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg.bytes);
  status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    return status;
  }
  switch (hdr->ordinal) {
    case kDirectoryAdmin_OnOpen_Ordinal:
    case kDirectoryAdmin_OnOpen_GenOrdinal:
    {
      constexpr uint32_t kTransformerDestSize = ::fidl::internal::ClampedMessageSize<OnOpenResponse, ::fidl::MessageDirection::kReceiving>();
      ::fidl::internal::ByteStorage<kTransformerDestSize> transformer_dest_storage(::fidl::internal::DelayAllocation);
      if (fidl_should_decode_union_from_xunion(hdr)) {
        transformer_dest_storage.Allocate();
        uint8_t* transformer_dest = transformer_dest_storage.buffer().data();
        zx_status_t transform_status = fidl_transform(FIDL_TRANSFORMATION_V1_TO_OLD,
                                                      OnOpenResponse::AltType,
                                                      reinterpret_cast<uint8_t*>(msg.bytes),
                                                      msg.num_bytes,
                                                      transformer_dest,
                                                      kTransformerDestSize,
                                                      &msg.num_bytes,
                                                      nullptr);
        if (transform_status != ZX_OK) {
          zx_handle_close_many(msg.handles, msg.num_handles);
          return ZX_ERR_INVALID_ARGS;
        }
        msg.bytes = transformer_dest;
      }
      auto result = ::fidl::DecodeAs<OnOpenResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      auto message = result.message.message();
      return handlers.on_open(std::move(message->s), std::move(message->info));
    }
    default:
      zx_handle_close_many(read_handles, actual_handles);
      return handlers.unknown();
  }
}

bool DirectoryAdmin::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kDirectoryAdmin_Clone_Ordinal:
    case kDirectoryAdmin_Clone_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<CloneRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Clone(std::move(message->flags), std::move(message->object),
          Interface::CloneCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_Close_Ordinal:
    case kDirectoryAdmin_Close_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<CloseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Close(
          Interface::CloseCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_Describe_Ordinal:
    case kDirectoryAdmin_Describe_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<DescribeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Describe(
          Interface::DescribeCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_Sync_Ordinal:
    case kDirectoryAdmin_Sync_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SyncRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Sync(
          Interface::SyncCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_GetAttr_Ordinal:
    case kDirectoryAdmin_GetAttr_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetAttrRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetAttr(
          Interface::GetAttrCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_SetAttr_Ordinal:
    case kDirectoryAdmin_SetAttr_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetAttrRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetAttr(std::move(message->flags), std::move(message->attributes),
          Interface::SetAttrCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_NodeGetFlags_Ordinal:
    case kDirectoryAdmin_NodeGetFlags_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<NodeGetFlagsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->NodeGetFlags(
          Interface::NodeGetFlagsCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_NodeSetFlags_Ordinal:
    case kDirectoryAdmin_NodeSetFlags_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<NodeSetFlagsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->NodeSetFlags(std::move(message->flags),
          Interface::NodeSetFlagsCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_Open_Ordinal:
    case kDirectoryAdmin_Open_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<OpenRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Open(std::move(message->flags), std::move(message->mode), std::move(message->path), std::move(message->object),
          Interface::OpenCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_Unlink_Ordinal:
    case kDirectoryAdmin_Unlink_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<UnlinkRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Unlink(std::move(message->path),
          Interface::UnlinkCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_ReadDirents_Ordinal:
    case kDirectoryAdmin_ReadDirents_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ReadDirentsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->ReadDirents(std::move(message->max_bytes),
          Interface::ReadDirentsCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_Rewind_Ordinal:
    case kDirectoryAdmin_Rewind_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<RewindRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Rewind(
          Interface::RewindCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_GetToken_Ordinal:
    case kDirectoryAdmin_GetToken_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetTokenRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetToken(
          Interface::GetTokenCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_Rename_Ordinal:
    case kDirectoryAdmin_Rename_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<RenameRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Rename(std::move(message->src), std::move(message->dst_parent_token), std::move(message->dst),
          Interface::RenameCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_Link_Ordinal:
    case kDirectoryAdmin_Link_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<LinkRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Link(std::move(message->src), std::move(message->dst_parent_token), std::move(message->dst),
          Interface::LinkCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_Watch_Ordinal:
    case kDirectoryAdmin_Watch_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<WatchRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Watch(std::move(message->mask), std::move(message->options), std::move(message->watcher),
          Interface::WatchCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_Mount_Ordinal:
    case kDirectoryAdmin_Mount_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<MountRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Mount(std::move(message->remote),
          Interface::MountCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_MountAndCreate_Ordinal:
    case kDirectoryAdmin_MountAndCreate_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<MountAndCreateRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->MountAndCreate(std::move(message->remote), std::move(message->name), std::move(message->flags),
          Interface::MountAndCreateCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_Unmount_Ordinal:
    case kDirectoryAdmin_Unmount_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<UnmountRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Unmount(
          Interface::UnmountCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_UnmountNode_Ordinal:
    case kDirectoryAdmin_UnmountNode_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<UnmountNodeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->UnmountNode(
          Interface::UnmountNodeCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_QueryFilesystem_Ordinal:
    case kDirectoryAdmin_QueryFilesystem_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<QueryFilesystemRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->QueryFilesystem(
          Interface::QueryFilesystemCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_GetDevicePath_Ordinal:
    case kDirectoryAdmin_GetDevicePath_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetDevicePathRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetDevicePath(
          Interface::GetDevicePathCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool DirectoryAdmin::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void DirectoryAdmin::Interface::CloseCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<CloseResponse*>(_write_bytes);
  DirectoryAdmin::SetTransactionHeaderFor::CloseResponse(
      ::fidl::DecodedMessage<CloseResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              CloseResponse::PrimarySize,
              CloseResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CloseResponse>(std::move(_response_bytes)));
}

void DirectoryAdmin::Interface::CloseCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < CloseResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<CloseResponse*>(_buffer.data());
  DirectoryAdmin::SetTransactionHeaderFor::CloseResponse(
      ::fidl::DecodedMessage<CloseResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              CloseResponse::PrimarySize,
              CloseResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(CloseResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CloseResponse>(std::move(_buffer)));
}

void DirectoryAdmin::Interface::CloseCompleterBase::Reply(::fidl::DecodedMessage<CloseResponse> params) {
  DirectoryAdmin::SetTransactionHeaderFor::CloseResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::DescribeCompleterBase::Reply(::llcpp::fuchsia::io::NodeInfo info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DescribeResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<DescribeResponse*>(_write_bytes);
  DirectoryAdmin::SetTransactionHeaderFor::DescribeResponse(
      ::fidl::DecodedMessage<DescribeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              DescribeResponse::PrimarySize,
              DescribeResponse::PrimarySize)));
  _response.info = std::move(info);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(DescribeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<DescribeResponse>(std::move(_response_bytes)));
}

void DirectoryAdmin::Interface::DescribeCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io::NodeInfo info) {
  if (_buffer.capacity() < DescribeResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<DescribeResponse*>(_buffer.data());
  DirectoryAdmin::SetTransactionHeaderFor::DescribeResponse(
      ::fidl::DecodedMessage<DescribeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              DescribeResponse::PrimarySize,
              DescribeResponse::PrimarySize)));
  _response.info = std::move(info);
  _buffer.set_actual(sizeof(DescribeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<DescribeResponse>(std::move(_buffer)));
}

void DirectoryAdmin::Interface::DescribeCompleterBase::Reply(::fidl::DecodedMessage<DescribeResponse> params) {
  DirectoryAdmin::SetTransactionHeaderFor::DescribeResponse(params);
  CompleterBase::SendReply(std::move(params));
}


zx_status_t DirectoryAdmin::SendOnOpenEvent(::zx::unowned_channel _chan, int32_t s, ::llcpp::fuchsia::io::NodeInfo* info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OnOpenResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  OnOpenResponse _response = {};
  DirectoryAdmin::SetTransactionHeaderFor::OnOpenResponse(
      ::fidl::DecodedMessage<OnOpenResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OnOpenResponse::PrimarySize,
              OnOpenResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t DirectoryAdmin::SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, int32_t s, ::llcpp::fuchsia::io::NodeInfo* info) {
  if (_buffer.capacity() < OnOpenResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  OnOpenResponse _response = {};
  DirectoryAdmin::SetTransactionHeaderFor::OnOpenResponse(
      ::fidl::DecodedMessage<OnOpenResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OnOpenResponse::PrimarySize,
              OnOpenResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
	return _linearize_result.status;
  }
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t DirectoryAdmin::SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnOpenResponse> params) {
  DirectoryAdmin::SetTransactionHeaderFor::OnOpenResponse(params);
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(params));
}


void DirectoryAdmin::Interface::SyncCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SyncResponse*>(_write_bytes);
  DirectoryAdmin::SetTransactionHeaderFor::SyncResponse(
      ::fidl::DecodedMessage<SyncResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SyncResponse::PrimarySize,
              SyncResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SyncResponse>(std::move(_response_bytes)));
}

void DirectoryAdmin::Interface::SyncCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < SyncResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SyncResponse*>(_buffer.data());
  DirectoryAdmin::SetTransactionHeaderFor::SyncResponse(
      ::fidl::DecodedMessage<SyncResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SyncResponse::PrimarySize,
              SyncResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(SyncResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SyncResponse>(std::move(_buffer)));
}

void DirectoryAdmin::Interface::SyncCompleterBase::Reply(::fidl::DecodedMessage<SyncResponse> params) {
  DirectoryAdmin::SetTransactionHeaderFor::SyncResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::GetAttrCompleterBase::Reply(int32_t s, ::llcpp::fuchsia::io::NodeAttributes attributes) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetAttrResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetAttrResponse*>(_write_bytes);
  DirectoryAdmin::SetTransactionHeaderFor::GetAttrResponse(
      ::fidl::DecodedMessage<GetAttrResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetAttrResponse::PrimarySize,
              GetAttrResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.attributes = std::move(attributes);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetAttrResponse>(std::move(_response_bytes)));
}

void DirectoryAdmin::Interface::GetAttrCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, ::llcpp::fuchsia::io::NodeAttributes attributes) {
  if (_buffer.capacity() < GetAttrResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetAttrResponse*>(_buffer.data());
  DirectoryAdmin::SetTransactionHeaderFor::GetAttrResponse(
      ::fidl::DecodedMessage<GetAttrResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetAttrResponse::PrimarySize,
              GetAttrResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.attributes = std::move(attributes);
  _buffer.set_actual(sizeof(GetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetAttrResponse>(std::move(_buffer)));
}

void DirectoryAdmin::Interface::GetAttrCompleterBase::Reply(::fidl::DecodedMessage<GetAttrResponse> params) {
  DirectoryAdmin::SetTransactionHeaderFor::GetAttrResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::SetAttrCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetAttrResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SetAttrResponse*>(_write_bytes);
  DirectoryAdmin::SetTransactionHeaderFor::SetAttrResponse(
      ::fidl::DecodedMessage<SetAttrResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetAttrResponse::PrimarySize,
              SetAttrResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetAttrResponse>(std::move(_response_bytes)));
}

void DirectoryAdmin::Interface::SetAttrCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < SetAttrResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SetAttrResponse*>(_buffer.data());
  DirectoryAdmin::SetTransactionHeaderFor::SetAttrResponse(
      ::fidl::DecodedMessage<SetAttrResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetAttrResponse::PrimarySize,
              SetAttrResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(SetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetAttrResponse>(std::move(_buffer)));
}

void DirectoryAdmin::Interface::SetAttrCompleterBase::Reply(::fidl::DecodedMessage<SetAttrResponse> params) {
  DirectoryAdmin::SetTransactionHeaderFor::SetAttrResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::NodeGetFlagsCompleterBase::Reply(int32_t s, uint32_t flags) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<NodeGetFlagsResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<NodeGetFlagsResponse*>(_write_bytes);
  DirectoryAdmin::SetTransactionHeaderFor::NodeGetFlagsResponse(
      ::fidl::DecodedMessage<NodeGetFlagsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              NodeGetFlagsResponse::PrimarySize,
              NodeGetFlagsResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.flags = std::move(flags);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(NodeGetFlagsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<NodeGetFlagsResponse>(std::move(_response_bytes)));
}

void DirectoryAdmin::Interface::NodeGetFlagsCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, uint32_t flags) {
  if (_buffer.capacity() < NodeGetFlagsResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<NodeGetFlagsResponse*>(_buffer.data());
  DirectoryAdmin::SetTransactionHeaderFor::NodeGetFlagsResponse(
      ::fidl::DecodedMessage<NodeGetFlagsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              NodeGetFlagsResponse::PrimarySize,
              NodeGetFlagsResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.flags = std::move(flags);
  _buffer.set_actual(sizeof(NodeGetFlagsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<NodeGetFlagsResponse>(std::move(_buffer)));
}

void DirectoryAdmin::Interface::NodeGetFlagsCompleterBase::Reply(::fidl::DecodedMessage<NodeGetFlagsResponse> params) {
  DirectoryAdmin::SetTransactionHeaderFor::NodeGetFlagsResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::NodeSetFlagsCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<NodeSetFlagsResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<NodeSetFlagsResponse*>(_write_bytes);
  DirectoryAdmin::SetTransactionHeaderFor::NodeSetFlagsResponse(
      ::fidl::DecodedMessage<NodeSetFlagsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              NodeSetFlagsResponse::PrimarySize,
              NodeSetFlagsResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(NodeSetFlagsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<NodeSetFlagsResponse>(std::move(_response_bytes)));
}

void DirectoryAdmin::Interface::NodeSetFlagsCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < NodeSetFlagsResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<NodeSetFlagsResponse*>(_buffer.data());
  DirectoryAdmin::SetTransactionHeaderFor::NodeSetFlagsResponse(
      ::fidl::DecodedMessage<NodeSetFlagsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              NodeSetFlagsResponse::PrimarySize,
              NodeSetFlagsResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(NodeSetFlagsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<NodeSetFlagsResponse>(std::move(_buffer)));
}

void DirectoryAdmin::Interface::NodeSetFlagsCompleterBase::Reply(::fidl::DecodedMessage<NodeSetFlagsResponse> params) {
  DirectoryAdmin::SetTransactionHeaderFor::NodeSetFlagsResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::UnlinkCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UnlinkResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<UnlinkResponse*>(_write_bytes);
  DirectoryAdmin::SetTransactionHeaderFor::UnlinkResponse(
      ::fidl::DecodedMessage<UnlinkResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              UnlinkResponse::PrimarySize,
              UnlinkResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(UnlinkResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<UnlinkResponse>(std::move(_response_bytes)));
}

void DirectoryAdmin::Interface::UnlinkCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < UnlinkResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<UnlinkResponse*>(_buffer.data());
  DirectoryAdmin::SetTransactionHeaderFor::UnlinkResponse(
      ::fidl::DecodedMessage<UnlinkResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              UnlinkResponse::PrimarySize,
              UnlinkResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(UnlinkResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<UnlinkResponse>(std::move(_buffer)));
}

void DirectoryAdmin::Interface::UnlinkCompleterBase::Reply(::fidl::DecodedMessage<UnlinkResponse> params) {
  DirectoryAdmin::SetTransactionHeaderFor::UnlinkResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::ReadDirentsCompleterBase::Reply(int32_t s, ::fidl::VectorView<uint8_t> dirents) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReadDirentsResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  ReadDirentsResponse _response = {};
  DirectoryAdmin::SetTransactionHeaderFor::ReadDirentsResponse(
      ::fidl::DecodedMessage<ReadDirentsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ReadDirentsResponse::PrimarySize,
              ReadDirentsResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.dirents = std::move(dirents);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void DirectoryAdmin::Interface::ReadDirentsCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, ::fidl::VectorView<uint8_t> dirents) {
  if (_buffer.capacity() < ReadDirentsResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  ReadDirentsResponse _response = {};
  DirectoryAdmin::SetTransactionHeaderFor::ReadDirentsResponse(
      ::fidl::DecodedMessage<ReadDirentsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ReadDirentsResponse::PrimarySize,
              ReadDirentsResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.dirents = std::move(dirents);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void DirectoryAdmin::Interface::ReadDirentsCompleterBase::Reply(::fidl::DecodedMessage<ReadDirentsResponse> params) {
  DirectoryAdmin::SetTransactionHeaderFor::ReadDirentsResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::RewindCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RewindResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<RewindResponse*>(_write_bytes);
  DirectoryAdmin::SetTransactionHeaderFor::RewindResponse(
      ::fidl::DecodedMessage<RewindResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              RewindResponse::PrimarySize,
              RewindResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(RewindResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<RewindResponse>(std::move(_response_bytes)));
}

void DirectoryAdmin::Interface::RewindCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < RewindResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<RewindResponse*>(_buffer.data());
  DirectoryAdmin::SetTransactionHeaderFor::RewindResponse(
      ::fidl::DecodedMessage<RewindResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              RewindResponse::PrimarySize,
              RewindResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(RewindResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<RewindResponse>(std::move(_buffer)));
}

void DirectoryAdmin::Interface::RewindCompleterBase::Reply(::fidl::DecodedMessage<RewindResponse> params) {
  DirectoryAdmin::SetTransactionHeaderFor::RewindResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::GetTokenCompleterBase::Reply(int32_t s, ::zx::handle token) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetTokenResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetTokenResponse*>(_write_bytes);
  DirectoryAdmin::SetTransactionHeaderFor::GetTokenResponse(
      ::fidl::DecodedMessage<GetTokenResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetTokenResponse::PrimarySize,
              GetTokenResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.token = std::move(token);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetTokenResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetTokenResponse>(std::move(_response_bytes)));
}

void DirectoryAdmin::Interface::GetTokenCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, ::zx::handle token) {
  if (_buffer.capacity() < GetTokenResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetTokenResponse*>(_buffer.data());
  DirectoryAdmin::SetTransactionHeaderFor::GetTokenResponse(
      ::fidl::DecodedMessage<GetTokenResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetTokenResponse::PrimarySize,
              GetTokenResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.token = std::move(token);
  _buffer.set_actual(sizeof(GetTokenResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetTokenResponse>(std::move(_buffer)));
}

void DirectoryAdmin::Interface::GetTokenCompleterBase::Reply(::fidl::DecodedMessage<GetTokenResponse> params) {
  DirectoryAdmin::SetTransactionHeaderFor::GetTokenResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::RenameCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RenameResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<RenameResponse*>(_write_bytes);
  DirectoryAdmin::SetTransactionHeaderFor::RenameResponse(
      ::fidl::DecodedMessage<RenameResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              RenameResponse::PrimarySize,
              RenameResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(RenameResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<RenameResponse>(std::move(_response_bytes)));
}

void DirectoryAdmin::Interface::RenameCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < RenameResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<RenameResponse*>(_buffer.data());
  DirectoryAdmin::SetTransactionHeaderFor::RenameResponse(
      ::fidl::DecodedMessage<RenameResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              RenameResponse::PrimarySize,
              RenameResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(RenameResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<RenameResponse>(std::move(_buffer)));
}

void DirectoryAdmin::Interface::RenameCompleterBase::Reply(::fidl::DecodedMessage<RenameResponse> params) {
  DirectoryAdmin::SetTransactionHeaderFor::RenameResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::LinkCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LinkResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<LinkResponse*>(_write_bytes);
  DirectoryAdmin::SetTransactionHeaderFor::LinkResponse(
      ::fidl::DecodedMessage<LinkResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LinkResponse::PrimarySize,
              LinkResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(LinkResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LinkResponse>(std::move(_response_bytes)));
}

void DirectoryAdmin::Interface::LinkCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < LinkResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<LinkResponse*>(_buffer.data());
  DirectoryAdmin::SetTransactionHeaderFor::LinkResponse(
      ::fidl::DecodedMessage<LinkResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LinkResponse::PrimarySize,
              LinkResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(LinkResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LinkResponse>(std::move(_buffer)));
}

void DirectoryAdmin::Interface::LinkCompleterBase::Reply(::fidl::DecodedMessage<LinkResponse> params) {
  DirectoryAdmin::SetTransactionHeaderFor::LinkResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::WatchCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WatchResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<WatchResponse*>(_write_bytes);
  DirectoryAdmin::SetTransactionHeaderFor::WatchResponse(
      ::fidl::DecodedMessage<WatchResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WatchResponse::PrimarySize,
              WatchResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(WatchResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WatchResponse>(std::move(_response_bytes)));
}

void DirectoryAdmin::Interface::WatchCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < WatchResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<WatchResponse*>(_buffer.data());
  DirectoryAdmin::SetTransactionHeaderFor::WatchResponse(
      ::fidl::DecodedMessage<WatchResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WatchResponse::PrimarySize,
              WatchResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(WatchResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WatchResponse>(std::move(_buffer)));
}

void DirectoryAdmin::Interface::WatchCompleterBase::Reply(::fidl::DecodedMessage<WatchResponse> params) {
  DirectoryAdmin::SetTransactionHeaderFor::WatchResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::MountCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MountResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<MountResponse*>(_write_bytes);
  DirectoryAdmin::SetTransactionHeaderFor::MountResponse(
      ::fidl::DecodedMessage<MountResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              MountResponse::PrimarySize,
              MountResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(MountResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<MountResponse>(std::move(_response_bytes)));
}

void DirectoryAdmin::Interface::MountCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < MountResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<MountResponse*>(_buffer.data());
  DirectoryAdmin::SetTransactionHeaderFor::MountResponse(
      ::fidl::DecodedMessage<MountResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              MountResponse::PrimarySize,
              MountResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(MountResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<MountResponse>(std::move(_buffer)));
}

void DirectoryAdmin::Interface::MountCompleterBase::Reply(::fidl::DecodedMessage<MountResponse> params) {
  DirectoryAdmin::SetTransactionHeaderFor::MountResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::MountAndCreateCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MountAndCreateResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<MountAndCreateResponse*>(_write_bytes);
  DirectoryAdmin::SetTransactionHeaderFor::MountAndCreateResponse(
      ::fidl::DecodedMessage<MountAndCreateResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              MountAndCreateResponse::PrimarySize,
              MountAndCreateResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(MountAndCreateResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<MountAndCreateResponse>(std::move(_response_bytes)));
}

void DirectoryAdmin::Interface::MountAndCreateCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < MountAndCreateResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<MountAndCreateResponse*>(_buffer.data());
  DirectoryAdmin::SetTransactionHeaderFor::MountAndCreateResponse(
      ::fidl::DecodedMessage<MountAndCreateResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              MountAndCreateResponse::PrimarySize,
              MountAndCreateResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(MountAndCreateResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<MountAndCreateResponse>(std::move(_buffer)));
}

void DirectoryAdmin::Interface::MountAndCreateCompleterBase::Reply(::fidl::DecodedMessage<MountAndCreateResponse> params) {
  DirectoryAdmin::SetTransactionHeaderFor::MountAndCreateResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::UnmountCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UnmountResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<UnmountResponse*>(_write_bytes);
  DirectoryAdmin::SetTransactionHeaderFor::UnmountResponse(
      ::fidl::DecodedMessage<UnmountResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              UnmountResponse::PrimarySize,
              UnmountResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(UnmountResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<UnmountResponse>(std::move(_response_bytes)));
}

void DirectoryAdmin::Interface::UnmountCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < UnmountResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<UnmountResponse*>(_buffer.data());
  DirectoryAdmin::SetTransactionHeaderFor::UnmountResponse(
      ::fidl::DecodedMessage<UnmountResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              UnmountResponse::PrimarySize,
              UnmountResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(UnmountResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<UnmountResponse>(std::move(_buffer)));
}

void DirectoryAdmin::Interface::UnmountCompleterBase::Reply(::fidl::DecodedMessage<UnmountResponse> params) {
  DirectoryAdmin::SetTransactionHeaderFor::UnmountResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::UnmountNodeCompleterBase::Reply(int32_t s, ::zx::channel remote) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UnmountNodeResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<UnmountNodeResponse*>(_write_bytes);
  DirectoryAdmin::SetTransactionHeaderFor::UnmountNodeResponse(
      ::fidl::DecodedMessage<UnmountNodeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              UnmountNodeResponse::PrimarySize,
              UnmountNodeResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.remote = std::move(remote);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(UnmountNodeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<UnmountNodeResponse>(std::move(_response_bytes)));
}

void DirectoryAdmin::Interface::UnmountNodeCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, ::zx::channel remote) {
  if (_buffer.capacity() < UnmountNodeResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<UnmountNodeResponse*>(_buffer.data());
  DirectoryAdmin::SetTransactionHeaderFor::UnmountNodeResponse(
      ::fidl::DecodedMessage<UnmountNodeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              UnmountNodeResponse::PrimarySize,
              UnmountNodeResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.remote = std::move(remote);
  _buffer.set_actual(sizeof(UnmountNodeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<UnmountNodeResponse>(std::move(_buffer)));
}

void DirectoryAdmin::Interface::UnmountNodeCompleterBase::Reply(::fidl::DecodedMessage<UnmountNodeResponse> params) {
  DirectoryAdmin::SetTransactionHeaderFor::UnmountNodeResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::QueryFilesystemCompleterBase::Reply(int32_t s, ::llcpp::fuchsia::io::FilesystemInfo* info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<QueryFilesystemResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  QueryFilesystemResponse _response = {};
  DirectoryAdmin::SetTransactionHeaderFor::QueryFilesystemResponse(
      ::fidl::DecodedMessage<QueryFilesystemResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              QueryFilesystemResponse::PrimarySize,
              QueryFilesystemResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void DirectoryAdmin::Interface::QueryFilesystemCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, ::llcpp::fuchsia::io::FilesystemInfo* info) {
  if (_buffer.capacity() < QueryFilesystemResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  QueryFilesystemResponse _response = {};
  DirectoryAdmin::SetTransactionHeaderFor::QueryFilesystemResponse(
      ::fidl::DecodedMessage<QueryFilesystemResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              QueryFilesystemResponse::PrimarySize,
              QueryFilesystemResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void DirectoryAdmin::Interface::QueryFilesystemCompleterBase::Reply(::fidl::DecodedMessage<QueryFilesystemResponse> params) {
  DirectoryAdmin::SetTransactionHeaderFor::QueryFilesystemResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::GetDevicePathCompleterBase::Reply(int32_t s, ::fidl::StringView path) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetDevicePathResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  GetDevicePathResponse _response = {};
  DirectoryAdmin::SetTransactionHeaderFor::GetDevicePathResponse(
      ::fidl::DecodedMessage<GetDevicePathResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetDevicePathResponse::PrimarySize,
              GetDevicePathResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.path = std::move(path);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void DirectoryAdmin::Interface::GetDevicePathCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, ::fidl::StringView path) {
  if (_buffer.capacity() < GetDevicePathResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetDevicePathResponse _response = {};
  DirectoryAdmin::SetTransactionHeaderFor::GetDevicePathResponse(
      ::fidl::DecodedMessage<GetDevicePathResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetDevicePathResponse::PrimarySize,
              GetDevicePathResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.path = std::move(path);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void DirectoryAdmin::Interface::GetDevicePathCompleterBase::Reply(::fidl::DecodedMessage<GetDevicePathResponse> params) {
  DirectoryAdmin::SetTransactionHeaderFor::GetDevicePathResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void DirectoryAdmin::SetTransactionHeaderFor::CloneRequest(const ::fidl::DecodedMessage<DirectoryAdmin::CloneRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_Clone_Ordinal);
}

void DirectoryAdmin::SetTransactionHeaderFor::CloseRequest(const ::fidl::DecodedMessage<DirectoryAdmin::CloseRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_Close_Ordinal);
}
void DirectoryAdmin::SetTransactionHeaderFor::CloseResponse(const ::fidl::DecodedMessage<DirectoryAdmin::CloseResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_Close_Ordinal);
}

void DirectoryAdmin::SetTransactionHeaderFor::DescribeRequest(const ::fidl::DecodedMessage<DirectoryAdmin::DescribeRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_Describe_Ordinal);
}
void DirectoryAdmin::SetTransactionHeaderFor::DescribeResponse(const ::fidl::DecodedMessage<DirectoryAdmin::DescribeResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_Describe_Ordinal);
}

void DirectoryAdmin::SetTransactionHeaderFor::OnOpenResponse(const ::fidl::DecodedMessage<DirectoryAdmin::OnOpenResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_OnOpen_Ordinal);
}

void DirectoryAdmin::SetTransactionHeaderFor::SyncRequest(const ::fidl::DecodedMessage<DirectoryAdmin::SyncRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_Sync_Ordinal);
}
void DirectoryAdmin::SetTransactionHeaderFor::SyncResponse(const ::fidl::DecodedMessage<DirectoryAdmin::SyncResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_Sync_Ordinal);
}

void DirectoryAdmin::SetTransactionHeaderFor::GetAttrRequest(const ::fidl::DecodedMessage<DirectoryAdmin::GetAttrRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_GetAttr_Ordinal);
}
void DirectoryAdmin::SetTransactionHeaderFor::GetAttrResponse(const ::fidl::DecodedMessage<DirectoryAdmin::GetAttrResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_GetAttr_Ordinal);
}

void DirectoryAdmin::SetTransactionHeaderFor::SetAttrRequest(const ::fidl::DecodedMessage<DirectoryAdmin::SetAttrRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_SetAttr_Ordinal);
}
void DirectoryAdmin::SetTransactionHeaderFor::SetAttrResponse(const ::fidl::DecodedMessage<DirectoryAdmin::SetAttrResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_SetAttr_Ordinal);
}

void DirectoryAdmin::SetTransactionHeaderFor::NodeGetFlagsRequest(const ::fidl::DecodedMessage<DirectoryAdmin::NodeGetFlagsRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_NodeGetFlags_Ordinal);
}
void DirectoryAdmin::SetTransactionHeaderFor::NodeGetFlagsResponse(const ::fidl::DecodedMessage<DirectoryAdmin::NodeGetFlagsResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_NodeGetFlags_Ordinal);
}

void DirectoryAdmin::SetTransactionHeaderFor::NodeSetFlagsRequest(const ::fidl::DecodedMessage<DirectoryAdmin::NodeSetFlagsRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_NodeSetFlags_Ordinal);
}
void DirectoryAdmin::SetTransactionHeaderFor::NodeSetFlagsResponse(const ::fidl::DecodedMessage<DirectoryAdmin::NodeSetFlagsResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_NodeSetFlags_Ordinal);
}

void DirectoryAdmin::SetTransactionHeaderFor::OpenRequest(const ::fidl::DecodedMessage<DirectoryAdmin::OpenRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_Open_Ordinal);
}

void DirectoryAdmin::SetTransactionHeaderFor::UnlinkRequest(const ::fidl::DecodedMessage<DirectoryAdmin::UnlinkRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_Unlink_Ordinal);
}
void DirectoryAdmin::SetTransactionHeaderFor::UnlinkResponse(const ::fidl::DecodedMessage<DirectoryAdmin::UnlinkResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_Unlink_Ordinal);
}

void DirectoryAdmin::SetTransactionHeaderFor::ReadDirentsRequest(const ::fidl::DecodedMessage<DirectoryAdmin::ReadDirentsRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_ReadDirents_Ordinal);
}
void DirectoryAdmin::SetTransactionHeaderFor::ReadDirentsResponse(const ::fidl::DecodedMessage<DirectoryAdmin::ReadDirentsResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_ReadDirents_Ordinal);
}

void DirectoryAdmin::SetTransactionHeaderFor::RewindRequest(const ::fidl::DecodedMessage<DirectoryAdmin::RewindRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_Rewind_Ordinal);
}
void DirectoryAdmin::SetTransactionHeaderFor::RewindResponse(const ::fidl::DecodedMessage<DirectoryAdmin::RewindResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_Rewind_Ordinal);
}

void DirectoryAdmin::SetTransactionHeaderFor::GetTokenRequest(const ::fidl::DecodedMessage<DirectoryAdmin::GetTokenRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_GetToken_Ordinal);
}
void DirectoryAdmin::SetTransactionHeaderFor::GetTokenResponse(const ::fidl::DecodedMessage<DirectoryAdmin::GetTokenResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_GetToken_Ordinal);
}

void DirectoryAdmin::SetTransactionHeaderFor::RenameRequest(const ::fidl::DecodedMessage<DirectoryAdmin::RenameRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_Rename_Ordinal);
}
void DirectoryAdmin::SetTransactionHeaderFor::RenameResponse(const ::fidl::DecodedMessage<DirectoryAdmin::RenameResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_Rename_Ordinal);
}

void DirectoryAdmin::SetTransactionHeaderFor::LinkRequest(const ::fidl::DecodedMessage<DirectoryAdmin::LinkRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_Link_Ordinal);
}
void DirectoryAdmin::SetTransactionHeaderFor::LinkResponse(const ::fidl::DecodedMessage<DirectoryAdmin::LinkResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_Link_Ordinal);
}

void DirectoryAdmin::SetTransactionHeaderFor::WatchRequest(const ::fidl::DecodedMessage<DirectoryAdmin::WatchRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_Watch_Ordinal);
}
void DirectoryAdmin::SetTransactionHeaderFor::WatchResponse(const ::fidl::DecodedMessage<DirectoryAdmin::WatchResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_Watch_Ordinal);
}

void DirectoryAdmin::SetTransactionHeaderFor::MountRequest(const ::fidl::DecodedMessage<DirectoryAdmin::MountRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_Mount_Ordinal);
}
void DirectoryAdmin::SetTransactionHeaderFor::MountResponse(const ::fidl::DecodedMessage<DirectoryAdmin::MountResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_Mount_Ordinal);
}

void DirectoryAdmin::SetTransactionHeaderFor::MountAndCreateRequest(const ::fidl::DecodedMessage<DirectoryAdmin::MountAndCreateRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_MountAndCreate_Ordinal);
}
void DirectoryAdmin::SetTransactionHeaderFor::MountAndCreateResponse(const ::fidl::DecodedMessage<DirectoryAdmin::MountAndCreateResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_MountAndCreate_Ordinal);
}

void DirectoryAdmin::SetTransactionHeaderFor::UnmountRequest(const ::fidl::DecodedMessage<DirectoryAdmin::UnmountRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_Unmount_Ordinal);
}
void DirectoryAdmin::SetTransactionHeaderFor::UnmountResponse(const ::fidl::DecodedMessage<DirectoryAdmin::UnmountResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_Unmount_Ordinal);
}

void DirectoryAdmin::SetTransactionHeaderFor::UnmountNodeRequest(const ::fidl::DecodedMessage<DirectoryAdmin::UnmountNodeRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_UnmountNode_Ordinal);
}
void DirectoryAdmin::SetTransactionHeaderFor::UnmountNodeResponse(const ::fidl::DecodedMessage<DirectoryAdmin::UnmountNodeResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_UnmountNode_Ordinal);
}

void DirectoryAdmin::SetTransactionHeaderFor::QueryFilesystemRequest(const ::fidl::DecodedMessage<DirectoryAdmin::QueryFilesystemRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_QueryFilesystem_Ordinal);
}
void DirectoryAdmin::SetTransactionHeaderFor::QueryFilesystemResponse(const ::fidl::DecodedMessage<DirectoryAdmin::QueryFilesystemResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_QueryFilesystem_Ordinal);
}

void DirectoryAdmin::SetTransactionHeaderFor::GetDevicePathRequest(const ::fidl::DecodedMessage<DirectoryAdmin::GetDevicePathRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_GetDevicePath_Ordinal);
}
void DirectoryAdmin::SetTransactionHeaderFor::GetDevicePathResponse(const ::fidl::DecodedMessage<DirectoryAdmin::GetDevicePathResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryAdmin_GetDevicePath_Ordinal);
}

}  // namespace io
}  // namespace fuchsia
}  // namespace llcpp

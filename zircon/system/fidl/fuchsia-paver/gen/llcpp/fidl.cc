// WARNING: This file is machine generated by fidlgen.

#include <fuchsia/paver/llcpp/fidl.h>
#include <memory>

namespace llcpp {

namespace fuchsia {
namespace paver {

::llcpp::fuchsia::paver::ReadResult::ReadResult() {
  ordinal_ = Ordinal::Invalid;
}

::llcpp::fuchsia::paver::ReadResult::~ReadResult() {
  Destroy();
}

void ::llcpp::fuchsia::paver::ReadResult::Destroy() {
  switch (ordinal_) {
  case Ordinal::kInfo:
    info_.~ReadInfo();
    break;
  default:
    break;
  }
  ordinal_ = Ordinal::Invalid;
}

void ::llcpp::fuchsia::paver::ReadResult::MoveImpl_(ReadResult&& other) {
  switch (other.ordinal_) {
  case Ordinal::kErr:
    mutable_err() = std::move(other.mutable_err());
    break;
  case Ordinal::kEof:
    mutable_eof() = std::move(other.mutable_eof());
    break;
  case Ordinal::kInfo:
    mutable_info() = std::move(other.mutable_info());
    break;
  default:
    break;
  }
  other.Destroy();
}

void ::llcpp::fuchsia::paver::ReadResult::SizeAndOffsetAssertionHelper() {
  static_assert(offsetof(::llcpp::fuchsia::paver::ReadResult, err_) == 8);
  static_assert(offsetof(::llcpp::fuchsia::paver::ReadResult, eof_) == 8);
  static_assert(offsetof(::llcpp::fuchsia::paver::ReadResult, info_) == 8);
  static_assert(sizeof(::llcpp::fuchsia::paver::ReadResult) == ::llcpp::fuchsia::paver::ReadResult::PrimarySize);
}


int32_t& ::llcpp::fuchsia::paver::ReadResult::mutable_err() {
  if (ordinal_ != Ordinal::kErr) {
    Destroy();
    new (&err_) int32_t;
  }
  ordinal_ = Ordinal::kErr;
  return err_;
}

bool& ::llcpp::fuchsia::paver::ReadResult::mutable_eof() {
  if (ordinal_ != Ordinal::kEof) {
    Destroy();
    new (&eof_) bool;
  }
  ordinal_ = Ordinal::kEof;
  return eof_;
}

::llcpp::fuchsia::paver::ReadInfo& ::llcpp::fuchsia::paver::ReadResult::mutable_info() {
  if (ordinal_ != Ordinal::kInfo) {
    Destroy();
    new (&info_) ::llcpp::fuchsia::paver::ReadInfo;
  }
  ordinal_ = Ordinal::kInfo;
  return info_;
}


namespace {

[[maybe_unused]]
constexpr uint64_t kPayloadStream_RegisterVmo_Ordinal = 0x1044c8d900000000lu;
[[maybe_unused]]
constexpr uint64_t kPayloadStream_RegisterVmo_GenOrdinal = 0x388d7fe44bcb4clu;
extern "C" const fidl_type_t fuchsia_paver_PayloadStreamRegisterVmoRequestTable;
extern "C" const fidl_type_t fuchsia_paver_PayloadStreamRegisterVmoResponseTable;
extern "C" const fidl_type_t v1_fuchsia_paver_PayloadStreamRegisterVmoResponseTable;
[[maybe_unused]]
constexpr uint64_t kPayloadStream_ReadData_Ordinal = 0x2c366e3600000000lu;
[[maybe_unused]]
constexpr uint64_t kPayloadStream_ReadData_GenOrdinal = 0x2ccde55366318afalu;
extern "C" const fidl_type_t fuchsia_paver_PayloadStreamReadDataRequestTable;
extern "C" const fidl_type_t fuchsia_paver_PayloadStreamReadDataResponseTable;
extern "C" const fidl_type_t v1_fuchsia_paver_PayloadStreamReadDataResponseTable;

}  // namespace
template <>
PayloadStream::ResultOf::RegisterVmo_Impl<PayloadStream::RegisterVmoResponse>::RegisterVmo_Impl(zx::unowned_channel _client_end, ::zx::vmo vmo) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RegisterVmoRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, RegisterVmoRequest::PrimarySize);
  auto& _request = *reinterpret_cast<RegisterVmoRequest*>(_write_bytes);
  _request.vmo = std::move(vmo);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(RegisterVmoRequest));
  ::fidl::DecodedMessage<RegisterVmoRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      PayloadStream::InPlace::RegisterVmo(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

PayloadStream::ResultOf::RegisterVmo PayloadStream::SyncClient::RegisterVmo(::zx::vmo vmo) {
  return ResultOf::RegisterVmo(zx::unowned_channel(this->channel_), std::move(vmo));
}

PayloadStream::ResultOf::RegisterVmo PayloadStream::Call::RegisterVmo(zx::unowned_channel _client_end, ::zx::vmo vmo) {
  return ResultOf::RegisterVmo(std::move(_client_end), std::move(vmo));
}

template <>
PayloadStream::UnownedResultOf::RegisterVmo_Impl<PayloadStream::RegisterVmoResponse>::RegisterVmo_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::vmo vmo, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < RegisterVmoRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<RegisterVmoResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, RegisterVmoRequest::PrimarySize);
  auto& _request = *reinterpret_cast<RegisterVmoRequest*>(_request_buffer.data());
  _request.vmo = std::move(vmo);
  _request_buffer.set_actual(sizeof(RegisterVmoRequest));
  ::fidl::DecodedMessage<RegisterVmoRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      PayloadStream::InPlace::RegisterVmo(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

PayloadStream::UnownedResultOf::RegisterVmo PayloadStream::SyncClient::RegisterVmo(::fidl::BytePart _request_buffer, ::zx::vmo vmo, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::RegisterVmo(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(vmo), std::move(_response_buffer));
}

PayloadStream::UnownedResultOf::RegisterVmo PayloadStream::Call::RegisterVmo(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::vmo vmo, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::RegisterVmo(std::move(_client_end), std::move(_request_buffer), std::move(vmo), std::move(_response_buffer));
}

::fidl::DecodeResult<PayloadStream::RegisterVmoResponse> PayloadStream::InPlace::RegisterVmo(zx::unowned_channel _client_end, ::fidl::DecodedMessage<RegisterVmoRequest> params, ::fidl::BytePart response_buffer) {
  PayloadStream::SetTransactionHeaderFor::RegisterVmoRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<PayloadStream::RegisterVmoResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<RegisterVmoRequest, RegisterVmoResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<PayloadStream::RegisterVmoResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
PayloadStream::ResultOf::ReadData_Impl<PayloadStream::ReadDataResponse>::ReadData_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReadDataRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ReadDataRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ReadDataRequest));
  ::fidl::DecodedMessage<ReadDataRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      PayloadStream::InPlace::ReadData(std::move(_client_end), Super::response_buffer()));
}

PayloadStream::ResultOf::ReadData PayloadStream::SyncClient::ReadData() {
  return ResultOf::ReadData(zx::unowned_channel(this->channel_));
}

PayloadStream::ResultOf::ReadData PayloadStream::Call::ReadData(zx::unowned_channel _client_end) {
  return ResultOf::ReadData(std::move(_client_end));
}

template <>
PayloadStream::UnownedResultOf::ReadData_Impl<PayloadStream::ReadDataResponse>::ReadData_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(ReadDataRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, ReadDataRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(ReadDataRequest));
  ::fidl::DecodedMessage<ReadDataRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      PayloadStream::InPlace::ReadData(std::move(_client_end), std::move(_response_buffer)));
}

PayloadStream::UnownedResultOf::ReadData PayloadStream::SyncClient::ReadData(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ReadData(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

PayloadStream::UnownedResultOf::ReadData PayloadStream::Call::ReadData(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ReadData(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<PayloadStream::ReadDataResponse> PayloadStream::InPlace::ReadData(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(ReadDataRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<ReadDataRequest> params(std::move(_request_buffer));
  PayloadStream::SetTransactionHeaderFor::ReadDataRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<PayloadStream::ReadDataResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ReadDataRequest, ReadDataResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<PayloadStream::ReadDataResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool PayloadStream::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kPayloadStream_RegisterVmo_Ordinal:
    case kPayloadStream_RegisterVmo_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<RegisterVmoRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->RegisterVmo(std::move(message->vmo),
          Interface::RegisterVmoCompleter::Sync(txn));
      return true;
    }
    case kPayloadStream_ReadData_Ordinal:
    case kPayloadStream_ReadData_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ReadDataRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->ReadData(
          Interface::ReadDataCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool PayloadStream::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void PayloadStream::Interface::RegisterVmoCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RegisterVmoResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<RegisterVmoResponse*>(_write_bytes);
  PayloadStream::SetTransactionHeaderFor::RegisterVmoResponse(
      ::fidl::DecodedMessage<RegisterVmoResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              RegisterVmoResponse::PrimarySize,
              RegisterVmoResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(RegisterVmoResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<RegisterVmoResponse>(std::move(_response_bytes)));
}

void PayloadStream::Interface::RegisterVmoCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < RegisterVmoResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<RegisterVmoResponse*>(_buffer.data());
  PayloadStream::SetTransactionHeaderFor::RegisterVmoResponse(
      ::fidl::DecodedMessage<RegisterVmoResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              RegisterVmoResponse::PrimarySize,
              RegisterVmoResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(RegisterVmoResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<RegisterVmoResponse>(std::move(_buffer)));
}

void PayloadStream::Interface::RegisterVmoCompleterBase::Reply(::fidl::DecodedMessage<RegisterVmoResponse> params) {
  PayloadStream::SetTransactionHeaderFor::RegisterVmoResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void PayloadStream::Interface::ReadDataCompleterBase::Reply(::llcpp::fuchsia::paver::ReadResult result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReadDataResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<ReadDataResponse*>(_write_bytes);
  PayloadStream::SetTransactionHeaderFor::ReadDataResponse(
      ::fidl::DecodedMessage<ReadDataResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ReadDataResponse::PrimarySize,
              ReadDataResponse::PrimarySize)));
  _response.result = std::move(result);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(ReadDataResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ReadDataResponse>(std::move(_response_bytes)));
}

void PayloadStream::Interface::ReadDataCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::paver::ReadResult result) {
  if (_buffer.capacity() < ReadDataResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<ReadDataResponse*>(_buffer.data());
  PayloadStream::SetTransactionHeaderFor::ReadDataResponse(
      ::fidl::DecodedMessage<ReadDataResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ReadDataResponse::PrimarySize,
              ReadDataResponse::PrimarySize)));
  _response.result = std::move(result);
  _buffer.set_actual(sizeof(ReadDataResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ReadDataResponse>(std::move(_buffer)));
}

void PayloadStream::Interface::ReadDataCompleterBase::Reply(::fidl::DecodedMessage<ReadDataResponse> params) {
  PayloadStream::SetTransactionHeaderFor::ReadDataResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void PayloadStream::SetTransactionHeaderFor::RegisterVmoRequest(const ::fidl::DecodedMessage<PayloadStream::RegisterVmoRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPayloadStream_RegisterVmo_GenOrdinal);
}
void PayloadStream::SetTransactionHeaderFor::RegisterVmoResponse(const ::fidl::DecodedMessage<PayloadStream::RegisterVmoResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPayloadStream_RegisterVmo_GenOrdinal);
}

void PayloadStream::SetTransactionHeaderFor::ReadDataRequest(const ::fidl::DecodedMessage<PayloadStream::ReadDataRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPayloadStream_ReadData_GenOrdinal);
}
void PayloadStream::SetTransactionHeaderFor::ReadDataResponse(const ::fidl::DecodedMessage<PayloadStream::ReadDataResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPayloadStream_ReadData_GenOrdinal);
}

::llcpp::fuchsia::paver::Paver_WipeVolume_Result::Paver_WipeVolume_Result() {
  ordinal_ = Ordinal::Invalid;
}

::llcpp::fuchsia::paver::Paver_WipeVolume_Result::~Paver_WipeVolume_Result() {
  Destroy();
}

void ::llcpp::fuchsia::paver::Paver_WipeVolume_Result::Destroy() {
  switch (ordinal_) {
  case Ordinal::kResponse:
    response_.~Paver_WipeVolume_Response();
    break;
  default:
    break;
  }
  ordinal_ = Ordinal::Invalid;
}

void ::llcpp::fuchsia::paver::Paver_WipeVolume_Result::MoveImpl_(Paver_WipeVolume_Result&& other) {
  switch (other.ordinal_) {
  case Ordinal::kResponse:
    mutable_response() = std::move(other.mutable_response());
    break;
  case Ordinal::kErr:
    mutable_err() = std::move(other.mutable_err());
    break;
  default:
    break;
  }
  other.Destroy();
}

void ::llcpp::fuchsia::paver::Paver_WipeVolume_Result::SizeAndOffsetAssertionHelper() {
  static_assert(offsetof(::llcpp::fuchsia::paver::Paver_WipeVolume_Result, response_) == 4);
  static_assert(offsetof(::llcpp::fuchsia::paver::Paver_WipeVolume_Result, err_) == 4);
  static_assert(sizeof(::llcpp::fuchsia::paver::Paver_WipeVolume_Result) == ::llcpp::fuchsia::paver::Paver_WipeVolume_Result::PrimarySize);
}


::llcpp::fuchsia::paver::Paver_WipeVolume_Response& ::llcpp::fuchsia::paver::Paver_WipeVolume_Result::mutable_response() {
  if (ordinal_ != Ordinal::kResponse) {
    Destroy();
    new (&response_) ::llcpp::fuchsia::paver::Paver_WipeVolume_Response;
  }
  ordinal_ = Ordinal::kResponse;
  return response_;
}

int32_t& ::llcpp::fuchsia::paver::Paver_WipeVolume_Result::mutable_err() {
  if (ordinal_ != Ordinal::kErr) {
    Destroy();
    new (&err_) int32_t;
  }
  ordinal_ = Ordinal::kErr;
  return err_;
}


::llcpp::fuchsia::paver::Paver_QueryConfigurationStatus_Result::Paver_QueryConfigurationStatus_Result() {
  ordinal_ = Ordinal::Invalid;
}

::llcpp::fuchsia::paver::Paver_QueryConfigurationStatus_Result::~Paver_QueryConfigurationStatus_Result() {
  Destroy();
}

void ::llcpp::fuchsia::paver::Paver_QueryConfigurationStatus_Result::Destroy() {
  switch (ordinal_) {
  case Ordinal::kResponse:
    response_.~Paver_QueryConfigurationStatus_Response();
    break;
  default:
    break;
  }
  ordinal_ = Ordinal::Invalid;
}

void ::llcpp::fuchsia::paver::Paver_QueryConfigurationStatus_Result::MoveImpl_(Paver_QueryConfigurationStatus_Result&& other) {
  switch (other.ordinal_) {
  case Ordinal::kResponse:
    mutable_response() = std::move(other.mutable_response());
    break;
  case Ordinal::kErr:
    mutable_err() = std::move(other.mutable_err());
    break;
  default:
    break;
  }
  other.Destroy();
}

void ::llcpp::fuchsia::paver::Paver_QueryConfigurationStatus_Result::SizeAndOffsetAssertionHelper() {
  static_assert(offsetof(::llcpp::fuchsia::paver::Paver_QueryConfigurationStatus_Result, response_) == 4);
  static_assert(offsetof(::llcpp::fuchsia::paver::Paver_QueryConfigurationStatus_Result, err_) == 4);
  static_assert(sizeof(::llcpp::fuchsia::paver::Paver_QueryConfigurationStatus_Result) == ::llcpp::fuchsia::paver::Paver_QueryConfigurationStatus_Result::PrimarySize);
}


::llcpp::fuchsia::paver::Paver_QueryConfigurationStatus_Response& ::llcpp::fuchsia::paver::Paver_QueryConfigurationStatus_Result::mutable_response() {
  if (ordinal_ != Ordinal::kResponse) {
    Destroy();
    new (&response_) ::llcpp::fuchsia::paver::Paver_QueryConfigurationStatus_Response;
  }
  ordinal_ = Ordinal::kResponse;
  return response_;
}

int32_t& ::llcpp::fuchsia::paver::Paver_QueryConfigurationStatus_Result::mutable_err() {
  if (ordinal_ != Ordinal::kErr) {
    Destroy();
    new (&err_) int32_t;
  }
  ordinal_ = Ordinal::kErr;
  return err_;
}


::llcpp::fuchsia::paver::Paver_QueryActiveConfiguration_Result::Paver_QueryActiveConfiguration_Result() {
  ordinal_ = Ordinal::Invalid;
}

::llcpp::fuchsia::paver::Paver_QueryActiveConfiguration_Result::~Paver_QueryActiveConfiguration_Result() {
  Destroy();
}

void ::llcpp::fuchsia::paver::Paver_QueryActiveConfiguration_Result::Destroy() {
  switch (ordinal_) {
  case Ordinal::kResponse:
    response_.~Paver_QueryActiveConfiguration_Response();
    break;
  default:
    break;
  }
  ordinal_ = Ordinal::Invalid;
}

void ::llcpp::fuchsia::paver::Paver_QueryActiveConfiguration_Result::MoveImpl_(Paver_QueryActiveConfiguration_Result&& other) {
  switch (other.ordinal_) {
  case Ordinal::kResponse:
    mutable_response() = std::move(other.mutable_response());
    break;
  case Ordinal::kErr:
    mutable_err() = std::move(other.mutable_err());
    break;
  default:
    break;
  }
  other.Destroy();
}

void ::llcpp::fuchsia::paver::Paver_QueryActiveConfiguration_Result::SizeAndOffsetAssertionHelper() {
  static_assert(offsetof(::llcpp::fuchsia::paver::Paver_QueryActiveConfiguration_Result, response_) == 4);
  static_assert(offsetof(::llcpp::fuchsia::paver::Paver_QueryActiveConfiguration_Result, err_) == 4);
  static_assert(sizeof(::llcpp::fuchsia::paver::Paver_QueryActiveConfiguration_Result) == ::llcpp::fuchsia::paver::Paver_QueryActiveConfiguration_Result::PrimarySize);
}


::llcpp::fuchsia::paver::Paver_QueryActiveConfiguration_Response& ::llcpp::fuchsia::paver::Paver_QueryActiveConfiguration_Result::mutable_response() {
  if (ordinal_ != Ordinal::kResponse) {
    Destroy();
    new (&response_) ::llcpp::fuchsia::paver::Paver_QueryActiveConfiguration_Response;
  }
  ordinal_ = Ordinal::kResponse;
  return response_;
}

int32_t& ::llcpp::fuchsia::paver::Paver_QueryActiveConfiguration_Result::mutable_err() {
  if (ordinal_ != Ordinal::kErr) {
    Destroy();
    new (&err_) int32_t;
  }
  ordinal_ = Ordinal::kErr;
  return err_;
}


::llcpp::fuchsia::paver::Paver_ReadAsset_Result::Paver_ReadAsset_Result() {
  ordinal_ = Ordinal::Invalid;
}

::llcpp::fuchsia::paver::Paver_ReadAsset_Result::~Paver_ReadAsset_Result() {
  Destroy();
}

void ::llcpp::fuchsia::paver::Paver_ReadAsset_Result::Destroy() {
  switch (ordinal_) {
  case Ordinal::kResponse:
    response_.~Paver_ReadAsset_Response();
    break;
  default:
    break;
  }
  ordinal_ = Ordinal::Invalid;
}

void ::llcpp::fuchsia::paver::Paver_ReadAsset_Result::MoveImpl_(Paver_ReadAsset_Result&& other) {
  switch (other.ordinal_) {
  case Ordinal::kResponse:
    mutable_response() = std::move(other.mutable_response());
    break;
  case Ordinal::kErr:
    mutable_err() = std::move(other.mutable_err());
    break;
  default:
    break;
  }
  other.Destroy();
}

void ::llcpp::fuchsia::paver::Paver_ReadAsset_Result::SizeAndOffsetAssertionHelper() {
  static_assert(offsetof(::llcpp::fuchsia::paver::Paver_ReadAsset_Result, response_) == 8);
  static_assert(offsetof(::llcpp::fuchsia::paver::Paver_ReadAsset_Result, err_) == 8);
  static_assert(sizeof(::llcpp::fuchsia::paver::Paver_ReadAsset_Result) == ::llcpp::fuchsia::paver::Paver_ReadAsset_Result::PrimarySize);
}


::llcpp::fuchsia::paver::Paver_ReadAsset_Response& ::llcpp::fuchsia::paver::Paver_ReadAsset_Result::mutable_response() {
  if (ordinal_ != Ordinal::kResponse) {
    Destroy();
    new (&response_) ::llcpp::fuchsia::paver::Paver_ReadAsset_Response;
  }
  ordinal_ = Ordinal::kResponse;
  return response_;
}

int32_t& ::llcpp::fuchsia::paver::Paver_ReadAsset_Result::mutable_err() {
  if (ordinal_ != Ordinal::kErr) {
    Destroy();
    new (&err_) int32_t;
  }
  ordinal_ = Ordinal::kErr;
  return err_;
}


namespace {

[[maybe_unused]]
constexpr uint64_t kPaver_InitializeAbr_Ordinal = 0x2233bf3300000000lu;
[[maybe_unused]]
constexpr uint64_t kPaver_InitializeAbr_GenOrdinal = 0x715dddabfb08c8e1lu;
extern "C" const fidl_type_t fuchsia_paver_PaverInitializeAbrRequestTable;
extern "C" const fidl_type_t fuchsia_paver_PaverInitializeAbrResponseTable;
extern "C" const fidl_type_t v1_fuchsia_paver_PaverInitializeAbrResponseTable;
[[maybe_unused]]
constexpr uint64_t kPaver_QueryActiveConfiguration_Ordinal = 0x43a5e49300000000lu;
[[maybe_unused]]
constexpr uint64_t kPaver_QueryActiveConfiguration_GenOrdinal = 0x5517c7c0119ded35lu;
extern "C" const fidl_type_t fuchsia_paver_PaverQueryActiveConfigurationRequestTable;
extern "C" const fidl_type_t fuchsia_paver_PaverQueryActiveConfigurationResponseTable;
extern "C" const fidl_type_t v1_fuchsia_paver_PaverQueryActiveConfigurationResponseTable;
[[maybe_unused]]
constexpr uint64_t kPaver_QueryConfigurationStatus_Ordinal = 0x6659a95000000000lu;
[[maybe_unused]]
constexpr uint64_t kPaver_QueryConfigurationStatus_GenOrdinal = 0x63a9170989a1efdflu;
extern "C" const fidl_type_t fuchsia_paver_PaverQueryConfigurationStatusRequestTable;
extern "C" const fidl_type_t fuchsia_paver_PaverQueryConfigurationStatusResponseTable;
extern "C" const fidl_type_t v1_fuchsia_paver_PaverQueryConfigurationStatusResponseTable;
[[maybe_unused]]
constexpr uint64_t kPaver_SetConfigurationActive_Ordinal = 0x942de4b00000000lu;
[[maybe_unused]]
constexpr uint64_t kPaver_SetConfigurationActive_GenOrdinal = 0x66a45688107aa07flu;
extern "C" const fidl_type_t fuchsia_paver_PaverSetConfigurationActiveRequestTable;
extern "C" const fidl_type_t fuchsia_paver_PaverSetConfigurationActiveResponseTable;
extern "C" const fidl_type_t v1_fuchsia_paver_PaverSetConfigurationActiveResponseTable;
[[maybe_unused]]
constexpr uint64_t kPaver_SetConfigurationUnbootable_Ordinal = 0x52cf3c8200000000lu;
[[maybe_unused]]
constexpr uint64_t kPaver_SetConfigurationUnbootable_GenOrdinal = 0x623c8fe814130d4alu;
extern "C" const fidl_type_t fuchsia_paver_PaverSetConfigurationUnbootableRequestTable;
extern "C" const fidl_type_t fuchsia_paver_PaverSetConfigurationUnbootableResponseTable;
extern "C" const fidl_type_t v1_fuchsia_paver_PaverSetConfigurationUnbootableResponseTable;
[[maybe_unused]]
constexpr uint64_t kPaver_SetActiveConfigurationHealthy_Ordinal = 0x14c8092400000000lu;
[[maybe_unused]]
constexpr uint64_t kPaver_SetActiveConfigurationHealthy_GenOrdinal = 0x6b86cae4d01d72c1lu;
extern "C" const fidl_type_t fuchsia_paver_PaverSetActiveConfigurationHealthyRequestTable;
extern "C" const fidl_type_t fuchsia_paver_PaverSetActiveConfigurationHealthyResponseTable;
extern "C" const fidl_type_t v1_fuchsia_paver_PaverSetActiveConfigurationHealthyResponseTable;
[[maybe_unused]]
constexpr uint64_t kPaver_ReadAsset_Ordinal = 0x4b8e09f500000000lu;
[[maybe_unused]]
constexpr uint64_t kPaver_ReadAsset_GenOrdinal = 0x30a69bd25198eb0lu;
extern "C" const fidl_type_t fuchsia_paver_PaverReadAssetRequestTable;
extern "C" const fidl_type_t fuchsia_paver_PaverReadAssetResponseTable;
extern "C" const fidl_type_t v1_fuchsia_paver_PaverReadAssetResponseTable;
[[maybe_unused]]
constexpr uint64_t kPaver_WriteAsset_Ordinal = 0x6a1ccf9c00000000lu;
[[maybe_unused]]
constexpr uint64_t kPaver_WriteAsset_GenOrdinal = 0x68008e0190578208lu;
extern "C" const fidl_type_t fuchsia_paver_PaverWriteAssetRequestTable;
extern "C" const fidl_type_t fuchsia_paver_PaverWriteAssetResponseTable;
extern "C" const fidl_type_t v1_fuchsia_paver_PaverWriteAssetResponseTable;
[[maybe_unused]]
constexpr uint64_t kPaver_WriteVolumes_Ordinal = 0x71b3cf2600000000lu;
[[maybe_unused]]
constexpr uint64_t kPaver_WriteVolumes_GenOrdinal = 0x1dedf69f6f1f9ba7lu;
extern "C" const fidl_type_t fuchsia_paver_PaverWriteVolumesRequestTable;
extern "C" const fidl_type_t fuchsia_paver_PaverWriteVolumesResponseTable;
extern "C" const fidl_type_t v1_fuchsia_paver_PaverWriteVolumesResponseTable;
[[maybe_unused]]
constexpr uint64_t kPaver_WriteBootloader_Ordinal = 0x4b6ba17600000000lu;
[[maybe_unused]]
constexpr uint64_t kPaver_WriteBootloader_GenOrdinal = 0x18099de6007b393lu;
extern "C" const fidl_type_t fuchsia_paver_PaverWriteBootloaderRequestTable;
extern "C" const fidl_type_t fuchsia_paver_PaverWriteBootloaderResponseTable;
extern "C" const fidl_type_t v1_fuchsia_paver_PaverWriteBootloaderResponseTable;
[[maybe_unused]]
constexpr uint64_t kPaver_WriteDataFile_Ordinal = 0x7b8433de00000000lu;
[[maybe_unused]]
constexpr uint64_t kPaver_WriteDataFile_GenOrdinal = 0x55cd644f9291ad5alu;
extern "C" const fidl_type_t fuchsia_paver_PaverWriteDataFileRequestTable;
extern "C" const fidl_type_t fuchsia_paver_PaverWriteDataFileResponseTable;
extern "C" const fidl_type_t v1_fuchsia_paver_PaverWriteDataFileResponseTable;
[[maybe_unused]]
constexpr uint64_t kPaver_WipeVolume_Ordinal = 0x4d18bc6b00000000lu;
[[maybe_unused]]
constexpr uint64_t kPaver_WipeVolume_GenOrdinal = 0x591bcb70b1ab9e73lu;
extern "C" const fidl_type_t fuchsia_paver_PaverWipeVolumeRequestTable;
extern "C" const fidl_type_t fuchsia_paver_PaverWipeVolumeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_paver_PaverWipeVolumeResponseTable;
[[maybe_unused]]
constexpr uint64_t kPaver_InitializePartitionTables_Ordinal = 0x5b692a5000000000lu;
[[maybe_unused]]
constexpr uint64_t kPaver_InitializePartitionTables_GenOrdinal = 0xee77c2ceea6edddlu;
extern "C" const fidl_type_t fuchsia_paver_PaverInitializePartitionTablesRequestTable;
extern "C" const fidl_type_t fuchsia_paver_PaverInitializePartitionTablesResponseTable;
extern "C" const fidl_type_t v1_fuchsia_paver_PaverInitializePartitionTablesResponseTable;
[[maybe_unused]]
constexpr uint64_t kPaver_WipePartitionTables_Ordinal = 0x5930adfc00000000lu;
[[maybe_unused]]
constexpr uint64_t kPaver_WipePartitionTables_GenOrdinal = 0x327490536ea29d7clu;
extern "C" const fidl_type_t fuchsia_paver_PaverWipePartitionTablesRequestTable;
extern "C" const fidl_type_t fuchsia_paver_PaverWipePartitionTablesResponseTable;
extern "C" const fidl_type_t v1_fuchsia_paver_PaverWipePartitionTablesResponseTable;

}  // namespace
template <>
Paver::ResultOf::InitializeAbr_Impl<Paver::InitializeAbrResponse>::InitializeAbr_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<InitializeAbrRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, InitializeAbrRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(InitializeAbrRequest));
  ::fidl::DecodedMessage<InitializeAbrRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Paver::InPlace::InitializeAbr(std::move(_client_end), Super::response_buffer()));
}

Paver::ResultOf::InitializeAbr Paver::SyncClient::InitializeAbr() {
  return ResultOf::InitializeAbr(zx::unowned_channel(this->channel_));
}

Paver::ResultOf::InitializeAbr Paver::Call::InitializeAbr(zx::unowned_channel _client_end) {
  return ResultOf::InitializeAbr(std::move(_client_end));
}

template <>
Paver::UnownedResultOf::InitializeAbr_Impl<Paver::InitializeAbrResponse>::InitializeAbr_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(InitializeAbrRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, InitializeAbrRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(InitializeAbrRequest));
  ::fidl::DecodedMessage<InitializeAbrRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Paver::InPlace::InitializeAbr(std::move(_client_end), std::move(_response_buffer)));
}

Paver::UnownedResultOf::InitializeAbr Paver::SyncClient::InitializeAbr(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::InitializeAbr(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Paver::UnownedResultOf::InitializeAbr Paver::Call::InitializeAbr(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::InitializeAbr(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Paver::InitializeAbrResponse> Paver::InPlace::InitializeAbr(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(InitializeAbrRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<InitializeAbrRequest> params(std::move(_request_buffer));
  Paver::SetTransactionHeaderFor::InitializeAbrRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Paver::InitializeAbrResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<InitializeAbrRequest, InitializeAbrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Paver::InitializeAbrResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Paver::ResultOf::QueryActiveConfiguration_Impl<Paver::QueryActiveConfigurationResponse>::QueryActiveConfiguration_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<QueryActiveConfigurationRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, QueryActiveConfigurationRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(QueryActiveConfigurationRequest));
  ::fidl::DecodedMessage<QueryActiveConfigurationRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Paver::InPlace::QueryActiveConfiguration(std::move(_client_end), Super::response_buffer()));
}

Paver::ResultOf::QueryActiveConfiguration Paver::SyncClient::QueryActiveConfiguration() {
  return ResultOf::QueryActiveConfiguration(zx::unowned_channel(this->channel_));
}

Paver::ResultOf::QueryActiveConfiguration Paver::Call::QueryActiveConfiguration(zx::unowned_channel _client_end) {
  return ResultOf::QueryActiveConfiguration(std::move(_client_end));
}

template <>
Paver::UnownedResultOf::QueryActiveConfiguration_Impl<Paver::QueryActiveConfigurationResponse>::QueryActiveConfiguration_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(QueryActiveConfigurationRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, QueryActiveConfigurationRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(QueryActiveConfigurationRequest));
  ::fidl::DecodedMessage<QueryActiveConfigurationRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Paver::InPlace::QueryActiveConfiguration(std::move(_client_end), std::move(_response_buffer)));
}

Paver::UnownedResultOf::QueryActiveConfiguration Paver::SyncClient::QueryActiveConfiguration(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::QueryActiveConfiguration(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Paver::UnownedResultOf::QueryActiveConfiguration Paver::Call::QueryActiveConfiguration(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::QueryActiveConfiguration(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Paver::QueryActiveConfigurationResponse> Paver::InPlace::QueryActiveConfiguration(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(QueryActiveConfigurationRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<QueryActiveConfigurationRequest> params(std::move(_request_buffer));
  Paver::SetTransactionHeaderFor::QueryActiveConfigurationRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Paver::QueryActiveConfigurationResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<QueryActiveConfigurationRequest, QueryActiveConfigurationResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Paver::QueryActiveConfigurationResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Paver::ResultOf::QueryConfigurationStatus_Impl<Paver::QueryConfigurationStatusResponse>::QueryConfigurationStatus_Impl(zx::unowned_channel _client_end, ::llcpp::fuchsia::paver::Configuration configuration) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<QueryConfigurationStatusRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, QueryConfigurationStatusRequest::PrimarySize);
  auto& _request = *reinterpret_cast<QueryConfigurationStatusRequest*>(_write_bytes);
  _request.configuration = std::move(configuration);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(QueryConfigurationStatusRequest));
  ::fidl::DecodedMessage<QueryConfigurationStatusRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Paver::InPlace::QueryConfigurationStatus(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Paver::ResultOf::QueryConfigurationStatus Paver::SyncClient::QueryConfigurationStatus(::llcpp::fuchsia::paver::Configuration configuration) {
  return ResultOf::QueryConfigurationStatus(zx::unowned_channel(this->channel_), std::move(configuration));
}

Paver::ResultOf::QueryConfigurationStatus Paver::Call::QueryConfigurationStatus(zx::unowned_channel _client_end, ::llcpp::fuchsia::paver::Configuration configuration) {
  return ResultOf::QueryConfigurationStatus(std::move(_client_end), std::move(configuration));
}

template <>
Paver::UnownedResultOf::QueryConfigurationStatus_Impl<Paver::QueryConfigurationStatusResponse>::QueryConfigurationStatus_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::paver::Configuration configuration, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < QueryConfigurationStatusRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<QueryConfigurationStatusResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, QueryConfigurationStatusRequest::PrimarySize);
  auto& _request = *reinterpret_cast<QueryConfigurationStatusRequest*>(_request_buffer.data());
  _request.configuration = std::move(configuration);
  _request_buffer.set_actual(sizeof(QueryConfigurationStatusRequest));
  ::fidl::DecodedMessage<QueryConfigurationStatusRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Paver::InPlace::QueryConfigurationStatus(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Paver::UnownedResultOf::QueryConfigurationStatus Paver::SyncClient::QueryConfigurationStatus(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::paver::Configuration configuration, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::QueryConfigurationStatus(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(configuration), std::move(_response_buffer));
}

Paver::UnownedResultOf::QueryConfigurationStatus Paver::Call::QueryConfigurationStatus(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::paver::Configuration configuration, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::QueryConfigurationStatus(std::move(_client_end), std::move(_request_buffer), std::move(configuration), std::move(_response_buffer));
}

::fidl::DecodeResult<Paver::QueryConfigurationStatusResponse> Paver::InPlace::QueryConfigurationStatus(zx::unowned_channel _client_end, ::fidl::DecodedMessage<QueryConfigurationStatusRequest> params, ::fidl::BytePart response_buffer) {
  Paver::SetTransactionHeaderFor::QueryConfigurationStatusRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Paver::QueryConfigurationStatusResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<QueryConfigurationStatusRequest, QueryConfigurationStatusResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Paver::QueryConfigurationStatusResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Paver::ResultOf::SetConfigurationActive_Impl<Paver::SetConfigurationActiveResponse>::SetConfigurationActive_Impl(zx::unowned_channel _client_end, ::llcpp::fuchsia::paver::Configuration configuration) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetConfigurationActiveRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetConfigurationActiveRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetConfigurationActiveRequest*>(_write_bytes);
  _request.configuration = std::move(configuration);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetConfigurationActiveRequest));
  ::fidl::DecodedMessage<SetConfigurationActiveRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Paver::InPlace::SetConfigurationActive(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Paver::ResultOf::SetConfigurationActive Paver::SyncClient::SetConfigurationActive(::llcpp::fuchsia::paver::Configuration configuration) {
  return ResultOf::SetConfigurationActive(zx::unowned_channel(this->channel_), std::move(configuration));
}

Paver::ResultOf::SetConfigurationActive Paver::Call::SetConfigurationActive(zx::unowned_channel _client_end, ::llcpp::fuchsia::paver::Configuration configuration) {
  return ResultOf::SetConfigurationActive(std::move(_client_end), std::move(configuration));
}

template <>
Paver::UnownedResultOf::SetConfigurationActive_Impl<Paver::SetConfigurationActiveResponse>::SetConfigurationActive_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::paver::Configuration configuration, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < SetConfigurationActiveRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<SetConfigurationActiveResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, SetConfigurationActiveRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetConfigurationActiveRequest*>(_request_buffer.data());
  _request.configuration = std::move(configuration);
  _request_buffer.set_actual(sizeof(SetConfigurationActiveRequest));
  ::fidl::DecodedMessage<SetConfigurationActiveRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Paver::InPlace::SetConfigurationActive(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Paver::UnownedResultOf::SetConfigurationActive Paver::SyncClient::SetConfigurationActive(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::paver::Configuration configuration, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetConfigurationActive(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(configuration), std::move(_response_buffer));
}

Paver::UnownedResultOf::SetConfigurationActive Paver::Call::SetConfigurationActive(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::paver::Configuration configuration, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetConfigurationActive(std::move(_client_end), std::move(_request_buffer), std::move(configuration), std::move(_response_buffer));
}

::fidl::DecodeResult<Paver::SetConfigurationActiveResponse> Paver::InPlace::SetConfigurationActive(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetConfigurationActiveRequest> params, ::fidl::BytePart response_buffer) {
  Paver::SetTransactionHeaderFor::SetConfigurationActiveRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Paver::SetConfigurationActiveResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SetConfigurationActiveRequest, SetConfigurationActiveResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Paver::SetConfigurationActiveResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Paver::ResultOf::SetConfigurationUnbootable_Impl<Paver::SetConfigurationUnbootableResponse>::SetConfigurationUnbootable_Impl(zx::unowned_channel _client_end, ::llcpp::fuchsia::paver::Configuration configuration) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetConfigurationUnbootableRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetConfigurationUnbootableRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetConfigurationUnbootableRequest*>(_write_bytes);
  _request.configuration = std::move(configuration);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetConfigurationUnbootableRequest));
  ::fidl::DecodedMessage<SetConfigurationUnbootableRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Paver::InPlace::SetConfigurationUnbootable(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Paver::ResultOf::SetConfigurationUnbootable Paver::SyncClient::SetConfigurationUnbootable(::llcpp::fuchsia::paver::Configuration configuration) {
  return ResultOf::SetConfigurationUnbootable(zx::unowned_channel(this->channel_), std::move(configuration));
}

Paver::ResultOf::SetConfigurationUnbootable Paver::Call::SetConfigurationUnbootable(zx::unowned_channel _client_end, ::llcpp::fuchsia::paver::Configuration configuration) {
  return ResultOf::SetConfigurationUnbootable(std::move(_client_end), std::move(configuration));
}

template <>
Paver::UnownedResultOf::SetConfigurationUnbootable_Impl<Paver::SetConfigurationUnbootableResponse>::SetConfigurationUnbootable_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::paver::Configuration configuration, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < SetConfigurationUnbootableRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<SetConfigurationUnbootableResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, SetConfigurationUnbootableRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetConfigurationUnbootableRequest*>(_request_buffer.data());
  _request.configuration = std::move(configuration);
  _request_buffer.set_actual(sizeof(SetConfigurationUnbootableRequest));
  ::fidl::DecodedMessage<SetConfigurationUnbootableRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Paver::InPlace::SetConfigurationUnbootable(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Paver::UnownedResultOf::SetConfigurationUnbootable Paver::SyncClient::SetConfigurationUnbootable(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::paver::Configuration configuration, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetConfigurationUnbootable(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(configuration), std::move(_response_buffer));
}

Paver::UnownedResultOf::SetConfigurationUnbootable Paver::Call::SetConfigurationUnbootable(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::paver::Configuration configuration, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetConfigurationUnbootable(std::move(_client_end), std::move(_request_buffer), std::move(configuration), std::move(_response_buffer));
}

::fidl::DecodeResult<Paver::SetConfigurationUnbootableResponse> Paver::InPlace::SetConfigurationUnbootable(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetConfigurationUnbootableRequest> params, ::fidl::BytePart response_buffer) {
  Paver::SetTransactionHeaderFor::SetConfigurationUnbootableRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Paver::SetConfigurationUnbootableResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SetConfigurationUnbootableRequest, SetConfigurationUnbootableResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Paver::SetConfigurationUnbootableResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Paver::ResultOf::SetActiveConfigurationHealthy_Impl<Paver::SetActiveConfigurationHealthyResponse>::SetActiveConfigurationHealthy_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetActiveConfigurationHealthyRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetActiveConfigurationHealthyRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetActiveConfigurationHealthyRequest));
  ::fidl::DecodedMessage<SetActiveConfigurationHealthyRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Paver::InPlace::SetActiveConfigurationHealthy(std::move(_client_end), Super::response_buffer()));
}

Paver::ResultOf::SetActiveConfigurationHealthy Paver::SyncClient::SetActiveConfigurationHealthy() {
  return ResultOf::SetActiveConfigurationHealthy(zx::unowned_channel(this->channel_));
}

Paver::ResultOf::SetActiveConfigurationHealthy Paver::Call::SetActiveConfigurationHealthy(zx::unowned_channel _client_end) {
  return ResultOf::SetActiveConfigurationHealthy(std::move(_client_end));
}

template <>
Paver::UnownedResultOf::SetActiveConfigurationHealthy_Impl<Paver::SetActiveConfigurationHealthyResponse>::SetActiveConfigurationHealthy_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(SetActiveConfigurationHealthyRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, SetActiveConfigurationHealthyRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(SetActiveConfigurationHealthyRequest));
  ::fidl::DecodedMessage<SetActiveConfigurationHealthyRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Paver::InPlace::SetActiveConfigurationHealthy(std::move(_client_end), std::move(_response_buffer)));
}

Paver::UnownedResultOf::SetActiveConfigurationHealthy Paver::SyncClient::SetActiveConfigurationHealthy(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetActiveConfigurationHealthy(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Paver::UnownedResultOf::SetActiveConfigurationHealthy Paver::Call::SetActiveConfigurationHealthy(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetActiveConfigurationHealthy(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Paver::SetActiveConfigurationHealthyResponse> Paver::InPlace::SetActiveConfigurationHealthy(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(SetActiveConfigurationHealthyRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<SetActiveConfigurationHealthyRequest> params(std::move(_request_buffer));
  Paver::SetTransactionHeaderFor::SetActiveConfigurationHealthyRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Paver::SetActiveConfigurationHealthyResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SetActiveConfigurationHealthyRequest, SetActiveConfigurationHealthyResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Paver::SetActiveConfigurationHealthyResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Paver::ResultOf::ReadAsset_Impl<Paver::ReadAssetResponse>::ReadAsset_Impl(zx::unowned_channel _client_end, ::llcpp::fuchsia::paver::Configuration configuration, ::llcpp::fuchsia::paver::Asset asset) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReadAssetRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ReadAssetRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReadAssetRequest*>(_write_bytes);
  _request.configuration = std::move(configuration);
  _request.asset = std::move(asset);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ReadAssetRequest));
  ::fidl::DecodedMessage<ReadAssetRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Paver::InPlace::ReadAsset(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Paver::ResultOf::ReadAsset Paver::SyncClient::ReadAsset(::llcpp::fuchsia::paver::Configuration configuration, ::llcpp::fuchsia::paver::Asset asset) {
  return ResultOf::ReadAsset(zx::unowned_channel(this->channel_), std::move(configuration), std::move(asset));
}

Paver::ResultOf::ReadAsset Paver::Call::ReadAsset(zx::unowned_channel _client_end, ::llcpp::fuchsia::paver::Configuration configuration, ::llcpp::fuchsia::paver::Asset asset) {
  return ResultOf::ReadAsset(std::move(_client_end), std::move(configuration), std::move(asset));
}

template <>
Paver::UnownedResultOf::ReadAsset_Impl<Paver::ReadAssetResponse>::ReadAsset_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::paver::Configuration configuration, ::llcpp::fuchsia::paver::Asset asset, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < ReadAssetRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<ReadAssetResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, ReadAssetRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReadAssetRequest*>(_request_buffer.data());
  _request.configuration = std::move(configuration);
  _request.asset = std::move(asset);
  _request_buffer.set_actual(sizeof(ReadAssetRequest));
  ::fidl::DecodedMessage<ReadAssetRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Paver::InPlace::ReadAsset(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Paver::UnownedResultOf::ReadAsset Paver::SyncClient::ReadAsset(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::paver::Configuration configuration, ::llcpp::fuchsia::paver::Asset asset, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ReadAsset(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(configuration), std::move(asset), std::move(_response_buffer));
}

Paver::UnownedResultOf::ReadAsset Paver::Call::ReadAsset(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::paver::Configuration configuration, ::llcpp::fuchsia::paver::Asset asset, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ReadAsset(std::move(_client_end), std::move(_request_buffer), std::move(configuration), std::move(asset), std::move(_response_buffer));
}

::fidl::DecodeResult<Paver::ReadAssetResponse> Paver::InPlace::ReadAsset(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReadAssetRequest> params, ::fidl::BytePart response_buffer) {
  Paver::SetTransactionHeaderFor::ReadAssetRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Paver::ReadAssetResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ReadAssetRequest, ReadAssetResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Paver::ReadAssetResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Paver::ResultOf::WriteAsset_Impl<Paver::WriteAssetResponse>::WriteAsset_Impl(zx::unowned_channel _client_end, ::llcpp::fuchsia::paver::Configuration configuration, ::llcpp::fuchsia::paver::Asset asset, ::llcpp::fuchsia::mem::Buffer payload) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WriteAssetRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, WriteAssetRequest::PrimarySize);
  auto& _request = *reinterpret_cast<WriteAssetRequest*>(_write_bytes);
  _request.configuration = std::move(configuration);
  _request.asset = std::move(asset);
  _request.payload = std::move(payload);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(WriteAssetRequest));
  ::fidl::DecodedMessage<WriteAssetRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Paver::InPlace::WriteAsset(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Paver::ResultOf::WriteAsset Paver::SyncClient::WriteAsset(::llcpp::fuchsia::paver::Configuration configuration, ::llcpp::fuchsia::paver::Asset asset, ::llcpp::fuchsia::mem::Buffer payload) {
  return ResultOf::WriteAsset(zx::unowned_channel(this->channel_), std::move(configuration), std::move(asset), std::move(payload));
}

Paver::ResultOf::WriteAsset Paver::Call::WriteAsset(zx::unowned_channel _client_end, ::llcpp::fuchsia::paver::Configuration configuration, ::llcpp::fuchsia::paver::Asset asset, ::llcpp::fuchsia::mem::Buffer payload) {
  return ResultOf::WriteAsset(std::move(_client_end), std::move(configuration), std::move(asset), std::move(payload));
}

template <>
Paver::UnownedResultOf::WriteAsset_Impl<Paver::WriteAssetResponse>::WriteAsset_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::paver::Configuration configuration, ::llcpp::fuchsia::paver::Asset asset, ::llcpp::fuchsia::mem::Buffer payload, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < WriteAssetRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<WriteAssetResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, WriteAssetRequest::PrimarySize);
  auto& _request = *reinterpret_cast<WriteAssetRequest*>(_request_buffer.data());
  _request.configuration = std::move(configuration);
  _request.asset = std::move(asset);
  _request.payload = std::move(payload);
  _request_buffer.set_actual(sizeof(WriteAssetRequest));
  ::fidl::DecodedMessage<WriteAssetRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Paver::InPlace::WriteAsset(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Paver::UnownedResultOf::WriteAsset Paver::SyncClient::WriteAsset(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::paver::Configuration configuration, ::llcpp::fuchsia::paver::Asset asset, ::llcpp::fuchsia::mem::Buffer payload, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WriteAsset(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(configuration), std::move(asset), std::move(payload), std::move(_response_buffer));
}

Paver::UnownedResultOf::WriteAsset Paver::Call::WriteAsset(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::paver::Configuration configuration, ::llcpp::fuchsia::paver::Asset asset, ::llcpp::fuchsia::mem::Buffer payload, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WriteAsset(std::move(_client_end), std::move(_request_buffer), std::move(configuration), std::move(asset), std::move(payload), std::move(_response_buffer));
}

::fidl::DecodeResult<Paver::WriteAssetResponse> Paver::InPlace::WriteAsset(zx::unowned_channel _client_end, ::fidl::DecodedMessage<WriteAssetRequest> params, ::fidl::BytePart response_buffer) {
  Paver::SetTransactionHeaderFor::WriteAssetRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Paver::WriteAssetResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<WriteAssetRequest, WriteAssetResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Paver::WriteAssetResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Paver::ResultOf::WriteVolumes_Impl<Paver::WriteVolumesResponse>::WriteVolumes_Impl(zx::unowned_channel _client_end, ::zx::channel payload) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WriteVolumesRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, WriteVolumesRequest::PrimarySize);
  auto& _request = *reinterpret_cast<WriteVolumesRequest*>(_write_bytes);
  _request.payload = std::move(payload);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(WriteVolumesRequest));
  ::fidl::DecodedMessage<WriteVolumesRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Paver::InPlace::WriteVolumes(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Paver::ResultOf::WriteVolumes Paver::SyncClient::WriteVolumes(::zx::channel payload) {
  return ResultOf::WriteVolumes(zx::unowned_channel(this->channel_), std::move(payload));
}

Paver::ResultOf::WriteVolumes Paver::Call::WriteVolumes(zx::unowned_channel _client_end, ::zx::channel payload) {
  return ResultOf::WriteVolumes(std::move(_client_end), std::move(payload));
}

template <>
Paver::UnownedResultOf::WriteVolumes_Impl<Paver::WriteVolumesResponse>::WriteVolumes_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel payload, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < WriteVolumesRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<WriteVolumesResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, WriteVolumesRequest::PrimarySize);
  auto& _request = *reinterpret_cast<WriteVolumesRequest*>(_request_buffer.data());
  _request.payload = std::move(payload);
  _request_buffer.set_actual(sizeof(WriteVolumesRequest));
  ::fidl::DecodedMessage<WriteVolumesRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Paver::InPlace::WriteVolumes(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Paver::UnownedResultOf::WriteVolumes Paver::SyncClient::WriteVolumes(::fidl::BytePart _request_buffer, ::zx::channel payload, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WriteVolumes(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(payload), std::move(_response_buffer));
}

Paver::UnownedResultOf::WriteVolumes Paver::Call::WriteVolumes(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel payload, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WriteVolumes(std::move(_client_end), std::move(_request_buffer), std::move(payload), std::move(_response_buffer));
}

::fidl::DecodeResult<Paver::WriteVolumesResponse> Paver::InPlace::WriteVolumes(zx::unowned_channel _client_end, ::fidl::DecodedMessage<WriteVolumesRequest> params, ::fidl::BytePart response_buffer) {
  Paver::SetTransactionHeaderFor::WriteVolumesRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Paver::WriteVolumesResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<WriteVolumesRequest, WriteVolumesResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Paver::WriteVolumesResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Paver::ResultOf::WriteBootloader_Impl<Paver::WriteBootloaderResponse>::WriteBootloader_Impl(zx::unowned_channel _client_end, ::llcpp::fuchsia::mem::Buffer payload) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WriteBootloaderRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, WriteBootloaderRequest::PrimarySize);
  auto& _request = *reinterpret_cast<WriteBootloaderRequest*>(_write_bytes);
  _request.payload = std::move(payload);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(WriteBootloaderRequest));
  ::fidl::DecodedMessage<WriteBootloaderRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Paver::InPlace::WriteBootloader(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Paver::ResultOf::WriteBootloader Paver::SyncClient::WriteBootloader(::llcpp::fuchsia::mem::Buffer payload) {
  return ResultOf::WriteBootloader(zx::unowned_channel(this->channel_), std::move(payload));
}

Paver::ResultOf::WriteBootloader Paver::Call::WriteBootloader(zx::unowned_channel _client_end, ::llcpp::fuchsia::mem::Buffer payload) {
  return ResultOf::WriteBootloader(std::move(_client_end), std::move(payload));
}

template <>
Paver::UnownedResultOf::WriteBootloader_Impl<Paver::WriteBootloaderResponse>::WriteBootloader_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::mem::Buffer payload, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < WriteBootloaderRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<WriteBootloaderResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, WriteBootloaderRequest::PrimarySize);
  auto& _request = *reinterpret_cast<WriteBootloaderRequest*>(_request_buffer.data());
  _request.payload = std::move(payload);
  _request_buffer.set_actual(sizeof(WriteBootloaderRequest));
  ::fidl::DecodedMessage<WriteBootloaderRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Paver::InPlace::WriteBootloader(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Paver::UnownedResultOf::WriteBootloader Paver::SyncClient::WriteBootloader(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::mem::Buffer payload, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WriteBootloader(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(payload), std::move(_response_buffer));
}

Paver::UnownedResultOf::WriteBootloader Paver::Call::WriteBootloader(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::mem::Buffer payload, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WriteBootloader(std::move(_client_end), std::move(_request_buffer), std::move(payload), std::move(_response_buffer));
}

::fidl::DecodeResult<Paver::WriteBootloaderResponse> Paver::InPlace::WriteBootloader(zx::unowned_channel _client_end, ::fidl::DecodedMessage<WriteBootloaderRequest> params, ::fidl::BytePart response_buffer) {
  Paver::SetTransactionHeaderFor::WriteBootloaderRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Paver::WriteBootloaderResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<WriteBootloaderRequest, WriteBootloaderResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Paver::WriteBootloaderResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Paver::ResultOf::WriteDataFile_Impl<Paver::WriteDataFileResponse>::WriteDataFile_Impl(zx::unowned_channel _client_end, ::fidl::StringView filename, ::llcpp::fuchsia::mem::Buffer payload) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WriteDataFileRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  WriteDataFileRequest _request = {};
  _request.filename = std::move(filename);
  _request.payload = std::move(payload);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<WriteDataFileRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Paver::InPlace::WriteDataFile(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Paver::ResultOf::WriteDataFile Paver::SyncClient::WriteDataFile(::fidl::StringView filename, ::llcpp::fuchsia::mem::Buffer payload) {
  return ResultOf::WriteDataFile(zx::unowned_channel(this->channel_), std::move(filename), std::move(payload));
}

Paver::ResultOf::WriteDataFile Paver::Call::WriteDataFile(zx::unowned_channel _client_end, ::fidl::StringView filename, ::llcpp::fuchsia::mem::Buffer payload) {
  return ResultOf::WriteDataFile(std::move(_client_end), std::move(filename), std::move(payload));
}

template <>
Paver::UnownedResultOf::WriteDataFile_Impl<Paver::WriteDataFileResponse>::WriteDataFile_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView filename, ::llcpp::fuchsia::mem::Buffer payload, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < WriteDataFileRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<WriteDataFileResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  WriteDataFileRequest _request = {};
  _request.filename = std::move(filename);
  _request.payload = std::move(payload);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<WriteDataFileRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Paver::InPlace::WriteDataFile(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Paver::UnownedResultOf::WriteDataFile Paver::SyncClient::WriteDataFile(::fidl::BytePart _request_buffer, ::fidl::StringView filename, ::llcpp::fuchsia::mem::Buffer payload, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WriteDataFile(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(filename), std::move(payload), std::move(_response_buffer));
}

Paver::UnownedResultOf::WriteDataFile Paver::Call::WriteDataFile(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView filename, ::llcpp::fuchsia::mem::Buffer payload, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WriteDataFile(std::move(_client_end), std::move(_request_buffer), std::move(filename), std::move(payload), std::move(_response_buffer));
}

::fidl::DecodeResult<Paver::WriteDataFileResponse> Paver::InPlace::WriteDataFile(zx::unowned_channel _client_end, ::fidl::DecodedMessage<WriteDataFileRequest> params, ::fidl::BytePart response_buffer) {
  Paver::SetTransactionHeaderFor::WriteDataFileRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Paver::WriteDataFileResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<WriteDataFileRequest, WriteDataFileResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Paver::WriteDataFileResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Paver::ResultOf::WipeVolume_Impl<Paver::WipeVolumeResponse>::WipeVolume_Impl(zx::unowned_channel _client_end, ::zx::channel block_device) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WipeVolumeRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, WipeVolumeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<WipeVolumeRequest*>(_write_bytes);
  _request.block_device = std::move(block_device);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(WipeVolumeRequest));
  ::fidl::DecodedMessage<WipeVolumeRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Paver::InPlace::WipeVolume(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Paver::ResultOf::WipeVolume Paver::SyncClient::WipeVolume(::zx::channel block_device) {
  return ResultOf::WipeVolume(zx::unowned_channel(this->channel_), std::move(block_device));
}

Paver::ResultOf::WipeVolume Paver::Call::WipeVolume(zx::unowned_channel _client_end, ::zx::channel block_device) {
  return ResultOf::WipeVolume(std::move(_client_end), std::move(block_device));
}

template <>
Paver::UnownedResultOf::WipeVolume_Impl<Paver::WipeVolumeResponse>::WipeVolume_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel block_device, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < WipeVolumeRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<WipeVolumeResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, WipeVolumeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<WipeVolumeRequest*>(_request_buffer.data());
  _request.block_device = std::move(block_device);
  _request_buffer.set_actual(sizeof(WipeVolumeRequest));
  ::fidl::DecodedMessage<WipeVolumeRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Paver::InPlace::WipeVolume(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Paver::UnownedResultOf::WipeVolume Paver::SyncClient::WipeVolume(::fidl::BytePart _request_buffer, ::zx::channel block_device, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WipeVolume(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(block_device), std::move(_response_buffer));
}

Paver::UnownedResultOf::WipeVolume Paver::Call::WipeVolume(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel block_device, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WipeVolume(std::move(_client_end), std::move(_request_buffer), std::move(block_device), std::move(_response_buffer));
}

::fidl::DecodeResult<Paver::WipeVolumeResponse> Paver::InPlace::WipeVolume(zx::unowned_channel _client_end, ::fidl::DecodedMessage<WipeVolumeRequest> params, ::fidl::BytePart response_buffer) {
  Paver::SetTransactionHeaderFor::WipeVolumeRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Paver::WipeVolumeResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<WipeVolumeRequest, WipeVolumeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Paver::WipeVolumeResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Paver::ResultOf::InitializePartitionTables_Impl<Paver::InitializePartitionTablesResponse>::InitializePartitionTables_Impl(zx::unowned_channel _client_end, ::zx::channel gpt_block_device) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<InitializePartitionTablesRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, InitializePartitionTablesRequest::PrimarySize);
  auto& _request = *reinterpret_cast<InitializePartitionTablesRequest*>(_write_bytes);
  _request.gpt_block_device = std::move(gpt_block_device);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(InitializePartitionTablesRequest));
  ::fidl::DecodedMessage<InitializePartitionTablesRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Paver::InPlace::InitializePartitionTables(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Paver::ResultOf::InitializePartitionTables Paver::SyncClient::InitializePartitionTables(::zx::channel gpt_block_device) {
  return ResultOf::InitializePartitionTables(zx::unowned_channel(this->channel_), std::move(gpt_block_device));
}

Paver::ResultOf::InitializePartitionTables Paver::Call::InitializePartitionTables(zx::unowned_channel _client_end, ::zx::channel gpt_block_device) {
  return ResultOf::InitializePartitionTables(std::move(_client_end), std::move(gpt_block_device));
}

template <>
Paver::UnownedResultOf::InitializePartitionTables_Impl<Paver::InitializePartitionTablesResponse>::InitializePartitionTables_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel gpt_block_device, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < InitializePartitionTablesRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<InitializePartitionTablesResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, InitializePartitionTablesRequest::PrimarySize);
  auto& _request = *reinterpret_cast<InitializePartitionTablesRequest*>(_request_buffer.data());
  _request.gpt_block_device = std::move(gpt_block_device);
  _request_buffer.set_actual(sizeof(InitializePartitionTablesRequest));
  ::fidl::DecodedMessage<InitializePartitionTablesRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Paver::InPlace::InitializePartitionTables(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Paver::UnownedResultOf::InitializePartitionTables Paver::SyncClient::InitializePartitionTables(::fidl::BytePart _request_buffer, ::zx::channel gpt_block_device, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::InitializePartitionTables(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(gpt_block_device), std::move(_response_buffer));
}

Paver::UnownedResultOf::InitializePartitionTables Paver::Call::InitializePartitionTables(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel gpt_block_device, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::InitializePartitionTables(std::move(_client_end), std::move(_request_buffer), std::move(gpt_block_device), std::move(_response_buffer));
}

::fidl::DecodeResult<Paver::InitializePartitionTablesResponse> Paver::InPlace::InitializePartitionTables(zx::unowned_channel _client_end, ::fidl::DecodedMessage<InitializePartitionTablesRequest> params, ::fidl::BytePart response_buffer) {
  Paver::SetTransactionHeaderFor::InitializePartitionTablesRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Paver::InitializePartitionTablesResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<InitializePartitionTablesRequest, InitializePartitionTablesResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Paver::InitializePartitionTablesResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Paver::ResultOf::WipePartitionTables_Impl<Paver::WipePartitionTablesResponse>::WipePartitionTables_Impl(zx::unowned_channel _client_end, ::zx::channel block_device) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WipePartitionTablesRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, WipePartitionTablesRequest::PrimarySize);
  auto& _request = *reinterpret_cast<WipePartitionTablesRequest*>(_write_bytes);
  _request.block_device = std::move(block_device);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(WipePartitionTablesRequest));
  ::fidl::DecodedMessage<WipePartitionTablesRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Paver::InPlace::WipePartitionTables(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Paver::ResultOf::WipePartitionTables Paver::SyncClient::WipePartitionTables(::zx::channel block_device) {
  return ResultOf::WipePartitionTables(zx::unowned_channel(this->channel_), std::move(block_device));
}

Paver::ResultOf::WipePartitionTables Paver::Call::WipePartitionTables(zx::unowned_channel _client_end, ::zx::channel block_device) {
  return ResultOf::WipePartitionTables(std::move(_client_end), std::move(block_device));
}

template <>
Paver::UnownedResultOf::WipePartitionTables_Impl<Paver::WipePartitionTablesResponse>::WipePartitionTables_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel block_device, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < WipePartitionTablesRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<WipePartitionTablesResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, WipePartitionTablesRequest::PrimarySize);
  auto& _request = *reinterpret_cast<WipePartitionTablesRequest*>(_request_buffer.data());
  _request.block_device = std::move(block_device);
  _request_buffer.set_actual(sizeof(WipePartitionTablesRequest));
  ::fidl::DecodedMessage<WipePartitionTablesRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Paver::InPlace::WipePartitionTables(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Paver::UnownedResultOf::WipePartitionTables Paver::SyncClient::WipePartitionTables(::fidl::BytePart _request_buffer, ::zx::channel block_device, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WipePartitionTables(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(block_device), std::move(_response_buffer));
}

Paver::UnownedResultOf::WipePartitionTables Paver::Call::WipePartitionTables(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel block_device, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WipePartitionTables(std::move(_client_end), std::move(_request_buffer), std::move(block_device), std::move(_response_buffer));
}

::fidl::DecodeResult<Paver::WipePartitionTablesResponse> Paver::InPlace::WipePartitionTables(zx::unowned_channel _client_end, ::fidl::DecodedMessage<WipePartitionTablesRequest> params, ::fidl::BytePart response_buffer) {
  Paver::SetTransactionHeaderFor::WipePartitionTablesRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Paver::WipePartitionTablesResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<WipePartitionTablesRequest, WipePartitionTablesResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Paver::WipePartitionTablesResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool Paver::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kPaver_InitializeAbr_Ordinal:
    case kPaver_InitializeAbr_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<InitializeAbrRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->InitializeAbr(
          Interface::InitializeAbrCompleter::Sync(txn));
      return true;
    }
    case kPaver_QueryActiveConfiguration_Ordinal:
    case kPaver_QueryActiveConfiguration_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<QueryActiveConfigurationRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->QueryActiveConfiguration(
          Interface::QueryActiveConfigurationCompleter::Sync(txn));
      return true;
    }
    case kPaver_QueryConfigurationStatus_Ordinal:
    case kPaver_QueryConfigurationStatus_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<QueryConfigurationStatusRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->QueryConfigurationStatus(std::move(message->configuration),
          Interface::QueryConfigurationStatusCompleter::Sync(txn));
      return true;
    }
    case kPaver_SetConfigurationActive_Ordinal:
    case kPaver_SetConfigurationActive_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetConfigurationActiveRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetConfigurationActive(std::move(message->configuration),
          Interface::SetConfigurationActiveCompleter::Sync(txn));
      return true;
    }
    case kPaver_SetConfigurationUnbootable_Ordinal:
    case kPaver_SetConfigurationUnbootable_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetConfigurationUnbootableRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetConfigurationUnbootable(std::move(message->configuration),
          Interface::SetConfigurationUnbootableCompleter::Sync(txn));
      return true;
    }
    case kPaver_SetActiveConfigurationHealthy_Ordinal:
    case kPaver_SetActiveConfigurationHealthy_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetActiveConfigurationHealthyRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->SetActiveConfigurationHealthy(
          Interface::SetActiveConfigurationHealthyCompleter::Sync(txn));
      return true;
    }
    case kPaver_ReadAsset_Ordinal:
    case kPaver_ReadAsset_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ReadAssetRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->ReadAsset(std::move(message->configuration), std::move(message->asset),
          Interface::ReadAssetCompleter::Sync(txn));
      return true;
    }
    case kPaver_WriteAsset_Ordinal:
    case kPaver_WriteAsset_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<WriteAssetRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->WriteAsset(std::move(message->configuration), std::move(message->asset), std::move(message->payload),
          Interface::WriteAssetCompleter::Sync(txn));
      return true;
    }
    case kPaver_WriteVolumes_Ordinal:
    case kPaver_WriteVolumes_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<WriteVolumesRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->WriteVolumes(std::move(message->payload),
          Interface::WriteVolumesCompleter::Sync(txn));
      return true;
    }
    case kPaver_WriteBootloader_Ordinal:
    case kPaver_WriteBootloader_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<WriteBootloaderRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->WriteBootloader(std::move(message->payload),
          Interface::WriteBootloaderCompleter::Sync(txn));
      return true;
    }
    case kPaver_WriteDataFile_Ordinal:
    case kPaver_WriteDataFile_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<WriteDataFileRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->WriteDataFile(std::move(message->filename), std::move(message->payload),
          Interface::WriteDataFileCompleter::Sync(txn));
      return true;
    }
    case kPaver_WipeVolume_Ordinal:
    case kPaver_WipeVolume_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<WipeVolumeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->WipeVolume(std::move(message->block_device),
          Interface::WipeVolumeCompleter::Sync(txn));
      return true;
    }
    case kPaver_InitializePartitionTables_Ordinal:
    case kPaver_InitializePartitionTables_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<InitializePartitionTablesRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->InitializePartitionTables(std::move(message->gpt_block_device),
          Interface::InitializePartitionTablesCompleter::Sync(txn));
      return true;
    }
    case kPaver_WipePartitionTables_Ordinal:
    case kPaver_WipePartitionTables_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<WipePartitionTablesRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->WipePartitionTables(std::move(message->block_device),
          Interface::WipePartitionTablesCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Paver::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void Paver::Interface::InitializeAbrCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<InitializeAbrResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<InitializeAbrResponse*>(_write_bytes);
  Paver::SetTransactionHeaderFor::InitializeAbrResponse(
      ::fidl::DecodedMessage<InitializeAbrResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              InitializeAbrResponse::PrimarySize,
              InitializeAbrResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(InitializeAbrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<InitializeAbrResponse>(std::move(_response_bytes)));
}

void Paver::Interface::InitializeAbrCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < InitializeAbrResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<InitializeAbrResponse*>(_buffer.data());
  Paver::SetTransactionHeaderFor::InitializeAbrResponse(
      ::fidl::DecodedMessage<InitializeAbrResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              InitializeAbrResponse::PrimarySize,
              InitializeAbrResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(InitializeAbrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<InitializeAbrResponse>(std::move(_buffer)));
}

void Paver::Interface::InitializeAbrCompleterBase::Reply(::fidl::DecodedMessage<InitializeAbrResponse> params) {
  Paver::SetTransactionHeaderFor::InitializeAbrResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Paver::Interface::QueryActiveConfigurationCompleterBase::Reply(::llcpp::fuchsia::paver::Paver_QueryActiveConfiguration_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<QueryActiveConfigurationResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<QueryActiveConfigurationResponse*>(_write_bytes);
  Paver::SetTransactionHeaderFor::QueryActiveConfigurationResponse(
      ::fidl::DecodedMessage<QueryActiveConfigurationResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              QueryActiveConfigurationResponse::PrimarySize,
              QueryActiveConfigurationResponse::PrimarySize)));
  _response.result = std::move(result);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(QueryActiveConfigurationResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<QueryActiveConfigurationResponse>(std::move(_response_bytes)));
}
void Paver::Interface::QueryActiveConfigurationCompleterBase::ReplySuccess(::llcpp::fuchsia::paver::Configuration configuration) {
  Paver_QueryActiveConfiguration_Response response;
  response.configuration = std::move(configuration);

  Reply(Paver_QueryActiveConfiguration_Result::WithResponse(&response));
}
void Paver::Interface::QueryActiveConfigurationCompleterBase::ReplyError(int32_t error) {
  Reply(Paver_QueryActiveConfiguration_Result::WithErr(&error));
}

void Paver::Interface::QueryActiveConfigurationCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::paver::Paver_QueryActiveConfiguration_Result result) {
  if (_buffer.capacity() < QueryActiveConfigurationResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<QueryActiveConfigurationResponse*>(_buffer.data());
  Paver::SetTransactionHeaderFor::QueryActiveConfigurationResponse(
      ::fidl::DecodedMessage<QueryActiveConfigurationResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              QueryActiveConfigurationResponse::PrimarySize,
              QueryActiveConfigurationResponse::PrimarySize)));
  _response.result = std::move(result);
  _buffer.set_actual(sizeof(QueryActiveConfigurationResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<QueryActiveConfigurationResponse>(std::move(_buffer)));
}
void Paver::Interface::QueryActiveConfigurationCompleterBase::ReplySuccess(::fidl::BytePart _buffer, ::llcpp::fuchsia::paver::Configuration configuration) {
  Paver_QueryActiveConfiguration_Response response;
  response.configuration = std::move(configuration);

  Reply(std::move(_buffer), Paver_QueryActiveConfiguration_Result::WithResponse(&response));
}

void Paver::Interface::QueryActiveConfigurationCompleterBase::Reply(::fidl::DecodedMessage<QueryActiveConfigurationResponse> params) {
  Paver::SetTransactionHeaderFor::QueryActiveConfigurationResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Paver::Interface::QueryConfigurationStatusCompleterBase::Reply(::llcpp::fuchsia::paver::Paver_QueryConfigurationStatus_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<QueryConfigurationStatusResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<QueryConfigurationStatusResponse*>(_write_bytes);
  Paver::SetTransactionHeaderFor::QueryConfigurationStatusResponse(
      ::fidl::DecodedMessage<QueryConfigurationStatusResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              QueryConfigurationStatusResponse::PrimarySize,
              QueryConfigurationStatusResponse::PrimarySize)));
  _response.result = std::move(result);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(QueryConfigurationStatusResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<QueryConfigurationStatusResponse>(std::move(_response_bytes)));
}
void Paver::Interface::QueryConfigurationStatusCompleterBase::ReplySuccess(::llcpp::fuchsia::paver::ConfigurationStatus status) {
  Paver_QueryConfigurationStatus_Response response;
  response.status = std::move(status);

  Reply(Paver_QueryConfigurationStatus_Result::WithResponse(&response));
}
void Paver::Interface::QueryConfigurationStatusCompleterBase::ReplyError(int32_t error) {
  Reply(Paver_QueryConfigurationStatus_Result::WithErr(&error));
}

void Paver::Interface::QueryConfigurationStatusCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::paver::Paver_QueryConfigurationStatus_Result result) {
  if (_buffer.capacity() < QueryConfigurationStatusResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<QueryConfigurationStatusResponse*>(_buffer.data());
  Paver::SetTransactionHeaderFor::QueryConfigurationStatusResponse(
      ::fidl::DecodedMessage<QueryConfigurationStatusResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              QueryConfigurationStatusResponse::PrimarySize,
              QueryConfigurationStatusResponse::PrimarySize)));
  _response.result = std::move(result);
  _buffer.set_actual(sizeof(QueryConfigurationStatusResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<QueryConfigurationStatusResponse>(std::move(_buffer)));
}
void Paver::Interface::QueryConfigurationStatusCompleterBase::ReplySuccess(::fidl::BytePart _buffer, ::llcpp::fuchsia::paver::ConfigurationStatus status) {
  Paver_QueryConfigurationStatus_Response response;
  response.status = std::move(status);

  Reply(std::move(_buffer), Paver_QueryConfigurationStatus_Result::WithResponse(&response));
}

void Paver::Interface::QueryConfigurationStatusCompleterBase::Reply(::fidl::DecodedMessage<QueryConfigurationStatusResponse> params) {
  Paver::SetTransactionHeaderFor::QueryConfigurationStatusResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Paver::Interface::SetConfigurationActiveCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetConfigurationActiveResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SetConfigurationActiveResponse*>(_write_bytes);
  Paver::SetTransactionHeaderFor::SetConfigurationActiveResponse(
      ::fidl::DecodedMessage<SetConfigurationActiveResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetConfigurationActiveResponse::PrimarySize,
              SetConfigurationActiveResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetConfigurationActiveResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetConfigurationActiveResponse>(std::move(_response_bytes)));
}

void Paver::Interface::SetConfigurationActiveCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < SetConfigurationActiveResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SetConfigurationActiveResponse*>(_buffer.data());
  Paver::SetTransactionHeaderFor::SetConfigurationActiveResponse(
      ::fidl::DecodedMessage<SetConfigurationActiveResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetConfigurationActiveResponse::PrimarySize,
              SetConfigurationActiveResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(SetConfigurationActiveResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetConfigurationActiveResponse>(std::move(_buffer)));
}

void Paver::Interface::SetConfigurationActiveCompleterBase::Reply(::fidl::DecodedMessage<SetConfigurationActiveResponse> params) {
  Paver::SetTransactionHeaderFor::SetConfigurationActiveResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Paver::Interface::SetConfigurationUnbootableCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetConfigurationUnbootableResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SetConfigurationUnbootableResponse*>(_write_bytes);
  Paver::SetTransactionHeaderFor::SetConfigurationUnbootableResponse(
      ::fidl::DecodedMessage<SetConfigurationUnbootableResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetConfigurationUnbootableResponse::PrimarySize,
              SetConfigurationUnbootableResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetConfigurationUnbootableResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetConfigurationUnbootableResponse>(std::move(_response_bytes)));
}

void Paver::Interface::SetConfigurationUnbootableCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < SetConfigurationUnbootableResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SetConfigurationUnbootableResponse*>(_buffer.data());
  Paver::SetTransactionHeaderFor::SetConfigurationUnbootableResponse(
      ::fidl::DecodedMessage<SetConfigurationUnbootableResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetConfigurationUnbootableResponse::PrimarySize,
              SetConfigurationUnbootableResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(SetConfigurationUnbootableResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetConfigurationUnbootableResponse>(std::move(_buffer)));
}

void Paver::Interface::SetConfigurationUnbootableCompleterBase::Reply(::fidl::DecodedMessage<SetConfigurationUnbootableResponse> params) {
  Paver::SetTransactionHeaderFor::SetConfigurationUnbootableResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Paver::Interface::SetActiveConfigurationHealthyCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetActiveConfigurationHealthyResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SetActiveConfigurationHealthyResponse*>(_write_bytes);
  Paver::SetTransactionHeaderFor::SetActiveConfigurationHealthyResponse(
      ::fidl::DecodedMessage<SetActiveConfigurationHealthyResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetActiveConfigurationHealthyResponse::PrimarySize,
              SetActiveConfigurationHealthyResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetActiveConfigurationHealthyResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetActiveConfigurationHealthyResponse>(std::move(_response_bytes)));
}

void Paver::Interface::SetActiveConfigurationHealthyCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < SetActiveConfigurationHealthyResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SetActiveConfigurationHealthyResponse*>(_buffer.data());
  Paver::SetTransactionHeaderFor::SetActiveConfigurationHealthyResponse(
      ::fidl::DecodedMessage<SetActiveConfigurationHealthyResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetActiveConfigurationHealthyResponse::PrimarySize,
              SetActiveConfigurationHealthyResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(SetActiveConfigurationHealthyResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetActiveConfigurationHealthyResponse>(std::move(_buffer)));
}

void Paver::Interface::SetActiveConfigurationHealthyCompleterBase::Reply(::fidl::DecodedMessage<SetActiveConfigurationHealthyResponse> params) {
  Paver::SetTransactionHeaderFor::SetActiveConfigurationHealthyResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Paver::Interface::ReadAssetCompleterBase::Reply(::llcpp::fuchsia::paver::Paver_ReadAsset_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReadAssetResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<ReadAssetResponse*>(_write_bytes);
  Paver::SetTransactionHeaderFor::ReadAssetResponse(
      ::fidl::DecodedMessage<ReadAssetResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ReadAssetResponse::PrimarySize,
              ReadAssetResponse::PrimarySize)));
  _response.result = std::move(result);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(ReadAssetResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ReadAssetResponse>(std::move(_response_bytes)));
}
void Paver::Interface::ReadAssetCompleterBase::ReplySuccess(::llcpp::fuchsia::mem::Buffer asset) {
  Paver_ReadAsset_Response response;
  response.asset = std::move(asset);

  Reply(Paver_ReadAsset_Result::WithResponse(&response));
}
void Paver::Interface::ReadAssetCompleterBase::ReplyError(int32_t error) {
  Reply(Paver_ReadAsset_Result::WithErr(&error));
}

void Paver::Interface::ReadAssetCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::paver::Paver_ReadAsset_Result result) {
  if (_buffer.capacity() < ReadAssetResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<ReadAssetResponse*>(_buffer.data());
  Paver::SetTransactionHeaderFor::ReadAssetResponse(
      ::fidl::DecodedMessage<ReadAssetResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ReadAssetResponse::PrimarySize,
              ReadAssetResponse::PrimarySize)));
  _response.result = std::move(result);
  _buffer.set_actual(sizeof(ReadAssetResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ReadAssetResponse>(std::move(_buffer)));
}
void Paver::Interface::ReadAssetCompleterBase::ReplySuccess(::fidl::BytePart _buffer, ::llcpp::fuchsia::mem::Buffer asset) {
  Paver_ReadAsset_Response response;
  response.asset = std::move(asset);

  Reply(std::move(_buffer), Paver_ReadAsset_Result::WithResponse(&response));
}

void Paver::Interface::ReadAssetCompleterBase::Reply(::fidl::DecodedMessage<ReadAssetResponse> params) {
  Paver::SetTransactionHeaderFor::ReadAssetResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Paver::Interface::WriteAssetCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WriteAssetResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<WriteAssetResponse*>(_write_bytes);
  Paver::SetTransactionHeaderFor::WriteAssetResponse(
      ::fidl::DecodedMessage<WriteAssetResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WriteAssetResponse::PrimarySize,
              WriteAssetResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(WriteAssetResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WriteAssetResponse>(std::move(_response_bytes)));
}

void Paver::Interface::WriteAssetCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < WriteAssetResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<WriteAssetResponse*>(_buffer.data());
  Paver::SetTransactionHeaderFor::WriteAssetResponse(
      ::fidl::DecodedMessage<WriteAssetResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WriteAssetResponse::PrimarySize,
              WriteAssetResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(WriteAssetResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WriteAssetResponse>(std::move(_buffer)));
}

void Paver::Interface::WriteAssetCompleterBase::Reply(::fidl::DecodedMessage<WriteAssetResponse> params) {
  Paver::SetTransactionHeaderFor::WriteAssetResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Paver::Interface::WriteVolumesCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WriteVolumesResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<WriteVolumesResponse*>(_write_bytes);
  Paver::SetTransactionHeaderFor::WriteVolumesResponse(
      ::fidl::DecodedMessage<WriteVolumesResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WriteVolumesResponse::PrimarySize,
              WriteVolumesResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(WriteVolumesResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WriteVolumesResponse>(std::move(_response_bytes)));
}

void Paver::Interface::WriteVolumesCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < WriteVolumesResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<WriteVolumesResponse*>(_buffer.data());
  Paver::SetTransactionHeaderFor::WriteVolumesResponse(
      ::fidl::DecodedMessage<WriteVolumesResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WriteVolumesResponse::PrimarySize,
              WriteVolumesResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(WriteVolumesResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WriteVolumesResponse>(std::move(_buffer)));
}

void Paver::Interface::WriteVolumesCompleterBase::Reply(::fidl::DecodedMessage<WriteVolumesResponse> params) {
  Paver::SetTransactionHeaderFor::WriteVolumesResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Paver::Interface::WriteBootloaderCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WriteBootloaderResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<WriteBootloaderResponse*>(_write_bytes);
  Paver::SetTransactionHeaderFor::WriteBootloaderResponse(
      ::fidl::DecodedMessage<WriteBootloaderResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WriteBootloaderResponse::PrimarySize,
              WriteBootloaderResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(WriteBootloaderResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WriteBootloaderResponse>(std::move(_response_bytes)));
}

void Paver::Interface::WriteBootloaderCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < WriteBootloaderResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<WriteBootloaderResponse*>(_buffer.data());
  Paver::SetTransactionHeaderFor::WriteBootloaderResponse(
      ::fidl::DecodedMessage<WriteBootloaderResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WriteBootloaderResponse::PrimarySize,
              WriteBootloaderResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(WriteBootloaderResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WriteBootloaderResponse>(std::move(_buffer)));
}

void Paver::Interface::WriteBootloaderCompleterBase::Reply(::fidl::DecodedMessage<WriteBootloaderResponse> params) {
  Paver::SetTransactionHeaderFor::WriteBootloaderResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Paver::Interface::WriteDataFileCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WriteDataFileResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<WriteDataFileResponse*>(_write_bytes);
  Paver::SetTransactionHeaderFor::WriteDataFileResponse(
      ::fidl::DecodedMessage<WriteDataFileResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WriteDataFileResponse::PrimarySize,
              WriteDataFileResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(WriteDataFileResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WriteDataFileResponse>(std::move(_response_bytes)));
}

void Paver::Interface::WriteDataFileCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < WriteDataFileResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<WriteDataFileResponse*>(_buffer.data());
  Paver::SetTransactionHeaderFor::WriteDataFileResponse(
      ::fidl::DecodedMessage<WriteDataFileResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WriteDataFileResponse::PrimarySize,
              WriteDataFileResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(WriteDataFileResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WriteDataFileResponse>(std::move(_buffer)));
}

void Paver::Interface::WriteDataFileCompleterBase::Reply(::fidl::DecodedMessage<WriteDataFileResponse> params) {
  Paver::SetTransactionHeaderFor::WriteDataFileResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Paver::Interface::WipeVolumeCompleterBase::Reply(::llcpp::fuchsia::paver::Paver_WipeVolume_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WipeVolumeResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<WipeVolumeResponse*>(_write_bytes);
  Paver::SetTransactionHeaderFor::WipeVolumeResponse(
      ::fidl::DecodedMessage<WipeVolumeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WipeVolumeResponse::PrimarySize,
              WipeVolumeResponse::PrimarySize)));
  _response.result = std::move(result);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(WipeVolumeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WipeVolumeResponse>(std::move(_response_bytes)));
}
void Paver::Interface::WipeVolumeCompleterBase::ReplySuccess(::zx::channel volume) {
  Paver_WipeVolume_Response response;
  response.volume = std::move(volume);

  Reply(Paver_WipeVolume_Result::WithResponse(&response));
}
void Paver::Interface::WipeVolumeCompleterBase::ReplyError(int32_t error) {
  Reply(Paver_WipeVolume_Result::WithErr(&error));
}

void Paver::Interface::WipeVolumeCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::paver::Paver_WipeVolume_Result result) {
  if (_buffer.capacity() < WipeVolumeResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<WipeVolumeResponse*>(_buffer.data());
  Paver::SetTransactionHeaderFor::WipeVolumeResponse(
      ::fidl::DecodedMessage<WipeVolumeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WipeVolumeResponse::PrimarySize,
              WipeVolumeResponse::PrimarySize)));
  _response.result = std::move(result);
  _buffer.set_actual(sizeof(WipeVolumeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WipeVolumeResponse>(std::move(_buffer)));
}
void Paver::Interface::WipeVolumeCompleterBase::ReplySuccess(::fidl::BytePart _buffer, ::zx::channel volume) {
  Paver_WipeVolume_Response response;
  response.volume = std::move(volume);

  Reply(std::move(_buffer), Paver_WipeVolume_Result::WithResponse(&response));
}

void Paver::Interface::WipeVolumeCompleterBase::Reply(::fidl::DecodedMessage<WipeVolumeResponse> params) {
  Paver::SetTransactionHeaderFor::WipeVolumeResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Paver::Interface::InitializePartitionTablesCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<InitializePartitionTablesResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<InitializePartitionTablesResponse*>(_write_bytes);
  Paver::SetTransactionHeaderFor::InitializePartitionTablesResponse(
      ::fidl::DecodedMessage<InitializePartitionTablesResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              InitializePartitionTablesResponse::PrimarySize,
              InitializePartitionTablesResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(InitializePartitionTablesResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<InitializePartitionTablesResponse>(std::move(_response_bytes)));
}

void Paver::Interface::InitializePartitionTablesCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < InitializePartitionTablesResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<InitializePartitionTablesResponse*>(_buffer.data());
  Paver::SetTransactionHeaderFor::InitializePartitionTablesResponse(
      ::fidl::DecodedMessage<InitializePartitionTablesResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              InitializePartitionTablesResponse::PrimarySize,
              InitializePartitionTablesResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(InitializePartitionTablesResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<InitializePartitionTablesResponse>(std::move(_buffer)));
}

void Paver::Interface::InitializePartitionTablesCompleterBase::Reply(::fidl::DecodedMessage<InitializePartitionTablesResponse> params) {
  Paver::SetTransactionHeaderFor::InitializePartitionTablesResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Paver::Interface::WipePartitionTablesCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WipePartitionTablesResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<WipePartitionTablesResponse*>(_write_bytes);
  Paver::SetTransactionHeaderFor::WipePartitionTablesResponse(
      ::fidl::DecodedMessage<WipePartitionTablesResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WipePartitionTablesResponse::PrimarySize,
              WipePartitionTablesResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(WipePartitionTablesResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WipePartitionTablesResponse>(std::move(_response_bytes)));
}

void Paver::Interface::WipePartitionTablesCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < WipePartitionTablesResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<WipePartitionTablesResponse*>(_buffer.data());
  Paver::SetTransactionHeaderFor::WipePartitionTablesResponse(
      ::fidl::DecodedMessage<WipePartitionTablesResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WipePartitionTablesResponse::PrimarySize,
              WipePartitionTablesResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(WipePartitionTablesResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WipePartitionTablesResponse>(std::move(_buffer)));
}

void Paver::Interface::WipePartitionTablesCompleterBase::Reply(::fidl::DecodedMessage<WipePartitionTablesResponse> params) {
  Paver::SetTransactionHeaderFor::WipePartitionTablesResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void Paver::SetTransactionHeaderFor::InitializeAbrRequest(const ::fidl::DecodedMessage<Paver::InitializeAbrRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPaver_InitializeAbr_GenOrdinal);
}
void Paver::SetTransactionHeaderFor::InitializeAbrResponse(const ::fidl::DecodedMessage<Paver::InitializeAbrResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPaver_InitializeAbr_GenOrdinal);
}

void Paver::SetTransactionHeaderFor::QueryActiveConfigurationRequest(const ::fidl::DecodedMessage<Paver::QueryActiveConfigurationRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPaver_QueryActiveConfiguration_GenOrdinal);
}
void Paver::SetTransactionHeaderFor::QueryActiveConfigurationResponse(const ::fidl::DecodedMessage<Paver::QueryActiveConfigurationResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPaver_QueryActiveConfiguration_GenOrdinal);
}

void Paver::SetTransactionHeaderFor::QueryConfigurationStatusRequest(const ::fidl::DecodedMessage<Paver::QueryConfigurationStatusRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPaver_QueryConfigurationStatus_GenOrdinal);
}
void Paver::SetTransactionHeaderFor::QueryConfigurationStatusResponse(const ::fidl::DecodedMessage<Paver::QueryConfigurationStatusResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPaver_QueryConfigurationStatus_GenOrdinal);
}

void Paver::SetTransactionHeaderFor::SetConfigurationActiveRequest(const ::fidl::DecodedMessage<Paver::SetConfigurationActiveRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPaver_SetConfigurationActive_GenOrdinal);
}
void Paver::SetTransactionHeaderFor::SetConfigurationActiveResponse(const ::fidl::DecodedMessage<Paver::SetConfigurationActiveResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPaver_SetConfigurationActive_GenOrdinal);
}

void Paver::SetTransactionHeaderFor::SetConfigurationUnbootableRequest(const ::fidl::DecodedMessage<Paver::SetConfigurationUnbootableRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPaver_SetConfigurationUnbootable_GenOrdinal);
}
void Paver::SetTransactionHeaderFor::SetConfigurationUnbootableResponse(const ::fidl::DecodedMessage<Paver::SetConfigurationUnbootableResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPaver_SetConfigurationUnbootable_GenOrdinal);
}

void Paver::SetTransactionHeaderFor::SetActiveConfigurationHealthyRequest(const ::fidl::DecodedMessage<Paver::SetActiveConfigurationHealthyRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPaver_SetActiveConfigurationHealthy_GenOrdinal);
}
void Paver::SetTransactionHeaderFor::SetActiveConfigurationHealthyResponse(const ::fidl::DecodedMessage<Paver::SetActiveConfigurationHealthyResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPaver_SetActiveConfigurationHealthy_GenOrdinal);
}

void Paver::SetTransactionHeaderFor::ReadAssetRequest(const ::fidl::DecodedMessage<Paver::ReadAssetRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPaver_ReadAsset_GenOrdinal);
}
void Paver::SetTransactionHeaderFor::ReadAssetResponse(const ::fidl::DecodedMessage<Paver::ReadAssetResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPaver_ReadAsset_GenOrdinal);
}

void Paver::SetTransactionHeaderFor::WriteAssetRequest(const ::fidl::DecodedMessage<Paver::WriteAssetRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPaver_WriteAsset_GenOrdinal);
}
void Paver::SetTransactionHeaderFor::WriteAssetResponse(const ::fidl::DecodedMessage<Paver::WriteAssetResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPaver_WriteAsset_GenOrdinal);
}

void Paver::SetTransactionHeaderFor::WriteVolumesRequest(const ::fidl::DecodedMessage<Paver::WriteVolumesRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPaver_WriteVolumes_GenOrdinal);
}
void Paver::SetTransactionHeaderFor::WriteVolumesResponse(const ::fidl::DecodedMessage<Paver::WriteVolumesResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPaver_WriteVolumes_GenOrdinal);
}

void Paver::SetTransactionHeaderFor::WriteBootloaderRequest(const ::fidl::DecodedMessage<Paver::WriteBootloaderRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPaver_WriteBootloader_GenOrdinal);
}
void Paver::SetTransactionHeaderFor::WriteBootloaderResponse(const ::fidl::DecodedMessage<Paver::WriteBootloaderResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPaver_WriteBootloader_GenOrdinal);
}

void Paver::SetTransactionHeaderFor::WriteDataFileRequest(const ::fidl::DecodedMessage<Paver::WriteDataFileRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPaver_WriteDataFile_GenOrdinal);
}
void Paver::SetTransactionHeaderFor::WriteDataFileResponse(const ::fidl::DecodedMessage<Paver::WriteDataFileResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPaver_WriteDataFile_GenOrdinal);
}

void Paver::SetTransactionHeaderFor::WipeVolumeRequest(const ::fidl::DecodedMessage<Paver::WipeVolumeRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPaver_WipeVolume_GenOrdinal);
}
void Paver::SetTransactionHeaderFor::WipeVolumeResponse(const ::fidl::DecodedMessage<Paver::WipeVolumeResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPaver_WipeVolume_GenOrdinal);
}

void Paver::SetTransactionHeaderFor::InitializePartitionTablesRequest(const ::fidl::DecodedMessage<Paver::InitializePartitionTablesRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPaver_InitializePartitionTables_GenOrdinal);
}
void Paver::SetTransactionHeaderFor::InitializePartitionTablesResponse(const ::fidl::DecodedMessage<Paver::InitializePartitionTablesResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPaver_InitializePartitionTables_GenOrdinal);
}

void Paver::SetTransactionHeaderFor::WipePartitionTablesRequest(const ::fidl::DecodedMessage<Paver::WipePartitionTablesRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPaver_WipePartitionTables_GenOrdinal);
}
void Paver::SetTransactionHeaderFor::WipePartitionTablesResponse(const ::fidl::DecodedMessage<Paver::WipePartitionTablesResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPaver_WipePartitionTables_GenOrdinal);
}

}  // namespace paver
}  // namespace fuchsia
}  // namespace llcpp

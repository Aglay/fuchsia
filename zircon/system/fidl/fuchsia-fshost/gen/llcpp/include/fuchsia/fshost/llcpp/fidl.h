// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/txn_header.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/connect_service.h>
#include <lib/fidl/llcpp/service_handler_interface.h>
#include <lib/fidl/llcpp/string_view.h>
#include <lib/fidl/llcpp/sync_call.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/fidl/llcpp/vector_view.h>
#include <lib/fit/function.h>
#include <lib/zx/channel.h>
#include <lib/zx/handle.h>
#include <zircon/fidl.h>

#include <fuchsia/io/llcpp/fidl.h>

namespace llcpp {

namespace fuchsia {
namespace fshost {

class Filesystems;
class Registry;

extern "C" const fidl_type_t fuchsia_fshost_FilesystemsCloneRequestTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsCloneRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsCloneResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsCloneResponseTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsCloseRequestTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsCloseRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsCloseResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsCloseResponseTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsDescribeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsDescribeRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsDescribeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsDescribeResponseTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsOnOpenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsOnOpenRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsOnOpenEventTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsOnOpenEventTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsSyncRequestTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsSyncRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsSyncResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsSyncResponseTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsGetAttrRequestTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsGetAttrRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsGetAttrResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsGetAttrResponseTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsSetAttrRequestTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsSetAttrRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsSetAttrResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsSetAttrResponseTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsNodeGetFlagsRequestTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsNodeGetFlagsRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsNodeGetFlagsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsNodeGetFlagsResponseTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsNodeSetFlagsRequestTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsNodeSetFlagsRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsNodeSetFlagsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsNodeSetFlagsResponseTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsOpenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsOpenRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsOpenResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsOpenResponseTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsUnlinkRequestTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsUnlinkRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsUnlinkResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsUnlinkResponseTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsReadDirentsRequestTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsReadDirentsRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsReadDirentsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsReadDirentsResponseTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsRewindRequestTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsRewindRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsRewindResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsRewindResponseTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsGetTokenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsGetTokenRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsGetTokenResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsGetTokenResponseTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsRenameRequestTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsRenameRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsRenameResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsRenameResponseTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsLinkRequestTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsLinkRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsLinkResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsLinkResponseTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsWatchRequestTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsWatchRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsWatchResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsWatchResponseTable;

// A collection of all registered filesystems.
class Filesystems final {
  Filesystems() = delete;
 public:
  static constexpr char Name[] = "fuchsia.fshost.Filesystems";

  struct CloneRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;
    ::zx::channel object;

    static constexpr const fidl_type_t* Type = &fuchsia_fshost_FilesystemsCloneRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_fshost_FilesystemsCloneRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct CloseResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &fuchsia_fshost_FilesystemsCloseResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_fshost_FilesystemsCloseResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using CloseRequest = ::fidl::AnyZeroArgMessage;

  struct DescribeResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io::NodeInfo info;

    static constexpr const fidl_type_t* Type = &fuchsia_fshost_FilesystemsDescribeResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_fshost_FilesystemsDescribeResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 24;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using DescribeRequest = ::fidl::AnyZeroArgMessage;

  struct OnOpenResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::llcpp::fuchsia::io::NodeInfo* info;

    static constexpr const fidl_type_t* Type = &fuchsia_fshost_FilesystemsOnOpenEventTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_fshost_FilesystemsOnOpenEventTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 32;
    static constexpr uint32_t AltPrimarySize = 48;
    static constexpr uint32_t AltMaxOutOfLine = 24;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SyncResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &fuchsia_fshost_FilesystemsSyncResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_fshost_FilesystemsSyncResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using SyncRequest = ::fidl::AnyZeroArgMessage;

  struct GetAttrResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::llcpp::fuchsia::io::NodeAttributes attributes;

    static constexpr const fidl_type_t* Type = &fuchsia_fshost_FilesystemsGetAttrResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_fshost_FilesystemsGetAttrResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 80;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 80;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetAttrRequest = ::fidl::AnyZeroArgMessage;

  struct SetAttrResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &fuchsia_fshost_FilesystemsSetAttrResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_fshost_FilesystemsSetAttrResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SetAttrRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;
    ::llcpp::fuchsia::io::NodeAttributes attributes;

    static constexpr const fidl_type_t* Type = &fuchsia_fshost_FilesystemsSetAttrRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_fshost_FilesystemsSetAttrRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 80;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 80;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SetAttrResponse;
  };

  struct NodeGetFlagsResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    uint32_t flags;

    static constexpr const fidl_type_t* Type = &fuchsia_fshost_FilesystemsNodeGetFlagsResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_fshost_FilesystemsNodeGetFlagsResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using NodeGetFlagsRequest = ::fidl::AnyZeroArgMessage;

  struct NodeSetFlagsResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &fuchsia_fshost_FilesystemsNodeSetFlagsResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_fshost_FilesystemsNodeSetFlagsResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct NodeSetFlagsRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;

    static constexpr const fidl_type_t* Type = &fuchsia_fshost_FilesystemsNodeSetFlagsRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_fshost_FilesystemsNodeSetFlagsRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = NodeSetFlagsResponse;
  };

  struct OpenRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;
    uint32_t mode;
    ::fidl::StringView path;
    ::zx::channel object;

    static constexpr const fidl_type_t* Type = &fuchsia_fshost_FilesystemsOpenRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_fshost_FilesystemsOpenRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 4096;
    static constexpr uint32_t AltPrimarySize = 48;
    static constexpr uint32_t AltMaxOutOfLine = 4096;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct UnlinkResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &fuchsia_fshost_FilesystemsUnlinkResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_fshost_FilesystemsUnlinkResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct UnlinkRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::StringView path;

    static constexpr const fidl_type_t* Type = &fuchsia_fshost_FilesystemsUnlinkRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_fshost_FilesystemsUnlinkRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 4096;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 4096;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = UnlinkResponse;
  };

  struct ReadDirentsResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::fidl::VectorView<uint8_t> dirents;

    static constexpr const fidl_type_t* Type = &fuchsia_fshost_FilesystemsReadDirentsResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_fshost_FilesystemsReadDirentsResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8192;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 8192;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct ReadDirentsRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t max_bytes;

    static constexpr const fidl_type_t* Type = &fuchsia_fshost_FilesystemsReadDirentsRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_fshost_FilesystemsReadDirentsRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = ReadDirentsResponse;
  };

  struct RewindResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &fuchsia_fshost_FilesystemsRewindResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_fshost_FilesystemsRewindResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using RewindRequest = ::fidl::AnyZeroArgMessage;

  struct GetTokenResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::zx::handle token;

    static constexpr const fidl_type_t* Type = &fuchsia_fshost_FilesystemsGetTokenResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_fshost_FilesystemsGetTokenResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetTokenRequest = ::fidl::AnyZeroArgMessage;

  struct RenameResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &fuchsia_fshost_FilesystemsRenameResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_fshost_FilesystemsRenameResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct RenameRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::StringView src;
    ::zx::handle dst_parent_token;
    ::fidl::StringView dst;

    static constexpr const fidl_type_t* Type = &fuchsia_fshost_FilesystemsRenameRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_fshost_FilesystemsRenameRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 56;
    static constexpr uint32_t MaxOutOfLine = 8192;
    static constexpr uint32_t AltPrimarySize = 56;
    static constexpr uint32_t AltMaxOutOfLine = 8192;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = RenameResponse;
  };

  struct LinkResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &fuchsia_fshost_FilesystemsLinkResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_fshost_FilesystemsLinkResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct LinkRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::StringView src;
    ::zx::handle dst_parent_token;
    ::fidl::StringView dst;

    static constexpr const fidl_type_t* Type = &fuchsia_fshost_FilesystemsLinkRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_fshost_FilesystemsLinkRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 56;
    static constexpr uint32_t MaxOutOfLine = 8192;
    static constexpr uint32_t AltPrimarySize = 56;
    static constexpr uint32_t AltMaxOutOfLine = 8192;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = LinkResponse;
  };

  struct WatchResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &fuchsia_fshost_FilesystemsWatchResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_fshost_FilesystemsWatchResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct WatchRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t mask;
    uint32_t options;
    ::zx::channel watcher;

    static constexpr const fidl_type_t* Type = &fuchsia_fshost_FilesystemsWatchRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_fshost_FilesystemsWatchRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = WatchResponse;
  };


  struct EventHandlers {
    // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
    //
    // Indicates the success or failure of the open operation, and optionally describes the
    // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
    // (the same as would be returned by `Describe`).
    fit::callback<zx_status_t(int32_t s, ::llcpp::fuchsia::io::NodeInfo* info)> on_open;

    // Fallback handler when an unknown ordinal is received.
    // Caller may put custom error handling logic here.
    fit::callback<zx_status_t()> unknown;
  };

  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    class Clone_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Clone_Impl(zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object);
      ~Clone_Impl() = default;
      Clone_Impl(Clone_Impl&& other) = default;
      Clone_Impl& operator=(Clone_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class Close_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Close_Impl(zx::unowned_channel _client_end);
      ~Close_Impl() = default;
      Close_Impl(Close_Impl&& other) = default;
      Close_Impl& operator=(Close_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Describe_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Describe_Impl(zx::unowned_channel _client_end);
      ~Describe_Impl() = default;
      Describe_Impl(Describe_Impl&& other) = default;
      Describe_Impl& operator=(Describe_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Sync_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Sync_Impl(zx::unowned_channel _client_end);
      ~Sync_Impl() = default;
      Sync_Impl(Sync_Impl&& other) = default;
      Sync_Impl& operator=(Sync_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetAttr_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetAttr_Impl(zx::unowned_channel _client_end);
      ~GetAttr_Impl() = default;
      GetAttr_Impl(GetAttr_Impl&& other) = default;
      GetAttr_Impl& operator=(GetAttr_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetAttr_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      SetAttr_Impl(zx::unowned_channel _client_end, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes);
      ~SetAttr_Impl() = default;
      SetAttr_Impl(SetAttr_Impl&& other) = default;
      SetAttr_Impl& operator=(SetAttr_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class NodeGetFlags_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      NodeGetFlags_Impl(zx::unowned_channel _client_end);
      ~NodeGetFlags_Impl() = default;
      NodeGetFlags_Impl(NodeGetFlags_Impl&& other) = default;
      NodeGetFlags_Impl& operator=(NodeGetFlags_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class NodeSetFlags_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      NodeSetFlags_Impl(zx::unowned_channel _client_end, uint32_t flags);
      ~NodeSetFlags_Impl() = default;
      NodeSetFlags_Impl(NodeSetFlags_Impl&& other) = default;
      NodeSetFlags_Impl& operator=(NodeSetFlags_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    class Open_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Open_Impl(zx::unowned_channel _client_end, uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object);
      ~Open_Impl() = default;
      Open_Impl(Open_Impl&& other) = default;
      Open_Impl& operator=(Open_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class Unlink_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Unlink_Impl(zx::unowned_channel _client_end, ::fidl::StringView path);
      ~Unlink_Impl() = default;
      Unlink_Impl(Unlink_Impl&& other) = default;
      Unlink_Impl& operator=(Unlink_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class ReadDirents_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      ReadDirents_Impl(zx::unowned_channel _client_end, uint64_t max_bytes);
      ~ReadDirents_Impl() = default;
      ReadDirents_Impl(ReadDirents_Impl&& other) = default;
      ReadDirents_Impl& operator=(ReadDirents_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Rewind_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Rewind_Impl(zx::unowned_channel _client_end);
      ~Rewind_Impl() = default;
      Rewind_Impl(Rewind_Impl&& other) = default;
      Rewind_Impl& operator=(Rewind_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetToken_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetToken_Impl(zx::unowned_channel _client_end);
      ~GetToken_Impl() = default;
      GetToken_Impl(GetToken_Impl&& other) = default;
      GetToken_Impl& operator=(GetToken_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Rename_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Rename_Impl(zx::unowned_channel _client_end, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst);
      ~Rename_Impl() = default;
      Rename_Impl(Rename_Impl&& other) = default;
      Rename_Impl& operator=(Rename_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Link_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Link_Impl(zx::unowned_channel _client_end, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst);
      ~Link_Impl() = default;
      Link_Impl(Link_Impl&& other) = default;
      Link_Impl& operator=(Link_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Watch_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Watch_Impl(zx::unowned_channel _client_end, uint32_t mask, uint32_t options, ::zx::channel watcher);
      ~Watch_Impl() = default;
      Watch_Impl(Watch_Impl&& other) = default;
      Watch_Impl& operator=(Watch_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Clone = Clone_Impl;
    using Close = Close_Impl<CloseResponse>;
    using Describe = Describe_Impl<DescribeResponse>;
    using Sync = Sync_Impl<SyncResponse>;
    using GetAttr = GetAttr_Impl<GetAttrResponse>;
    using SetAttr = SetAttr_Impl<SetAttrResponse>;
    using NodeGetFlags = NodeGetFlags_Impl<NodeGetFlagsResponse>;
    using NodeSetFlags = NodeSetFlags_Impl<NodeSetFlagsResponse>;
    using Open = Open_Impl;
    using Unlink = Unlink_Impl<UnlinkResponse>;
    using ReadDirents = ReadDirents_Impl<ReadDirentsResponse>;
    using Rewind = Rewind_Impl<RewindResponse>;
    using GetToken = GetToken_Impl<GetTokenResponse>;
    using Rename = Rename_Impl<RenameResponse>;
    using Link = Link_Impl<LinkResponse>;
    using Watch = Watch_Impl<WatchResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    class Clone_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Clone_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);
      ~Clone_Impl() = default;
      Clone_Impl(Clone_Impl&& other) = default;
      Clone_Impl& operator=(Clone_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class Close_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Close_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Close_Impl() = default;
      Close_Impl(Close_Impl&& other) = default;
      Close_Impl& operator=(Close_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Describe_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Describe_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Describe_Impl() = default;
      Describe_Impl(Describe_Impl&& other) = default;
      Describe_Impl& operator=(Describe_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Sync_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Sync_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Sync_Impl() = default;
      Sync_Impl(Sync_Impl&& other) = default;
      Sync_Impl& operator=(Sync_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetAttr_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetAttr_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetAttr_Impl() = default;
      GetAttr_Impl(GetAttr_Impl&& other) = default;
      GetAttr_Impl& operator=(GetAttr_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetAttr_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      SetAttr_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer);
      ~SetAttr_Impl() = default;
      SetAttr_Impl(SetAttr_Impl&& other) = default;
      SetAttr_Impl& operator=(SetAttr_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class NodeGetFlags_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      NodeGetFlags_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~NodeGetFlags_Impl() = default;
      NodeGetFlags_Impl(NodeGetFlags_Impl&& other) = default;
      NodeGetFlags_Impl& operator=(NodeGetFlags_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class NodeSetFlags_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      NodeSetFlags_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer);
      ~NodeSetFlags_Impl() = default;
      NodeSetFlags_Impl(NodeSetFlags_Impl&& other) = default;
      NodeSetFlags_Impl& operator=(NodeSetFlags_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    class Open_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Open_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object);
      ~Open_Impl() = default;
      Open_Impl(Open_Impl&& other) = default;
      Open_Impl& operator=(Open_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class Unlink_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Unlink_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView path, ::fidl::BytePart _response_buffer);
      ~Unlink_Impl() = default;
      Unlink_Impl(Unlink_Impl&& other) = default;
      Unlink_Impl& operator=(Unlink_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class ReadDirents_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      ReadDirents_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t max_bytes, ::fidl::BytePart _response_buffer);
      ~ReadDirents_Impl() = default;
      ReadDirents_Impl(ReadDirents_Impl&& other) = default;
      ReadDirents_Impl& operator=(ReadDirents_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Rewind_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Rewind_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Rewind_Impl() = default;
      Rewind_Impl(Rewind_Impl&& other) = default;
      Rewind_Impl& operator=(Rewind_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetToken_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetToken_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetToken_Impl() = default;
      GetToken_Impl(GetToken_Impl&& other) = default;
      GetToken_Impl& operator=(GetToken_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Rename_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Rename_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer);
      ~Rename_Impl() = default;
      Rename_Impl(Rename_Impl&& other) = default;
      Rename_Impl& operator=(Rename_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Link_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Link_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer);
      ~Link_Impl() = default;
      Link_Impl(Link_Impl&& other) = default;
      Link_Impl& operator=(Link_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Watch_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Watch_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t mask, uint32_t options, ::zx::channel watcher, ::fidl::BytePart _response_buffer);
      ~Watch_Impl() = default;
      Watch_Impl(Watch_Impl&& other) = default;
      Watch_Impl& operator=(Watch_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Clone = Clone_Impl;
    using Close = Close_Impl<CloseResponse>;
    using Describe = Describe_Impl<DescribeResponse>;
    using Sync = Sync_Impl<SyncResponse>;
    using GetAttr = GetAttr_Impl<GetAttrResponse>;
    using SetAttr = SetAttr_Impl<SetAttrResponse>;
    using NodeGetFlags = NodeGetFlags_Impl<NodeGetFlagsResponse>;
    using NodeSetFlags = NodeSetFlags_Impl<NodeSetFlagsResponse>;
    using Open = Open_Impl;
    using Unlink = Unlink_Impl<UnlinkResponse>;
    using ReadDirents = ReadDirents_Impl<ReadDirentsResponse>;
    using Rewind = Rewind_Impl<RewindResponse>;
    using GetToken = GetToken_Impl<GetTokenResponse>;
    using Rename = Rename_Impl<RenameResponse>;
    using Link = Link_Impl<LinkResponse>;
    using Watch = Watch_Impl<WatchResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    //
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with
    // `CLONE_FLAG_SAME_RIGHTS`.
    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Clone Clone(uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    //
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with
    // `CLONE_FLAG_SAME_RIGHTS`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Clone Clone(::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Close Close();

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Close Close(::fidl::BytePart _response_buffer);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Describe Describe();

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Describe Describe(::fidl::BytePart _response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Sync Sync();

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Sync Sync(::fidl::BytePart _response_buffer);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Allocates 96 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetAttr GetAttr();

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetAttr GetAttr(::fidl::BytePart _response_buffer);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Allocates 104 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::SetAttr SetAttr(uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetAttr SetAttr(::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer);

    // Acquires the `Directory.Open` rights and flags used to access this file.
    //
    // This method does not require any rights.
    // This method has the same functionality as GetFlags for File and is
    // meant as an in-progress replacement.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::NodeGetFlags NodeGetFlags();

    // Acquires the `Directory.Open` rights and flags used to access this file.
    //
    // This method does not require any rights.
    // This method has the same functionality as GetFlags for File and is
    // meant as an in-progress replacement.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::NodeGetFlags NodeGetFlags(::fidl::BytePart _response_buffer);

    // Changes the `Directory.Open` flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // This method has the same functionality as SetFlags for File and is
    // meant as an in-progress replacement.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::NodeSetFlags NodeSetFlags(uint32_t flags);

    // Changes the `Directory.Open` flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // This method has the same functionality as SetFlags for File and is
    // meant as an in-progress replacement.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::NodeSetFlags NodeSetFlags(::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer);

    // Opens a new object relative to this directory object.
    //
    // `path` may contain multiple segments, separated by "/" characters,
    // and should never be empty; i.e., "" is an invalid path.
    //
    // `flags` may be any of the `OPEN_FLAG_*` and `OPEN_RIGHT_*` values, bitwise ORed together.
    // The `OPEN_FLAG_DESCRIBE` flag may cause an `OnOpen` event to be transmitted
    // on the `object` handle, indicating the type of object opened.
    //
    // If an unknown value is sent for either flags or mode, the connection should
    // be closed.
    //
    // `OPEN_RIGHT_*` flags provided in `flags` will restrict access rights on
    // the `object` channel which will be connected to the opened entity.
    //
    // Rights are never increased. When you open a nested entity within a directory, you may only
    // request the same rights as what the directory connection already has, or a subset of those.
    // Exceeding those rights causes an access denied error to be transmitted in the
    // `OnOpen` event if applicable, and the `object` connection closed.
    //
    // The caller must specify either one or more of the `OPEN_RIGHT_*` flags, or
    // the `OPEN_FLAG_NODE_REFERENCE` flag.
    // Request is heap-allocated.
    ResultOf::Open Open(uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object);

    // Opens a new object relative to this directory object.
    //
    // `path` may contain multiple segments, separated by "/" characters,
    // and should never be empty; i.e., "" is an invalid path.
    //
    // `flags` may be any of the `OPEN_FLAG_*` and `OPEN_RIGHT_*` values, bitwise ORed together.
    // The `OPEN_FLAG_DESCRIBE` flag may cause an `OnOpen` event to be transmitted
    // on the `object` handle, indicating the type of object opened.
    //
    // If an unknown value is sent for either flags or mode, the connection should
    // be closed.
    //
    // `OPEN_RIGHT_*` flags provided in `flags` will restrict access rights on
    // the `object` channel which will be connected to the opened entity.
    //
    // Rights are never increased. When you open a nested entity within a directory, you may only
    // request the same rights as what the directory connection already has, or a subset of those.
    // Exceeding those rights causes an access denied error to be transmitted in the
    // `OnOpen` event if applicable, and the `object` connection closed.
    //
    // The caller must specify either one or more of the `OPEN_RIGHT_*` flags, or
    // the `OPEN_FLAG_NODE_REFERENCE` flag.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Open Open(::fidl::BytePart _request_buffer, uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object);

    // Detaches an object from this directory object.
    //
    // The underlying object may or may not be deleted after this method
    // completes: although the link will be removed from the containing directory,
    // objects with multiple references (such as files which are still open)
    // will not actually be destroyed until all references are removed.
    //
    // If a directory is unlinked while it still has an open reference,
    // it must become read-only, preventing new entries from being created
    // until all references close and the directory is destroyed.
    //
    // `path` identifies the file which should be detached.
    // If `path` contains multiple segments, separated by "/" characters,
    // then the directory is traversed, one segment at a time, relative to the
    // originally accessed Directory.
    //
    // Returns:
    //   `ZX_ERR_ACCESS_DENIED` if the connection (or the underlying filesystem) does not
    //     allow writable access.
    //   `ZX_ERR_INVALID_ARGS` if `path` contains ".." segments.
    //   `ZX_ERR_NOT_EMPTY` if `path` refers to a non-empty directory.
    //   `ZX_ERR_UNAVAILABLE` if `path` refers to a mount point, containing a remote channel.
    //   `ZX_ERR_UNAVAILABLE` if `path` is ".".
    //
    // Other errors may be returned for filesystem-specific reasons.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Allocates 24 bytes of response buffer on the stack. Request is heap-allocated.
    ResultOf::Unlink Unlink(::fidl::StringView path);

    // Detaches an object from this directory object.
    //
    // The underlying object may or may not be deleted after this method
    // completes: although the link will be removed from the containing directory,
    // objects with multiple references (such as files which are still open)
    // will not actually be destroyed until all references are removed.
    //
    // If a directory is unlinked while it still has an open reference,
    // it must become read-only, preventing new entries from being created
    // until all references close and the directory is destroyed.
    //
    // `path` identifies the file which should be detached.
    // If `path` contains multiple segments, separated by "/" characters,
    // then the directory is traversed, one segment at a time, relative to the
    // originally accessed Directory.
    //
    // Returns:
    //   `ZX_ERR_ACCESS_DENIED` if the connection (or the underlying filesystem) does not
    //     allow writable access.
    //   `ZX_ERR_INVALID_ARGS` if `path` contains ".." segments.
    //   `ZX_ERR_NOT_EMPTY` if `path` refers to a non-empty directory.
    //   `ZX_ERR_UNAVAILABLE` if `path` refers to a mount point, containing a remote channel.
    //   `ZX_ERR_UNAVAILABLE` if `path` is ".".
    //
    // Other errors may be returned for filesystem-specific reasons.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Unlink Unlink(::fidl::BytePart _request_buffer, ::fidl::StringView path, ::fidl::BytePart _response_buffer);

    // Reads a collection of variably sized dirents into a buffer.
    // The number of dirents in a directory may be very large: akin to
    // calling read multiple times on a file, directories have a seek
    // offset which is updated on subsequent calls to ReadDirents.
    //
    // These dirents are of the form:
    // ```
    // struct dirent {
    //   // Describes the inode of the entry.
    //   uint64 ino;
    //   // Describes the length of the dirent name in bytes.
    //   uint8 size;
    //   // Describes the type of the entry. Aligned with the
    //   // POSIX d_type values. Use `DIRENT_TYPE_*` constants.
    //   uint8 type;
    //   // Unterminated name of entry.
    //   char name[0];
    // }
    // ```
    //
    // This method does not require any rights, since one could always probe for
    // directory contents by triggering name conflicts during file creation.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::ReadDirents ReadDirents(uint64_t max_bytes);

    // Reads a collection of variably sized dirents into a buffer.
    // The number of dirents in a directory may be very large: akin to
    // calling read multiple times on a file, directories have a seek
    // offset which is updated on subsequent calls to ReadDirents.
    //
    // These dirents are of the form:
    // ```
    // struct dirent {
    //   // Describes the inode of the entry.
    //   uint64 ino;
    //   // Describes the length of the dirent name in bytes.
    //   uint8 size;
    //   // Describes the type of the entry. Aligned with the
    //   // POSIX d_type values. Use `DIRENT_TYPE_*` constants.
    //   uint8 type;
    //   // Unterminated name of entry.
    //   char name[0];
    // }
    // ```
    //
    // This method does not require any rights, since one could always probe for
    // directory contents by triggering name conflicts during file creation.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::ReadDirents ReadDirents(::fidl::BytePart _request_buffer, uint64_t max_bytes, ::fidl::BytePart _response_buffer);

    // Resets the directory seek offset.
    //
    // This method does not require any rights, similar to ReadDirents.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Rewind Rewind();

    // Resets the directory seek offset.
    //
    // This method does not require any rights, similar to ReadDirents.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Rewind Rewind(::fidl::BytePart _response_buffer);

    // Acquires a token to a Directory which can be used to identify
    // access to it at a later point in time.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetToken GetToken();

    // Acquires a token to a Directory which can be used to identify
    // access to it at a later point in time.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetToken GetToken(::fidl::BytePart _response_buffer);

    // Renames an object named src to the name dst, in a directory represented by token.
    //
    // `src/dst` must be resolved object names. Including "/" in any position
    // other than the end of the string will return `ZX_ERR_INVALID_ARGS`.
    // Returning "/" at the end of either string implies that it must be a
    // directory, or else `ZX_ERR_NOT_DIR` should be returned.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Allocates 24 bytes of response buffer on the stack. Request is heap-allocated.
    ResultOf::Rename Rename(::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst);

    // Renames an object named src to the name dst, in a directory represented by token.
    //
    // `src/dst` must be resolved object names. Including "/" in any position
    // other than the end of the string will return `ZX_ERR_INVALID_ARGS`.
    // Returning "/" at the end of either string implies that it must be a
    // directory, or else `ZX_ERR_NOT_DIR` should be returned.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Rename Rename(::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer);

    // Creates a link to an object named src by the name dst, within a directory represented by
    // token.
    //
    // `src` must be a resolved object name. Including "/" in the string will
    // return `ZX_ERR_INVALID_ARGS`.
    //
    // `dst` must be a resolved object name. Including "/" in the string will
    // return `ZX_ERR_INVALID_ARGS`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Allocates 24 bytes of response buffer on the stack. Request is heap-allocated.
    ResultOf::Link Link(::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst);

    // Creates a link to an object named src by the name dst, within a directory represented by
    // token.
    //
    // `src` must be a resolved object name. Including "/" in the string will
    // return `ZX_ERR_INVALID_ARGS`.
    //
    // `dst` must be a resolved object name. Including "/" in the string will
    // return `ZX_ERR_INVALID_ARGS`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Link Link(::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer);

    // Watches a directory, receiving events of added messages on the
    // watcher request channel.
    //
    // The `watcher` handle will send messages of the form:
    // ```
    // struct {
    //   uint8 event;
    //   uint8 len;
    //   char name[];
    // };
    // ```
    // Where names are NOT null-terminated.
    //
    // This API is unstable; in the future, watcher will be a `DirectoryWatcher` client.
    //
    // Mask specifies a bitmask of events to observe.
    // Options must be zero; it is reserved.
    //
    // This method does not require any rights, similar to ReadDirents.
    // Allocates 56 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Watch Watch(uint32_t mask, uint32_t options, ::zx::channel watcher);

    // Watches a directory, receiving events of added messages on the
    // watcher request channel.
    //
    // The `watcher` handle will send messages of the form:
    // ```
    // struct {
    //   uint8 event;
    //   uint8 len;
    //   char name[];
    // };
    // ```
    // Where names are NOT null-terminated.
    //
    // This API is unstable; in the future, watcher will be a `DirectoryWatcher` client.
    //
    // Mask specifies a bitmask of events to observe.
    // Options must be zero; it is reserved.
    //
    // This method does not require any rights, similar to ReadDirents.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Watch Watch(::fidl::BytePart _request_buffer, uint32_t mask, uint32_t options, ::zx::channel watcher, ::fidl::BytePart _response_buffer);

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    zx_status_t HandleEvents(EventHandlers handlers);
   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    //
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with
    // `CLONE_FLAG_SAME_RIGHTS`.
    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Clone Clone(zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    //
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with
    // `CLONE_FLAG_SAME_RIGHTS`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Clone Clone(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Close Close(zx::unowned_channel _client_end);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Close Close(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Describe Describe(zx::unowned_channel _client_end);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Describe Describe(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Sync Sync(zx::unowned_channel _client_end);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Sync Sync(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Allocates 96 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetAttr GetAttr(zx::unowned_channel _client_end);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetAttr GetAttr(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Allocates 104 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::SetAttr SetAttr(zx::unowned_channel _client_end, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetAttr SetAttr(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer);

    // Acquires the `Directory.Open` rights and flags used to access this file.
    //
    // This method does not require any rights.
    // This method has the same functionality as GetFlags for File and is
    // meant as an in-progress replacement.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::NodeGetFlags NodeGetFlags(zx::unowned_channel _client_end);

    // Acquires the `Directory.Open` rights and flags used to access this file.
    //
    // This method does not require any rights.
    // This method has the same functionality as GetFlags for File and is
    // meant as an in-progress replacement.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::NodeGetFlags NodeGetFlags(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Changes the `Directory.Open` flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // This method has the same functionality as SetFlags for File and is
    // meant as an in-progress replacement.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::NodeSetFlags NodeSetFlags(zx::unowned_channel _client_end, uint32_t flags);

    // Changes the `Directory.Open` flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // This method has the same functionality as SetFlags for File and is
    // meant as an in-progress replacement.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::NodeSetFlags NodeSetFlags(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer);

    // Opens a new object relative to this directory object.
    //
    // `path` may contain multiple segments, separated by "/" characters,
    // and should never be empty; i.e., "" is an invalid path.
    //
    // `flags` may be any of the `OPEN_FLAG_*` and `OPEN_RIGHT_*` values, bitwise ORed together.
    // The `OPEN_FLAG_DESCRIBE` flag may cause an `OnOpen` event to be transmitted
    // on the `object` handle, indicating the type of object opened.
    //
    // If an unknown value is sent for either flags or mode, the connection should
    // be closed.
    //
    // `OPEN_RIGHT_*` flags provided in `flags` will restrict access rights on
    // the `object` channel which will be connected to the opened entity.
    //
    // Rights are never increased. When you open a nested entity within a directory, you may only
    // request the same rights as what the directory connection already has, or a subset of those.
    // Exceeding those rights causes an access denied error to be transmitted in the
    // `OnOpen` event if applicable, and the `object` connection closed.
    //
    // The caller must specify either one or more of the `OPEN_RIGHT_*` flags, or
    // the `OPEN_FLAG_NODE_REFERENCE` flag.
    // Request is heap-allocated.
    static ResultOf::Open Open(zx::unowned_channel _client_end, uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object);

    // Opens a new object relative to this directory object.
    //
    // `path` may contain multiple segments, separated by "/" characters,
    // and should never be empty; i.e., "" is an invalid path.
    //
    // `flags` may be any of the `OPEN_FLAG_*` and `OPEN_RIGHT_*` values, bitwise ORed together.
    // The `OPEN_FLAG_DESCRIBE` flag may cause an `OnOpen` event to be transmitted
    // on the `object` handle, indicating the type of object opened.
    //
    // If an unknown value is sent for either flags or mode, the connection should
    // be closed.
    //
    // `OPEN_RIGHT_*` flags provided in `flags` will restrict access rights on
    // the `object` channel which will be connected to the opened entity.
    //
    // Rights are never increased. When you open a nested entity within a directory, you may only
    // request the same rights as what the directory connection already has, or a subset of those.
    // Exceeding those rights causes an access denied error to be transmitted in the
    // `OnOpen` event if applicable, and the `object` connection closed.
    //
    // The caller must specify either one or more of the `OPEN_RIGHT_*` flags, or
    // the `OPEN_FLAG_NODE_REFERENCE` flag.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Open Open(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object);

    // Detaches an object from this directory object.
    //
    // The underlying object may or may not be deleted after this method
    // completes: although the link will be removed from the containing directory,
    // objects with multiple references (such as files which are still open)
    // will not actually be destroyed until all references are removed.
    //
    // If a directory is unlinked while it still has an open reference,
    // it must become read-only, preventing new entries from being created
    // until all references close and the directory is destroyed.
    //
    // `path` identifies the file which should be detached.
    // If `path` contains multiple segments, separated by "/" characters,
    // then the directory is traversed, one segment at a time, relative to the
    // originally accessed Directory.
    //
    // Returns:
    //   `ZX_ERR_ACCESS_DENIED` if the connection (or the underlying filesystem) does not
    //     allow writable access.
    //   `ZX_ERR_INVALID_ARGS` if `path` contains ".." segments.
    //   `ZX_ERR_NOT_EMPTY` if `path` refers to a non-empty directory.
    //   `ZX_ERR_UNAVAILABLE` if `path` refers to a mount point, containing a remote channel.
    //   `ZX_ERR_UNAVAILABLE` if `path` is ".".
    //
    // Other errors may be returned for filesystem-specific reasons.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Allocates 24 bytes of response buffer on the stack. Request is heap-allocated.
    static ResultOf::Unlink Unlink(zx::unowned_channel _client_end, ::fidl::StringView path);

    // Detaches an object from this directory object.
    //
    // The underlying object may or may not be deleted after this method
    // completes: although the link will be removed from the containing directory,
    // objects with multiple references (such as files which are still open)
    // will not actually be destroyed until all references are removed.
    //
    // If a directory is unlinked while it still has an open reference,
    // it must become read-only, preventing new entries from being created
    // until all references close and the directory is destroyed.
    //
    // `path` identifies the file which should be detached.
    // If `path` contains multiple segments, separated by "/" characters,
    // then the directory is traversed, one segment at a time, relative to the
    // originally accessed Directory.
    //
    // Returns:
    //   `ZX_ERR_ACCESS_DENIED` if the connection (or the underlying filesystem) does not
    //     allow writable access.
    //   `ZX_ERR_INVALID_ARGS` if `path` contains ".." segments.
    //   `ZX_ERR_NOT_EMPTY` if `path` refers to a non-empty directory.
    //   `ZX_ERR_UNAVAILABLE` if `path` refers to a mount point, containing a remote channel.
    //   `ZX_ERR_UNAVAILABLE` if `path` is ".".
    //
    // Other errors may be returned for filesystem-specific reasons.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Unlink Unlink(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView path, ::fidl::BytePart _response_buffer);

    // Reads a collection of variably sized dirents into a buffer.
    // The number of dirents in a directory may be very large: akin to
    // calling read multiple times on a file, directories have a seek
    // offset which is updated on subsequent calls to ReadDirents.
    //
    // These dirents are of the form:
    // ```
    // struct dirent {
    //   // Describes the inode of the entry.
    //   uint64 ino;
    //   // Describes the length of the dirent name in bytes.
    //   uint8 size;
    //   // Describes the type of the entry. Aligned with the
    //   // POSIX d_type values. Use `DIRENT_TYPE_*` constants.
    //   uint8 type;
    //   // Unterminated name of entry.
    //   char name[0];
    // }
    // ```
    //
    // This method does not require any rights, since one could always probe for
    // directory contents by triggering name conflicts during file creation.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::ReadDirents ReadDirents(zx::unowned_channel _client_end, uint64_t max_bytes);

    // Reads a collection of variably sized dirents into a buffer.
    // The number of dirents in a directory may be very large: akin to
    // calling read multiple times on a file, directories have a seek
    // offset which is updated on subsequent calls to ReadDirents.
    //
    // These dirents are of the form:
    // ```
    // struct dirent {
    //   // Describes the inode of the entry.
    //   uint64 ino;
    //   // Describes the length of the dirent name in bytes.
    //   uint8 size;
    //   // Describes the type of the entry. Aligned with the
    //   // POSIX d_type values. Use `DIRENT_TYPE_*` constants.
    //   uint8 type;
    //   // Unterminated name of entry.
    //   char name[0];
    // }
    // ```
    //
    // This method does not require any rights, since one could always probe for
    // directory contents by triggering name conflicts during file creation.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::ReadDirents ReadDirents(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t max_bytes, ::fidl::BytePart _response_buffer);

    // Resets the directory seek offset.
    //
    // This method does not require any rights, similar to ReadDirents.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Rewind Rewind(zx::unowned_channel _client_end);

    // Resets the directory seek offset.
    //
    // This method does not require any rights, similar to ReadDirents.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Rewind Rewind(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Acquires a token to a Directory which can be used to identify
    // access to it at a later point in time.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetToken GetToken(zx::unowned_channel _client_end);

    // Acquires a token to a Directory which can be used to identify
    // access to it at a later point in time.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetToken GetToken(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Renames an object named src to the name dst, in a directory represented by token.
    //
    // `src/dst` must be resolved object names. Including "/" in any position
    // other than the end of the string will return `ZX_ERR_INVALID_ARGS`.
    // Returning "/" at the end of either string implies that it must be a
    // directory, or else `ZX_ERR_NOT_DIR` should be returned.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Allocates 24 bytes of response buffer on the stack. Request is heap-allocated.
    static ResultOf::Rename Rename(zx::unowned_channel _client_end, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst);

    // Renames an object named src to the name dst, in a directory represented by token.
    //
    // `src/dst` must be resolved object names. Including "/" in any position
    // other than the end of the string will return `ZX_ERR_INVALID_ARGS`.
    // Returning "/" at the end of either string implies that it must be a
    // directory, or else `ZX_ERR_NOT_DIR` should be returned.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Rename Rename(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer);

    // Creates a link to an object named src by the name dst, within a directory represented by
    // token.
    //
    // `src` must be a resolved object name. Including "/" in the string will
    // return `ZX_ERR_INVALID_ARGS`.
    //
    // `dst` must be a resolved object name. Including "/" in the string will
    // return `ZX_ERR_INVALID_ARGS`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Allocates 24 bytes of response buffer on the stack. Request is heap-allocated.
    static ResultOf::Link Link(zx::unowned_channel _client_end, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst);

    // Creates a link to an object named src by the name dst, within a directory represented by
    // token.
    //
    // `src` must be a resolved object name. Including "/" in the string will
    // return `ZX_ERR_INVALID_ARGS`.
    //
    // `dst` must be a resolved object name. Including "/" in the string will
    // return `ZX_ERR_INVALID_ARGS`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Link Link(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer);

    // Watches a directory, receiving events of added messages on the
    // watcher request channel.
    //
    // The `watcher` handle will send messages of the form:
    // ```
    // struct {
    //   uint8 event;
    //   uint8 len;
    //   char name[];
    // };
    // ```
    // Where names are NOT null-terminated.
    //
    // This API is unstable; in the future, watcher will be a `DirectoryWatcher` client.
    //
    // Mask specifies a bitmask of events to observe.
    // Options must be zero; it is reserved.
    //
    // This method does not require any rights, similar to ReadDirents.
    // Allocates 56 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Watch Watch(zx::unowned_channel _client_end, uint32_t mask, uint32_t options, ::zx::channel watcher);

    // Watches a directory, receiving events of added messages on the
    // watcher request channel.
    //
    // The `watcher` handle will send messages of the form:
    // ```
    // struct {
    //   uint8 event;
    //   uint8 len;
    //   char name[];
    // };
    // ```
    // Where names are NOT null-terminated.
    //
    // This API is unstable; in the future, watcher will be a `DirectoryWatcher` client.
    //
    // Mask specifies a bitmask of events to observe.
    // Options must be zero; it is reserved.
    //
    // This method does not require any rights, similar to ReadDirents.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Watch Watch(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t mask, uint32_t options, ::zx::channel watcher, ::fidl::BytePart _response_buffer);

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    static zx_status_t HandleEvents(zx::unowned_channel client_end, EventHandlers handlers);
  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    //
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with
    // `CLONE_FLAG_SAME_RIGHTS`.
    static ::fidl::internal::StatusAndError Clone(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CloneRequest> params);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<CloseResponse> Close(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<DescribeResponse> Describe(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<SyncResponse> Sync(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<GetAttrResponse> GetAttr(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    static ::fidl::DecodeResult<SetAttrResponse> SetAttr(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetAttrRequest> params, ::fidl::BytePart response_buffer);

    // Acquires the `Directory.Open` rights and flags used to access this file.
    //
    // This method does not require any rights.
    // This method has the same functionality as GetFlags for File and is
    // meant as an in-progress replacement.
    static ::fidl::DecodeResult<NodeGetFlagsResponse> NodeGetFlags(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Changes the `Directory.Open` flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // This method has the same functionality as SetFlags for File and is
    // meant as an in-progress replacement.
    static ::fidl::DecodeResult<NodeSetFlagsResponse> NodeSetFlags(zx::unowned_channel _client_end, ::fidl::DecodedMessage<NodeSetFlagsRequest> params, ::fidl::BytePart response_buffer);

    // Opens a new object relative to this directory object.
    //
    // `path` may contain multiple segments, separated by "/" characters,
    // and should never be empty; i.e., "" is an invalid path.
    //
    // `flags` may be any of the `OPEN_FLAG_*` and `OPEN_RIGHT_*` values, bitwise ORed together.
    // The `OPEN_FLAG_DESCRIBE` flag may cause an `OnOpen` event to be transmitted
    // on the `object` handle, indicating the type of object opened.
    //
    // If an unknown value is sent for either flags or mode, the connection should
    // be closed.
    //
    // `OPEN_RIGHT_*` flags provided in `flags` will restrict access rights on
    // the `object` channel which will be connected to the opened entity.
    //
    // Rights are never increased. When you open a nested entity within a directory, you may only
    // request the same rights as what the directory connection already has, or a subset of those.
    // Exceeding those rights causes an access denied error to be transmitted in the
    // `OnOpen` event if applicable, and the `object` connection closed.
    //
    // The caller must specify either one or more of the `OPEN_RIGHT_*` flags, or
    // the `OPEN_FLAG_NODE_REFERENCE` flag.
    static ::fidl::internal::StatusAndError Open(zx::unowned_channel _client_end, ::fidl::DecodedMessage<OpenRequest> params);

    // Detaches an object from this directory object.
    //
    // The underlying object may or may not be deleted after this method
    // completes: although the link will be removed from the containing directory,
    // objects with multiple references (such as files which are still open)
    // will not actually be destroyed until all references are removed.
    //
    // If a directory is unlinked while it still has an open reference,
    // it must become read-only, preventing new entries from being created
    // until all references close and the directory is destroyed.
    //
    // `path` identifies the file which should be detached.
    // If `path` contains multiple segments, separated by "/" characters,
    // then the directory is traversed, one segment at a time, relative to the
    // originally accessed Directory.
    //
    // Returns:
    //   `ZX_ERR_ACCESS_DENIED` if the connection (or the underlying filesystem) does not
    //     allow writable access.
    //   `ZX_ERR_INVALID_ARGS` if `path` contains ".." segments.
    //   `ZX_ERR_NOT_EMPTY` if `path` refers to a non-empty directory.
    //   `ZX_ERR_UNAVAILABLE` if `path` refers to a mount point, containing a remote channel.
    //   `ZX_ERR_UNAVAILABLE` if `path` is ".".
    //
    // Other errors may be returned for filesystem-specific reasons.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    static ::fidl::DecodeResult<UnlinkResponse> Unlink(zx::unowned_channel _client_end, ::fidl::DecodedMessage<UnlinkRequest> params, ::fidl::BytePart response_buffer);

    // Reads a collection of variably sized dirents into a buffer.
    // The number of dirents in a directory may be very large: akin to
    // calling read multiple times on a file, directories have a seek
    // offset which is updated on subsequent calls to ReadDirents.
    //
    // These dirents are of the form:
    // ```
    // struct dirent {
    //   // Describes the inode of the entry.
    //   uint64 ino;
    //   // Describes the length of the dirent name in bytes.
    //   uint8 size;
    //   // Describes the type of the entry. Aligned with the
    //   // POSIX d_type values. Use `DIRENT_TYPE_*` constants.
    //   uint8 type;
    //   // Unterminated name of entry.
    //   char name[0];
    // }
    // ```
    //
    // This method does not require any rights, since one could always probe for
    // directory contents by triggering name conflicts during file creation.
    static ::fidl::DecodeResult<ReadDirentsResponse> ReadDirents(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReadDirentsRequest> params, ::fidl::BytePart response_buffer);

    // Resets the directory seek offset.
    //
    // This method does not require any rights, similar to ReadDirents.
    static ::fidl::DecodeResult<RewindResponse> Rewind(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Acquires a token to a Directory which can be used to identify
    // access to it at a later point in time.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    static ::fidl::DecodeResult<GetTokenResponse> GetToken(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Renames an object named src to the name dst, in a directory represented by token.
    //
    // `src/dst` must be resolved object names. Including "/" in any position
    // other than the end of the string will return `ZX_ERR_INVALID_ARGS`.
    // Returning "/" at the end of either string implies that it must be a
    // directory, or else `ZX_ERR_NOT_DIR` should be returned.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    static ::fidl::DecodeResult<RenameResponse> Rename(zx::unowned_channel _client_end, ::fidl::DecodedMessage<RenameRequest> params, ::fidl::BytePart response_buffer);

    // Creates a link to an object named src by the name dst, within a directory represented by
    // token.
    //
    // `src` must be a resolved object name. Including "/" in the string will
    // return `ZX_ERR_INVALID_ARGS`.
    //
    // `dst` must be a resolved object name. Including "/" in the string will
    // return `ZX_ERR_INVALID_ARGS`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    static ::fidl::DecodeResult<LinkResponse> Link(zx::unowned_channel _client_end, ::fidl::DecodedMessage<LinkRequest> params, ::fidl::BytePart response_buffer);

    // Watches a directory, receiving events of added messages on the
    // watcher request channel.
    //
    // The `watcher` handle will send messages of the form:
    // ```
    // struct {
    //   uint8 event;
    //   uint8 len;
    //   char name[];
    // };
    // ```
    // Where names are NOT null-terminated.
    //
    // This API is unstable; in the future, watcher will be a `DirectoryWatcher` client.
    //
    // Mask specifies a bitmask of events to observe.
    // Options must be zero; it is reserved.
    //
    // This method does not require any rights, similar to ReadDirents.
    static ::fidl::DecodeResult<WatchResponse> Watch(zx::unowned_channel _client_end, ::fidl::DecodedMessage<WatchRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Filesystems;
    using _Base = ::fidl::CompleterBase;

    using CloneCompleter = ::fidl::Completer<>;

    virtual void Clone(uint32_t flags, ::zx::channel object, CloneCompleter::Sync _completer) = 0;

    class CloseCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<CloseResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using CloseCompleter = ::fidl::Completer<CloseCompleterBase>;

    virtual void Close(CloseCompleter::Sync _completer) = 0;

    class DescribeCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io::NodeInfo info);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io::NodeInfo info);
      void Reply(::fidl::DecodedMessage<DescribeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using DescribeCompleter = ::fidl::Completer<DescribeCompleterBase>;

    virtual void Describe(DescribeCompleter::Sync _completer) = 0;

    class SyncCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<SyncResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SyncCompleter = ::fidl::Completer<SyncCompleterBase>;

    virtual void Sync(SyncCompleter::Sync _completer) = 0;

    class GetAttrCompleterBase : public _Base {
     public:
      void Reply(int32_t s, ::llcpp::fuchsia::io::NodeAttributes attributes);
      void Reply(::fidl::BytePart _buffer, int32_t s, ::llcpp::fuchsia::io::NodeAttributes attributes);
      void Reply(::fidl::DecodedMessage<GetAttrResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetAttrCompleter = ::fidl::Completer<GetAttrCompleterBase>;

    virtual void GetAttr(GetAttrCompleter::Sync _completer) = 0;

    class SetAttrCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<SetAttrResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetAttrCompleter = ::fidl::Completer<SetAttrCompleterBase>;

    virtual void SetAttr(uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, SetAttrCompleter::Sync _completer) = 0;

    class NodeGetFlagsCompleterBase : public _Base {
     public:
      void Reply(int32_t s, uint32_t flags);
      void Reply(::fidl::BytePart _buffer, int32_t s, uint32_t flags);
      void Reply(::fidl::DecodedMessage<NodeGetFlagsResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using NodeGetFlagsCompleter = ::fidl::Completer<NodeGetFlagsCompleterBase>;

    virtual void NodeGetFlags(NodeGetFlagsCompleter::Sync _completer) { _completer.Close(ZX_ERR_NOT_SUPPORTED); }

    class NodeSetFlagsCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<NodeSetFlagsResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using NodeSetFlagsCompleter = ::fidl::Completer<NodeSetFlagsCompleterBase>;

    virtual void NodeSetFlags(uint32_t flags, NodeSetFlagsCompleter::Sync _completer) { _completer.Close(ZX_ERR_NOT_SUPPORTED); }

    using OpenCompleter = ::fidl::Completer<>;

    virtual void Open(uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object, OpenCompleter::Sync _completer) = 0;

    class UnlinkCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<UnlinkResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using UnlinkCompleter = ::fidl::Completer<UnlinkCompleterBase>;

    virtual void Unlink(::fidl::StringView path, UnlinkCompleter::Sync _completer) = 0;

    class ReadDirentsCompleterBase : public _Base {
     public:
      void Reply(int32_t s, ::fidl::VectorView<uint8_t> dirents);
      void Reply(::fidl::BytePart _buffer, int32_t s, ::fidl::VectorView<uint8_t> dirents);
      void Reply(::fidl::DecodedMessage<ReadDirentsResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ReadDirentsCompleter = ::fidl::Completer<ReadDirentsCompleterBase>;

    virtual void ReadDirents(uint64_t max_bytes, ReadDirentsCompleter::Sync _completer) = 0;

    class RewindCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<RewindResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using RewindCompleter = ::fidl::Completer<RewindCompleterBase>;

    virtual void Rewind(RewindCompleter::Sync _completer) = 0;

    class GetTokenCompleterBase : public _Base {
     public:
      void Reply(int32_t s, ::zx::handle token);
      void Reply(::fidl::BytePart _buffer, int32_t s, ::zx::handle token);
      void Reply(::fidl::DecodedMessage<GetTokenResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetTokenCompleter = ::fidl::Completer<GetTokenCompleterBase>;

    virtual void GetToken(GetTokenCompleter::Sync _completer) = 0;

    class RenameCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<RenameResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using RenameCompleter = ::fidl::Completer<RenameCompleterBase>;

    virtual void Rename(::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, RenameCompleter::Sync _completer) = 0;

    class LinkCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<LinkResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using LinkCompleter = ::fidl::Completer<LinkCompleterBase>;

    virtual void Link(::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, LinkCompleter::Sync _completer) = 0;

    class WatchCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<WatchResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using WatchCompleter = ::fidl::Completer<WatchCompleterBase>;

    virtual void Watch(uint32_t mask, uint32_t options, ::zx::channel watcher, WatchCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

  // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
  // (the same as would be returned by `Describe`).
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, int32_t s, ::llcpp::fuchsia::io::NodeInfo* info);

  // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
  // (the same as would be returned by `Describe`).
  // Caller provides the backing storage for FIDL message via response buffers.
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, int32_t s, ::llcpp::fuchsia::io::NodeInfo* info);

  // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
  // (the same as would be returned by `Describe`).
  // Messages are encoded in-place.
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnOpenResponse> params);


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void CloneRequest(const ::fidl::DecodedMessage<Filesystems::CloneRequest>& _msg);
    static void CloseRequest(const ::fidl::DecodedMessage<Filesystems::CloseRequest>& _msg);
    static void CloseResponse(const ::fidl::DecodedMessage<Filesystems::CloseResponse>& _msg);
    static void DescribeRequest(const ::fidl::DecodedMessage<Filesystems::DescribeRequest>& _msg);
    static void DescribeResponse(const ::fidl::DecodedMessage<Filesystems::DescribeResponse>& _msg);
    static void OnOpenResponse(const ::fidl::DecodedMessage<Filesystems::OnOpenResponse>& _msg);
    static void SyncRequest(const ::fidl::DecodedMessage<Filesystems::SyncRequest>& _msg);
    static void SyncResponse(const ::fidl::DecodedMessage<Filesystems::SyncResponse>& _msg);
    static void GetAttrRequest(const ::fidl::DecodedMessage<Filesystems::GetAttrRequest>& _msg);
    static void GetAttrResponse(const ::fidl::DecodedMessage<Filesystems::GetAttrResponse>& _msg);
    static void SetAttrRequest(const ::fidl::DecodedMessage<Filesystems::SetAttrRequest>& _msg);
    static void SetAttrResponse(const ::fidl::DecodedMessage<Filesystems::SetAttrResponse>& _msg);
    static void NodeGetFlagsRequest(const ::fidl::DecodedMessage<Filesystems::NodeGetFlagsRequest>& _msg);
    static void NodeGetFlagsResponse(const ::fidl::DecodedMessage<Filesystems::NodeGetFlagsResponse>& _msg);
    static void NodeSetFlagsRequest(const ::fidl::DecodedMessage<Filesystems::NodeSetFlagsRequest>& _msg);
    static void NodeSetFlagsResponse(const ::fidl::DecodedMessage<Filesystems::NodeSetFlagsResponse>& _msg);
    static void OpenRequest(const ::fidl::DecodedMessage<Filesystems::OpenRequest>& _msg);
    static void UnlinkRequest(const ::fidl::DecodedMessage<Filesystems::UnlinkRequest>& _msg);
    static void UnlinkResponse(const ::fidl::DecodedMessage<Filesystems::UnlinkResponse>& _msg);
    static void ReadDirentsRequest(const ::fidl::DecodedMessage<Filesystems::ReadDirentsRequest>& _msg);
    static void ReadDirentsResponse(const ::fidl::DecodedMessage<Filesystems::ReadDirentsResponse>& _msg);
    static void RewindRequest(const ::fidl::DecodedMessage<Filesystems::RewindRequest>& _msg);
    static void RewindResponse(const ::fidl::DecodedMessage<Filesystems::RewindResponse>& _msg);
    static void GetTokenRequest(const ::fidl::DecodedMessage<Filesystems::GetTokenRequest>& _msg);
    static void GetTokenResponse(const ::fidl::DecodedMessage<Filesystems::GetTokenResponse>& _msg);
    static void RenameRequest(const ::fidl::DecodedMessage<Filesystems::RenameRequest>& _msg);
    static void RenameResponse(const ::fidl::DecodedMessage<Filesystems::RenameResponse>& _msg);
    static void LinkRequest(const ::fidl::DecodedMessage<Filesystems::LinkRequest>& _msg);
    static void LinkResponse(const ::fidl::DecodedMessage<Filesystems::LinkResponse>& _msg);
    static void WatchRequest(const ::fidl::DecodedMessage<Filesystems::WatchRequest>& _msg);
    static void WatchResponse(const ::fidl::DecodedMessage<Filesystems::WatchResponse>& _msg);
  };
};

extern "C" const fidl_type_t fuchsia_fshost_RegistryRegisterFilesystemRequestTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_RegistryRegisterFilesystemRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_RegistryRegisterFilesystemResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_RegistryRegisterFilesystemResponseTable;

// Manages filesystems which wish to be globally exposed under the filesystem host.
class Registry final {
  Registry() = delete;
 public:
  static constexpr char Name[] = "fuchsia.fshost.Registry";

  struct RegisterFilesystemResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &fuchsia_fshost_RegistryRegisterFilesystemResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_fshost_RegistryRegisterFilesystemResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct RegisterFilesystemRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::channel public_export;

    static constexpr const fidl_type_t* Type = &fuchsia_fshost_RegistryRegisterFilesystemRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_fshost_RegistryRegisterFilesystemRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = RegisterFilesystemResponse;
  };


  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    template <typename ResponseType>
    class RegisterFilesystem_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      RegisterFilesystem_Impl(zx::unowned_channel _client_end, ::zx::channel public_export);
      ~RegisterFilesystem_Impl() = default;
      RegisterFilesystem_Impl(RegisterFilesystem_Impl&& other) = default;
      RegisterFilesystem_Impl& operator=(RegisterFilesystem_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using RegisterFilesystem = RegisterFilesystem_Impl<RegisterFilesystemResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    template <typename ResponseType>
    class RegisterFilesystem_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      RegisterFilesystem_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel public_export, ::fidl::BytePart _response_buffer);
      ~RegisterFilesystem_Impl() = default;
      RegisterFilesystem_Impl(RegisterFilesystem_Impl&& other) = default;
      RegisterFilesystem_Impl& operator=(RegisterFilesystem_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using RegisterFilesystem = RegisterFilesystem_Impl<RegisterFilesystemResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Registers the output directory of a filesystem. These filesystems are
    // exported from the fuchsia.fshost.Filesystems service, where they are
    // be identified by an instance number (of the form "000", "001", etc).
    //
    // This directory is automatically de-registered from fuchsia.fshost.Filesystems
    // if the server end of the connection is closed.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::RegisterFilesystem RegisterFilesystem(::zx::channel public_export);

    // Registers the output directory of a filesystem. These filesystems are
    // exported from the fuchsia.fshost.Filesystems service, where they are
    // be identified by an instance number (of the form "000", "001", etc).
    //
    // This directory is automatically de-registered from fuchsia.fshost.Filesystems
    // if the server end of the connection is closed.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::RegisterFilesystem RegisterFilesystem(::fidl::BytePart _request_buffer, ::zx::channel public_export, ::fidl::BytePart _response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Registers the output directory of a filesystem. These filesystems are
    // exported from the fuchsia.fshost.Filesystems service, where they are
    // be identified by an instance number (of the form "000", "001", etc).
    //
    // This directory is automatically de-registered from fuchsia.fshost.Filesystems
    // if the server end of the connection is closed.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::RegisterFilesystem RegisterFilesystem(zx::unowned_channel _client_end, ::zx::channel public_export);

    // Registers the output directory of a filesystem. These filesystems are
    // exported from the fuchsia.fshost.Filesystems service, where they are
    // be identified by an instance number (of the form "000", "001", etc).
    //
    // This directory is automatically de-registered from fuchsia.fshost.Filesystems
    // if the server end of the connection is closed.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::RegisterFilesystem RegisterFilesystem(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel public_export, ::fidl::BytePart _response_buffer);

  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Registers the output directory of a filesystem. These filesystems are
    // exported from the fuchsia.fshost.Filesystems service, where they are
    // be identified by an instance number (of the form "000", "001", etc).
    //
    // This directory is automatically de-registered from fuchsia.fshost.Filesystems
    // if the server end of the connection is closed.
    static ::fidl::DecodeResult<RegisterFilesystemResponse> RegisterFilesystem(zx::unowned_channel _client_end, ::fidl::DecodedMessage<RegisterFilesystemRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Registry;
    using _Base = ::fidl::CompleterBase;

    class RegisterFilesystemCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<RegisterFilesystemResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using RegisterFilesystemCompleter = ::fidl::Completer<RegisterFilesystemCompleterBase>;

    virtual void RegisterFilesystem(::zx::channel public_export, RegisterFilesystemCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void RegisterFilesystemRequest(const ::fidl::DecodedMessage<Registry::RegisterFilesystemRequest>& _msg);
    static void RegisterFilesystemResponse(const ::fidl::DecodedMessage<Registry::RegisterFilesystemResponse>& _msg);
  };
};

}  // namespace fshost
}  // namespace fuchsia
}  // namespace llcpp

namespace fidl {

template <>
struct IsFidlType<::llcpp::fuchsia::fshost::Filesystems::CloneRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::fshost::Filesystems::CloneRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::fshost::Filesystems::CloneRequest)
    == ::llcpp::fuchsia::fshost::Filesystems::CloneRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::CloneRequest, flags) == 16);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::CloneRequest, object) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::fshost::Filesystems::CloseResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::fshost::Filesystems::CloseResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::fshost::Filesystems::CloseResponse)
    == ::llcpp::fuchsia::fshost::Filesystems::CloseResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::CloseResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::fshost::Filesystems::DescribeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::fshost::Filesystems::DescribeResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::fshost::Filesystems::DescribeResponse)
    == ::llcpp::fuchsia::fshost::Filesystems::DescribeResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::DescribeResponse, info) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::fshost::Filesystems::OnOpenResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::fshost::Filesystems::OnOpenResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::fshost::Filesystems::OnOpenResponse)
    == ::llcpp::fuchsia::fshost::Filesystems::OnOpenResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::OnOpenResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::OnOpenResponse, info) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::fshost::Filesystems::SyncResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::fshost::Filesystems::SyncResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::fshost::Filesystems::SyncResponse)
    == ::llcpp::fuchsia::fshost::Filesystems::SyncResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::SyncResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::fshost::Filesystems::GetAttrResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::fshost::Filesystems::GetAttrResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::fshost::Filesystems::GetAttrResponse)
    == ::llcpp::fuchsia::fshost::Filesystems::GetAttrResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::GetAttrResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::GetAttrResponse, attributes) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::fshost::Filesystems::SetAttrRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::fshost::Filesystems::SetAttrRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::fshost::Filesystems::SetAttrRequest)
    == ::llcpp::fuchsia::fshost::Filesystems::SetAttrRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::SetAttrRequest, flags) == 16);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::SetAttrRequest, attributes) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::fshost::Filesystems::SetAttrResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::fshost::Filesystems::SetAttrResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::fshost::Filesystems::SetAttrResponse)
    == ::llcpp::fuchsia::fshost::Filesystems::SetAttrResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::SetAttrResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::fshost::Filesystems::NodeGetFlagsResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::fshost::Filesystems::NodeGetFlagsResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::fshost::Filesystems::NodeGetFlagsResponse)
    == ::llcpp::fuchsia::fshost::Filesystems::NodeGetFlagsResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::NodeGetFlagsResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::NodeGetFlagsResponse, flags) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::fshost::Filesystems::NodeSetFlagsRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::fshost::Filesystems::NodeSetFlagsRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::fshost::Filesystems::NodeSetFlagsRequest)
    == ::llcpp::fuchsia::fshost::Filesystems::NodeSetFlagsRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::NodeSetFlagsRequest, flags) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::fshost::Filesystems::NodeSetFlagsResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::fshost::Filesystems::NodeSetFlagsResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::fshost::Filesystems::NodeSetFlagsResponse)
    == ::llcpp::fuchsia::fshost::Filesystems::NodeSetFlagsResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::NodeSetFlagsResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::fshost::Filesystems::OpenRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::fshost::Filesystems::OpenRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::fshost::Filesystems::OpenRequest)
    == ::llcpp::fuchsia::fshost::Filesystems::OpenRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::OpenRequest, flags) == 16);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::OpenRequest, mode) == 20);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::OpenRequest, path) == 24);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::OpenRequest, object) == 40);

template <>
struct IsFidlType<::llcpp::fuchsia::fshost::Filesystems::UnlinkRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::fshost::Filesystems::UnlinkRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::fshost::Filesystems::UnlinkRequest)
    == ::llcpp::fuchsia::fshost::Filesystems::UnlinkRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::UnlinkRequest, path) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::fshost::Filesystems::UnlinkResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::fshost::Filesystems::UnlinkResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::fshost::Filesystems::UnlinkResponse)
    == ::llcpp::fuchsia::fshost::Filesystems::UnlinkResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::UnlinkResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::fshost::Filesystems::ReadDirentsRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::fshost::Filesystems::ReadDirentsRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::fshost::Filesystems::ReadDirentsRequest)
    == ::llcpp::fuchsia::fshost::Filesystems::ReadDirentsRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::ReadDirentsRequest, max_bytes) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::fshost::Filesystems::ReadDirentsResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::fshost::Filesystems::ReadDirentsResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::fshost::Filesystems::ReadDirentsResponse)
    == ::llcpp::fuchsia::fshost::Filesystems::ReadDirentsResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::ReadDirentsResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::ReadDirentsResponse, dirents) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::fshost::Filesystems::RewindResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::fshost::Filesystems::RewindResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::fshost::Filesystems::RewindResponse)
    == ::llcpp::fuchsia::fshost::Filesystems::RewindResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::RewindResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::fshost::Filesystems::GetTokenResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::fshost::Filesystems::GetTokenResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::fshost::Filesystems::GetTokenResponse)
    == ::llcpp::fuchsia::fshost::Filesystems::GetTokenResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::GetTokenResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::GetTokenResponse, token) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::fshost::Filesystems::RenameRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::fshost::Filesystems::RenameRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::fshost::Filesystems::RenameRequest)
    == ::llcpp::fuchsia::fshost::Filesystems::RenameRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::RenameRequest, src) == 16);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::RenameRequest, dst_parent_token) == 32);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::RenameRequest, dst) == 40);

template <>
struct IsFidlType<::llcpp::fuchsia::fshost::Filesystems::RenameResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::fshost::Filesystems::RenameResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::fshost::Filesystems::RenameResponse)
    == ::llcpp::fuchsia::fshost::Filesystems::RenameResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::RenameResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::fshost::Filesystems::LinkRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::fshost::Filesystems::LinkRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::fshost::Filesystems::LinkRequest)
    == ::llcpp::fuchsia::fshost::Filesystems::LinkRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::LinkRequest, src) == 16);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::LinkRequest, dst_parent_token) == 32);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::LinkRequest, dst) == 40);

template <>
struct IsFidlType<::llcpp::fuchsia::fshost::Filesystems::LinkResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::fshost::Filesystems::LinkResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::fshost::Filesystems::LinkResponse)
    == ::llcpp::fuchsia::fshost::Filesystems::LinkResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::LinkResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::fshost::Filesystems::WatchRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::fshost::Filesystems::WatchRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::fshost::Filesystems::WatchRequest)
    == ::llcpp::fuchsia::fshost::Filesystems::WatchRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::WatchRequest, mask) == 16);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::WatchRequest, options) == 20);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::WatchRequest, watcher) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::fshost::Filesystems::WatchResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::fshost::Filesystems::WatchResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::fshost::Filesystems::WatchResponse)
    == ::llcpp::fuchsia::fshost::Filesystems::WatchResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::fshost::Filesystems::WatchResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::fshost::Registry::RegisterFilesystemRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::fshost::Registry::RegisterFilesystemRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::fshost::Registry::RegisterFilesystemRequest)
    == ::llcpp::fuchsia::fshost::Registry::RegisterFilesystemRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::fshost::Registry::RegisterFilesystemRequest, public_export) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::fshost::Registry::RegisterFilesystemResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::fshost::Registry::RegisterFilesystemResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::fshost::Registry::RegisterFilesystemResponse)
    == ::llcpp::fuchsia::fshost::Registry::RegisterFilesystemResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::fshost::Registry::RegisterFilesystemResponse, s) == 16);

}  // namespace fidl

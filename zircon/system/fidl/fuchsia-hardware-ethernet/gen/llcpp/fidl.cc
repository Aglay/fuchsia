// WARNING: This file is machine generated by fidlgen.

#include <fuchsia/hardware/ethernet/llcpp/fidl.h>
#include <memory>

namespace llcpp {

namespace fuchsia {
namespace hardware {
namespace ethernet {

namespace {

[[maybe_unused]]
constexpr uint64_t kDevice_GetInfo_Ordinal = 0x10c7deb400000000lu;
[[maybe_unused]]
constexpr uint64_t kDevice_GetInfo_GenOrdinal = 0x7f8e9a8dda706422lu;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceGetInfoRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceGetInfoResponseTable;
[[maybe_unused]]
constexpr uint64_t kDevice_GetFifos_Ordinal = 0x21e1e8f800000000lu;
[[maybe_unused]]
constexpr uint64_t kDevice_GetFifos_GenOrdinal = 0x57924e13bf602360lu;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceGetFifosRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceGetFifosResponseTable;
[[maybe_unused]]
constexpr uint64_t kDevice_SetIOBuffer_Ordinal = 0x201df7f300000000lu;
[[maybe_unused]]
constexpr uint64_t kDevice_SetIOBuffer_GenOrdinal = 0x66af0a45e326fda8lu;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceSetIOBufferRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceSetIOBufferResponseTable;
[[maybe_unused]]
constexpr uint64_t kDevice_Start_Ordinal = 0x23db365900000000lu;
[[maybe_unused]]
constexpr uint64_t kDevice_Start_GenOrdinal = 0x6e59b9bb7123be35lu;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceStartRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceStartResponseTable;
[[maybe_unused]]
constexpr uint64_t kDevice_Stop_Ordinal = 0x3dfcfe9500000000lu;
[[maybe_unused]]
constexpr uint64_t kDevice_Stop_GenOrdinal = 0x4bea699d7725dffblu;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceStopRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceStopResponseTable;
[[maybe_unused]]
constexpr uint64_t kDevice_ListenStart_Ordinal = 0x5b2495bb00000000lu;
[[maybe_unused]]
constexpr uint64_t kDevice_ListenStart_GenOrdinal = 0x2825d26aac1495dlu;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceListenStartRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceListenStartResponseTable;
[[maybe_unused]]
constexpr uint64_t kDevice_ListenStop_Ordinal = 0x236b1c5700000000lu;
[[maybe_unused]]
constexpr uint64_t kDevice_ListenStop_GenOrdinal = 0x102cbf5639c2403alu;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceListenStopRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceListenStopResponseTable;
[[maybe_unused]]
constexpr uint64_t kDevice_SetClientName_Ordinal = 0x640c922100000000lu;
[[maybe_unused]]
constexpr uint64_t kDevice_SetClientName_GenOrdinal = 0x16226cf5bfe3a001lu;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceSetClientNameRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceSetClientNameResponseTable;
[[maybe_unused]]
constexpr uint64_t kDevice_GetStatus_Ordinal = 0x6d63b33e00000000lu;
[[maybe_unused]]
constexpr uint64_t kDevice_GetStatus_GenOrdinal = 0x379a5ed530acd140lu;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceGetStatusRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceGetStatusResponseTable;
[[maybe_unused]]
constexpr uint64_t kDevice_SetPromiscuousMode_Ordinal = 0x34c1970400000000lu;
[[maybe_unused]]
constexpr uint64_t kDevice_SetPromiscuousMode_GenOrdinal = 0x6ae9e4516810f945lu;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceSetPromiscuousModeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceSetPromiscuousModeResponseTable;
[[maybe_unused]]
constexpr uint64_t kDevice_ConfigMulticastAddMac_Ordinal = 0x39fce1800000000lu;
[[maybe_unused]]
constexpr uint64_t kDevice_ConfigMulticastAddMac_GenOrdinal = 0x5cdb4b0bd52337b8lu;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceConfigMulticastAddMacRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceConfigMulticastAddMacResponseTable;
[[maybe_unused]]
constexpr uint64_t kDevice_ConfigMulticastDeleteMac_Ordinal = 0x51dadb9d00000000lu;
[[maybe_unused]]
constexpr uint64_t kDevice_ConfigMulticastDeleteMac_GenOrdinal = 0x540f49129d9bfa07lu;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceConfigMulticastDeleteMacRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceConfigMulticastDeleteMacResponseTable;
[[maybe_unused]]
constexpr uint64_t kDevice_ConfigMulticastSetPromiscuousMode_Ordinal = 0x2ab48ffa00000000lu;
[[maybe_unused]]
constexpr uint64_t kDevice_ConfigMulticastSetPromiscuousMode_GenOrdinal = 0x53d4ba4a14dbe91alu;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceConfigMulticastSetPromiscuousModeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceConfigMulticastSetPromiscuousModeResponseTable;
[[maybe_unused]]
constexpr uint64_t kDevice_ConfigMulticastTestFilter_Ordinal = 0x54b616e00000000lu;
[[maybe_unused]]
constexpr uint64_t kDevice_ConfigMulticastTestFilter_GenOrdinal = 0x5a83a0ecc3d952a3lu;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceConfigMulticastTestFilterRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceConfigMulticastTestFilterResponseTable;
[[maybe_unused]]
constexpr uint64_t kDevice_DumpRegisters_Ordinal = 0x5dd3c8c100000000lu;
[[maybe_unused]]
constexpr uint64_t kDevice_DumpRegisters_GenOrdinal = 0x43a8fb0535f81274lu;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceDumpRegistersRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceDumpRegistersResponseTable;

}  // namespace
template <>
Device::ResultOf::GetInfo_Impl<Device::GetInfoResponse>::GetInfo_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetInfoRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetInfoRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetInfoRequest));
  ::fidl::DecodedMessage<GetInfoRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Device::InPlace::GetInfo(std::move(_client_end), Super::response_buffer()));
}

Device::ResultOf::GetInfo Device::SyncClient::GetInfo() {
    return ResultOf::GetInfo(::zx::unowned_channel(this->channel_));
}

Device::ResultOf::GetInfo Device::Call::GetInfo(::zx::unowned_channel _client_end) {
  return ResultOf::GetInfo(std::move(_client_end));
}

template <>
Device::UnownedResultOf::GetInfo_Impl<Device::GetInfoResponse>::GetInfo_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetInfoRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetInfoRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetInfoRequest));
  ::fidl::DecodedMessage<GetInfoRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Device::InPlace::GetInfo(std::move(_client_end), std::move(_response_buffer)));
}

Device::UnownedResultOf::GetInfo Device::SyncClient::GetInfo(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetInfo(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Device::UnownedResultOf::GetInfo Device::Call::GetInfo(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetInfo(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::GetInfoResponse> Device::InPlace::GetInfo(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetInfoRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetInfoRequest> params(std::move(_request_buffer));
  Device::SetTransactionHeaderFor::GetInfoRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::GetInfoResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetInfoRequest, GetInfoResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::GetInfoResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Device::ResultOf::GetFifos_Impl<Device::GetFifosResponse>::GetFifos_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetFifosRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetFifosRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetFifosRequest));
  ::fidl::DecodedMessage<GetFifosRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Device::InPlace::GetFifos(std::move(_client_end), Super::response_buffer()));
}

Device::ResultOf::GetFifos Device::SyncClient::GetFifos() {
    return ResultOf::GetFifos(::zx::unowned_channel(this->channel_));
}

Device::ResultOf::GetFifos Device::Call::GetFifos(::zx::unowned_channel _client_end) {
  return ResultOf::GetFifos(std::move(_client_end));
}

template <>
Device::UnownedResultOf::GetFifos_Impl<Device::GetFifosResponse>::GetFifos_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetFifosRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetFifosRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetFifosRequest));
  ::fidl::DecodedMessage<GetFifosRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Device::InPlace::GetFifos(std::move(_client_end), std::move(_response_buffer)));
}

Device::UnownedResultOf::GetFifos Device::SyncClient::GetFifos(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetFifos(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Device::UnownedResultOf::GetFifos Device::Call::GetFifos(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetFifos(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::GetFifosResponse> Device::InPlace::GetFifos(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetFifosRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetFifosRequest> params(std::move(_request_buffer));
  Device::SetTransactionHeaderFor::GetFifosRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::GetFifosResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetFifosRequest, GetFifosResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::GetFifosResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Device::ResultOf::SetIOBuffer_Impl<Device::SetIOBufferResponse>::SetIOBuffer_Impl(::zx::unowned_channel _client_end, ::zx::vmo h) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetIOBufferRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetIOBufferRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetIOBufferRequest*>(_write_bytes);
  _request.h = std::move(h);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetIOBufferRequest));
  ::fidl::DecodedMessage<SetIOBufferRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Device::InPlace::SetIOBuffer(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Device::ResultOf::SetIOBuffer Device::SyncClient::SetIOBuffer(::zx::vmo h) {
    return ResultOf::SetIOBuffer(::zx::unowned_channel(this->channel_), std::move(h));
}

Device::ResultOf::SetIOBuffer Device::Call::SetIOBuffer(::zx::unowned_channel _client_end, ::zx::vmo h) {
  return ResultOf::SetIOBuffer(std::move(_client_end), std::move(h));
}

template <>
Device::UnownedResultOf::SetIOBuffer_Impl<Device::SetIOBufferResponse>::SetIOBuffer_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::vmo h, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < SetIOBufferRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<SetIOBufferResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, SetIOBufferRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetIOBufferRequest*>(_request_buffer.data());
  _request.h = std::move(h);
  _request_buffer.set_actual(sizeof(SetIOBufferRequest));
  ::fidl::DecodedMessage<SetIOBufferRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Device::InPlace::SetIOBuffer(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Device::UnownedResultOf::SetIOBuffer Device::SyncClient::SetIOBuffer(::fidl::BytePart _request_buffer, ::zx::vmo h, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetIOBuffer(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(h), std::move(_response_buffer));
}

Device::UnownedResultOf::SetIOBuffer Device::Call::SetIOBuffer(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::vmo h, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetIOBuffer(std::move(_client_end), std::move(_request_buffer), std::move(h), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::SetIOBufferResponse> Device::InPlace::SetIOBuffer(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetIOBufferRequest> params, ::fidl::BytePart response_buffer) {
  Device::SetTransactionHeaderFor::SetIOBufferRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::SetIOBufferResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SetIOBufferRequest, SetIOBufferResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::SetIOBufferResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Device::ResultOf::Start_Impl<Device::StartResponse>::Start_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<StartRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, StartRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(StartRequest));
  ::fidl::DecodedMessage<StartRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Device::InPlace::Start(std::move(_client_end), Super::response_buffer()));
}

Device::ResultOf::Start Device::SyncClient::Start() {
    return ResultOf::Start(::zx::unowned_channel(this->channel_));
}

Device::ResultOf::Start Device::Call::Start(::zx::unowned_channel _client_end) {
  return ResultOf::Start(std::move(_client_end));
}

template <>
Device::UnownedResultOf::Start_Impl<Device::StartResponse>::Start_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(StartRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, StartRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(StartRequest));
  ::fidl::DecodedMessage<StartRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Device::InPlace::Start(std::move(_client_end), std::move(_response_buffer)));
}

Device::UnownedResultOf::Start Device::SyncClient::Start(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Start(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Device::UnownedResultOf::Start Device::Call::Start(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Start(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::StartResponse> Device::InPlace::Start(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(StartRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<StartRequest> params(std::move(_request_buffer));
  Device::SetTransactionHeaderFor::StartRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::StartResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<StartRequest, StartResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::StartResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Device::ResultOf::Stop_Impl<Device::StopResponse>::Stop_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<StopRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, StopRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(StopRequest));
  ::fidl::DecodedMessage<StopRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Device::InPlace::Stop(std::move(_client_end), Super::response_buffer()));
}

Device::ResultOf::Stop Device::SyncClient::Stop() {
    return ResultOf::Stop(::zx::unowned_channel(this->channel_));
}

Device::ResultOf::Stop Device::Call::Stop(::zx::unowned_channel _client_end) {
  return ResultOf::Stop(std::move(_client_end));
}

::fidl::DecodeResult<Device::StopResponse> Device::InPlace::Stop(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(StopRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<StopRequest> params(std::move(_request_buffer));
  Device::SetTransactionHeaderFor::StopRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::StopResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<StopRequest, StopResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::StopResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Device::ResultOf::ListenStart_Impl<Device::ListenStartResponse>::ListenStart_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ListenStartRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ListenStartRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ListenStartRequest));
  ::fidl::DecodedMessage<ListenStartRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Device::InPlace::ListenStart(std::move(_client_end), Super::response_buffer()));
}

Device::ResultOf::ListenStart Device::SyncClient::ListenStart() {
    return ResultOf::ListenStart(::zx::unowned_channel(this->channel_));
}

Device::ResultOf::ListenStart Device::Call::ListenStart(::zx::unowned_channel _client_end) {
  return ResultOf::ListenStart(std::move(_client_end));
}

template <>
Device::UnownedResultOf::ListenStart_Impl<Device::ListenStartResponse>::ListenStart_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(ListenStartRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, ListenStartRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(ListenStartRequest));
  ::fidl::DecodedMessage<ListenStartRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Device::InPlace::ListenStart(std::move(_client_end), std::move(_response_buffer)));
}

Device::UnownedResultOf::ListenStart Device::SyncClient::ListenStart(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ListenStart(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Device::UnownedResultOf::ListenStart Device::Call::ListenStart(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ListenStart(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::ListenStartResponse> Device::InPlace::ListenStart(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(ListenStartRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<ListenStartRequest> params(std::move(_request_buffer));
  Device::SetTransactionHeaderFor::ListenStartRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::ListenStartResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ListenStartRequest, ListenStartResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::ListenStartResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Device::ResultOf::ListenStop_Impl<Device::ListenStopResponse>::ListenStop_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ListenStopRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ListenStopRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ListenStopRequest));
  ::fidl::DecodedMessage<ListenStopRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Device::InPlace::ListenStop(std::move(_client_end), Super::response_buffer()));
}

Device::ResultOf::ListenStop Device::SyncClient::ListenStop() {
    return ResultOf::ListenStop(::zx::unowned_channel(this->channel_));
}

Device::ResultOf::ListenStop Device::Call::ListenStop(::zx::unowned_channel _client_end) {
  return ResultOf::ListenStop(std::move(_client_end));
}

::fidl::DecodeResult<Device::ListenStopResponse> Device::InPlace::ListenStop(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(ListenStopRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<ListenStopRequest> params(std::move(_request_buffer));
  Device::SetTransactionHeaderFor::ListenStopRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::ListenStopResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ListenStopRequest, ListenStopResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::ListenStopResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Device::ResultOf::SetClientName_Impl<Device::SetClientNameResponse>::SetClientName_Impl(::zx::unowned_channel _client_end, ::fidl::StringView name) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetClientNameRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  SetClientNameRequest _request = {};
  _request.name = std::move(name);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<SetClientNameRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Device::InPlace::SetClientName(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Device::ResultOf::SetClientName Device::SyncClient::SetClientName(::fidl::StringView name) {
    return ResultOf::SetClientName(::zx::unowned_channel(this->channel_), std::move(name));
}

Device::ResultOf::SetClientName Device::Call::SetClientName(::zx::unowned_channel _client_end, ::fidl::StringView name) {
  return ResultOf::SetClientName(std::move(_client_end), std::move(name));
}

template <>
Device::UnownedResultOf::SetClientName_Impl<Device::SetClientNameResponse>::SetClientName_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView name, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < SetClientNameRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<SetClientNameResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  SetClientNameRequest _request = {};
  _request.name = std::move(name);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<SetClientNameRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Device::InPlace::SetClientName(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Device::UnownedResultOf::SetClientName Device::SyncClient::SetClientName(::fidl::BytePart _request_buffer, ::fidl::StringView name, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetClientName(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(name), std::move(_response_buffer));
}

Device::UnownedResultOf::SetClientName Device::Call::SetClientName(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView name, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetClientName(std::move(_client_end), std::move(_request_buffer), std::move(name), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::SetClientNameResponse> Device::InPlace::SetClientName(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetClientNameRequest> params, ::fidl::BytePart response_buffer) {
  Device::SetTransactionHeaderFor::SetClientNameRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::SetClientNameResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SetClientNameRequest, SetClientNameResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::SetClientNameResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Device::ResultOf::GetStatus_Impl<Device::GetStatusResponse>::GetStatus_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetStatusRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetStatusRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetStatusRequest));
  ::fidl::DecodedMessage<GetStatusRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Device::InPlace::GetStatus(std::move(_client_end), Super::response_buffer()));
}

Device::ResultOf::GetStatus Device::SyncClient::GetStatus() {
    return ResultOf::GetStatus(::zx::unowned_channel(this->channel_));
}

Device::ResultOf::GetStatus Device::Call::GetStatus(::zx::unowned_channel _client_end) {
  return ResultOf::GetStatus(std::move(_client_end));
}

template <>
Device::UnownedResultOf::GetStatus_Impl<Device::GetStatusResponse>::GetStatus_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetStatusRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetStatusRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetStatusRequest));
  ::fidl::DecodedMessage<GetStatusRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Device::InPlace::GetStatus(std::move(_client_end), std::move(_response_buffer)));
}

Device::UnownedResultOf::GetStatus Device::SyncClient::GetStatus(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetStatus(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Device::UnownedResultOf::GetStatus Device::Call::GetStatus(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetStatus(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::GetStatusResponse> Device::InPlace::GetStatus(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetStatusRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetStatusRequest> params(std::move(_request_buffer));
  Device::SetTransactionHeaderFor::GetStatusRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::GetStatusResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetStatusRequest, GetStatusResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::GetStatusResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Device::ResultOf::SetPromiscuousMode_Impl<Device::SetPromiscuousModeResponse>::SetPromiscuousMode_Impl(::zx::unowned_channel _client_end, bool enabled) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetPromiscuousModeRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetPromiscuousModeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetPromiscuousModeRequest*>(_write_bytes);
  _request.enabled = std::move(enabled);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetPromiscuousModeRequest));
  ::fidl::DecodedMessage<SetPromiscuousModeRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Device::InPlace::SetPromiscuousMode(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Device::ResultOf::SetPromiscuousMode Device::SyncClient::SetPromiscuousMode(bool enabled) {
    return ResultOf::SetPromiscuousMode(::zx::unowned_channel(this->channel_), std::move(enabled));
}

Device::ResultOf::SetPromiscuousMode Device::Call::SetPromiscuousMode(::zx::unowned_channel _client_end, bool enabled) {
  return ResultOf::SetPromiscuousMode(std::move(_client_end), std::move(enabled));
}

template <>
Device::UnownedResultOf::SetPromiscuousMode_Impl<Device::SetPromiscuousModeResponse>::SetPromiscuousMode_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, bool enabled, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < SetPromiscuousModeRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<SetPromiscuousModeResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, SetPromiscuousModeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetPromiscuousModeRequest*>(_request_buffer.data());
  _request.enabled = std::move(enabled);
  _request_buffer.set_actual(sizeof(SetPromiscuousModeRequest));
  ::fidl::DecodedMessage<SetPromiscuousModeRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Device::InPlace::SetPromiscuousMode(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Device::UnownedResultOf::SetPromiscuousMode Device::SyncClient::SetPromiscuousMode(::fidl::BytePart _request_buffer, bool enabled, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetPromiscuousMode(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(enabled), std::move(_response_buffer));
}

Device::UnownedResultOf::SetPromiscuousMode Device::Call::SetPromiscuousMode(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, bool enabled, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetPromiscuousMode(std::move(_client_end), std::move(_request_buffer), std::move(enabled), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::SetPromiscuousModeResponse> Device::InPlace::SetPromiscuousMode(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetPromiscuousModeRequest> params, ::fidl::BytePart response_buffer) {
  Device::SetTransactionHeaderFor::SetPromiscuousModeRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::SetPromiscuousModeResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SetPromiscuousModeRequest, SetPromiscuousModeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::SetPromiscuousModeResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Device::ResultOf::ConfigMulticastAddMac_Impl<Device::ConfigMulticastAddMacResponse>::ConfigMulticastAddMac_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::ethernet::MacAddress addr) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ConfigMulticastAddMacRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ConfigMulticastAddMacRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ConfigMulticastAddMacRequest*>(_write_bytes);
  _request.addr = std::move(addr);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ConfigMulticastAddMacRequest));
  ::fidl::DecodedMessage<ConfigMulticastAddMacRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Device::InPlace::ConfigMulticastAddMac(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Device::ResultOf::ConfigMulticastAddMac Device::SyncClient::ConfigMulticastAddMac(::llcpp::fuchsia::hardware::ethernet::MacAddress addr) {
    return ResultOf::ConfigMulticastAddMac(::zx::unowned_channel(this->channel_), std::move(addr));
}

Device::ResultOf::ConfigMulticastAddMac Device::Call::ConfigMulticastAddMac(::zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::ethernet::MacAddress addr) {
  return ResultOf::ConfigMulticastAddMac(std::move(_client_end), std::move(addr));
}

template <>
Device::UnownedResultOf::ConfigMulticastAddMac_Impl<Device::ConfigMulticastAddMacResponse>::ConfigMulticastAddMac_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::ethernet::MacAddress addr, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < ConfigMulticastAddMacRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<ConfigMulticastAddMacResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, ConfigMulticastAddMacRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ConfigMulticastAddMacRequest*>(_request_buffer.data());
  _request.addr = std::move(addr);
  _request_buffer.set_actual(sizeof(ConfigMulticastAddMacRequest));
  ::fidl::DecodedMessage<ConfigMulticastAddMacRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Device::InPlace::ConfigMulticastAddMac(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Device::UnownedResultOf::ConfigMulticastAddMac Device::SyncClient::ConfigMulticastAddMac(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::ethernet::MacAddress addr, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ConfigMulticastAddMac(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(addr), std::move(_response_buffer));
}

Device::UnownedResultOf::ConfigMulticastAddMac Device::Call::ConfigMulticastAddMac(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::ethernet::MacAddress addr, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ConfigMulticastAddMac(std::move(_client_end), std::move(_request_buffer), std::move(addr), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::ConfigMulticastAddMacResponse> Device::InPlace::ConfigMulticastAddMac(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ConfigMulticastAddMacRequest> params, ::fidl::BytePart response_buffer) {
  Device::SetTransactionHeaderFor::ConfigMulticastAddMacRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::ConfigMulticastAddMacResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ConfigMulticastAddMacRequest, ConfigMulticastAddMacResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::ConfigMulticastAddMacResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Device::ResultOf::ConfigMulticastDeleteMac_Impl<Device::ConfigMulticastDeleteMacResponse>::ConfigMulticastDeleteMac_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::ethernet::MacAddress addr) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ConfigMulticastDeleteMacRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ConfigMulticastDeleteMacRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ConfigMulticastDeleteMacRequest*>(_write_bytes);
  _request.addr = std::move(addr);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ConfigMulticastDeleteMacRequest));
  ::fidl::DecodedMessage<ConfigMulticastDeleteMacRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Device::InPlace::ConfigMulticastDeleteMac(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Device::ResultOf::ConfigMulticastDeleteMac Device::SyncClient::ConfigMulticastDeleteMac(::llcpp::fuchsia::hardware::ethernet::MacAddress addr) {
    return ResultOf::ConfigMulticastDeleteMac(::zx::unowned_channel(this->channel_), std::move(addr));
}

Device::ResultOf::ConfigMulticastDeleteMac Device::Call::ConfigMulticastDeleteMac(::zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::ethernet::MacAddress addr) {
  return ResultOf::ConfigMulticastDeleteMac(std::move(_client_end), std::move(addr));
}

template <>
Device::UnownedResultOf::ConfigMulticastDeleteMac_Impl<Device::ConfigMulticastDeleteMacResponse>::ConfigMulticastDeleteMac_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::ethernet::MacAddress addr, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < ConfigMulticastDeleteMacRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<ConfigMulticastDeleteMacResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, ConfigMulticastDeleteMacRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ConfigMulticastDeleteMacRequest*>(_request_buffer.data());
  _request.addr = std::move(addr);
  _request_buffer.set_actual(sizeof(ConfigMulticastDeleteMacRequest));
  ::fidl::DecodedMessage<ConfigMulticastDeleteMacRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Device::InPlace::ConfigMulticastDeleteMac(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Device::UnownedResultOf::ConfigMulticastDeleteMac Device::SyncClient::ConfigMulticastDeleteMac(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::ethernet::MacAddress addr, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ConfigMulticastDeleteMac(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(addr), std::move(_response_buffer));
}

Device::UnownedResultOf::ConfigMulticastDeleteMac Device::Call::ConfigMulticastDeleteMac(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::ethernet::MacAddress addr, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ConfigMulticastDeleteMac(std::move(_client_end), std::move(_request_buffer), std::move(addr), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::ConfigMulticastDeleteMacResponse> Device::InPlace::ConfigMulticastDeleteMac(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ConfigMulticastDeleteMacRequest> params, ::fidl::BytePart response_buffer) {
  Device::SetTransactionHeaderFor::ConfigMulticastDeleteMacRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::ConfigMulticastDeleteMacResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ConfigMulticastDeleteMacRequest, ConfigMulticastDeleteMacResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::ConfigMulticastDeleteMacResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Device::ResultOf::ConfigMulticastSetPromiscuousMode_Impl<Device::ConfigMulticastSetPromiscuousModeResponse>::ConfigMulticastSetPromiscuousMode_Impl(::zx::unowned_channel _client_end, bool enabled) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ConfigMulticastSetPromiscuousModeRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ConfigMulticastSetPromiscuousModeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ConfigMulticastSetPromiscuousModeRequest*>(_write_bytes);
  _request.enabled = std::move(enabled);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ConfigMulticastSetPromiscuousModeRequest));
  ::fidl::DecodedMessage<ConfigMulticastSetPromiscuousModeRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Device::InPlace::ConfigMulticastSetPromiscuousMode(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Device::ResultOf::ConfigMulticastSetPromiscuousMode Device::SyncClient::ConfigMulticastSetPromiscuousMode(bool enabled) {
    return ResultOf::ConfigMulticastSetPromiscuousMode(::zx::unowned_channel(this->channel_), std::move(enabled));
}

Device::ResultOf::ConfigMulticastSetPromiscuousMode Device::Call::ConfigMulticastSetPromiscuousMode(::zx::unowned_channel _client_end, bool enabled) {
  return ResultOf::ConfigMulticastSetPromiscuousMode(std::move(_client_end), std::move(enabled));
}

template <>
Device::UnownedResultOf::ConfigMulticastSetPromiscuousMode_Impl<Device::ConfigMulticastSetPromiscuousModeResponse>::ConfigMulticastSetPromiscuousMode_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, bool enabled, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < ConfigMulticastSetPromiscuousModeRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<ConfigMulticastSetPromiscuousModeResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, ConfigMulticastSetPromiscuousModeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ConfigMulticastSetPromiscuousModeRequest*>(_request_buffer.data());
  _request.enabled = std::move(enabled);
  _request_buffer.set_actual(sizeof(ConfigMulticastSetPromiscuousModeRequest));
  ::fidl::DecodedMessage<ConfigMulticastSetPromiscuousModeRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Device::InPlace::ConfigMulticastSetPromiscuousMode(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Device::UnownedResultOf::ConfigMulticastSetPromiscuousMode Device::SyncClient::ConfigMulticastSetPromiscuousMode(::fidl::BytePart _request_buffer, bool enabled, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ConfigMulticastSetPromiscuousMode(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(enabled), std::move(_response_buffer));
}

Device::UnownedResultOf::ConfigMulticastSetPromiscuousMode Device::Call::ConfigMulticastSetPromiscuousMode(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, bool enabled, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ConfigMulticastSetPromiscuousMode(std::move(_client_end), std::move(_request_buffer), std::move(enabled), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::ConfigMulticastSetPromiscuousModeResponse> Device::InPlace::ConfigMulticastSetPromiscuousMode(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ConfigMulticastSetPromiscuousModeRequest> params, ::fidl::BytePart response_buffer) {
  Device::SetTransactionHeaderFor::ConfigMulticastSetPromiscuousModeRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::ConfigMulticastSetPromiscuousModeResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ConfigMulticastSetPromiscuousModeRequest, ConfigMulticastSetPromiscuousModeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::ConfigMulticastSetPromiscuousModeResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Device::ResultOf::ConfigMulticastTestFilter_Impl<Device::ConfigMulticastTestFilterResponse>::ConfigMulticastTestFilter_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ConfigMulticastTestFilterRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ConfigMulticastTestFilterRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ConfigMulticastTestFilterRequest));
  ::fidl::DecodedMessage<ConfigMulticastTestFilterRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Device::InPlace::ConfigMulticastTestFilter(std::move(_client_end), Super::response_buffer()));
}

Device::ResultOf::ConfigMulticastTestFilter Device::SyncClient::ConfigMulticastTestFilter() {
    return ResultOf::ConfigMulticastTestFilter(::zx::unowned_channel(this->channel_));
}

Device::ResultOf::ConfigMulticastTestFilter Device::Call::ConfigMulticastTestFilter(::zx::unowned_channel _client_end) {
  return ResultOf::ConfigMulticastTestFilter(std::move(_client_end));
}

template <>
Device::UnownedResultOf::ConfigMulticastTestFilter_Impl<Device::ConfigMulticastTestFilterResponse>::ConfigMulticastTestFilter_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(ConfigMulticastTestFilterRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, ConfigMulticastTestFilterRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(ConfigMulticastTestFilterRequest));
  ::fidl::DecodedMessage<ConfigMulticastTestFilterRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Device::InPlace::ConfigMulticastTestFilter(std::move(_client_end), std::move(_response_buffer)));
}

Device::UnownedResultOf::ConfigMulticastTestFilter Device::SyncClient::ConfigMulticastTestFilter(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ConfigMulticastTestFilter(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Device::UnownedResultOf::ConfigMulticastTestFilter Device::Call::ConfigMulticastTestFilter(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ConfigMulticastTestFilter(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::ConfigMulticastTestFilterResponse> Device::InPlace::ConfigMulticastTestFilter(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(ConfigMulticastTestFilterRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<ConfigMulticastTestFilterRequest> params(std::move(_request_buffer));
  Device::SetTransactionHeaderFor::ConfigMulticastTestFilterRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::ConfigMulticastTestFilterResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ConfigMulticastTestFilterRequest, ConfigMulticastTestFilterResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::ConfigMulticastTestFilterResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Device::ResultOf::DumpRegisters_Impl<Device::DumpRegistersResponse>::DumpRegisters_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DumpRegistersRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, DumpRegistersRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(DumpRegistersRequest));
  ::fidl::DecodedMessage<DumpRegistersRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Device::InPlace::DumpRegisters(std::move(_client_end), Super::response_buffer()));
}

Device::ResultOf::DumpRegisters Device::SyncClient::DumpRegisters() {
    return ResultOf::DumpRegisters(::zx::unowned_channel(this->channel_));
}

Device::ResultOf::DumpRegisters Device::Call::DumpRegisters(::zx::unowned_channel _client_end) {
  return ResultOf::DumpRegisters(std::move(_client_end));
}

template <>
Device::UnownedResultOf::DumpRegisters_Impl<Device::DumpRegistersResponse>::DumpRegisters_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(DumpRegistersRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, DumpRegistersRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(DumpRegistersRequest));
  ::fidl::DecodedMessage<DumpRegistersRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Device::InPlace::DumpRegisters(std::move(_client_end), std::move(_response_buffer)));
}

Device::UnownedResultOf::DumpRegisters Device::SyncClient::DumpRegisters(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::DumpRegisters(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Device::UnownedResultOf::DumpRegisters Device::Call::DumpRegisters(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::DumpRegisters(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::DumpRegistersResponse> Device::InPlace::DumpRegisters(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(DumpRegistersRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<DumpRegistersRequest> params(std::move(_request_buffer));
  Device::SetTransactionHeaderFor::DumpRegistersRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::DumpRegistersResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<DumpRegistersRequest, DumpRegistersResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::DumpRegistersResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool Device::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kDevice_GetInfo_Ordinal:
    case kDevice_GetInfo_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetInfoRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetInfo(
          Interface::GetInfoCompleter::Sync(txn));
      return true;
    }
    case kDevice_GetFifos_Ordinal:
    case kDevice_GetFifos_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetFifosRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetFifos(
          Interface::GetFifosCompleter::Sync(txn));
      return true;
    }
    case kDevice_SetIOBuffer_Ordinal:
    case kDevice_SetIOBuffer_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetIOBufferRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetIOBuffer(std::move(message->h),
          Interface::SetIOBufferCompleter::Sync(txn));
      return true;
    }
    case kDevice_Start_Ordinal:
    case kDevice_Start_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<StartRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Start(
          Interface::StartCompleter::Sync(txn));
      return true;
    }
    case kDevice_Stop_Ordinal:
    case kDevice_Stop_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<StopRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Stop(
          Interface::StopCompleter::Sync(txn));
      return true;
    }
    case kDevice_ListenStart_Ordinal:
    case kDevice_ListenStart_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ListenStartRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->ListenStart(
          Interface::ListenStartCompleter::Sync(txn));
      return true;
    }
    case kDevice_ListenStop_Ordinal:
    case kDevice_ListenStop_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ListenStopRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->ListenStop(
          Interface::ListenStopCompleter::Sync(txn));
      return true;
    }
    case kDevice_SetClientName_Ordinal:
    case kDevice_SetClientName_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetClientNameRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetClientName(std::move(message->name),
          Interface::SetClientNameCompleter::Sync(txn));
      return true;
    }
    case kDevice_GetStatus_Ordinal:
    case kDevice_GetStatus_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetStatusRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetStatus(
          Interface::GetStatusCompleter::Sync(txn));
      return true;
    }
    case kDevice_SetPromiscuousMode_Ordinal:
    case kDevice_SetPromiscuousMode_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetPromiscuousModeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetPromiscuousMode(std::move(message->enabled),
          Interface::SetPromiscuousModeCompleter::Sync(txn));
      return true;
    }
    case kDevice_ConfigMulticastAddMac_Ordinal:
    case kDevice_ConfigMulticastAddMac_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ConfigMulticastAddMacRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->ConfigMulticastAddMac(std::move(message->addr),
          Interface::ConfigMulticastAddMacCompleter::Sync(txn));
      return true;
    }
    case kDevice_ConfigMulticastDeleteMac_Ordinal:
    case kDevice_ConfigMulticastDeleteMac_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ConfigMulticastDeleteMacRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->ConfigMulticastDeleteMac(std::move(message->addr),
          Interface::ConfigMulticastDeleteMacCompleter::Sync(txn));
      return true;
    }
    case kDevice_ConfigMulticastSetPromiscuousMode_Ordinal:
    case kDevice_ConfigMulticastSetPromiscuousMode_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ConfigMulticastSetPromiscuousModeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->ConfigMulticastSetPromiscuousMode(std::move(message->enabled),
          Interface::ConfigMulticastSetPromiscuousModeCompleter::Sync(txn));
      return true;
    }
    case kDevice_ConfigMulticastTestFilter_Ordinal:
    case kDevice_ConfigMulticastTestFilter_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ConfigMulticastTestFilterRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->ConfigMulticastTestFilter(
          Interface::ConfigMulticastTestFilterCompleter::Sync(txn));
      return true;
    }
    case kDevice_DumpRegisters_Ordinal:
    case kDevice_DumpRegisters_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<DumpRegistersRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->DumpRegisters(
          Interface::DumpRegistersCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Device::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void Device::Interface::GetInfoCompleterBase::Reply(::llcpp::fuchsia::hardware::ethernet::Info info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetInfoResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetInfoResponse*>(_write_bytes);
  Device::SetTransactionHeaderFor::GetInfoResponse(
      ::fidl::DecodedMessage<GetInfoResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetInfoResponse::PrimarySize,
              GetInfoResponse::PrimarySize)));
  _response.info = std::move(info);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetInfoResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetInfoResponse>(std::move(_response_bytes)));
}

void Device::Interface::GetInfoCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::ethernet::Info info) {
  if (_buffer.capacity() < GetInfoResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetInfoResponse*>(_buffer.data());
  Device::SetTransactionHeaderFor::GetInfoResponse(
      ::fidl::DecodedMessage<GetInfoResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetInfoResponse::PrimarySize,
              GetInfoResponse::PrimarySize)));
  _response.info = std::move(info);
  _buffer.set_actual(sizeof(GetInfoResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetInfoResponse>(std::move(_buffer)));
}

void Device::Interface::GetInfoCompleterBase::Reply(::fidl::DecodedMessage<GetInfoResponse> params) {
  Device::SetTransactionHeaderFor::GetInfoResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Device::Interface::GetFifosCompleterBase::Reply(int32_t status, ::llcpp::fuchsia::hardware::ethernet::Fifos* info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetFifosResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  GetFifosResponse _response = {};
  Device::SetTransactionHeaderFor::GetFifosResponse(
      ::fidl::DecodedMessage<GetFifosResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetFifosResponse::PrimarySize,
              GetFifosResponse::PrimarySize)));
  _response.status = std::move(status);
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Device::Interface::GetFifosCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status, ::llcpp::fuchsia::hardware::ethernet::Fifos* info) {
  if (_buffer.capacity() < GetFifosResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetFifosResponse _response = {};
  Device::SetTransactionHeaderFor::GetFifosResponse(
      ::fidl::DecodedMessage<GetFifosResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetFifosResponse::PrimarySize,
              GetFifosResponse::PrimarySize)));
  _response.status = std::move(status);
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Device::Interface::GetFifosCompleterBase::Reply(::fidl::DecodedMessage<GetFifosResponse> params) {
  Device::SetTransactionHeaderFor::GetFifosResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Device::Interface::SetIOBufferCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetIOBufferResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SetIOBufferResponse*>(_write_bytes);
  Device::SetTransactionHeaderFor::SetIOBufferResponse(
      ::fidl::DecodedMessage<SetIOBufferResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetIOBufferResponse::PrimarySize,
              SetIOBufferResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetIOBufferResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetIOBufferResponse>(std::move(_response_bytes)));
}

void Device::Interface::SetIOBufferCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < SetIOBufferResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SetIOBufferResponse*>(_buffer.data());
  Device::SetTransactionHeaderFor::SetIOBufferResponse(
      ::fidl::DecodedMessage<SetIOBufferResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetIOBufferResponse::PrimarySize,
              SetIOBufferResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(SetIOBufferResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetIOBufferResponse>(std::move(_buffer)));
}

void Device::Interface::SetIOBufferCompleterBase::Reply(::fidl::DecodedMessage<SetIOBufferResponse> params) {
  Device::SetTransactionHeaderFor::SetIOBufferResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Device::Interface::StartCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<StartResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<StartResponse*>(_write_bytes);
  Device::SetTransactionHeaderFor::StartResponse(
      ::fidl::DecodedMessage<StartResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              StartResponse::PrimarySize,
              StartResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(StartResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<StartResponse>(std::move(_response_bytes)));
}

void Device::Interface::StartCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < StartResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<StartResponse*>(_buffer.data());
  Device::SetTransactionHeaderFor::StartResponse(
      ::fidl::DecodedMessage<StartResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              StartResponse::PrimarySize,
              StartResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(StartResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<StartResponse>(std::move(_buffer)));
}

void Device::Interface::StartCompleterBase::Reply(::fidl::DecodedMessage<StartResponse> params) {
  Device::SetTransactionHeaderFor::StartResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Device::Interface::StopCompleterBase::Reply() {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<StopResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<StopResponse*>(_write_bytes);
  Device::SetTransactionHeaderFor::StopResponse(
      ::fidl::DecodedMessage<StopResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              StopResponse::PrimarySize,
              StopResponse::PrimarySize)));
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(StopResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<StopResponse>(std::move(_response_bytes)));
}


void Device::Interface::ListenStartCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ListenStartResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<ListenStartResponse*>(_write_bytes);
  Device::SetTransactionHeaderFor::ListenStartResponse(
      ::fidl::DecodedMessage<ListenStartResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ListenStartResponse::PrimarySize,
              ListenStartResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(ListenStartResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ListenStartResponse>(std::move(_response_bytes)));
}

void Device::Interface::ListenStartCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < ListenStartResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<ListenStartResponse*>(_buffer.data());
  Device::SetTransactionHeaderFor::ListenStartResponse(
      ::fidl::DecodedMessage<ListenStartResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ListenStartResponse::PrimarySize,
              ListenStartResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(ListenStartResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ListenStartResponse>(std::move(_buffer)));
}

void Device::Interface::ListenStartCompleterBase::Reply(::fidl::DecodedMessage<ListenStartResponse> params) {
  Device::SetTransactionHeaderFor::ListenStartResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Device::Interface::ListenStopCompleterBase::Reply() {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ListenStopResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<ListenStopResponse*>(_write_bytes);
  Device::SetTransactionHeaderFor::ListenStopResponse(
      ::fidl::DecodedMessage<ListenStopResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ListenStopResponse::PrimarySize,
              ListenStopResponse::PrimarySize)));
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(ListenStopResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ListenStopResponse>(std::move(_response_bytes)));
}


void Device::Interface::SetClientNameCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetClientNameResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SetClientNameResponse*>(_write_bytes);
  Device::SetTransactionHeaderFor::SetClientNameResponse(
      ::fidl::DecodedMessage<SetClientNameResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetClientNameResponse::PrimarySize,
              SetClientNameResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetClientNameResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetClientNameResponse>(std::move(_response_bytes)));
}

void Device::Interface::SetClientNameCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < SetClientNameResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SetClientNameResponse*>(_buffer.data());
  Device::SetTransactionHeaderFor::SetClientNameResponse(
      ::fidl::DecodedMessage<SetClientNameResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetClientNameResponse::PrimarySize,
              SetClientNameResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(SetClientNameResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetClientNameResponse>(std::move(_buffer)));
}

void Device::Interface::SetClientNameCompleterBase::Reply(::fidl::DecodedMessage<SetClientNameResponse> params) {
  Device::SetTransactionHeaderFor::SetClientNameResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Device::Interface::GetStatusCompleterBase::Reply(uint32_t device_status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetStatusResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetStatusResponse*>(_write_bytes);
  Device::SetTransactionHeaderFor::GetStatusResponse(
      ::fidl::DecodedMessage<GetStatusResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetStatusResponse::PrimarySize,
              GetStatusResponse::PrimarySize)));
  _response.device_status = std::move(device_status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetStatusResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetStatusResponse>(std::move(_response_bytes)));
}

void Device::Interface::GetStatusCompleterBase::Reply(::fidl::BytePart _buffer, uint32_t device_status) {
  if (_buffer.capacity() < GetStatusResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetStatusResponse*>(_buffer.data());
  Device::SetTransactionHeaderFor::GetStatusResponse(
      ::fidl::DecodedMessage<GetStatusResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetStatusResponse::PrimarySize,
              GetStatusResponse::PrimarySize)));
  _response.device_status = std::move(device_status);
  _buffer.set_actual(sizeof(GetStatusResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetStatusResponse>(std::move(_buffer)));
}

void Device::Interface::GetStatusCompleterBase::Reply(::fidl::DecodedMessage<GetStatusResponse> params) {
  Device::SetTransactionHeaderFor::GetStatusResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Device::Interface::SetPromiscuousModeCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetPromiscuousModeResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SetPromiscuousModeResponse*>(_write_bytes);
  Device::SetTransactionHeaderFor::SetPromiscuousModeResponse(
      ::fidl::DecodedMessage<SetPromiscuousModeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetPromiscuousModeResponse::PrimarySize,
              SetPromiscuousModeResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetPromiscuousModeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetPromiscuousModeResponse>(std::move(_response_bytes)));
}

void Device::Interface::SetPromiscuousModeCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < SetPromiscuousModeResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SetPromiscuousModeResponse*>(_buffer.data());
  Device::SetTransactionHeaderFor::SetPromiscuousModeResponse(
      ::fidl::DecodedMessage<SetPromiscuousModeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetPromiscuousModeResponse::PrimarySize,
              SetPromiscuousModeResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(SetPromiscuousModeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetPromiscuousModeResponse>(std::move(_buffer)));
}

void Device::Interface::SetPromiscuousModeCompleterBase::Reply(::fidl::DecodedMessage<SetPromiscuousModeResponse> params) {
  Device::SetTransactionHeaderFor::SetPromiscuousModeResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Device::Interface::ConfigMulticastAddMacCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ConfigMulticastAddMacResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<ConfigMulticastAddMacResponse*>(_write_bytes);
  Device::SetTransactionHeaderFor::ConfigMulticastAddMacResponse(
      ::fidl::DecodedMessage<ConfigMulticastAddMacResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ConfigMulticastAddMacResponse::PrimarySize,
              ConfigMulticastAddMacResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(ConfigMulticastAddMacResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ConfigMulticastAddMacResponse>(std::move(_response_bytes)));
}

void Device::Interface::ConfigMulticastAddMacCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < ConfigMulticastAddMacResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<ConfigMulticastAddMacResponse*>(_buffer.data());
  Device::SetTransactionHeaderFor::ConfigMulticastAddMacResponse(
      ::fidl::DecodedMessage<ConfigMulticastAddMacResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ConfigMulticastAddMacResponse::PrimarySize,
              ConfigMulticastAddMacResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(ConfigMulticastAddMacResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ConfigMulticastAddMacResponse>(std::move(_buffer)));
}

void Device::Interface::ConfigMulticastAddMacCompleterBase::Reply(::fidl::DecodedMessage<ConfigMulticastAddMacResponse> params) {
  Device::SetTransactionHeaderFor::ConfigMulticastAddMacResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Device::Interface::ConfigMulticastDeleteMacCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ConfigMulticastDeleteMacResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<ConfigMulticastDeleteMacResponse*>(_write_bytes);
  Device::SetTransactionHeaderFor::ConfigMulticastDeleteMacResponse(
      ::fidl::DecodedMessage<ConfigMulticastDeleteMacResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ConfigMulticastDeleteMacResponse::PrimarySize,
              ConfigMulticastDeleteMacResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(ConfigMulticastDeleteMacResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ConfigMulticastDeleteMacResponse>(std::move(_response_bytes)));
}

void Device::Interface::ConfigMulticastDeleteMacCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < ConfigMulticastDeleteMacResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<ConfigMulticastDeleteMacResponse*>(_buffer.data());
  Device::SetTransactionHeaderFor::ConfigMulticastDeleteMacResponse(
      ::fidl::DecodedMessage<ConfigMulticastDeleteMacResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ConfigMulticastDeleteMacResponse::PrimarySize,
              ConfigMulticastDeleteMacResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(ConfigMulticastDeleteMacResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ConfigMulticastDeleteMacResponse>(std::move(_buffer)));
}

void Device::Interface::ConfigMulticastDeleteMacCompleterBase::Reply(::fidl::DecodedMessage<ConfigMulticastDeleteMacResponse> params) {
  Device::SetTransactionHeaderFor::ConfigMulticastDeleteMacResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Device::Interface::ConfigMulticastSetPromiscuousModeCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ConfigMulticastSetPromiscuousModeResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<ConfigMulticastSetPromiscuousModeResponse*>(_write_bytes);
  Device::SetTransactionHeaderFor::ConfigMulticastSetPromiscuousModeResponse(
      ::fidl::DecodedMessage<ConfigMulticastSetPromiscuousModeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ConfigMulticastSetPromiscuousModeResponse::PrimarySize,
              ConfigMulticastSetPromiscuousModeResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(ConfigMulticastSetPromiscuousModeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ConfigMulticastSetPromiscuousModeResponse>(std::move(_response_bytes)));
}

void Device::Interface::ConfigMulticastSetPromiscuousModeCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < ConfigMulticastSetPromiscuousModeResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<ConfigMulticastSetPromiscuousModeResponse*>(_buffer.data());
  Device::SetTransactionHeaderFor::ConfigMulticastSetPromiscuousModeResponse(
      ::fidl::DecodedMessage<ConfigMulticastSetPromiscuousModeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ConfigMulticastSetPromiscuousModeResponse::PrimarySize,
              ConfigMulticastSetPromiscuousModeResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(ConfigMulticastSetPromiscuousModeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ConfigMulticastSetPromiscuousModeResponse>(std::move(_buffer)));
}

void Device::Interface::ConfigMulticastSetPromiscuousModeCompleterBase::Reply(::fidl::DecodedMessage<ConfigMulticastSetPromiscuousModeResponse> params) {
  Device::SetTransactionHeaderFor::ConfigMulticastSetPromiscuousModeResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Device::Interface::ConfigMulticastTestFilterCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ConfigMulticastTestFilterResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<ConfigMulticastTestFilterResponse*>(_write_bytes);
  Device::SetTransactionHeaderFor::ConfigMulticastTestFilterResponse(
      ::fidl::DecodedMessage<ConfigMulticastTestFilterResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ConfigMulticastTestFilterResponse::PrimarySize,
              ConfigMulticastTestFilterResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(ConfigMulticastTestFilterResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ConfigMulticastTestFilterResponse>(std::move(_response_bytes)));
}

void Device::Interface::ConfigMulticastTestFilterCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < ConfigMulticastTestFilterResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<ConfigMulticastTestFilterResponse*>(_buffer.data());
  Device::SetTransactionHeaderFor::ConfigMulticastTestFilterResponse(
      ::fidl::DecodedMessage<ConfigMulticastTestFilterResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ConfigMulticastTestFilterResponse::PrimarySize,
              ConfigMulticastTestFilterResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(ConfigMulticastTestFilterResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ConfigMulticastTestFilterResponse>(std::move(_buffer)));
}

void Device::Interface::ConfigMulticastTestFilterCompleterBase::Reply(::fidl::DecodedMessage<ConfigMulticastTestFilterResponse> params) {
  Device::SetTransactionHeaderFor::ConfigMulticastTestFilterResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Device::Interface::DumpRegistersCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DumpRegistersResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<DumpRegistersResponse*>(_write_bytes);
  Device::SetTransactionHeaderFor::DumpRegistersResponse(
      ::fidl::DecodedMessage<DumpRegistersResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              DumpRegistersResponse::PrimarySize,
              DumpRegistersResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(DumpRegistersResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<DumpRegistersResponse>(std::move(_response_bytes)));
}

void Device::Interface::DumpRegistersCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < DumpRegistersResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<DumpRegistersResponse*>(_buffer.data());
  Device::SetTransactionHeaderFor::DumpRegistersResponse(
      ::fidl::DecodedMessage<DumpRegistersResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              DumpRegistersResponse::PrimarySize,
              DumpRegistersResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(DumpRegistersResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<DumpRegistersResponse>(std::move(_buffer)));
}

void Device::Interface::DumpRegistersCompleterBase::Reply(::fidl::DecodedMessage<DumpRegistersResponse> params) {
  Device::SetTransactionHeaderFor::DumpRegistersResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void Device::SetTransactionHeaderFor::GetInfoRequest(const ::fidl::DecodedMessage<Device::GetInfoRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_GetInfo_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Device::SetTransactionHeaderFor::GetInfoResponse(const ::fidl::DecodedMessage<Device::GetInfoResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_GetInfo_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Device::SetTransactionHeaderFor::GetFifosRequest(const ::fidl::DecodedMessage<Device::GetFifosRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_GetFifos_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Device::SetTransactionHeaderFor::GetFifosResponse(const ::fidl::DecodedMessage<Device::GetFifosResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_GetFifos_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Device::SetTransactionHeaderFor::SetIOBufferRequest(const ::fidl::DecodedMessage<Device::SetIOBufferRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_SetIOBuffer_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Device::SetTransactionHeaderFor::SetIOBufferResponse(const ::fidl::DecodedMessage<Device::SetIOBufferResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_SetIOBuffer_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Device::SetTransactionHeaderFor::StartRequest(const ::fidl::DecodedMessage<Device::StartRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_Start_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Device::SetTransactionHeaderFor::StartResponse(const ::fidl::DecodedMessage<Device::StartResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_Start_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Device::SetTransactionHeaderFor::StopRequest(const ::fidl::DecodedMessage<Device::StopRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_Stop_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Device::SetTransactionHeaderFor::StopResponse(const ::fidl::DecodedMessage<Device::StopResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_Stop_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Device::SetTransactionHeaderFor::ListenStartRequest(const ::fidl::DecodedMessage<Device::ListenStartRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_ListenStart_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Device::SetTransactionHeaderFor::ListenStartResponse(const ::fidl::DecodedMessage<Device::ListenStartResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_ListenStart_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Device::SetTransactionHeaderFor::ListenStopRequest(const ::fidl::DecodedMessage<Device::ListenStopRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_ListenStop_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Device::SetTransactionHeaderFor::ListenStopResponse(const ::fidl::DecodedMessage<Device::ListenStopResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_ListenStop_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Device::SetTransactionHeaderFor::SetClientNameRequest(const ::fidl::DecodedMessage<Device::SetClientNameRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_SetClientName_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Device::SetTransactionHeaderFor::SetClientNameResponse(const ::fidl::DecodedMessage<Device::SetClientNameResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_SetClientName_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Device::SetTransactionHeaderFor::GetStatusRequest(const ::fidl::DecodedMessage<Device::GetStatusRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_GetStatus_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Device::SetTransactionHeaderFor::GetStatusResponse(const ::fidl::DecodedMessage<Device::GetStatusResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_GetStatus_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Device::SetTransactionHeaderFor::SetPromiscuousModeRequest(const ::fidl::DecodedMessage<Device::SetPromiscuousModeRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_SetPromiscuousMode_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Device::SetTransactionHeaderFor::SetPromiscuousModeResponse(const ::fidl::DecodedMessage<Device::SetPromiscuousModeResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_SetPromiscuousMode_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Device::SetTransactionHeaderFor::ConfigMulticastAddMacRequest(const ::fidl::DecodedMessage<Device::ConfigMulticastAddMacRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_ConfigMulticastAddMac_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Device::SetTransactionHeaderFor::ConfigMulticastAddMacResponse(const ::fidl::DecodedMessage<Device::ConfigMulticastAddMacResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_ConfigMulticastAddMac_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Device::SetTransactionHeaderFor::ConfigMulticastDeleteMacRequest(const ::fidl::DecodedMessage<Device::ConfigMulticastDeleteMacRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_ConfigMulticastDeleteMac_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Device::SetTransactionHeaderFor::ConfigMulticastDeleteMacResponse(const ::fidl::DecodedMessage<Device::ConfigMulticastDeleteMacResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_ConfigMulticastDeleteMac_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Device::SetTransactionHeaderFor::ConfigMulticastSetPromiscuousModeRequest(const ::fidl::DecodedMessage<Device::ConfigMulticastSetPromiscuousModeRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_ConfigMulticastSetPromiscuousMode_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Device::SetTransactionHeaderFor::ConfigMulticastSetPromiscuousModeResponse(const ::fidl::DecodedMessage<Device::ConfigMulticastSetPromiscuousModeResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_ConfigMulticastSetPromiscuousMode_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Device::SetTransactionHeaderFor::ConfigMulticastTestFilterRequest(const ::fidl::DecodedMessage<Device::ConfigMulticastTestFilterRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_ConfigMulticastTestFilter_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Device::SetTransactionHeaderFor::ConfigMulticastTestFilterResponse(const ::fidl::DecodedMessage<Device::ConfigMulticastTestFilterResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_ConfigMulticastTestFilter_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Device::SetTransactionHeaderFor::DumpRegistersRequest(const ::fidl::DecodedMessage<Device::DumpRegistersRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_DumpRegisters_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Device::SetTransactionHeaderFor::DumpRegistersResponse(const ::fidl::DecodedMessage<Device::DumpRegistersResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDevice_DumpRegisters_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

}  // namespace ethernet
}  // namespace hardware
}  // namespace fuchsia
}  // namespace llcpp

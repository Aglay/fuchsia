// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/txn_header.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/connect_service.h>
#include <lib/fidl/llcpp/service_handler_interface.h>
#include <lib/fidl/llcpp/string_view.h>
#include <lib/fidl/llcpp/sync_call.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/fidl/llcpp/vector_view.h>
#include <lib/fit/function.h>
#include <lib/zx/channel.h>
#include <lib/zx/fifo.h>
#include <lib/zx/vmo.h>
#include <zircon/fidl.h>

namespace llcpp {

namespace fuchsia {
namespace hardware {
namespace ethernet {

struct MacAddress;
struct Info;
class Device;
struct Fifos;

constexpr uint32_t SIGNAL_STATUS = 16777216u;

constexpr uint32_t SET_CLIENT_NAME_MAX_LEN = 16u;

extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_MacAddressTable;

struct MacAddress {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_ethernet_MacAddressTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 6;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  ::fidl::Array<uint8_t, 6> octets = {};
};

extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_InfoTable;

struct Info {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_ethernet_InfoTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  uint32_t features = {};

  uint32_t mtu = {};

  ::llcpp::fuchsia::hardware::ethernet::MacAddress mac = {};
};

extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceGetInfoRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceGetInfoResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceGetFifosRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceGetFifosResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceSetIOBufferRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceSetIOBufferResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceStartRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceStartResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceStopRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceStopResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceListenStartRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceListenStartResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceListenStopRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceListenStopResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceSetClientNameRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceSetClientNameResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceGetStatusRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceGetStatusResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceSetPromiscuousModeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceSetPromiscuousModeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceConfigMulticastAddMacRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceConfigMulticastAddMacResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceConfigMulticastDeleteMacRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceConfigMulticastDeleteMacResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceConfigMulticastSetPromiscuousModeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceConfigMulticastSetPromiscuousModeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceConfigMulticastTestFilterRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceConfigMulticastTestFilterResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceDumpRegistersRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_DeviceDumpRegistersResponseTable;

// Operation
//
// Packets are transmitted by writing data into the IO buffer and writing
// a FifoEntry referencing that data (offset + length) into the tx fifo.
// When the driver is done accessing the data, a FifoEntry with the same
// cookie value (opaque to the driver) will be readable from the tx fifo.
//
// Packets are received by writing a FifoEntry referencing an available
// buffer (offset + length) in the IO buffer.  When a packet is received,
// a FifoEntry with the same cookie value (opaque to the driver) will be
// readable from the rx fifo.  The offset field will be the same as was
// sent.  The length field will reflect the actual size of the received
// packet.  The flags field will indicate success or a specific failure
// condition.
//
// IMPORTANT: The driver *will not* buffer response messages.  It is the
// client's responsibility to ensure that there is space in the reply side
// of each fifo for each outstanding tx or rx request.  The fifo sizes
// are returned along with the fifo handles from GetFifos().
//
// See //zircon/system/public/zircon/device/ethernet.h for fifo entry layout
// and request / response message bits.
class Device final {
  Device() = delete;
 public:

  struct GetInfoResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::ethernet::Info info;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_ethernet_DeviceGetInfoResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetInfoRequest = ::fidl::AnyZeroArgMessage;

  struct GetFifosResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    ::llcpp::fuchsia::hardware::ethernet::Fifos* info;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_ethernet_DeviceGetFifosResponseTable;
    static constexpr uint32_t MaxNumHandles = 2;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 16;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetFifosRequest = ::fidl::AnyZeroArgMessage;

  struct SetIOBufferResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_ethernet_DeviceSetIOBufferResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SetIOBufferRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::vmo h;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_ethernet_DeviceSetIOBufferRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SetIOBufferResponse;
  };

  struct StartResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_ethernet_DeviceStartResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using StartRequest = ::fidl::AnyZeroArgMessage;

  using StopResponse = ::fidl::AnyZeroArgMessage;
  using StopRequest = ::fidl::AnyZeroArgMessage;

  struct ListenStartResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_ethernet_DeviceListenStartResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using ListenStartRequest = ::fidl::AnyZeroArgMessage;

  using ListenStopResponse = ::fidl::AnyZeroArgMessage;
  using ListenStopRequest = ::fidl::AnyZeroArgMessage;

  struct SetClientNameResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_ethernet_DeviceSetClientNameResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SetClientNameRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::StringView name;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_ethernet_DeviceSetClientNameRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 16;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 16;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SetClientNameResponse;
  };

  struct GetStatusResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t device_status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_ethernet_DeviceGetStatusResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetStatusRequest = ::fidl::AnyZeroArgMessage;

  struct SetPromiscuousModeResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_ethernet_DeviceSetPromiscuousModeResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SetPromiscuousModeRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    bool enabled;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_ethernet_DeviceSetPromiscuousModeRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SetPromiscuousModeResponse;
  };

  struct ConfigMulticastAddMacResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_ethernet_DeviceConfigMulticastAddMacResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct ConfigMulticastAddMacRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::ethernet::MacAddress addr;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_ethernet_DeviceConfigMulticastAddMacRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = ConfigMulticastAddMacResponse;
  };

  struct ConfigMulticastDeleteMacResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_ethernet_DeviceConfigMulticastDeleteMacResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct ConfigMulticastDeleteMacRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::ethernet::MacAddress addr;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_ethernet_DeviceConfigMulticastDeleteMacRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = ConfigMulticastDeleteMacResponse;
  };

  struct ConfigMulticastSetPromiscuousModeResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_ethernet_DeviceConfigMulticastSetPromiscuousModeResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct ConfigMulticastSetPromiscuousModeRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    bool enabled;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_ethernet_DeviceConfigMulticastSetPromiscuousModeRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = ConfigMulticastSetPromiscuousModeResponse;
  };

  struct ConfigMulticastTestFilterResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_ethernet_DeviceConfigMulticastTestFilterResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using ConfigMulticastTestFilterRequest = ::fidl::AnyZeroArgMessage;

  struct DumpRegistersResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_ethernet_DeviceDumpRegistersResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using DumpRegistersRequest = ::fidl::AnyZeroArgMessage;


  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    template <typename ResponseType>
    class GetInfo_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetInfo_Impl(::zx::unowned_channel _client_end);
      ~GetInfo_Impl() = default;
      GetInfo_Impl(GetInfo_Impl&& other) = default;
      GetInfo_Impl& operator=(GetInfo_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetFifos_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetFifos_Impl(::zx::unowned_channel _client_end);
      ~GetFifos_Impl() = default;
      GetFifos_Impl(GetFifos_Impl&& other) = default;
      GetFifos_Impl& operator=(GetFifos_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetIOBuffer_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      SetIOBuffer_Impl(::zx::unowned_channel _client_end, ::zx::vmo h);
      ~SetIOBuffer_Impl() = default;
      SetIOBuffer_Impl(SetIOBuffer_Impl&& other) = default;
      SetIOBuffer_Impl& operator=(SetIOBuffer_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Start_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Start_Impl(::zx::unowned_channel _client_end);
      ~Start_Impl() = default;
      Start_Impl(Start_Impl&& other) = default;
      Start_Impl& operator=(Start_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Stop_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Stop_Impl(::zx::unowned_channel _client_end);
      ~Stop_Impl() = default;
      Stop_Impl(Stop_Impl&& other) = default;
      Stop_Impl& operator=(Stop_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class ListenStart_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      ListenStart_Impl(::zx::unowned_channel _client_end);
      ~ListenStart_Impl() = default;
      ListenStart_Impl(ListenStart_Impl&& other) = default;
      ListenStart_Impl& operator=(ListenStart_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class ListenStop_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      ListenStop_Impl(::zx::unowned_channel _client_end);
      ~ListenStop_Impl() = default;
      ListenStop_Impl(ListenStop_Impl&& other) = default;
      ListenStop_Impl& operator=(ListenStop_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetClientName_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      SetClientName_Impl(::zx::unowned_channel _client_end, ::fidl::StringView name);
      ~SetClientName_Impl() = default;
      SetClientName_Impl(SetClientName_Impl&& other) = default;
      SetClientName_Impl& operator=(SetClientName_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetStatus_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetStatus_Impl(::zx::unowned_channel _client_end);
      ~GetStatus_Impl() = default;
      GetStatus_Impl(GetStatus_Impl&& other) = default;
      GetStatus_Impl& operator=(GetStatus_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetPromiscuousMode_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      SetPromiscuousMode_Impl(::zx::unowned_channel _client_end, bool enabled);
      ~SetPromiscuousMode_Impl() = default;
      SetPromiscuousMode_Impl(SetPromiscuousMode_Impl&& other) = default;
      SetPromiscuousMode_Impl& operator=(SetPromiscuousMode_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class ConfigMulticastAddMac_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      ConfigMulticastAddMac_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::ethernet::MacAddress addr);
      ~ConfigMulticastAddMac_Impl() = default;
      ConfigMulticastAddMac_Impl(ConfigMulticastAddMac_Impl&& other) = default;
      ConfigMulticastAddMac_Impl& operator=(ConfigMulticastAddMac_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class ConfigMulticastDeleteMac_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      ConfigMulticastDeleteMac_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::ethernet::MacAddress addr);
      ~ConfigMulticastDeleteMac_Impl() = default;
      ConfigMulticastDeleteMac_Impl(ConfigMulticastDeleteMac_Impl&& other) = default;
      ConfigMulticastDeleteMac_Impl& operator=(ConfigMulticastDeleteMac_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class ConfigMulticastSetPromiscuousMode_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      ConfigMulticastSetPromiscuousMode_Impl(::zx::unowned_channel _client_end, bool enabled);
      ~ConfigMulticastSetPromiscuousMode_Impl() = default;
      ConfigMulticastSetPromiscuousMode_Impl(ConfigMulticastSetPromiscuousMode_Impl&& other) = default;
      ConfigMulticastSetPromiscuousMode_Impl& operator=(ConfigMulticastSetPromiscuousMode_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class ConfigMulticastTestFilter_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      ConfigMulticastTestFilter_Impl(::zx::unowned_channel _client_end);
      ~ConfigMulticastTestFilter_Impl() = default;
      ConfigMulticastTestFilter_Impl(ConfigMulticastTestFilter_Impl&& other) = default;
      ConfigMulticastTestFilter_Impl& operator=(ConfigMulticastTestFilter_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class DumpRegisters_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      DumpRegisters_Impl(::zx::unowned_channel _client_end);
      ~DumpRegisters_Impl() = default;
      DumpRegisters_Impl(DumpRegisters_Impl&& other) = default;
      DumpRegisters_Impl& operator=(DumpRegisters_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using GetInfo = GetInfo_Impl<GetInfoResponse>;
    using GetFifos = GetFifos_Impl<GetFifosResponse>;
    using SetIOBuffer = SetIOBuffer_Impl<SetIOBufferResponse>;
    using Start = Start_Impl<StartResponse>;
    using Stop = Stop_Impl<StopResponse>;
    using ListenStart = ListenStart_Impl<ListenStartResponse>;
    using ListenStop = ListenStop_Impl<ListenStopResponse>;
    using SetClientName = SetClientName_Impl<SetClientNameResponse>;
    using GetStatus = GetStatus_Impl<GetStatusResponse>;
    using SetPromiscuousMode = SetPromiscuousMode_Impl<SetPromiscuousModeResponse>;
    using ConfigMulticastAddMac = ConfigMulticastAddMac_Impl<ConfigMulticastAddMacResponse>;
    using ConfigMulticastDeleteMac = ConfigMulticastDeleteMac_Impl<ConfigMulticastDeleteMacResponse>;
    using ConfigMulticastSetPromiscuousMode = ConfigMulticastSetPromiscuousMode_Impl<ConfigMulticastSetPromiscuousModeResponse>;
    using ConfigMulticastTestFilter = ConfigMulticastTestFilter_Impl<ConfigMulticastTestFilterResponse>;
    using DumpRegisters = DumpRegisters_Impl<DumpRegistersResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    template <typename ResponseType>
    class GetInfo_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetInfo_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetInfo_Impl() = default;
      GetInfo_Impl(GetInfo_Impl&& other) = default;
      GetInfo_Impl& operator=(GetInfo_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetFifos_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetFifos_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetFifos_Impl() = default;
      GetFifos_Impl(GetFifos_Impl&& other) = default;
      GetFifos_Impl& operator=(GetFifos_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetIOBuffer_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      SetIOBuffer_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::vmo h, ::fidl::BytePart _response_buffer);
      ~SetIOBuffer_Impl() = default;
      SetIOBuffer_Impl(SetIOBuffer_Impl&& other) = default;
      SetIOBuffer_Impl& operator=(SetIOBuffer_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Start_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Start_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Start_Impl() = default;
      Start_Impl(Start_Impl&& other) = default;
      Start_Impl& operator=(Start_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Stop_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Stop_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Stop_Impl() = default;
      Stop_Impl(Stop_Impl&& other) = default;
      Stop_Impl& operator=(Stop_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class ListenStart_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      ListenStart_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~ListenStart_Impl() = default;
      ListenStart_Impl(ListenStart_Impl&& other) = default;
      ListenStart_Impl& operator=(ListenStart_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class ListenStop_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      ListenStop_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~ListenStop_Impl() = default;
      ListenStop_Impl(ListenStop_Impl&& other) = default;
      ListenStop_Impl& operator=(ListenStop_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetClientName_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      SetClientName_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView name, ::fidl::BytePart _response_buffer);
      ~SetClientName_Impl() = default;
      SetClientName_Impl(SetClientName_Impl&& other) = default;
      SetClientName_Impl& operator=(SetClientName_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetStatus_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetStatus_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetStatus_Impl() = default;
      GetStatus_Impl(GetStatus_Impl&& other) = default;
      GetStatus_Impl& operator=(GetStatus_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetPromiscuousMode_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      SetPromiscuousMode_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, bool enabled, ::fidl::BytePart _response_buffer);
      ~SetPromiscuousMode_Impl() = default;
      SetPromiscuousMode_Impl(SetPromiscuousMode_Impl&& other) = default;
      SetPromiscuousMode_Impl& operator=(SetPromiscuousMode_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class ConfigMulticastAddMac_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      ConfigMulticastAddMac_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::ethernet::MacAddress addr, ::fidl::BytePart _response_buffer);
      ~ConfigMulticastAddMac_Impl() = default;
      ConfigMulticastAddMac_Impl(ConfigMulticastAddMac_Impl&& other) = default;
      ConfigMulticastAddMac_Impl& operator=(ConfigMulticastAddMac_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class ConfigMulticastDeleteMac_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      ConfigMulticastDeleteMac_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::ethernet::MacAddress addr, ::fidl::BytePart _response_buffer);
      ~ConfigMulticastDeleteMac_Impl() = default;
      ConfigMulticastDeleteMac_Impl(ConfigMulticastDeleteMac_Impl&& other) = default;
      ConfigMulticastDeleteMac_Impl& operator=(ConfigMulticastDeleteMac_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class ConfigMulticastSetPromiscuousMode_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      ConfigMulticastSetPromiscuousMode_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, bool enabled, ::fidl::BytePart _response_buffer);
      ~ConfigMulticastSetPromiscuousMode_Impl() = default;
      ConfigMulticastSetPromiscuousMode_Impl(ConfigMulticastSetPromiscuousMode_Impl&& other) = default;
      ConfigMulticastSetPromiscuousMode_Impl& operator=(ConfigMulticastSetPromiscuousMode_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class ConfigMulticastTestFilter_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      ConfigMulticastTestFilter_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~ConfigMulticastTestFilter_Impl() = default;
      ConfigMulticastTestFilter_Impl(ConfigMulticastTestFilter_Impl&& other) = default;
      ConfigMulticastTestFilter_Impl& operator=(ConfigMulticastTestFilter_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class DumpRegisters_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      DumpRegisters_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~DumpRegisters_Impl() = default;
      DumpRegisters_Impl(DumpRegisters_Impl&& other) = default;
      DumpRegisters_Impl& operator=(DumpRegisters_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using GetInfo = GetInfo_Impl<GetInfoResponse>;
    using GetFifos = GetFifos_Impl<GetFifosResponse>;
    using SetIOBuffer = SetIOBuffer_Impl<SetIOBufferResponse>;
    using Start = Start_Impl<StartResponse>;
    using Stop = Stop_Impl<StopResponse>;
    using ListenStart = ListenStart_Impl<ListenStartResponse>;
    using ListenStop = ListenStop_Impl<ListenStopResponse>;
    using SetClientName = SetClientName_Impl<SetClientNameResponse>;
    using GetStatus = GetStatus_Impl<GetStatusResponse>;
    using SetPromiscuousMode = SetPromiscuousMode_Impl<SetPromiscuousModeResponse>;
    using ConfigMulticastAddMac = ConfigMulticastAddMac_Impl<ConfigMulticastAddMacResponse>;
    using ConfigMulticastDeleteMac = ConfigMulticastDeleteMac_Impl<ConfigMulticastDeleteMacResponse>;
    using ConfigMulticastSetPromiscuousMode = ConfigMulticastSetPromiscuousMode_Impl<ConfigMulticastSetPromiscuousModeResponse>;
    using ConfigMulticastTestFilter = ConfigMulticastTestFilter_Impl<ConfigMulticastTestFilterResponse>;
    using DumpRegisters = DumpRegisters_Impl<DumpRegistersResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetInfo GetInfo();

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetInfo GetInfo(::fidl::BytePart _response_buffer);

    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetFifos GetFifos();

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetFifos GetFifos(::fidl::BytePart _response_buffer);

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::SetIOBuffer SetIOBuffer(::zx::vmo h);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetIOBuffer SetIOBuffer(::fidl::BytePart _request_buffer, ::zx::vmo h, ::fidl::BytePart _response_buffer);

    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Start Start();

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Start Start(::fidl::BytePart _response_buffer);

    // Allocates 32 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Stop Stop();


    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::ListenStart ListenStart();

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::ListenStart ListenStart(::fidl::BytePart _response_buffer);

    // Allocates 32 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::ListenStop ListenStop();


    // Allocates 72 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::SetClientName SetClientName(::fidl::StringView name);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetClientName SetClientName(::fidl::BytePart _request_buffer, ::fidl::StringView name, ::fidl::BytePart _response_buffer);

    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetStatus GetStatus();

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetStatus GetStatus(::fidl::BytePart _response_buffer);

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::SetPromiscuousMode SetPromiscuousMode(bool enabled);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetPromiscuousMode SetPromiscuousMode(::fidl::BytePart _request_buffer, bool enabled, ::fidl::BytePart _response_buffer);

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::ConfigMulticastAddMac ConfigMulticastAddMac(::llcpp::fuchsia::hardware::ethernet::MacAddress addr);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::ConfigMulticastAddMac ConfigMulticastAddMac(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::ethernet::MacAddress addr, ::fidl::BytePart _response_buffer);

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::ConfigMulticastDeleteMac ConfigMulticastDeleteMac(::llcpp::fuchsia::hardware::ethernet::MacAddress addr);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::ConfigMulticastDeleteMac ConfigMulticastDeleteMac(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::ethernet::MacAddress addr, ::fidl::BytePart _response_buffer);

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::ConfigMulticastSetPromiscuousMode ConfigMulticastSetPromiscuousMode(bool enabled);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::ConfigMulticastSetPromiscuousMode ConfigMulticastSetPromiscuousMode(::fidl::BytePart _request_buffer, bool enabled, ::fidl::BytePart _response_buffer);

    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::ConfigMulticastTestFilter ConfigMulticastTestFilter();

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::ConfigMulticastTestFilter ConfigMulticastTestFilter(::fidl::BytePart _response_buffer);

    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::DumpRegisters DumpRegisters();

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::DumpRegisters DumpRegisters(::fidl::BytePart _response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetInfo GetInfo(::zx::unowned_channel _client_end);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetInfo GetInfo(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetFifos GetFifos(::zx::unowned_channel _client_end);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetFifos GetFifos(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::SetIOBuffer SetIOBuffer(::zx::unowned_channel _client_end, ::zx::vmo h);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetIOBuffer SetIOBuffer(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::vmo h, ::fidl::BytePart _response_buffer);

    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Start Start(::zx::unowned_channel _client_end);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Start Start(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Allocates 32 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Stop Stop(::zx::unowned_channel _client_end);


    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::ListenStart ListenStart(::zx::unowned_channel _client_end);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::ListenStart ListenStart(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Allocates 32 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::ListenStop ListenStop(::zx::unowned_channel _client_end);


    // Allocates 72 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::SetClientName SetClientName(::zx::unowned_channel _client_end, ::fidl::StringView name);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetClientName SetClientName(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView name, ::fidl::BytePart _response_buffer);

    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetStatus GetStatus(::zx::unowned_channel _client_end);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetStatus GetStatus(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::SetPromiscuousMode SetPromiscuousMode(::zx::unowned_channel _client_end, bool enabled);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetPromiscuousMode SetPromiscuousMode(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, bool enabled, ::fidl::BytePart _response_buffer);

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::ConfigMulticastAddMac ConfigMulticastAddMac(::zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::ethernet::MacAddress addr);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::ConfigMulticastAddMac ConfigMulticastAddMac(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::ethernet::MacAddress addr, ::fidl::BytePart _response_buffer);

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::ConfigMulticastDeleteMac ConfigMulticastDeleteMac(::zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::ethernet::MacAddress addr);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::ConfigMulticastDeleteMac ConfigMulticastDeleteMac(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::ethernet::MacAddress addr, ::fidl::BytePart _response_buffer);

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::ConfigMulticastSetPromiscuousMode ConfigMulticastSetPromiscuousMode(::zx::unowned_channel _client_end, bool enabled);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::ConfigMulticastSetPromiscuousMode ConfigMulticastSetPromiscuousMode(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, bool enabled, ::fidl::BytePart _response_buffer);

    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::ConfigMulticastTestFilter ConfigMulticastTestFilter(::zx::unowned_channel _client_end);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::ConfigMulticastTestFilter ConfigMulticastTestFilter(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::DumpRegisters DumpRegisters(::zx::unowned_channel _client_end);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::DumpRegisters DumpRegisters(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    static ::fidl::DecodeResult<GetInfoResponse> GetInfo(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<GetFifosResponse> GetFifos(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<SetIOBufferResponse> SetIOBuffer(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetIOBufferRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<StartResponse> Start(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<StopResponse> Stop(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<ListenStartResponse> ListenStart(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<ListenStopResponse> ListenStop(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<SetClientNameResponse> SetClientName(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetClientNameRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<GetStatusResponse> GetStatus(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<SetPromiscuousModeResponse> SetPromiscuousMode(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetPromiscuousModeRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<ConfigMulticastAddMacResponse> ConfigMulticastAddMac(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ConfigMulticastAddMacRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<ConfigMulticastDeleteMacResponse> ConfigMulticastDeleteMac(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ConfigMulticastDeleteMacRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<ConfigMulticastSetPromiscuousModeResponse> ConfigMulticastSetPromiscuousMode(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ConfigMulticastSetPromiscuousModeRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<ConfigMulticastTestFilterResponse> ConfigMulticastTestFilter(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<DumpRegistersResponse> DumpRegisters(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Device;
    using _Base = ::fidl::CompleterBase;

    class GetInfoCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::hardware::ethernet::Info info);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::ethernet::Info info);
      void Reply(::fidl::DecodedMessage<GetInfoResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetInfoCompleter = ::fidl::Completer<GetInfoCompleterBase>;

    virtual void GetInfo(GetInfoCompleter::Sync _completer) = 0;

    class GetFifosCompleterBase : public _Base {
     public:
      void Reply(int32_t status, ::llcpp::fuchsia::hardware::ethernet::Fifos* info);
      void Reply(::fidl::BytePart _buffer, int32_t status, ::llcpp::fuchsia::hardware::ethernet::Fifos* info);
      void Reply(::fidl::DecodedMessage<GetFifosResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetFifosCompleter = ::fidl::Completer<GetFifosCompleterBase>;

    virtual void GetFifos(GetFifosCompleter::Sync _completer) = 0;

    class SetIOBufferCompleterBase : public _Base {
     public:
      void Reply(int32_t status);
      void Reply(::fidl::BytePart _buffer, int32_t status);
      void Reply(::fidl::DecodedMessage<SetIOBufferResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetIOBufferCompleter = ::fidl::Completer<SetIOBufferCompleterBase>;

    virtual void SetIOBuffer(::zx::vmo h, SetIOBufferCompleter::Sync _completer) = 0;

    class StartCompleterBase : public _Base {
     public:
      void Reply(int32_t status);
      void Reply(::fidl::BytePart _buffer, int32_t status);
      void Reply(::fidl::DecodedMessage<StartResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using StartCompleter = ::fidl::Completer<StartCompleterBase>;

    virtual void Start(StartCompleter::Sync _completer) = 0;

    class StopCompleterBase : public _Base {
     public:
      void Reply();

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using StopCompleter = ::fidl::Completer<StopCompleterBase>;

    virtual void Stop(StopCompleter::Sync _completer) = 0;

    class ListenStartCompleterBase : public _Base {
     public:
      void Reply(int32_t status);
      void Reply(::fidl::BytePart _buffer, int32_t status);
      void Reply(::fidl::DecodedMessage<ListenStartResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ListenStartCompleter = ::fidl::Completer<ListenStartCompleterBase>;

    virtual void ListenStart(ListenStartCompleter::Sync _completer) = 0;

    class ListenStopCompleterBase : public _Base {
     public:
      void Reply();

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ListenStopCompleter = ::fidl::Completer<ListenStopCompleterBase>;

    virtual void ListenStop(ListenStopCompleter::Sync _completer) = 0;

    class SetClientNameCompleterBase : public _Base {
     public:
      void Reply(int32_t status);
      void Reply(::fidl::BytePart _buffer, int32_t status);
      void Reply(::fidl::DecodedMessage<SetClientNameResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetClientNameCompleter = ::fidl::Completer<SetClientNameCompleterBase>;

    virtual void SetClientName(::fidl::StringView name, SetClientNameCompleter::Sync _completer) = 0;

    class GetStatusCompleterBase : public _Base {
     public:
      void Reply(uint32_t device_status);
      void Reply(::fidl::BytePart _buffer, uint32_t device_status);
      void Reply(::fidl::DecodedMessage<GetStatusResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetStatusCompleter = ::fidl::Completer<GetStatusCompleterBase>;

    virtual void GetStatus(GetStatusCompleter::Sync _completer) = 0;

    class SetPromiscuousModeCompleterBase : public _Base {
     public:
      void Reply(int32_t status);
      void Reply(::fidl::BytePart _buffer, int32_t status);
      void Reply(::fidl::DecodedMessage<SetPromiscuousModeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetPromiscuousModeCompleter = ::fidl::Completer<SetPromiscuousModeCompleterBase>;

    virtual void SetPromiscuousMode(bool enabled, SetPromiscuousModeCompleter::Sync _completer) = 0;

    class ConfigMulticastAddMacCompleterBase : public _Base {
     public:
      void Reply(int32_t status);
      void Reply(::fidl::BytePart _buffer, int32_t status);
      void Reply(::fidl::DecodedMessage<ConfigMulticastAddMacResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ConfigMulticastAddMacCompleter = ::fidl::Completer<ConfigMulticastAddMacCompleterBase>;

    virtual void ConfigMulticastAddMac(::llcpp::fuchsia::hardware::ethernet::MacAddress addr, ConfigMulticastAddMacCompleter::Sync _completer) = 0;

    class ConfigMulticastDeleteMacCompleterBase : public _Base {
     public:
      void Reply(int32_t status);
      void Reply(::fidl::BytePart _buffer, int32_t status);
      void Reply(::fidl::DecodedMessage<ConfigMulticastDeleteMacResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ConfigMulticastDeleteMacCompleter = ::fidl::Completer<ConfigMulticastDeleteMacCompleterBase>;

    virtual void ConfigMulticastDeleteMac(::llcpp::fuchsia::hardware::ethernet::MacAddress addr, ConfigMulticastDeleteMacCompleter::Sync _completer) = 0;

    class ConfigMulticastSetPromiscuousModeCompleterBase : public _Base {
     public:
      void Reply(int32_t status);
      void Reply(::fidl::BytePart _buffer, int32_t status);
      void Reply(::fidl::DecodedMessage<ConfigMulticastSetPromiscuousModeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ConfigMulticastSetPromiscuousModeCompleter = ::fidl::Completer<ConfigMulticastSetPromiscuousModeCompleterBase>;

    virtual void ConfigMulticastSetPromiscuousMode(bool enabled, ConfigMulticastSetPromiscuousModeCompleter::Sync _completer) = 0;

    class ConfigMulticastTestFilterCompleterBase : public _Base {
     public:
      void Reply(int32_t status);
      void Reply(::fidl::BytePart _buffer, int32_t status);
      void Reply(::fidl::DecodedMessage<ConfigMulticastTestFilterResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ConfigMulticastTestFilterCompleter = ::fidl::Completer<ConfigMulticastTestFilterCompleterBase>;

    virtual void ConfigMulticastTestFilter(ConfigMulticastTestFilterCompleter::Sync _completer) = 0;

    class DumpRegistersCompleterBase : public _Base {
     public:
      void Reply(int32_t status);
      void Reply(::fidl::BytePart _buffer, int32_t status);
      void Reply(::fidl::DecodedMessage<DumpRegistersResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using DumpRegistersCompleter = ::fidl::Completer<DumpRegistersCompleterBase>;

    virtual void DumpRegisters(DumpRegistersCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void GetInfoRequest(const ::fidl::DecodedMessage<Device::GetInfoRequest>& _msg);
    static void GetInfoResponse(const ::fidl::DecodedMessage<Device::GetInfoResponse>& _msg);
    static void GetFifosRequest(const ::fidl::DecodedMessage<Device::GetFifosRequest>& _msg);
    static void GetFifosResponse(const ::fidl::DecodedMessage<Device::GetFifosResponse>& _msg);
    static void SetIOBufferRequest(const ::fidl::DecodedMessage<Device::SetIOBufferRequest>& _msg);
    static void SetIOBufferResponse(const ::fidl::DecodedMessage<Device::SetIOBufferResponse>& _msg);
    static void StartRequest(const ::fidl::DecodedMessage<Device::StartRequest>& _msg);
    static void StartResponse(const ::fidl::DecodedMessage<Device::StartResponse>& _msg);
    static void StopRequest(const ::fidl::DecodedMessage<Device::StopRequest>& _msg);
    static void StopResponse(const ::fidl::DecodedMessage<Device::StopResponse>& _msg);
    static void ListenStartRequest(const ::fidl::DecodedMessage<Device::ListenStartRequest>& _msg);
    static void ListenStartResponse(const ::fidl::DecodedMessage<Device::ListenStartResponse>& _msg);
    static void ListenStopRequest(const ::fidl::DecodedMessage<Device::ListenStopRequest>& _msg);
    static void ListenStopResponse(const ::fidl::DecodedMessage<Device::ListenStopResponse>& _msg);
    static void SetClientNameRequest(const ::fidl::DecodedMessage<Device::SetClientNameRequest>& _msg);
    static void SetClientNameResponse(const ::fidl::DecodedMessage<Device::SetClientNameResponse>& _msg);
    static void GetStatusRequest(const ::fidl::DecodedMessage<Device::GetStatusRequest>& _msg);
    static void GetStatusResponse(const ::fidl::DecodedMessage<Device::GetStatusResponse>& _msg);
    static void SetPromiscuousModeRequest(const ::fidl::DecodedMessage<Device::SetPromiscuousModeRequest>& _msg);
    static void SetPromiscuousModeResponse(const ::fidl::DecodedMessage<Device::SetPromiscuousModeResponse>& _msg);
    static void ConfigMulticastAddMacRequest(const ::fidl::DecodedMessage<Device::ConfigMulticastAddMacRequest>& _msg);
    static void ConfigMulticastAddMacResponse(const ::fidl::DecodedMessage<Device::ConfigMulticastAddMacResponse>& _msg);
    static void ConfigMulticastDeleteMacRequest(const ::fidl::DecodedMessage<Device::ConfigMulticastDeleteMacRequest>& _msg);
    static void ConfigMulticastDeleteMacResponse(const ::fidl::DecodedMessage<Device::ConfigMulticastDeleteMacResponse>& _msg);
    static void ConfigMulticastSetPromiscuousModeRequest(const ::fidl::DecodedMessage<Device::ConfigMulticastSetPromiscuousModeRequest>& _msg);
    static void ConfigMulticastSetPromiscuousModeResponse(const ::fidl::DecodedMessage<Device::ConfigMulticastSetPromiscuousModeResponse>& _msg);
    static void ConfigMulticastTestFilterRequest(const ::fidl::DecodedMessage<Device::ConfigMulticastTestFilterRequest>& _msg);
    static void ConfigMulticastTestFilterResponse(const ::fidl::DecodedMessage<Device::ConfigMulticastTestFilterResponse>& _msg);
    static void DumpRegistersRequest(const ::fidl::DecodedMessage<Device::DumpRegistersRequest>& _msg);
    static void DumpRegistersResponse(const ::fidl::DecodedMessage<Device::DumpRegistersResponse>& _msg);
  };
};

constexpr uint32_t MAX_CLIENT_NAME_LEN = 15u;

constexpr uint32_t INFO_FEATURE_WLAN = 1u;

constexpr uint32_t INFO_FEATURE_SYNTH = 2u;

constexpr uint32_t INFO_FEATURE_LOOPBACK = 4u;

extern "C" const fidl_type_t v1_fuchsia_hardware_ethernet_FifosTable;

struct Fifos {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_ethernet_FifosTable;
  static constexpr uint32_t MaxNumHandles = 2;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  ::zx::fifo rx = {};

  ::zx::fifo tx = {};

  uint32_t rx_depth = {};

  uint32_t tx_depth = {};
};

constexpr uint32_t DEVICE_STATUS_ONLINE = 1u;

}  // namespace ethernet
}  // namespace hardware
}  // namespace fuchsia
}  // namespace llcpp

namespace fidl {

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::ethernet::MacAddress> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::ethernet::MacAddress>);
static_assert(offsetof(::llcpp::fuchsia::hardware::ethernet::MacAddress, octets) == 0);
static_assert(sizeof(::llcpp::fuchsia::hardware::ethernet::MacAddress) == ::llcpp::fuchsia::hardware::ethernet::MacAddress::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::ethernet::Info> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::ethernet::Info>);
static_assert(offsetof(::llcpp::fuchsia::hardware::ethernet::Info, features) == 0);
static_assert(offsetof(::llcpp::fuchsia::hardware::ethernet::Info, mtu) == 4);
static_assert(offsetof(::llcpp::fuchsia::hardware::ethernet::Info, mac) == 8);
static_assert(sizeof(::llcpp::fuchsia::hardware::ethernet::Info) == ::llcpp::fuchsia::hardware::ethernet::Info::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::ethernet::Device::GetInfoResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::ethernet::Device::GetInfoResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::ethernet::Device::GetInfoResponse)
    == ::llcpp::fuchsia::hardware::ethernet::Device::GetInfoResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::ethernet::Device::GetInfoResponse, info) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::ethernet::Device::GetFifosResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::ethernet::Device::GetFifosResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::ethernet::Device::GetFifosResponse)
    == ::llcpp::fuchsia::hardware::ethernet::Device::GetFifosResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::ethernet::Device::GetFifosResponse, status) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::ethernet::Device::GetFifosResponse, info) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::ethernet::Device::SetIOBufferRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::ethernet::Device::SetIOBufferRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::ethernet::Device::SetIOBufferRequest)
    == ::llcpp::fuchsia::hardware::ethernet::Device::SetIOBufferRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::ethernet::Device::SetIOBufferRequest, h) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::ethernet::Device::SetIOBufferResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::ethernet::Device::SetIOBufferResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::ethernet::Device::SetIOBufferResponse)
    == ::llcpp::fuchsia::hardware::ethernet::Device::SetIOBufferResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::ethernet::Device::SetIOBufferResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::ethernet::Device::StartResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::ethernet::Device::StartResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::ethernet::Device::StartResponse)
    == ::llcpp::fuchsia::hardware::ethernet::Device::StartResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::ethernet::Device::StartResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::ethernet::Device::ListenStartResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::ethernet::Device::ListenStartResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::ethernet::Device::ListenStartResponse)
    == ::llcpp::fuchsia::hardware::ethernet::Device::ListenStartResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::ethernet::Device::ListenStartResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::ethernet::Device::SetClientNameRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::ethernet::Device::SetClientNameRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::ethernet::Device::SetClientNameRequest)
    == ::llcpp::fuchsia::hardware::ethernet::Device::SetClientNameRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::ethernet::Device::SetClientNameRequest, name) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::ethernet::Device::SetClientNameResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::ethernet::Device::SetClientNameResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::ethernet::Device::SetClientNameResponse)
    == ::llcpp::fuchsia::hardware::ethernet::Device::SetClientNameResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::ethernet::Device::SetClientNameResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::ethernet::Device::GetStatusResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::ethernet::Device::GetStatusResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::ethernet::Device::GetStatusResponse)
    == ::llcpp::fuchsia::hardware::ethernet::Device::GetStatusResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::ethernet::Device::GetStatusResponse, device_status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::ethernet::Device::SetPromiscuousModeRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::ethernet::Device::SetPromiscuousModeRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::ethernet::Device::SetPromiscuousModeRequest)
    == ::llcpp::fuchsia::hardware::ethernet::Device::SetPromiscuousModeRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::ethernet::Device::SetPromiscuousModeRequest, enabled) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::ethernet::Device::SetPromiscuousModeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::ethernet::Device::SetPromiscuousModeResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::ethernet::Device::SetPromiscuousModeResponse)
    == ::llcpp::fuchsia::hardware::ethernet::Device::SetPromiscuousModeResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::ethernet::Device::SetPromiscuousModeResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastAddMacRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastAddMacRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastAddMacRequest)
    == ::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastAddMacRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastAddMacRequest, addr) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastAddMacResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastAddMacResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastAddMacResponse)
    == ::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastAddMacResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastAddMacResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastDeleteMacRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastDeleteMacRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastDeleteMacRequest)
    == ::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastDeleteMacRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastDeleteMacRequest, addr) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastDeleteMacResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastDeleteMacResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastDeleteMacResponse)
    == ::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastDeleteMacResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastDeleteMacResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastSetPromiscuousModeRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastSetPromiscuousModeRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastSetPromiscuousModeRequest)
    == ::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastSetPromiscuousModeRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastSetPromiscuousModeRequest, enabled) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastSetPromiscuousModeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastSetPromiscuousModeResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastSetPromiscuousModeResponse)
    == ::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastSetPromiscuousModeResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastSetPromiscuousModeResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastTestFilterResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastTestFilterResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastTestFilterResponse)
    == ::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastTestFilterResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::ethernet::Device::ConfigMulticastTestFilterResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::ethernet::Device::DumpRegistersResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::ethernet::Device::DumpRegistersResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::ethernet::Device::DumpRegistersResponse)
    == ::llcpp::fuchsia::hardware::ethernet::Device::DumpRegistersResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::ethernet::Device::DumpRegistersResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::ethernet::Fifos> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::ethernet::Fifos>);
static_assert(offsetof(::llcpp::fuchsia::hardware::ethernet::Fifos, rx) == 0);
static_assert(offsetof(::llcpp::fuchsia::hardware::ethernet::Fifos, tx) == 4);
static_assert(offsetof(::llcpp::fuchsia::hardware::ethernet::Fifos, rx_depth) == 8);
static_assert(offsetof(::llcpp::fuchsia::hardware::ethernet::Fifos, tx_depth) == 12);
static_assert(sizeof(::llcpp::fuchsia::hardware::ethernet::Fifos) == ::llcpp::fuchsia::hardware::ethernet::Fifos::PrimarySize);

}  // namespace fidl

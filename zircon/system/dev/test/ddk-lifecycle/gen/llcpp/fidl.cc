// WARNING: This file is machine generated by fidlgen.

#include <fuchsia/device/lifecycle/test/llcpp/fidl.h>
#include <memory>

namespace llcpp {

namespace fuchsia {
namespace device {
namespace lifecycle {
namespace test {

void ::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Result::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(TestDevice_SubscribeToLifecycle_Result) == sizeof(fidl_xunion_t));
  static_assert(offsetof(TestDevice_SubscribeToLifecycle_Result, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(TestDevice_SubscribeToLifecycle_Result, envelope_) == offsetof(fidl_xunion_t, envelope));
}

void ::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Result::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(TestDevice_RemoveChild_Result) == sizeof(fidl_xunion_t));
  static_assert(offsetof(TestDevice_RemoveChild_Result, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(TestDevice_RemoveChild_Result, envelope_) == offsetof(fidl_xunion_t, envelope));
}

void ::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Result::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(TestDevice_AddChild_Result) == sizeof(fidl_xunion_t));
  static_assert(offsetof(TestDevice_AddChild_Result, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(TestDevice_AddChild_Result, envelope_) == offsetof(fidl_xunion_t, envelope));
}

namespace {

[[maybe_unused]]
constexpr uint64_t kLifecycle_OnChildPreRelease_Ordinal = 0x5b8ccdc000000000lu;
[[maybe_unused]]
constexpr uint64_t kLifecycle_OnChildPreRelease_GenOrdinal = 0x45196940343cd66alu;
extern "C" const fidl_type_t fuchsia_device_lifecycle_test_LifecycleOnChildPreReleaseRequestTable;
extern "C" const fidl_type_t fuchsia_device_lifecycle_test_LifecycleOnChildPreReleaseEventTable;
extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_LifecycleOnChildPreReleaseEventTable;

}  // namespace
zx_status_t Lifecycle::SyncClient::HandleEvents(Lifecycle::EventHandlers handlers) {
  return Lifecycle::Call::HandleEvents(::zx::unowned_channel(channel_), std::move(handlers));
}

zx_status_t Lifecycle::Call::HandleEvents(::zx::unowned_channel client_end, Lifecycle::EventHandlers handlers) {
  zx_status_t status = client_end->wait_one(ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED,
                                            ::zx::time::infinite(),
                                            nullptr);
  if (status != ZX_OK) {
    return status;
  }
  constexpr uint32_t kReadAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::internal::ClampedMessageSize<OnChildPreReleaseResponse, ::fidl::MessageDirection::kReceiving>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<OnChildPreReleaseResponse, ::fidl::MessageDirection::kReceiving>();
    }
    return x;
  })();
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (OnChildPreReleaseResponse::MaxNumHandles >= x) {
      x = OnChildPreReleaseResponse::MaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  ::fidl::internal::ByteStorage<kReadAllocSize> read_storage;
  uint8_t* read_bytes = read_storage.buffer().data();
  zx_handle_t read_handles[kHandleAllocSize];
  uint32_t actual_bytes;
  uint32_t actual_handles;
  status = client_end->read(ZX_CHANNEL_READ_MAY_DISCARD,
                            read_bytes, read_handles,
                            kReadAllocSize, kHandleAllocSize,
                            &actual_bytes, &actual_handles);
  if (status == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new event,
    // whose size exceeds the maximum of known events in the current protocol.
    return handlers.unknown();
  }
  if (status != ZX_OK) {
    return status;
  }
  if (actual_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(read_handles, actual_handles);
    return ZX_ERR_INVALID_ARGS;
  }
  auto msg = fidl_msg_t {
      .bytes = read_bytes,
      .handles = read_handles,
      .num_bytes = actual_bytes,
      .num_handles = actual_handles
  };
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg.bytes);
  status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    return status;
  }
  switch (hdr->ordinal) {
    case kLifecycle_OnChildPreRelease_Ordinal:
    case kLifecycle_OnChildPreRelease_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<OnChildPreReleaseResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      auto message = result.message.message();
      return handlers.on_child_pre_release(std::move(message->child_id));
    }
    default:
      zx_handle_close_many(read_handles, actual_handles);
      return handlers.unknown();
  }
}

bool Lifecycle::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    default: {
      return false;
    }
  }
}

bool Lifecycle::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


zx_status_t Lifecycle::SendOnChildPreReleaseEvent(::zx::unowned_channel _chan, uint64_t child_id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OnChildPreReleaseResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<OnChildPreReleaseResponse*>(_write_bytes);
  Lifecycle::SetTransactionHeaderFor::OnChildPreReleaseResponse(
      ::fidl::DecodedMessage<OnChildPreReleaseResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OnChildPreReleaseResponse::PrimarySize,
              OnChildPreReleaseResponse::PrimarySize)));
  _response.child_id = std::move(child_id);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(OnChildPreReleaseResponse));
  return ::fidl::Write(::zx::unowned_channel(_chan), ::fidl::DecodedMessage<OnChildPreReleaseResponse>(std::move(_response_bytes)));
}

zx_status_t Lifecycle::SendOnChildPreReleaseEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, uint64_t child_id) {
  if (_buffer.capacity() < OnChildPreReleaseResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  auto& _response = *reinterpret_cast<OnChildPreReleaseResponse*>(_buffer.data());
  Lifecycle::SetTransactionHeaderFor::OnChildPreReleaseResponse(
      ::fidl::DecodedMessage<OnChildPreReleaseResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OnChildPreReleaseResponse::PrimarySize,
              OnChildPreReleaseResponse::PrimarySize)));
  _response.child_id = std::move(child_id);
  _buffer.set_actual(sizeof(OnChildPreReleaseResponse));
  return ::fidl::Write(::zx::unowned_channel(_chan), ::fidl::DecodedMessage<OnChildPreReleaseResponse>(std::move(_buffer)));
}

zx_status_t Lifecycle::SendOnChildPreReleaseEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnChildPreReleaseResponse> params) {
  Lifecycle::SetTransactionHeaderFor::OnChildPreReleaseResponse(params);
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(params));
}



void Lifecycle::SetTransactionHeaderFor::OnChildPreReleaseResponse(const ::fidl::DecodedMessage<Lifecycle::OnChildPreReleaseResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLifecycle_OnChildPreRelease_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

namespace {

[[maybe_unused]]
constexpr uint64_t kTestDevice_AddChild_Ordinal = 0x1ffc4d2900000000lu;
[[maybe_unused]]
constexpr uint64_t kTestDevice_AddChild_GenOrdinal = 0x7ffb522521de57belu;
extern "C" const fidl_type_t fuchsia_device_lifecycle_test_TestDeviceAddChildRequestTable;
extern "C" const fidl_type_t fuchsia_device_lifecycle_test_TestDeviceAddChildResponseTable;
extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_TestDeviceAddChildResponseTable;
[[maybe_unused]]
constexpr uint64_t kTestDevice_RemoveChild_Ordinal = 0x60d5f7ec00000000lu;
[[maybe_unused]]
constexpr uint64_t kTestDevice_RemoveChild_GenOrdinal = 0x1cf9401a022c96f1lu;
extern "C" const fidl_type_t fuchsia_device_lifecycle_test_TestDeviceRemoveChildRequestTable;
extern "C" const fidl_type_t fuchsia_device_lifecycle_test_TestDeviceRemoveChildResponseTable;
extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_TestDeviceRemoveChildResponseTable;
[[maybe_unused]]
constexpr uint64_t kTestDevice_SubscribeToLifecycle_Ordinal = 0x41ac589900000000lu;
[[maybe_unused]]
constexpr uint64_t kTestDevice_SubscribeToLifecycle_GenOrdinal = 0x650868f21ef733bflu;
extern "C" const fidl_type_t fuchsia_device_lifecycle_test_TestDeviceSubscribeToLifecycleRequestTable;
extern "C" const fidl_type_t fuchsia_device_lifecycle_test_TestDeviceSubscribeToLifecycleResponseTable;
extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_TestDeviceSubscribeToLifecycleResponseTable;

}  // namespace
template <>
TestDevice::ResultOf::AddChild_Impl<TestDevice::AddChildResponse>::AddChild_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<AddChildRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, AddChildRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(AddChildRequest));
  ::fidl::DecodedMessage<AddChildRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      TestDevice::InPlace::AddChild(std::move(_client_end), Super::response_buffer()));
}

TestDevice::ResultOf::AddChild TestDevice::SyncClient::AddChild() {
    return ResultOf::AddChild(::zx::unowned_channel(this->channel_));
}

TestDevice::ResultOf::AddChild TestDevice::Call::AddChild(::zx::unowned_channel _client_end) {
  return ResultOf::AddChild(std::move(_client_end));
}

template <>
TestDevice::UnownedResultOf::AddChild_Impl<TestDevice::AddChildResponse>::AddChild_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(AddChildRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, AddChildRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(AddChildRequest));
  ::fidl::DecodedMessage<AddChildRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      TestDevice::InPlace::AddChild(std::move(_client_end), std::move(_response_buffer)));
}

TestDevice::UnownedResultOf::AddChild TestDevice::SyncClient::AddChild(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::AddChild(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

TestDevice::UnownedResultOf::AddChild TestDevice::Call::AddChild(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::AddChild(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<TestDevice::AddChildResponse> TestDevice::InPlace::AddChild(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(AddChildRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<AddChildRequest> params(std::move(_request_buffer));
  TestDevice::SetTransactionHeaderFor::AddChildRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<TestDevice::AddChildResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<AddChildRequest, AddChildResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<TestDevice::AddChildResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
TestDevice::ResultOf::RemoveChild_Impl<TestDevice::RemoveChildResponse>::RemoveChild_Impl(::zx::unowned_channel _client_end, uint64_t child_id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RemoveChildRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, RemoveChildRequest::PrimarySize);
  auto& _request = *reinterpret_cast<RemoveChildRequest*>(_write_bytes);
  _request.child_id = std::move(child_id);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(RemoveChildRequest));
  ::fidl::DecodedMessage<RemoveChildRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      TestDevice::InPlace::RemoveChild(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

TestDevice::ResultOf::RemoveChild TestDevice::SyncClient::RemoveChild(uint64_t child_id) {
    return ResultOf::RemoveChild(::zx::unowned_channel(this->channel_), std::move(child_id));
}

TestDevice::ResultOf::RemoveChild TestDevice::Call::RemoveChild(::zx::unowned_channel _client_end, uint64_t child_id) {
  return ResultOf::RemoveChild(std::move(_client_end), std::move(child_id));
}

template <>
TestDevice::UnownedResultOf::RemoveChild_Impl<TestDevice::RemoveChildResponse>::RemoveChild_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t child_id, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < RemoveChildRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<RemoveChildResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, RemoveChildRequest::PrimarySize);
  auto& _request = *reinterpret_cast<RemoveChildRequest*>(_request_buffer.data());
  _request.child_id = std::move(child_id);
  _request_buffer.set_actual(sizeof(RemoveChildRequest));
  ::fidl::DecodedMessage<RemoveChildRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      TestDevice::InPlace::RemoveChild(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

TestDevice::UnownedResultOf::RemoveChild TestDevice::SyncClient::RemoveChild(::fidl::BytePart _request_buffer, uint64_t child_id, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::RemoveChild(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(child_id), std::move(_response_buffer));
}

TestDevice::UnownedResultOf::RemoveChild TestDevice::Call::RemoveChild(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t child_id, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::RemoveChild(std::move(_client_end), std::move(_request_buffer), std::move(child_id), std::move(_response_buffer));
}

::fidl::DecodeResult<TestDevice::RemoveChildResponse> TestDevice::InPlace::RemoveChild(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<RemoveChildRequest> params, ::fidl::BytePart response_buffer) {
  TestDevice::SetTransactionHeaderFor::RemoveChildRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<TestDevice::RemoveChildResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<RemoveChildRequest, RemoveChildResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<TestDevice::RemoveChildResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
TestDevice::ResultOf::SubscribeToLifecycle_Impl<TestDevice::SubscribeToLifecycleResponse>::SubscribeToLifecycle_Impl(::zx::unowned_channel _client_end, ::zx::channel client) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SubscribeToLifecycleRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SubscribeToLifecycleRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SubscribeToLifecycleRequest*>(_write_bytes);
  _request.client = std::move(client);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SubscribeToLifecycleRequest));
  ::fidl::DecodedMessage<SubscribeToLifecycleRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      TestDevice::InPlace::SubscribeToLifecycle(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

TestDevice::ResultOf::SubscribeToLifecycle TestDevice::SyncClient::SubscribeToLifecycle(::zx::channel client) {
    return ResultOf::SubscribeToLifecycle(::zx::unowned_channel(this->channel_), std::move(client));
}

TestDevice::ResultOf::SubscribeToLifecycle TestDevice::Call::SubscribeToLifecycle(::zx::unowned_channel _client_end, ::zx::channel client) {
  return ResultOf::SubscribeToLifecycle(std::move(_client_end), std::move(client));
}

template <>
TestDevice::UnownedResultOf::SubscribeToLifecycle_Impl<TestDevice::SubscribeToLifecycleResponse>::SubscribeToLifecycle_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel client, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < SubscribeToLifecycleRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<SubscribeToLifecycleResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, SubscribeToLifecycleRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SubscribeToLifecycleRequest*>(_request_buffer.data());
  _request.client = std::move(client);
  _request_buffer.set_actual(sizeof(SubscribeToLifecycleRequest));
  ::fidl::DecodedMessage<SubscribeToLifecycleRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      TestDevice::InPlace::SubscribeToLifecycle(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

TestDevice::UnownedResultOf::SubscribeToLifecycle TestDevice::SyncClient::SubscribeToLifecycle(::fidl::BytePart _request_buffer, ::zx::channel client, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SubscribeToLifecycle(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(client), std::move(_response_buffer));
}

TestDevice::UnownedResultOf::SubscribeToLifecycle TestDevice::Call::SubscribeToLifecycle(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel client, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SubscribeToLifecycle(std::move(_client_end), std::move(_request_buffer), std::move(client), std::move(_response_buffer));
}

::fidl::DecodeResult<TestDevice::SubscribeToLifecycleResponse> TestDevice::InPlace::SubscribeToLifecycle(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SubscribeToLifecycleRequest> params, ::fidl::BytePart response_buffer) {
  TestDevice::SetTransactionHeaderFor::SubscribeToLifecycleRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<TestDevice::SubscribeToLifecycleResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SubscribeToLifecycleRequest, SubscribeToLifecycleResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<TestDevice::SubscribeToLifecycleResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool TestDevice::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kTestDevice_AddChild_Ordinal:
    case kTestDevice_AddChild_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<AddChildRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->AddChild(
          Interface::AddChildCompleter::Sync(txn));
      return true;
    }
    case kTestDevice_RemoveChild_Ordinal:
    case kTestDevice_RemoveChild_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<RemoveChildRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->RemoveChild(std::move(message->child_id),
          Interface::RemoveChildCompleter::Sync(txn));
      return true;
    }
    case kTestDevice_SubscribeToLifecycle_Ordinal:
    case kTestDevice_SubscribeToLifecycle_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SubscribeToLifecycleRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SubscribeToLifecycle(std::move(message->client),
          Interface::SubscribeToLifecycleCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool TestDevice::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void TestDevice::Interface::AddChildCompleterBase::Reply(::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<AddChildResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  AddChildResponse _response = {};
  TestDevice::SetTransactionHeaderFor::AddChildResponse(
      ::fidl::DecodedMessage<AddChildResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              AddChildResponse::PrimarySize,
              AddChildResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void TestDevice::Interface::AddChildCompleterBase::ReplySuccess(uint64_t child_id) {
  TestDevice_AddChild_Response response;
  response.child_id = std::move(child_id);

  Reply(TestDevice_AddChild_Result::WithResponse(&response));
}
void TestDevice::Interface::AddChildCompleterBase::ReplyError(int32_t error) {
  Reply(TestDevice_AddChild_Result::WithErr(&error));
}

void TestDevice::Interface::AddChildCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Result result) {
  if (_buffer.capacity() < AddChildResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  AddChildResponse _response = {};
  TestDevice::SetTransactionHeaderFor::AddChildResponse(
      ::fidl::DecodedMessage<AddChildResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              AddChildResponse::PrimarySize,
              AddChildResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void TestDevice::Interface::AddChildCompleterBase::ReplySuccess(::fidl::BytePart _buffer, uint64_t child_id) {
  TestDevice_AddChild_Response response;
  response.child_id = std::move(child_id);

  Reply(std::move(_buffer), TestDevice_AddChild_Result::WithResponse(&response));
}

void TestDevice::Interface::AddChildCompleterBase::Reply(::fidl::DecodedMessage<AddChildResponse> params) {
  TestDevice::SetTransactionHeaderFor::AddChildResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void TestDevice::Interface::RemoveChildCompleterBase::Reply(::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RemoveChildResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  RemoveChildResponse _response = {};
  TestDevice::SetTransactionHeaderFor::RemoveChildResponse(
      ::fidl::DecodedMessage<RemoveChildResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              RemoveChildResponse::PrimarySize,
              RemoveChildResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void TestDevice::Interface::RemoveChildCompleterBase::ReplySuccess() {
  TestDevice_RemoveChild_Response response;

  Reply(TestDevice_RemoveChild_Result::WithResponse(&response));
}
void TestDevice::Interface::RemoveChildCompleterBase::ReplyError(int32_t error) {
  Reply(TestDevice_RemoveChild_Result::WithErr(&error));
}

void TestDevice::Interface::RemoveChildCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Result result) {
  if (_buffer.capacity() < RemoveChildResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  RemoveChildResponse _response = {};
  TestDevice::SetTransactionHeaderFor::RemoveChildResponse(
      ::fidl::DecodedMessage<RemoveChildResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              RemoveChildResponse::PrimarySize,
              RemoveChildResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void TestDevice::Interface::RemoveChildCompleterBase::ReplySuccess(::fidl::BytePart _buffer) {
  TestDevice_RemoveChild_Response response;

  Reply(std::move(_buffer), TestDevice_RemoveChild_Result::WithResponse(&response));
}

void TestDevice::Interface::RemoveChildCompleterBase::Reply(::fidl::DecodedMessage<RemoveChildResponse> params) {
  TestDevice::SetTransactionHeaderFor::RemoveChildResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void TestDevice::Interface::SubscribeToLifecycleCompleterBase::Reply(::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SubscribeToLifecycleResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  SubscribeToLifecycleResponse _response = {};
  TestDevice::SetTransactionHeaderFor::SubscribeToLifecycleResponse(
      ::fidl::DecodedMessage<SubscribeToLifecycleResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SubscribeToLifecycleResponse::PrimarySize,
              SubscribeToLifecycleResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void TestDevice::Interface::SubscribeToLifecycleCompleterBase::ReplySuccess() {
  TestDevice_SubscribeToLifecycle_Response response;

  Reply(TestDevice_SubscribeToLifecycle_Result::WithResponse(&response));
}
void TestDevice::Interface::SubscribeToLifecycleCompleterBase::ReplyError(int32_t error) {
  Reply(TestDevice_SubscribeToLifecycle_Result::WithErr(&error));
}

void TestDevice::Interface::SubscribeToLifecycleCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Result result) {
  if (_buffer.capacity() < SubscribeToLifecycleResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  SubscribeToLifecycleResponse _response = {};
  TestDevice::SetTransactionHeaderFor::SubscribeToLifecycleResponse(
      ::fidl::DecodedMessage<SubscribeToLifecycleResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SubscribeToLifecycleResponse::PrimarySize,
              SubscribeToLifecycleResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void TestDevice::Interface::SubscribeToLifecycleCompleterBase::ReplySuccess(::fidl::BytePart _buffer) {
  TestDevice_SubscribeToLifecycle_Response response;

  Reply(std::move(_buffer), TestDevice_SubscribeToLifecycle_Result::WithResponse(&response));
}

void TestDevice::Interface::SubscribeToLifecycleCompleterBase::Reply(::fidl::DecodedMessage<SubscribeToLifecycleResponse> params) {
  TestDevice::SetTransactionHeaderFor::SubscribeToLifecycleResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void TestDevice::SetTransactionHeaderFor::AddChildRequest(const ::fidl::DecodedMessage<TestDevice::AddChildRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kTestDevice_AddChild_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void TestDevice::SetTransactionHeaderFor::AddChildResponse(const ::fidl::DecodedMessage<TestDevice::AddChildResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kTestDevice_AddChild_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void TestDevice::SetTransactionHeaderFor::RemoveChildRequest(const ::fidl::DecodedMessage<TestDevice::RemoveChildRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kTestDevice_RemoveChild_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void TestDevice::SetTransactionHeaderFor::RemoveChildResponse(const ::fidl::DecodedMessage<TestDevice::RemoveChildResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kTestDevice_RemoveChild_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void TestDevice::SetTransactionHeaderFor::SubscribeToLifecycleRequest(const ::fidl::DecodedMessage<TestDevice::SubscribeToLifecycleRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kTestDevice_SubscribeToLifecycle_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void TestDevice::SetTransactionHeaderFor::SubscribeToLifecycleResponse(const ::fidl::DecodedMessage<TestDevice::SubscribeToLifecycleResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kTestDevice_SubscribeToLifecycle_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

}  // namespace test
}  // namespace lifecycle
}  // namespace device
}  // namespace fuchsia
}  // namespace llcpp

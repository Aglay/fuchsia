// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/txn_header.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/connect_service.h>
#include <lib/fidl/llcpp/service_handler_interface.h>
#include <lib/fidl/llcpp/string_view.h>
#include <lib/fidl/llcpp/sync_call.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/fidl/llcpp/vector_view.h>
#include <lib/fit/function.h>
#include <lib/zx/channel.h>
#include <zircon/fidl.h>

namespace llcpp {

namespace fuchsia {
namespace device {
namespace lifecycle {
namespace test {

struct TestDevice_SubscribeToLifecycle_Response;
struct TestDevice_SubscribeToLifecycle_Result;
struct TestDevice_RemoveChild_Response;
struct TestDevice_RemoveChild_Result;
struct TestDevice_CompleteChildInit_Response;
struct TestDevice_CompleteChildInit_Result;
struct TestDevice_AddChild_Response;
struct TestDevice_AddChild_Result;
class Lifecycle;
class TestDevice;

extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_TestDevice_SubscribeToLifecycle_ResultTable;

struct TestDevice_SubscribeToLifecycle_Result {
  TestDevice_SubscribeToLifecycle_Result() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal() == Ordinal::kResponse; }

  static TestDevice_SubscribeToLifecycle_Result WithResponse(::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Response* val) {
    TestDevice_SubscribeToLifecycle_Result result;
    result.set_response(val);
    return result;
  }

  void set_response(::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Response* elem) {
    ordinal_ = Ordinal::kResponse;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Response& mutable_response() {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Response*>(envelope_.data);
  }
  const ::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Response& response() const {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Response*>(envelope_.data);
  }

  bool is_err() const { return ordinal() == Ordinal::kErr; }

  static TestDevice_SubscribeToLifecycle_Result WithErr(int32_t* val) {
    TestDevice_SubscribeToLifecycle_Result result;
    result.set_err(val);
    return result;
  }

  void set_err(int32_t* elem) {
    ordinal_ = Ordinal::kErr;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_err() {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_device_lifecycle_test_TestDevice_SubscribeToLifecycle_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_TestDevice_RemoveChild_ResultTable;

struct TestDevice_RemoveChild_Result {
  TestDevice_RemoveChild_Result() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal() == Ordinal::kResponse; }

  static TestDevice_RemoveChild_Result WithResponse(::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Response* val) {
    TestDevice_RemoveChild_Result result;
    result.set_response(val);
    return result;
  }

  void set_response(::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Response* elem) {
    ordinal_ = Ordinal::kResponse;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Response& mutable_response() {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Response*>(envelope_.data);
  }
  const ::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Response& response() const {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Response*>(envelope_.data);
  }

  bool is_err() const { return ordinal() == Ordinal::kErr; }

  static TestDevice_RemoveChild_Result WithErr(int32_t* val) {
    TestDevice_RemoveChild_Result result;
    result.set_err(val);
    return result;
  }

  void set_err(int32_t* elem) {
    ordinal_ = Ordinal::kErr;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_err() {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_device_lifecycle_test_TestDevice_RemoveChild_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_TestDevice_CompleteChildInit_ResultTable;

struct TestDevice_CompleteChildInit_Result {
  TestDevice_CompleteChildInit_Result() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal() == Ordinal::kResponse; }

  static TestDevice_CompleteChildInit_Result WithResponse(::llcpp::fuchsia::device::lifecycle::test::TestDevice_CompleteChildInit_Response* val) {
    TestDevice_CompleteChildInit_Result result;
    result.set_response(val);
    return result;
  }

  void set_response(::llcpp::fuchsia::device::lifecycle::test::TestDevice_CompleteChildInit_Response* elem) {
    ordinal_ = Ordinal::kResponse;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::device::lifecycle::test::TestDevice_CompleteChildInit_Response& mutable_response() {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::device::lifecycle::test::TestDevice_CompleteChildInit_Response*>(envelope_.data);
  }
  const ::llcpp::fuchsia::device::lifecycle::test::TestDevice_CompleteChildInit_Response& response() const {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::device::lifecycle::test::TestDevice_CompleteChildInit_Response*>(envelope_.data);
  }

  bool is_err() const { return ordinal() == Ordinal::kErr; }

  static TestDevice_CompleteChildInit_Result WithErr(int32_t* val) {
    TestDevice_CompleteChildInit_Result result;
    result.set_err(val);
    return result;
  }

  void set_err(int32_t* elem) {
    ordinal_ = Ordinal::kErr;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_err() {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_device_lifecycle_test_TestDevice_CompleteChildInit_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_TestDevice_AddChild_ResultTable;

struct TestDevice_AddChild_Result {
  TestDevice_AddChild_Result() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal() == Ordinal::kResponse; }

  static TestDevice_AddChild_Result WithResponse(::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Response* val) {
    TestDevice_AddChild_Result result;
    result.set_response(val);
    return result;
  }

  void set_response(::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Response* elem) {
    ordinal_ = Ordinal::kResponse;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Response& mutable_response() {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Response*>(envelope_.data);
  }
  const ::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Response& response() const {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Response*>(envelope_.data);
  }

  bool is_err() const { return ordinal() == Ordinal::kErr; }

  static TestDevice_AddChild_Result WithErr(int32_t* val) {
    TestDevice_AddChild_Result result;
    result.set_err(val);
    return result;
  }

  void set_err(int32_t* elem) {
    ordinal_ = Ordinal::kErr;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_err() {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_device_lifecycle_test_TestDevice_AddChild_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_TestDevice_SubscribeToLifecycle_ResponseTable;

struct TestDevice_SubscribeToLifecycle_Response {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_device_lifecycle_test_TestDevice_SubscribeToLifecycle_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  uint8_t __reserved = {};
};

extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_TestDevice_RemoveChild_ResponseTable;

struct TestDevice_RemoveChild_Response {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_device_lifecycle_test_TestDevice_RemoveChild_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  uint8_t __reserved = {};
};

extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_TestDevice_CompleteChildInit_ResponseTable;

struct TestDevice_CompleteChildInit_Response {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_device_lifecycle_test_TestDevice_CompleteChildInit_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  uint8_t __reserved = {};
};

extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_TestDevice_AddChild_ResponseTable;

struct TestDevice_AddChild_Response {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_device_lifecycle_test_TestDevice_AddChild_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  uint64_t child_id = {};
};

extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_LifecycleOnChildPreReleaseRequestTable;
extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_LifecycleOnChildPreReleaseEventTable;

class Lifecycle final {
  Lifecycle() = delete;
 public:

  struct OnChildPreReleaseResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t child_id;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_device_lifecycle_test_LifecycleOnChildPreReleaseEventTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };

  struct EventHandlers {
    // Sent when the ChildPreRelease hook is called.
    fit::callback<zx_status_t(uint64_t child_id)> on_child_pre_release;

    // Fallback handler when an unknown ordinal is received.
    // Caller may put custom error handling logic here.
    fit::callback<zx_status_t()> unknown;
  };

  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:

   public:
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:

   public:
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    zx_status_t HandleEvents(EventHandlers handlers);
   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    static zx_status_t HandleEvents(::zx::unowned_channel client_end, EventHandlers handlers);
  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Lifecycle;
    using _Base = ::fidl::CompleterBase;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

  // Sent when the ChildPreRelease hook is called.
  static zx_status_t SendOnChildPreReleaseEvent(::zx::unowned_channel _chan, uint64_t child_id);

  // Sent when the ChildPreRelease hook is called.
  // Caller provides the backing storage for FIDL message via response buffers.
  static zx_status_t SendOnChildPreReleaseEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, uint64_t child_id);

  // Sent when the ChildPreRelease hook is called.
  // Messages are encoded in-place.
  static zx_status_t SendOnChildPreReleaseEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnChildPreReleaseResponse> params);


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void OnChildPreReleaseResponse(const ::fidl::DecodedMessage<Lifecycle::OnChildPreReleaseResponse>& _msg);
  };
};

extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_TestDeviceAddChildRequestTable;
extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_TestDeviceAddChildResponseTable;
extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_TestDeviceRemoveChildRequestTable;
extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_TestDeviceRemoveChildResponseTable;
extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_TestDeviceCompleteChildInitRequestTable;
extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_TestDeviceCompleteChildInitResponseTable;
extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_TestDeviceSubscribeToLifecycleRequestTable;
extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_TestDeviceSubscribeToLifecycleResponseTable;

class TestDevice final {
  TestDevice() = delete;
 public:

  struct AddChildResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_device_lifecycle_test_TestDeviceAddChildResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct AddChildRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    bool init_complete;
    int32_t init_status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_device_lifecycle_test_TestDeviceAddChildRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = AddChildResponse;
  };

  struct RemoveChildResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_device_lifecycle_test_TestDeviceRemoveChildResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct RemoveChildRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t child_id;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_device_lifecycle_test_TestDeviceRemoveChildRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = RemoveChildResponse;
  };

  struct CompleteChildInitResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::device::lifecycle::test::TestDevice_CompleteChildInit_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_device_lifecycle_test_TestDeviceCompleteChildInitResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct CompleteChildInitRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t child_id;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_device_lifecycle_test_TestDeviceCompleteChildInitRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = CompleteChildInitResponse;
  };

  struct SubscribeToLifecycleResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_device_lifecycle_test_TestDeviceSubscribeToLifecycleResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SubscribeToLifecycleRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::channel client;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_device_lifecycle_test_TestDeviceSubscribeToLifecycleRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SubscribeToLifecycleResponse;
  };


  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    template <typename ResponseType>
    class AddChild_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      AddChild_Impl(::zx::unowned_channel _client_end, bool init_complete, int32_t init_status);
      ~AddChild_Impl() = default;
      AddChild_Impl(AddChild_Impl&& other) = default;
      AddChild_Impl& operator=(AddChild_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class RemoveChild_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      RemoveChild_Impl(::zx::unowned_channel _client_end, uint64_t child_id);
      ~RemoveChild_Impl() = default;
      RemoveChild_Impl(RemoveChild_Impl&& other) = default;
      RemoveChild_Impl& operator=(RemoveChild_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class CompleteChildInit_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      CompleteChildInit_Impl(::zx::unowned_channel _client_end, uint64_t child_id);
      ~CompleteChildInit_Impl() = default;
      CompleteChildInit_Impl(CompleteChildInit_Impl&& other) = default;
      CompleteChildInit_Impl& operator=(CompleteChildInit_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SubscribeToLifecycle_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      SubscribeToLifecycle_Impl(::zx::unowned_channel _client_end, ::zx::channel client);
      ~SubscribeToLifecycle_Impl() = default;
      SubscribeToLifecycle_Impl(SubscribeToLifecycle_Impl&& other) = default;
      SubscribeToLifecycle_Impl& operator=(SubscribeToLifecycle_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using AddChild = AddChild_Impl<AddChildResponse>;
    using RemoveChild = RemoveChild_Impl<RemoveChildResponse>;
    using CompleteChildInit = CompleteChildInit_Impl<CompleteChildInitResponse>;
    using SubscribeToLifecycle = SubscribeToLifecycle_Impl<SubscribeToLifecycleResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    template <typename ResponseType>
    class AddChild_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      AddChild_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, bool init_complete, int32_t init_status, ::fidl::BytePart _response_buffer);
      ~AddChild_Impl() = default;
      AddChild_Impl(AddChild_Impl&& other) = default;
      AddChild_Impl& operator=(AddChild_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class RemoveChild_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      RemoveChild_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t child_id, ::fidl::BytePart _response_buffer);
      ~RemoveChild_Impl() = default;
      RemoveChild_Impl(RemoveChild_Impl&& other) = default;
      RemoveChild_Impl& operator=(RemoveChild_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class CompleteChildInit_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      CompleteChildInit_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t child_id, ::fidl::BytePart _response_buffer);
      ~CompleteChildInit_Impl() = default;
      CompleteChildInit_Impl(CompleteChildInit_Impl&& other) = default;
      CompleteChildInit_Impl& operator=(CompleteChildInit_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SubscribeToLifecycle_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      SubscribeToLifecycle_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel client, ::fidl::BytePart _response_buffer);
      ~SubscribeToLifecycle_Impl() = default;
      SubscribeToLifecycle_Impl(SubscribeToLifecycle_Impl&& other) = default;
      SubscribeToLifecycle_Impl& operator=(SubscribeToLifecycle_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using AddChild = AddChild_Impl<AddChildResponse>;
    using RemoveChild = RemoveChild_Impl<RemoveChildResponse>;
    using CompleteChildInit = CompleteChildInit_Impl<CompleteChildInitResponse>;
    using SubscribeToLifecycle = SubscribeToLifecycle_Impl<SubscribeToLifecycleResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Adds a child device and returns a unique |id| for the created device.
    // |complete_init| specifies whether the init hook should be replied to immediately,
    // or completed later by the caller with |CompleteChildInit|.
    // Allocates 72 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::AddChild AddChild(bool init_complete, int32_t init_status);

    // Adds a child device and returns a unique |id| for the created device.
    // |complete_init| specifies whether the init hook should be replied to immediately,
    // or completed later by the caller with |CompleteChildInit|.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::AddChild AddChild(::fidl::BytePart _request_buffer, bool init_complete, int32_t init_status, ::fidl::BytePart _response_buffer);

    // Removes the child device of the given |id|.
    // Allocates 72 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::RemoveChild RemoveChild(uint64_t child_id);

    // Removes the child device of the given |id|.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::RemoveChild RemoveChild(::fidl::BytePart _request_buffer, uint64_t child_id, ::fidl::BytePart _response_buffer);

    // Replies to the child init hook.
    // Returns an error if the child has no pending init.
    // Allocates 72 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::CompleteChildInit CompleteChildInit(uint64_t child_id);

    // Replies to the child init hook.
    // Returns an error if the child has no pending init.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::CompleteChildInit CompleteChildInit(::fidl::BytePart _request_buffer, uint64_t child_id, ::fidl::BytePart _response_buffer);

    // Registers the client for device lifecycle events.
    // Allocates 72 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::SubscribeToLifecycle SubscribeToLifecycle(::zx::channel client);

    // Registers the client for device lifecycle events.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SubscribeToLifecycle SubscribeToLifecycle(::fidl::BytePart _request_buffer, ::zx::channel client, ::fidl::BytePart _response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Adds a child device and returns a unique |id| for the created device.
    // |complete_init| specifies whether the init hook should be replied to immediately,
    // or completed later by the caller with |CompleteChildInit|.
    // Allocates 72 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::AddChild AddChild(::zx::unowned_channel _client_end, bool init_complete, int32_t init_status);

    // Adds a child device and returns a unique |id| for the created device.
    // |complete_init| specifies whether the init hook should be replied to immediately,
    // or completed later by the caller with |CompleteChildInit|.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::AddChild AddChild(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, bool init_complete, int32_t init_status, ::fidl::BytePart _response_buffer);

    // Removes the child device of the given |id|.
    // Allocates 72 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::RemoveChild RemoveChild(::zx::unowned_channel _client_end, uint64_t child_id);

    // Removes the child device of the given |id|.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::RemoveChild RemoveChild(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t child_id, ::fidl::BytePart _response_buffer);

    // Replies to the child init hook.
    // Returns an error if the child has no pending init.
    // Allocates 72 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::CompleteChildInit CompleteChildInit(::zx::unowned_channel _client_end, uint64_t child_id);

    // Replies to the child init hook.
    // Returns an error if the child has no pending init.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::CompleteChildInit CompleteChildInit(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t child_id, ::fidl::BytePart _response_buffer);

    // Registers the client for device lifecycle events.
    // Allocates 72 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::SubscribeToLifecycle SubscribeToLifecycle(::zx::unowned_channel _client_end, ::zx::channel client);

    // Registers the client for device lifecycle events.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SubscribeToLifecycle SubscribeToLifecycle(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel client, ::fidl::BytePart _response_buffer);

  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Adds a child device and returns a unique |id| for the created device.
    // |complete_init| specifies whether the init hook should be replied to immediately,
    // or completed later by the caller with |CompleteChildInit|.
    static ::fidl::DecodeResult<AddChildResponse> AddChild(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<AddChildRequest> params, ::fidl::BytePart response_buffer);

    // Removes the child device of the given |id|.
    static ::fidl::DecodeResult<RemoveChildResponse> RemoveChild(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<RemoveChildRequest> params, ::fidl::BytePart response_buffer);

    // Replies to the child init hook.
    // Returns an error if the child has no pending init.
    static ::fidl::DecodeResult<CompleteChildInitResponse> CompleteChildInit(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<CompleteChildInitRequest> params, ::fidl::BytePart response_buffer);

    // Registers the client for device lifecycle events.
    static ::fidl::DecodeResult<SubscribeToLifecycleResponse> SubscribeToLifecycle(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SubscribeToLifecycleRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = TestDevice;
    using _Base = ::fidl::CompleterBase;

    class AddChildCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Result result);
      void ReplySuccess(uint64_t child_id);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, uint64_t child_id);
      void Reply(::fidl::DecodedMessage<AddChildResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using AddChildCompleter = ::fidl::Completer<AddChildCompleterBase>;

    virtual void AddChild(bool init_complete, int32_t init_status, AddChildCompleter::Sync _completer) = 0;

    class RemoveChildCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<RemoveChildResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using RemoveChildCompleter = ::fidl::Completer<RemoveChildCompleterBase>;

    virtual void RemoveChild(uint64_t child_id, RemoveChildCompleter::Sync _completer) = 0;

    class CompleteChildInitCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::device::lifecycle::test::TestDevice_CompleteChildInit_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::device::lifecycle::test::TestDevice_CompleteChildInit_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<CompleteChildInitResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using CompleteChildInitCompleter = ::fidl::Completer<CompleteChildInitCompleterBase>;

    virtual void CompleteChildInit(uint64_t child_id, CompleteChildInitCompleter::Sync _completer) = 0;

    class SubscribeToLifecycleCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<SubscribeToLifecycleResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SubscribeToLifecycleCompleter = ::fidl::Completer<SubscribeToLifecycleCompleterBase>;

    virtual void SubscribeToLifecycle(::zx::channel client, SubscribeToLifecycleCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void AddChildRequest(const ::fidl::DecodedMessage<TestDevice::AddChildRequest>& _msg);
    static void AddChildResponse(const ::fidl::DecodedMessage<TestDevice::AddChildResponse>& _msg);
    static void RemoveChildRequest(const ::fidl::DecodedMessage<TestDevice::RemoveChildRequest>& _msg);
    static void RemoveChildResponse(const ::fidl::DecodedMessage<TestDevice::RemoveChildResponse>& _msg);
    static void CompleteChildInitRequest(const ::fidl::DecodedMessage<TestDevice::CompleteChildInitRequest>& _msg);
    static void CompleteChildInitResponse(const ::fidl::DecodedMessage<TestDevice::CompleteChildInitResponse>& _msg);
    static void SubscribeToLifecycleRequest(const ::fidl::DecodedMessage<TestDevice::SubscribeToLifecycleRequest>& _msg);
    static void SubscribeToLifecycleResponse(const ::fidl::DecodedMessage<TestDevice::SubscribeToLifecycleResponse>& _msg);
  };
};

}  // namespace test
}  // namespace lifecycle
}  // namespace device
}  // namespace fuchsia
}  // namespace llcpp

namespace fidl {

template <>
struct IsFidlType<::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Response>);
static_assert(offsetof(::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Response, __reserved) == 0);
static_assert(sizeof(::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Response) == ::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Response>);
static_assert(offsetof(::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Response, __reserved) == 0);
static_assert(sizeof(::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Response) == ::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::device::lifecycle::test::TestDevice_CompleteChildInit_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::device::lifecycle::test::TestDevice_CompleteChildInit_Response>);
static_assert(offsetof(::llcpp::fuchsia::device::lifecycle::test::TestDevice_CompleteChildInit_Response, __reserved) == 0);
static_assert(sizeof(::llcpp::fuchsia::device::lifecycle::test::TestDevice_CompleteChildInit_Response) == ::llcpp::fuchsia::device::lifecycle::test::TestDevice_CompleteChildInit_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::device::lifecycle::test::TestDevice_CompleteChildInit_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::device::lifecycle::test::TestDevice_CompleteChildInit_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Response>);
static_assert(offsetof(::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Response, child_id) == 0);
static_assert(sizeof(::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Response) == ::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::device::lifecycle::test::Lifecycle::OnChildPreReleaseResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::lifecycle::test::Lifecycle::OnChildPreReleaseResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::lifecycle::test::Lifecycle::OnChildPreReleaseResponse)
    == ::llcpp::fuchsia::device::lifecycle::test::Lifecycle::OnChildPreReleaseResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::lifecycle::test::Lifecycle::OnChildPreReleaseResponse, child_id) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::device::lifecycle::test::TestDevice::AddChildRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::lifecycle::test::TestDevice::AddChildRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::lifecycle::test::TestDevice::AddChildRequest)
    == ::llcpp::fuchsia::device::lifecycle::test::TestDevice::AddChildRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::lifecycle::test::TestDevice::AddChildRequest, init_complete) == 16);
static_assert(offsetof(::llcpp::fuchsia::device::lifecycle::test::TestDevice::AddChildRequest, init_status) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::device::lifecycle::test::TestDevice::AddChildResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::lifecycle::test::TestDevice::AddChildResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::lifecycle::test::TestDevice::AddChildResponse)
    == ::llcpp::fuchsia::device::lifecycle::test::TestDevice::AddChildResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::lifecycle::test::TestDevice::AddChildResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::device::lifecycle::test::TestDevice::RemoveChildRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::lifecycle::test::TestDevice::RemoveChildRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::lifecycle::test::TestDevice::RemoveChildRequest)
    == ::llcpp::fuchsia::device::lifecycle::test::TestDevice::RemoveChildRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::lifecycle::test::TestDevice::RemoveChildRequest, child_id) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::device::lifecycle::test::TestDevice::RemoveChildResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::lifecycle::test::TestDevice::RemoveChildResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::lifecycle::test::TestDevice::RemoveChildResponse)
    == ::llcpp::fuchsia::device::lifecycle::test::TestDevice::RemoveChildResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::lifecycle::test::TestDevice::RemoveChildResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::device::lifecycle::test::TestDevice::CompleteChildInitRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::lifecycle::test::TestDevice::CompleteChildInitRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::lifecycle::test::TestDevice::CompleteChildInitRequest)
    == ::llcpp::fuchsia::device::lifecycle::test::TestDevice::CompleteChildInitRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::lifecycle::test::TestDevice::CompleteChildInitRequest, child_id) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::device::lifecycle::test::TestDevice::CompleteChildInitResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::lifecycle::test::TestDevice::CompleteChildInitResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::lifecycle::test::TestDevice::CompleteChildInitResponse)
    == ::llcpp::fuchsia::device::lifecycle::test::TestDevice::CompleteChildInitResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::lifecycle::test::TestDevice::CompleteChildInitResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::device::lifecycle::test::TestDevice::SubscribeToLifecycleRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::lifecycle::test::TestDevice::SubscribeToLifecycleRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::lifecycle::test::TestDevice::SubscribeToLifecycleRequest)
    == ::llcpp::fuchsia::device::lifecycle::test::TestDevice::SubscribeToLifecycleRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::lifecycle::test::TestDevice::SubscribeToLifecycleRequest, client) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::device::lifecycle::test::TestDevice::SubscribeToLifecycleResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::lifecycle::test::TestDevice::SubscribeToLifecycleResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::lifecycle::test::TestDevice::SubscribeToLifecycleResponse)
    == ::llcpp::fuchsia::device::lifecycle::test::TestDevice::SubscribeToLifecycleResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::lifecycle::test::TestDevice::SubscribeToLifecycleResponse, result) == 16);

}  // namespace fidl

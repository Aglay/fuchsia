// WARNING: This file is machine generated by fidlgen.

#include <fuchsia/device/schedule/work/test/llcpp/fidl.h>
#include <memory>

namespace llcpp {

namespace fuchsia {
namespace device {
namespace schedule {
namespace work {
namespace test {

void ::llcpp::fuchsia::device::schedule::work::test::TestDevice_ScheduleWork_Result::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(TestDevice_ScheduleWork_Result) == sizeof(fidl_xunion_t));
  static_assert(offsetof(TestDevice_ScheduleWork_Result, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(TestDevice_ScheduleWork_Result, envelope_) == offsetof(fidl_xunion_t, envelope));
}

void ::llcpp::fuchsia::device::schedule::work::test::TestDevice_ScheduleWorkDifferentThread_Result::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(TestDevice_ScheduleWorkDifferentThread_Result) == sizeof(fidl_xunion_t));
  static_assert(offsetof(TestDevice_ScheduleWorkDifferentThread_Result, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(TestDevice_ScheduleWorkDifferentThread_Result, envelope_) == offsetof(fidl_xunion_t, envelope));
}

void ::llcpp::fuchsia::device::schedule::work::test::TestDevice_GetDoneEvent_Result::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(TestDevice_GetDoneEvent_Result) == sizeof(fidl_xunion_t));
  static_assert(offsetof(TestDevice_GetDoneEvent_Result, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(TestDevice_GetDoneEvent_Result, envelope_) == offsetof(fidl_xunion_t, envelope));
}

void ::llcpp::fuchsia::device::schedule::work::test::TestDevice_GetChannel_Result::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(TestDevice_GetChannel_Result) == sizeof(fidl_xunion_t));
  static_assert(offsetof(TestDevice_GetChannel_Result, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(TestDevice_GetChannel_Result, envelope_) == offsetof(fidl_xunion_t, envelope));
}

namespace {

[[maybe_unused]]
constexpr uint64_t kTestDevice_ScheduleWork_Ordinal = 0x4be6132300000000lu;
[[maybe_unused]]
constexpr uint64_t kTestDevice_ScheduleWork_GenOrdinal = 0x170d21d7a7c60c39lu;
extern "C" const fidl_type_t v1_fuchsia_device_schedule_work_test_TestDeviceScheduleWorkRequestTable;
extern "C" const fidl_type_t v1_fuchsia_device_schedule_work_test_TestDeviceScheduleWorkResponseTable;
[[maybe_unused]]
constexpr uint64_t kTestDevice_ScheduleWorkDifferentThread_Ordinal = 0x6ab14d600000000lu;
[[maybe_unused]]
constexpr uint64_t kTestDevice_ScheduleWorkDifferentThread_GenOrdinal = 0x5f561520dc24b81flu;
extern "C" const fidl_type_t v1_fuchsia_device_schedule_work_test_TestDeviceScheduleWorkDifferentThreadRequestTable;
extern "C" const fidl_type_t v1_fuchsia_device_schedule_work_test_TestDeviceScheduleWorkDifferentThreadResponseTable;
[[maybe_unused]]
constexpr uint64_t kTestDevice_GetDoneEvent_Ordinal = 0x2f1b0e5800000000lu;
[[maybe_unused]]
constexpr uint64_t kTestDevice_GetDoneEvent_GenOrdinal = 0x6c1ddc133dc96d1lu;
extern "C" const fidl_type_t v1_fuchsia_device_schedule_work_test_TestDeviceGetDoneEventRequestTable;
extern "C" const fidl_type_t v1_fuchsia_device_schedule_work_test_TestDeviceGetDoneEventResponseTable;
[[maybe_unused]]
constexpr uint64_t kTestDevice_ScheduledWorkRan_Ordinal = 0x686e4e5500000000lu;
[[maybe_unused]]
constexpr uint64_t kTestDevice_ScheduledWorkRan_GenOrdinal = 0x1d1b1aabae000a2dlu;
extern "C" const fidl_type_t v1_fuchsia_device_schedule_work_test_TestDeviceScheduledWorkRanRequestTable;
extern "C" const fidl_type_t v1_fuchsia_device_schedule_work_test_TestDeviceScheduledWorkRanResponseTable;
[[maybe_unused]]
constexpr uint64_t kTestDevice_GetChannel_Ordinal = 0x1828922200000000lu;
[[maybe_unused]]
constexpr uint64_t kTestDevice_GetChannel_GenOrdinal = 0x3097d0cfd3d89a66lu;
extern "C" const fidl_type_t v1_fuchsia_device_schedule_work_test_TestDeviceGetChannelRequestTable;
extern "C" const fidl_type_t v1_fuchsia_device_schedule_work_test_TestDeviceGetChannelResponseTable;

}  // namespace
template <>
TestDevice::ResultOf::ScheduleWork_Impl<TestDevice::ScheduleWorkResponse>::ScheduleWork_Impl(::zx::unowned_channel _client_end, uint32_t batch_size, uint32_t num_work_items) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ScheduleWorkRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ScheduleWorkRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ScheduleWorkRequest*>(_write_bytes);
  _request.batch_size = std::move(batch_size);
  _request.num_work_items = std::move(num_work_items);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ScheduleWorkRequest));
  ::fidl::DecodedMessage<ScheduleWorkRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      TestDevice::InPlace::ScheduleWork(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

TestDevice::ResultOf::ScheduleWork TestDevice::SyncClient::ScheduleWork(uint32_t batch_size, uint32_t num_work_items) {
    return ResultOf::ScheduleWork(::zx::unowned_channel(this->channel_), std::move(batch_size), std::move(num_work_items));
}

TestDevice::ResultOf::ScheduleWork TestDevice::Call::ScheduleWork(::zx::unowned_channel _client_end, uint32_t batch_size, uint32_t num_work_items) {
  return ResultOf::ScheduleWork(std::move(_client_end), std::move(batch_size), std::move(num_work_items));
}

template <>
TestDevice::UnownedResultOf::ScheduleWork_Impl<TestDevice::ScheduleWorkResponse>::ScheduleWork_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t batch_size, uint32_t num_work_items, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < ScheduleWorkRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<ScheduleWorkResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, ScheduleWorkRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ScheduleWorkRequest*>(_request_buffer.data());
  _request.batch_size = std::move(batch_size);
  _request.num_work_items = std::move(num_work_items);
  _request_buffer.set_actual(sizeof(ScheduleWorkRequest));
  ::fidl::DecodedMessage<ScheduleWorkRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      TestDevice::InPlace::ScheduleWork(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

TestDevice::UnownedResultOf::ScheduleWork TestDevice::SyncClient::ScheduleWork(::fidl::BytePart _request_buffer, uint32_t batch_size, uint32_t num_work_items, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ScheduleWork(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(batch_size), std::move(num_work_items), std::move(_response_buffer));
}

TestDevice::UnownedResultOf::ScheduleWork TestDevice::Call::ScheduleWork(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t batch_size, uint32_t num_work_items, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ScheduleWork(std::move(_client_end), std::move(_request_buffer), std::move(batch_size), std::move(num_work_items), std::move(_response_buffer));
}

::fidl::DecodeResult<TestDevice::ScheduleWorkResponse> TestDevice::InPlace::ScheduleWork(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ScheduleWorkRequest> params, ::fidl::BytePart response_buffer) {
  TestDevice::SetTransactionHeaderFor::ScheduleWorkRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<TestDevice::ScheduleWorkResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ScheduleWorkRequest, ScheduleWorkResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<TestDevice::ScheduleWorkResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
TestDevice::ResultOf::ScheduleWorkDifferentThread_Impl<TestDevice::ScheduleWorkDifferentThreadResponse>::ScheduleWorkDifferentThread_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ScheduleWorkDifferentThreadRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ScheduleWorkDifferentThreadRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ScheduleWorkDifferentThreadRequest));
  ::fidl::DecodedMessage<ScheduleWorkDifferentThreadRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      TestDevice::InPlace::ScheduleWorkDifferentThread(std::move(_client_end), Super::response_buffer()));
}

TestDevice::ResultOf::ScheduleWorkDifferentThread TestDevice::SyncClient::ScheduleWorkDifferentThread() {
    return ResultOf::ScheduleWorkDifferentThread(::zx::unowned_channel(this->channel_));
}

TestDevice::ResultOf::ScheduleWorkDifferentThread TestDevice::Call::ScheduleWorkDifferentThread(::zx::unowned_channel _client_end) {
  return ResultOf::ScheduleWorkDifferentThread(std::move(_client_end));
}

template <>
TestDevice::UnownedResultOf::ScheduleWorkDifferentThread_Impl<TestDevice::ScheduleWorkDifferentThreadResponse>::ScheduleWorkDifferentThread_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(ScheduleWorkDifferentThreadRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, ScheduleWorkDifferentThreadRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(ScheduleWorkDifferentThreadRequest));
  ::fidl::DecodedMessage<ScheduleWorkDifferentThreadRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      TestDevice::InPlace::ScheduleWorkDifferentThread(std::move(_client_end), std::move(_response_buffer)));
}

TestDevice::UnownedResultOf::ScheduleWorkDifferentThread TestDevice::SyncClient::ScheduleWorkDifferentThread(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ScheduleWorkDifferentThread(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

TestDevice::UnownedResultOf::ScheduleWorkDifferentThread TestDevice::Call::ScheduleWorkDifferentThread(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ScheduleWorkDifferentThread(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<TestDevice::ScheduleWorkDifferentThreadResponse> TestDevice::InPlace::ScheduleWorkDifferentThread(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(ScheduleWorkDifferentThreadRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<ScheduleWorkDifferentThreadRequest> params(std::move(_request_buffer));
  TestDevice::SetTransactionHeaderFor::ScheduleWorkDifferentThreadRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<TestDevice::ScheduleWorkDifferentThreadResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ScheduleWorkDifferentThreadRequest, ScheduleWorkDifferentThreadResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<TestDevice::ScheduleWorkDifferentThreadResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
TestDevice::ResultOf::GetDoneEvent_Impl<TestDevice::GetDoneEventResponse>::GetDoneEvent_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetDoneEventRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetDoneEventRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetDoneEventRequest));
  ::fidl::DecodedMessage<GetDoneEventRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      TestDevice::InPlace::GetDoneEvent(std::move(_client_end), Super::response_buffer()));
}

TestDevice::ResultOf::GetDoneEvent TestDevice::SyncClient::GetDoneEvent() {
    return ResultOf::GetDoneEvent(::zx::unowned_channel(this->channel_));
}

TestDevice::ResultOf::GetDoneEvent TestDevice::Call::GetDoneEvent(::zx::unowned_channel _client_end) {
  return ResultOf::GetDoneEvent(std::move(_client_end));
}

template <>
TestDevice::UnownedResultOf::GetDoneEvent_Impl<TestDevice::GetDoneEventResponse>::GetDoneEvent_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetDoneEventRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetDoneEventRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetDoneEventRequest));
  ::fidl::DecodedMessage<GetDoneEventRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      TestDevice::InPlace::GetDoneEvent(std::move(_client_end), std::move(_response_buffer)));
}

TestDevice::UnownedResultOf::GetDoneEvent TestDevice::SyncClient::GetDoneEvent(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetDoneEvent(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

TestDevice::UnownedResultOf::GetDoneEvent TestDevice::Call::GetDoneEvent(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetDoneEvent(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<TestDevice::GetDoneEventResponse> TestDevice::InPlace::GetDoneEvent(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetDoneEventRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetDoneEventRequest> params(std::move(_request_buffer));
  TestDevice::SetTransactionHeaderFor::GetDoneEventRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<TestDevice::GetDoneEventResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetDoneEventRequest, GetDoneEventResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<TestDevice::GetDoneEventResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
TestDevice::ResultOf::ScheduledWorkRan_Impl<TestDevice::ScheduledWorkRanResponse>::ScheduledWorkRan_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ScheduledWorkRanRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ScheduledWorkRanRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ScheduledWorkRanRequest));
  ::fidl::DecodedMessage<ScheduledWorkRanRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      TestDevice::InPlace::ScheduledWorkRan(std::move(_client_end), Super::response_buffer()));
}

TestDevice::ResultOf::ScheduledWorkRan TestDevice::SyncClient::ScheduledWorkRan() {
    return ResultOf::ScheduledWorkRan(::zx::unowned_channel(this->channel_));
}

TestDevice::ResultOf::ScheduledWorkRan TestDevice::Call::ScheduledWorkRan(::zx::unowned_channel _client_end) {
  return ResultOf::ScheduledWorkRan(std::move(_client_end));
}

template <>
TestDevice::UnownedResultOf::ScheduledWorkRan_Impl<TestDevice::ScheduledWorkRanResponse>::ScheduledWorkRan_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(ScheduledWorkRanRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, ScheduledWorkRanRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(ScheduledWorkRanRequest));
  ::fidl::DecodedMessage<ScheduledWorkRanRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      TestDevice::InPlace::ScheduledWorkRan(std::move(_client_end), std::move(_response_buffer)));
}

TestDevice::UnownedResultOf::ScheduledWorkRan TestDevice::SyncClient::ScheduledWorkRan(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ScheduledWorkRan(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

TestDevice::UnownedResultOf::ScheduledWorkRan TestDevice::Call::ScheduledWorkRan(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ScheduledWorkRan(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<TestDevice::ScheduledWorkRanResponse> TestDevice::InPlace::ScheduledWorkRan(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(ScheduledWorkRanRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<ScheduledWorkRanRequest> params(std::move(_request_buffer));
  TestDevice::SetTransactionHeaderFor::ScheduledWorkRanRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<TestDevice::ScheduledWorkRanResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ScheduledWorkRanRequest, ScheduledWorkRanResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<TestDevice::ScheduledWorkRanResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
TestDevice::ResultOf::GetChannel_Impl<TestDevice::GetChannelResponse>::GetChannel_Impl(::zx::unowned_channel _client_end, ::zx::channel test) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetChannelRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetChannelRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetChannelRequest*>(_write_bytes);
  _request.test = std::move(test);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetChannelRequest));
  ::fidl::DecodedMessage<GetChannelRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      TestDevice::InPlace::GetChannel(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

TestDevice::ResultOf::GetChannel TestDevice::SyncClient::GetChannel(::zx::channel test) {
    return ResultOf::GetChannel(::zx::unowned_channel(this->channel_), std::move(test));
}

TestDevice::ResultOf::GetChannel TestDevice::Call::GetChannel(::zx::unowned_channel _client_end, ::zx::channel test) {
  return ResultOf::GetChannel(std::move(_client_end), std::move(test));
}

template <>
TestDevice::UnownedResultOf::GetChannel_Impl<TestDevice::GetChannelResponse>::GetChannel_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel test, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < GetChannelRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<GetChannelResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, GetChannelRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetChannelRequest*>(_request_buffer.data());
  _request.test = std::move(test);
  _request_buffer.set_actual(sizeof(GetChannelRequest));
  ::fidl::DecodedMessage<GetChannelRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      TestDevice::InPlace::GetChannel(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

TestDevice::UnownedResultOf::GetChannel TestDevice::SyncClient::GetChannel(::fidl::BytePart _request_buffer, ::zx::channel test, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetChannel(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(test), std::move(_response_buffer));
}

TestDevice::UnownedResultOf::GetChannel TestDevice::Call::GetChannel(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel test, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetChannel(std::move(_client_end), std::move(_request_buffer), std::move(test), std::move(_response_buffer));
}

::fidl::DecodeResult<TestDevice::GetChannelResponse> TestDevice::InPlace::GetChannel(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetChannelRequest> params, ::fidl::BytePart response_buffer) {
  TestDevice::SetTransactionHeaderFor::GetChannelRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<TestDevice::GetChannelResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetChannelRequest, GetChannelResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<TestDevice::GetChannelResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool TestDevice::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kTestDevice_ScheduleWork_Ordinal:
    case kTestDevice_ScheduleWork_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ScheduleWorkRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->ScheduleWork(std::move(message->batch_size), std::move(message->num_work_items),
          Interface::ScheduleWorkCompleter::Sync(txn));
      return true;
    }
    case kTestDevice_ScheduleWorkDifferentThread_Ordinal:
    case kTestDevice_ScheduleWorkDifferentThread_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ScheduleWorkDifferentThreadRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->ScheduleWorkDifferentThread(
          Interface::ScheduleWorkDifferentThreadCompleter::Sync(txn));
      return true;
    }
    case kTestDevice_GetDoneEvent_Ordinal:
    case kTestDevice_GetDoneEvent_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetDoneEventRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetDoneEvent(
          Interface::GetDoneEventCompleter::Sync(txn));
      return true;
    }
    case kTestDevice_ScheduledWorkRan_Ordinal:
    case kTestDevice_ScheduledWorkRan_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ScheduledWorkRanRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->ScheduledWorkRan(
          Interface::ScheduledWorkRanCompleter::Sync(txn));
      return true;
    }
    case kTestDevice_GetChannel_Ordinal:
    case kTestDevice_GetChannel_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetChannelRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->GetChannel(std::move(message->test),
          Interface::GetChannelCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool TestDevice::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void TestDevice::Interface::ScheduleWorkCompleterBase::Reply(::llcpp::fuchsia::device::schedule::work::test::TestDevice_ScheduleWork_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ScheduleWorkResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  ScheduleWorkResponse _response = {};
  TestDevice::SetTransactionHeaderFor::ScheduleWorkResponse(
      ::fidl::DecodedMessage<ScheduleWorkResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ScheduleWorkResponse::PrimarySize,
              ScheduleWorkResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void TestDevice::Interface::ScheduleWorkCompleterBase::ReplySuccess() {
  TestDevice_ScheduleWork_Response response;

  Reply(TestDevice_ScheduleWork_Result::WithResponse(&response));
}
void TestDevice::Interface::ScheduleWorkCompleterBase::ReplyError(int32_t error) {
  Reply(TestDevice_ScheduleWork_Result::WithErr(&error));
}

void TestDevice::Interface::ScheduleWorkCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::device::schedule::work::test::TestDevice_ScheduleWork_Result result) {
  if (_buffer.capacity() < ScheduleWorkResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  ScheduleWorkResponse _response = {};
  TestDevice::SetTransactionHeaderFor::ScheduleWorkResponse(
      ::fidl::DecodedMessage<ScheduleWorkResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ScheduleWorkResponse::PrimarySize,
              ScheduleWorkResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void TestDevice::Interface::ScheduleWorkCompleterBase::ReplySuccess(::fidl::BytePart _buffer) {
  TestDevice_ScheduleWork_Response response;

  Reply(std::move(_buffer), TestDevice_ScheduleWork_Result::WithResponse(&response));
}

void TestDevice::Interface::ScheduleWorkCompleterBase::Reply(::fidl::DecodedMessage<ScheduleWorkResponse> params) {
  TestDevice::SetTransactionHeaderFor::ScheduleWorkResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void TestDevice::Interface::ScheduleWorkDifferentThreadCompleterBase::Reply(::llcpp::fuchsia::device::schedule::work::test::TestDevice_ScheduleWorkDifferentThread_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ScheduleWorkDifferentThreadResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  ScheduleWorkDifferentThreadResponse _response = {};
  TestDevice::SetTransactionHeaderFor::ScheduleWorkDifferentThreadResponse(
      ::fidl::DecodedMessage<ScheduleWorkDifferentThreadResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ScheduleWorkDifferentThreadResponse::PrimarySize,
              ScheduleWorkDifferentThreadResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void TestDevice::Interface::ScheduleWorkDifferentThreadCompleterBase::ReplySuccess() {
  TestDevice_ScheduleWorkDifferentThread_Response response;

  Reply(TestDevice_ScheduleWorkDifferentThread_Result::WithResponse(&response));
}
void TestDevice::Interface::ScheduleWorkDifferentThreadCompleterBase::ReplyError(int32_t error) {
  Reply(TestDevice_ScheduleWorkDifferentThread_Result::WithErr(&error));
}

void TestDevice::Interface::ScheduleWorkDifferentThreadCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::device::schedule::work::test::TestDevice_ScheduleWorkDifferentThread_Result result) {
  if (_buffer.capacity() < ScheduleWorkDifferentThreadResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  ScheduleWorkDifferentThreadResponse _response = {};
  TestDevice::SetTransactionHeaderFor::ScheduleWorkDifferentThreadResponse(
      ::fidl::DecodedMessage<ScheduleWorkDifferentThreadResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ScheduleWorkDifferentThreadResponse::PrimarySize,
              ScheduleWorkDifferentThreadResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void TestDevice::Interface::ScheduleWorkDifferentThreadCompleterBase::ReplySuccess(::fidl::BytePart _buffer) {
  TestDevice_ScheduleWorkDifferentThread_Response response;

  Reply(std::move(_buffer), TestDevice_ScheduleWorkDifferentThread_Result::WithResponse(&response));
}

void TestDevice::Interface::ScheduleWorkDifferentThreadCompleterBase::Reply(::fidl::DecodedMessage<ScheduleWorkDifferentThreadResponse> params) {
  TestDevice::SetTransactionHeaderFor::ScheduleWorkDifferentThreadResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void TestDevice::Interface::GetDoneEventCompleterBase::Reply(::llcpp::fuchsia::device::schedule::work::test::TestDevice_GetDoneEvent_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetDoneEventResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  GetDoneEventResponse _response = {};
  TestDevice::SetTransactionHeaderFor::GetDoneEventResponse(
      ::fidl::DecodedMessage<GetDoneEventResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetDoneEventResponse::PrimarySize,
              GetDoneEventResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void TestDevice::Interface::GetDoneEventCompleterBase::ReplySuccess(::zx::event event) {
  TestDevice_GetDoneEvent_Response response;
  response.event = std::move(event);

  Reply(TestDevice_GetDoneEvent_Result::WithResponse(&response));
}
void TestDevice::Interface::GetDoneEventCompleterBase::ReplyError(int32_t error) {
  Reply(TestDevice_GetDoneEvent_Result::WithErr(&error));
}

void TestDevice::Interface::GetDoneEventCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::device::schedule::work::test::TestDevice_GetDoneEvent_Result result) {
  if (_buffer.capacity() < GetDoneEventResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetDoneEventResponse _response = {};
  TestDevice::SetTransactionHeaderFor::GetDoneEventResponse(
      ::fidl::DecodedMessage<GetDoneEventResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetDoneEventResponse::PrimarySize,
              GetDoneEventResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void TestDevice::Interface::GetDoneEventCompleterBase::ReplySuccess(::fidl::BytePart _buffer, ::zx::event event) {
  TestDevice_GetDoneEvent_Response response;
  response.event = std::move(event);

  Reply(std::move(_buffer), TestDevice_GetDoneEvent_Result::WithResponse(&response));
}

void TestDevice::Interface::GetDoneEventCompleterBase::Reply(::fidl::DecodedMessage<GetDoneEventResponse> params) {
  TestDevice::SetTransactionHeaderFor::GetDoneEventResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void TestDevice::Interface::ScheduledWorkRanCompleterBase::Reply(uint32_t work_items_run, ::llcpp::fuchsia::device::schedule::work::test::LatencyHistogram histogram) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ScheduledWorkRanResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<ScheduledWorkRanResponse*>(_write_bytes);
  TestDevice::SetTransactionHeaderFor::ScheduledWorkRanResponse(
      ::fidl::DecodedMessage<ScheduledWorkRanResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ScheduledWorkRanResponse::PrimarySize,
              ScheduledWorkRanResponse::PrimarySize)));
  _response.work_items_run = std::move(work_items_run);
  _response.histogram = std::move(histogram);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(ScheduledWorkRanResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ScheduledWorkRanResponse>(std::move(_response_bytes)));
}

void TestDevice::Interface::ScheduledWorkRanCompleterBase::Reply(::fidl::BytePart _buffer, uint32_t work_items_run, ::llcpp::fuchsia::device::schedule::work::test::LatencyHistogram histogram) {
  if (_buffer.capacity() < ScheduledWorkRanResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<ScheduledWorkRanResponse*>(_buffer.data());
  TestDevice::SetTransactionHeaderFor::ScheduledWorkRanResponse(
      ::fidl::DecodedMessage<ScheduledWorkRanResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ScheduledWorkRanResponse::PrimarySize,
              ScheduledWorkRanResponse::PrimarySize)));
  _response.work_items_run = std::move(work_items_run);
  _response.histogram = std::move(histogram);
  _buffer.set_actual(sizeof(ScheduledWorkRanResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ScheduledWorkRanResponse>(std::move(_buffer)));
}

void TestDevice::Interface::ScheduledWorkRanCompleterBase::Reply(::fidl::DecodedMessage<ScheduledWorkRanResponse> params) {
  TestDevice::SetTransactionHeaderFor::ScheduledWorkRanResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void TestDevice::Interface::GetChannelCompleterBase::Reply(::llcpp::fuchsia::device::schedule::work::test::TestDevice_GetChannel_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetChannelResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  GetChannelResponse _response = {};
  TestDevice::SetTransactionHeaderFor::GetChannelResponse(
      ::fidl::DecodedMessage<GetChannelResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetChannelResponse::PrimarySize,
              GetChannelResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void TestDevice::Interface::GetChannelCompleterBase::ReplySuccess() {
  TestDevice_GetChannel_Response response;

  Reply(TestDevice_GetChannel_Result::WithResponse(&response));
}
void TestDevice::Interface::GetChannelCompleterBase::ReplyError(int32_t error) {
  Reply(TestDevice_GetChannel_Result::WithErr(&error));
}

void TestDevice::Interface::GetChannelCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::device::schedule::work::test::TestDevice_GetChannel_Result result) {
  if (_buffer.capacity() < GetChannelResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetChannelResponse _response = {};
  TestDevice::SetTransactionHeaderFor::GetChannelResponse(
      ::fidl::DecodedMessage<GetChannelResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetChannelResponse::PrimarySize,
              GetChannelResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void TestDevice::Interface::GetChannelCompleterBase::ReplySuccess(::fidl::BytePart _buffer) {
  TestDevice_GetChannel_Response response;

  Reply(std::move(_buffer), TestDevice_GetChannel_Result::WithResponse(&response));
}

void TestDevice::Interface::GetChannelCompleterBase::Reply(::fidl::DecodedMessage<GetChannelResponse> params) {
  TestDevice::SetTransactionHeaderFor::GetChannelResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void TestDevice::SetTransactionHeaderFor::ScheduleWorkRequest(const ::fidl::DecodedMessage<TestDevice::ScheduleWorkRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kTestDevice_ScheduleWork_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void TestDevice::SetTransactionHeaderFor::ScheduleWorkResponse(const ::fidl::DecodedMessage<TestDevice::ScheduleWorkResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kTestDevice_ScheduleWork_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void TestDevice::SetTransactionHeaderFor::ScheduleWorkDifferentThreadRequest(const ::fidl::DecodedMessage<TestDevice::ScheduleWorkDifferentThreadRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kTestDevice_ScheduleWorkDifferentThread_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void TestDevice::SetTransactionHeaderFor::ScheduleWorkDifferentThreadResponse(const ::fidl::DecodedMessage<TestDevice::ScheduleWorkDifferentThreadResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kTestDevice_ScheduleWorkDifferentThread_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void TestDevice::SetTransactionHeaderFor::GetDoneEventRequest(const ::fidl::DecodedMessage<TestDevice::GetDoneEventRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kTestDevice_GetDoneEvent_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void TestDevice::SetTransactionHeaderFor::GetDoneEventResponse(const ::fidl::DecodedMessage<TestDevice::GetDoneEventResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kTestDevice_GetDoneEvent_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void TestDevice::SetTransactionHeaderFor::ScheduledWorkRanRequest(const ::fidl::DecodedMessage<TestDevice::ScheduledWorkRanRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kTestDevice_ScheduledWorkRan_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void TestDevice::SetTransactionHeaderFor::ScheduledWorkRanResponse(const ::fidl::DecodedMessage<TestDevice::ScheduledWorkRanResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kTestDevice_ScheduledWorkRan_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void TestDevice::SetTransactionHeaderFor::GetChannelRequest(const ::fidl::DecodedMessage<TestDevice::GetChannelRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kTestDevice_GetChannel_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void TestDevice::SetTransactionHeaderFor::GetChannelResponse(const ::fidl::DecodedMessage<TestDevice::GetChannelResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kTestDevice_GetChannel_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void ::llcpp::fuchsia::device::schedule::work::test::OwnedChannelDevice_ScheduleWork_Result::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(OwnedChannelDevice_ScheduleWork_Result) == sizeof(fidl_xunion_t));
  static_assert(offsetof(OwnedChannelDevice_ScheduleWork_Result, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(OwnedChannelDevice_ScheduleWork_Result, envelope_) == offsetof(fidl_xunion_t, envelope));
}

namespace {

[[maybe_unused]]
constexpr uint64_t kOwnedChannelDevice_ScheduleWork_Ordinal = 0x45d160ce00000000lu;
[[maybe_unused]]
constexpr uint64_t kOwnedChannelDevice_ScheduleWork_GenOrdinal = 0x68e8de848728c3a4lu;
extern "C" const fidl_type_t v1_fuchsia_device_schedule_work_test_OwnedChannelDeviceScheduleWorkRequestTable;
extern "C" const fidl_type_t v1_fuchsia_device_schedule_work_test_OwnedChannelDeviceScheduleWorkResponseTable;

}  // namespace
template <>
OwnedChannelDevice::ResultOf::ScheduleWork_Impl<OwnedChannelDevice::ScheduleWorkResponse>::ScheduleWork_Impl(::zx::unowned_channel _client_end, uint32_t batch_size, uint32_t num_work_items) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ScheduleWorkRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ScheduleWorkRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ScheduleWorkRequest*>(_write_bytes);
  _request.batch_size = std::move(batch_size);
  _request.num_work_items = std::move(num_work_items);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ScheduleWorkRequest));
  ::fidl::DecodedMessage<ScheduleWorkRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      OwnedChannelDevice::InPlace::ScheduleWork(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

OwnedChannelDevice::ResultOf::ScheduleWork OwnedChannelDevice::SyncClient::ScheduleWork(uint32_t batch_size, uint32_t num_work_items) {
    return ResultOf::ScheduleWork(::zx::unowned_channel(this->channel_), std::move(batch_size), std::move(num_work_items));
}

OwnedChannelDevice::ResultOf::ScheduleWork OwnedChannelDevice::Call::ScheduleWork(::zx::unowned_channel _client_end, uint32_t batch_size, uint32_t num_work_items) {
  return ResultOf::ScheduleWork(std::move(_client_end), std::move(batch_size), std::move(num_work_items));
}

template <>
OwnedChannelDevice::UnownedResultOf::ScheduleWork_Impl<OwnedChannelDevice::ScheduleWorkResponse>::ScheduleWork_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t batch_size, uint32_t num_work_items, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < ScheduleWorkRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<ScheduleWorkResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, ScheduleWorkRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ScheduleWorkRequest*>(_request_buffer.data());
  _request.batch_size = std::move(batch_size);
  _request.num_work_items = std::move(num_work_items);
  _request_buffer.set_actual(sizeof(ScheduleWorkRequest));
  ::fidl::DecodedMessage<ScheduleWorkRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      OwnedChannelDevice::InPlace::ScheduleWork(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

OwnedChannelDevice::UnownedResultOf::ScheduleWork OwnedChannelDevice::SyncClient::ScheduleWork(::fidl::BytePart _request_buffer, uint32_t batch_size, uint32_t num_work_items, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ScheduleWork(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(batch_size), std::move(num_work_items), std::move(_response_buffer));
}

OwnedChannelDevice::UnownedResultOf::ScheduleWork OwnedChannelDevice::Call::ScheduleWork(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t batch_size, uint32_t num_work_items, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ScheduleWork(std::move(_client_end), std::move(_request_buffer), std::move(batch_size), std::move(num_work_items), std::move(_response_buffer));
}

::fidl::DecodeResult<OwnedChannelDevice::ScheduleWorkResponse> OwnedChannelDevice::InPlace::ScheduleWork(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ScheduleWorkRequest> params, ::fidl::BytePart response_buffer) {
  OwnedChannelDevice::SetTransactionHeaderFor::ScheduleWorkRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<OwnedChannelDevice::ScheduleWorkResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ScheduleWorkRequest, ScheduleWorkResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<OwnedChannelDevice::ScheduleWorkResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool OwnedChannelDevice::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kOwnedChannelDevice_ScheduleWork_Ordinal:
    case kOwnedChannelDevice_ScheduleWork_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ScheduleWorkRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->ScheduleWork(std::move(message->batch_size), std::move(message->num_work_items),
          Interface::ScheduleWorkCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool OwnedChannelDevice::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void OwnedChannelDevice::Interface::ScheduleWorkCompleterBase::Reply(::llcpp::fuchsia::device::schedule::work::test::OwnedChannelDevice_ScheduleWork_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ScheduleWorkResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  ScheduleWorkResponse _response = {};
  OwnedChannelDevice::SetTransactionHeaderFor::ScheduleWorkResponse(
      ::fidl::DecodedMessage<ScheduleWorkResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ScheduleWorkResponse::PrimarySize,
              ScheduleWorkResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void OwnedChannelDevice::Interface::ScheduleWorkCompleterBase::ReplySuccess(::llcpp::fuchsia::device::schedule::work::test::LatencyHistogram histogram) {
  OwnedChannelDevice_ScheduleWork_Response response;
  response.histogram = std::move(histogram);

  Reply(OwnedChannelDevice_ScheduleWork_Result::WithResponse(&response));
}
void OwnedChannelDevice::Interface::ScheduleWorkCompleterBase::ReplyError(int32_t error) {
  Reply(OwnedChannelDevice_ScheduleWork_Result::WithErr(&error));
}

void OwnedChannelDevice::Interface::ScheduleWorkCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::device::schedule::work::test::OwnedChannelDevice_ScheduleWork_Result result) {
  if (_buffer.capacity() < ScheduleWorkResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  ScheduleWorkResponse _response = {};
  OwnedChannelDevice::SetTransactionHeaderFor::ScheduleWorkResponse(
      ::fidl::DecodedMessage<ScheduleWorkResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ScheduleWorkResponse::PrimarySize,
              ScheduleWorkResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void OwnedChannelDevice::Interface::ScheduleWorkCompleterBase::ReplySuccess(::fidl::BytePart _buffer, ::llcpp::fuchsia::device::schedule::work::test::LatencyHistogram histogram) {
  OwnedChannelDevice_ScheduleWork_Response response;
  response.histogram = std::move(histogram);

  Reply(std::move(_buffer), OwnedChannelDevice_ScheduleWork_Result::WithResponse(&response));
}

void OwnedChannelDevice::Interface::ScheduleWorkCompleterBase::Reply(::fidl::DecodedMessage<ScheduleWorkResponse> params) {
  OwnedChannelDevice::SetTransactionHeaderFor::ScheduleWorkResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void OwnedChannelDevice::SetTransactionHeaderFor::ScheduleWorkRequest(const ::fidl::DecodedMessage<OwnedChannelDevice::ScheduleWorkRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kOwnedChannelDevice_ScheduleWork_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void OwnedChannelDevice::SetTransactionHeaderFor::ScheduleWorkResponse(const ::fidl::DecodedMessage<OwnedChannelDevice::ScheduleWorkResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kOwnedChannelDevice_ScheduleWork_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

}  // namespace test
}  // namespace work
}  // namespace schedule
}  // namespace device
}  // namespace fuchsia
}  // namespace llcpp

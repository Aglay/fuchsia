# Copyright 2019 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

##########################################
# Though under //zircon, this build file #
# is meant to be used in the Fuchsia GN  #
# build.                                 #
# See fxb/36548.                         #
##########################################

assert(!defined(zx) || zx != "/",
       "This file can only be used in the Fuchsia GN build.")

import("//build/unification/zbi/resource.gni")
import("//build/unification/zx_library.gni")

# TODO(38226): This is a kludge to make fuzzer.foosan builds actually just use
# the plain foosan build of libfdio.  This works around the problem that
# libfuzzer itself calls into libfdio and so its own calls pollute the data
# it's collecting about the code under test.  By redirecting from the fuzzer
# environment to the base environment (i.e. "user.fuzzer" -> "user"), we get
# the build that has the same foosan instrumentation to catch bugs but doesn't
# have the fuzzer (i.e. coverage tracking) instrumentation that influences
# libfuzzer's choices.
fuzzer_configs = [ "//build/config/sanitizers:fuzzer" ]
if (toolchain_variant.configs + fuzzer_configs - fuzzer_configs !=
    toolchain_variant.configs) {
  group("fdio") {
    public_deps = [ ":fdio(${toolchain_variant.base})" ]

    deps = [ ":fuzzer-redirect-manifest(${toolchain_variant.base})" ]
  }
} else if (is_fuchsia) {
  zx_library("fdio") {
    sdk = "shared"
    sdk_publishable = true
    sdk_headers = [
      "lib/fdio/directory.h",
      "lib/fdio/fd.h",
      "lib/fdio/fdio.h",
      "lib/fdio/io.h",
      "lib/fdio/limits.h",
      "lib/fdio/namespace.h",
      "lib/fdio/private.h",
      "lib/fdio/spawn.h",
      "lib/fdio/unsafe.h",
      "lib/fdio/vfs.h",
      "lib/fdio/watcher.h",
    ]
    shared = true
    sources = [
      "bsdsocket.cc",
      "event.cc",
      "fd.cc",
      "fdio.cc",
      "get-vmo.cc",
      "iovec.cc",
      "namespace/local-connection.cc",
      "namespace/local-filesystem.cc",
      "namespace/local-vnode.cc",
      "namespace/namespace.cc",
      "null.cc",
      "remoteio.cc",
      "socket.cc",
      "spawn.cc",
      "stubs.cc",
      "timer.cc",
      "uname.cc",
      "unistd.cc",
      "waitable.cc",
      "watcher.cc",
      "zxio.cc",
    ]
    deps = [
      "//sdk/fidl/fuchsia.net:fuchsia.net_llcpp",
      "//sdk/fidl/fuchsia.posix.socket:fuchsia.posix.socket_llcpp",
      "//sdk/fidl/fuchsia.process:fuchsia.process_c",
      "//zircon/public/lib/fbl",
      "//zircon/public/lib/fidl",
      "//zircon/public/lib/safemath",
      "//zircon/public/lib/zircon-internal",
      "//zircon/public/lib/zx",
      "//zircon/system/fidl/fuchsia-device:llcpp",
      "//zircon/system/fidl/fuchsia-io:llcpp",
      "//zircon/system/fidl/fuchsia-io2:llcpp",
      "//zircon/system/ulib/zxio",
    ]
    public_configs = [ "//build/config:Wno-unused-function" ]
  }

  # TODO(38226): Binaries built in the fuzzer environment look for libraries
  # in that environment.variant's libprefix.  But the redirect above sent it
  # to the base environment (with the same variant), which has a different
  # libprefix.  So add metadata that places the runtime shlib binary
  # underneath the fuzzer libprefix so it will be found where it's expected.
  # Note that the manifest will also mention the base environment variant
  # location for the same library, which is superfluous but harmless.
  resource("fuzzer-redirect-manifest") {
    visibility = [ ":*" ]
    sources = [ "$root_out_dir/libfdio.so" ]
    outputs = [ "lib/fuzzer.${toolchain_variant.name}/{{source_file_part}}" ]
  }
} else {
  config("fdio_includes") {
    include_dirs = [ "include" ]
  }

  source_set("fdio") {
    public_configs = [ ":fdio_includes" ]
  }
}

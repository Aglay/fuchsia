# Copyright 2019 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# IMPORTANT: This file serves to build the Fuchsia platform sysroot, used
# at build time to provide the C library, the Zircon VDSO, and a few linker
# stubs for legacy link targets like libm.so. Plus all associated headers.

sysroot_toolchain = "//build/zircon:sysroot_toolchain"
sysroot_dir = get_label_info(":sysroot($sysroot_toolchain)", "root_out_dir")
sysroot_dir += "/sysroot"

if (current_toolchain != sysroot_toolchain) {
  # Depend on this to only require the Zircon headers, but not link to the
  # C library or Zircon VDSO.
  group("headers") {
    public_deps = [ ":$target_name($sysroot_toolchain)" ]
  }

  # Any regular Fuchsia binary should depend on this target to ensure the
  # sysroot is properly setup, i.e. all headers are present and the C library,
  # VDSO library and stub libraries are built.
  group("cpp_binary_deps") {
    # This public_deps list will ensure the sysroot is populated with
    # the system headers, and linker stubs. However, we need to depend
    # on the real libraries to collect the right metadata as well.
    public_deps = [ ":$target_name($sysroot_toolchain)" ]

    # The following deps entries ensure that the right variant of the
    # C library and VDSO are linked to the current linkable binary.
    deps = [
      "//zircon/system/ulib/c",
      "//zircon/system/ulib/zircon",
    ]
  }

  # An additional dependency for executable() Fuchsia user binaries. It adds
  # the C runtime startup object code.
  group("crt1_deps") {
    public_deps = [ ":$target_name($sysroot_toolchain)" ]
  }

  # Rust binaries should depend on this target only.
  group("rust_binary_deps") {
    public_deps = [ ":$target_name($sysroot_toolchain)" ]
  }

  # Go binaries should depend on this targe tonly.
  group("go_binary_deps") {
    public_deps = [ ":$target_name($sysroot_toolchain)" ]
  }

  # A special dependency that ensure that the uninstrumented C library is
  # available in the system package as /lib/ld.so.1. For more details read
  # //zircon/system/ulib/c/libc_toolchain.gni
  #
  # In practice, should only be used by the package() template, and some
  # prebuilt driver binaries.
  group("system_libc_deps") {
    public_deps = [ ":$target_name($sysroot_toolchain)" ]
  }
} else {
  import("//build/config/fuchsia/zircon.gni")

  import("//zircon/system/ulib/c/sysroot_entries.gni")
  import("//zircon/system/ulib/zircon/sysroot_entries.gni")
  sysroot_entries =
      sysroot_uninstrumented_libc_entries + sysroot_instrumented_libc_entries +
      sysroot_crt1_entries + sysroot_vdso_entries

  sysroot_dir = get_label_info(":sysroot($sysroot_toolchain)", "root_out_dir")
  sysroot_dir += "/sysroot"

  # For historical reasons, only the scopes with an `sdk` key are considered
  # here. Each value associated with an `sdk` key is a scope itself, with the
  # following schema:
  #
  # If `include_dir` is present then:
  #
  #   include_dir (optional)
  #     [GN path] A GN path to a subdirectory containing zero or more headers
  #     to copy to the sysroot's include directory.
  #
  #   headers (optional)
  #     [list of paths] Required if `include_dir` is specified, ignored otherwise.
  #     A list of header sub-paths, relative to `include_dir`, that must be
  #     copied to the sysroot directory.
  #
  #   no_export (optional)
  #     [boolean] Ignored if `include_dir` is not used. A flag that is set to
  #     indicate that the set of headers described in the current entry should
  #     not be exported to the SDK sysroot (though they will still be copied
  #     to the platform's sysroot). This is useful for <zircon/device/*.h>
  #     headers, as well as `testonly-cdecls.inc`.
  #
  # Otherwise, if `include_dir` is _not_ present:
  #
  #   source (optional)
  #     [path] A path, relative to the current root build directory, where
  #     to find the source file to be copied into the sysroot, where destination
  #     is specified by one of the ` link`, `debug` or `dist` keys described
  #     below. Ignored if `include_dir` is present.
  #
  #   debug (optional)
  #   dist (optional)
  #   link (optional)
  #     [path] A path relative to the sysroot directory, that specifies where
  #     the `source` file needs to be copied into the SDK. Only one of these
  #     keys can be used per entry. For the platform SDK, onle `dist` and `link`
  #     are used. The SDK sysroot will use all three though.
  #
  #   deps (optional)
  #     [list of labels] A list of labels to dependencies for this entry,
  #     this should correspond to the GN target that built the `source`
  #     file, once the sysroot generation is moved to the Fuchsia build.
  #
  # IMPORTANT: The populate_sysroot_headers.py script in this directory relies
  # on this exact schema definition. Keep it in sync if the schema changes!
  #
  sysroot_headers = []
  sysroot_headers_deps = []
  foreach(entry, sysroot_entries) {
    if (defined(entry.sdk)) {
      sdk = {
      }
      sdk = entry.sdk
      if (defined(sdk.headers)) {
        # This has to generate a separate copy() target for each file.
        dir = rebase_path(sdk.include_dir, "", root_build_dir)
        foreach(file, sdk.headers) {
          sysroot_headers += [ "$sysroot_dir/include/$file" ]
          if (defined(sdk.deps)) {
            # Some dependencies are necessary for auto-generated headers.
            # NOTE: This branch will never be taken when parsing zircon_legacy_sysroot
            # but it will be once we switch to parsing the sysroot_entries directly.
            # For now, hack the missing dependency in sysroot_headers below.
            sysroot_headers_deps += sdk.deps
          }
        }
      }
    }
  }

  # Write sysroot_entries to a JSON file that will get parsed
  # by our populate_sysroot_headers.py script below.
  sysroot_entries_json_file = "$root_out_dir/sysroot-entries.json"

  generated_file("sysroot-entries-json") {
    visibility = [ ":*" ]
    contents = sysroot_entries
    outputs = [ sysroot_entries_json_file ]
    output_conversion = "json"
  }

  action("headers") {
    inputs = [ sysroot_entries_json_file ]
    outputs = sysroot_headers
    depfile = "$root_out_dir/sysroot_headers.d"
    script = "populate_sysroot_headers.py"
    args = [
      "--src-dir",
      rebase_path("//", root_build_dir),
      "--sysroot-json",
      rebase_path(inputs[0], root_build_dir),
      "--sysroot-dir",
      rebase_path(sysroot_dir, root_build_dir),
      "--dep-file",
      rebase_path(depfile, root_build_dir),

      # The --debug flag can be used to print the script's operations for debugging.
      #"--debug",
    ]
    deps = [ ":sysroot-entries-json" ] + sysroot_headers_deps

    # NOTE: This extra dependency is because the zircon_legacy_entries don't have
    # the right dependencies on the Fuchsia build target that generates some
    # Zircon headers. This can go away once we switch to parsing the sysroot_entries
    # directly. See the comment about sdk.deps for headers above too.
    deps += [ "//zircon/vdso:public($default_toolchain)" ]

    visibility = [ ":*" ]
  }

  # Copy the unstripped C library to the sysroot as libc.so, as this will be used
  # for Rust and Go binaries.
  copy("sysroot_libc") {
    outputs = [ "$sysroot_dir/lib/libc.so" ]
    sources = [ rebase_path(system_libc_unstripped, ".", root_build_dir) ]
    deps = [ system_libc_target ]
  }

  # Copy the unstripped Zircon library to the sysroot, this is used to support
  # '-lzircon' that might still appear in build commands in certain build
  # configurations.
  copy("sysroot_libzircon") {
    outputs = [ "$sysroot_dir/lib/libzircon.so" ]
    sources = [ sysroot_vdso_unstripped ]
    deps = [ sysroot_vdso_target ]
  }

  # Copy the C runtime startup object to the sysroot.
  copy("sysroot_crt1") {
    outputs = [ "$sysroot_dir/lib/Scrt1.o" ]
    sources = [ sysroot_crt1_obj ]
    deps = [ sysroot_crt1_target ]
  }

  # When generating the build commands to link Rust binaries, GN will actually
  # create build commands that include '-lc.so' and '-lzircon.so' to the final
  # linker (instead of '-lc' and '-lzircon'.
  #
  # That's because GN will list of library dependencies, and convert each one
  # of them into an '-l<something>' argument by removing the "lib" prefix and
  # the file's extension.
  #
  # In the case of the C library and the VDSO, dependencies will point to
  # 'libc.so.debug' and 'libzircon.so.debug', the unstripped versions, so
  # the '.debug' extension is removed, but the '.so' suffix remains.
  #
  # A simple way to work-around the issue is to provide linker stub named
  # 'libc.so.so' and 'libzircon.so.so' that redirect to the real library.
  generated_file("sysroot_libc_rust") {
    outputs = [ "$sysroot_dir/lib/libc.so.so" ]
    contents = [ "INPUT(libc.so)" ]
  }

  generated_file("sysroot_libzircon_rust") {
    outputs = [ "$sysroot_dir/lib/libzircon.so.so" ]
    contents = [ "INPUT(libzircon.so)" ]
  }

  sysroot_binary_deps = [
    ":sysroot_libc",
    ":sysroot_libc_rust",
    ":sysroot_libzircon",
    ":sysroot_libzircon_rust",
  ]

  # Generate empty linker stubs for legacy system libraries, whose API
  # is fully implemented by the C library.
  sysroot_binary_stub_deps = []

  foreach(stub,
          [
            "libdl",
            "libm",
            "libpthread",
            "librt",
          ]) {
    generated_file("sysroot_$stub") {
      outputs = [ "$sysroot_dir/lib/$stub.so" ]
      contents = [ "/* DUMMY */" ]
    }
    sysroot_binary_stub_deps += [ ":sysroot_$stub" ]
  }

  sysroot_binary_deps += sysroot_binary_stub_deps

  group("cpp_binary_deps") {
    deps = sysroot_binary_deps + [ ":headers" ]
  }

  group("crt1_deps") {
    # This ensures that the C runtime startup object is built and copied to
    # the sysroot, but not added as a link-time dependency. This is necessary
    # because the compiler will implicitly inject the sysroot's Scrt1.o into the
    # final link command anyway.
    deps = [ ":sysroot_crt1" ]
  }

  group("rust_binary_deps") {
    deps = sysroot_binary_deps + [ ":headers" ]
  }

  group("go_binary_deps") {
    deps = sysroot_binary_deps + [ ":headers" ]
  }

  group("system_libc_deps") {
    data_deps = [ system_libc_target ]
  }
}

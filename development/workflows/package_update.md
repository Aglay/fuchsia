# Developing with Fuchsia packages

Almost everything that exists on a Fuchsia system is a [Fuchsia package][pkg-struct].
Even the contents of /system are backed by a Fuchsia package. Whether it is
immediately apparent or not almost everything you see on Fuchsia lives in a
package. This document will cover the basics of a package-driven workflow where
you [build][pkg-doc] a package and push it to a Fuchsia device which is reachable
via IP from your development host.

## Pre-requisites and overview

The host and target must be able to communicate over IP. In particular
it must be possible to SSH from the development host to the target device. The
SSH connection is used to set up a reverse tunnel from the target to the
development host which is used to move bits.

The development host will run a simple, static file, HTTP server which makes the
updates available to the target. This HTTP server is part of the Fuchsia source
code and built automatically.

The target is instructed to look for changes on the development host via a
couple of commands that are run manually. When the update system on the target
sees these changes it will fetch the new software from the HTTP server running
on the host. The new software will be available until the target is rebooted.

## Building

> TODO(jmatt): improve to talk about wider variety of build options

To build a package containing the required code, a package type build rule is
used. If one of these needs to be created for the target package, consult the
reference [page][pkg-doc] for this. Some build rule types are actually
extensions of the package rule type, for example [`flutter_app`][flutter-gni]
extends the package type. The rule must also not set `system_image` to true,
things in the system image can only be updated by [paving][paver].

Once an appropriate build rule is available the target package can be
re-generated by running `fx full-build` or `fx build <target_name>`.

## Connecting host and target

The Fuchsia source contains a simple HTTP server which serves static files. The
build generates a [TUF][TUF-home] file tree which is served.

The update agent on the target defaults to using a local port on the target. To
connect the agent on the target to the HTTP server running on the development
host we can establish a reverse SSH tunnel. The host HTTP server is started and
reverse SSH tunnel created by calling `fx serve-updates`.

The reverse SSH tunnel will remain until sshd running on the target is
restarted, this will happen if you *reboot* the device *or* *restart* *`sysmgr`*.
The HTTP server on the host will remain running until explicitly killed.
`fx serve-updates` can be run again to reconnect the tunnel or restart the HTTP
server. Note that an error will be reported if a second instance of the HTTP
server is started, *this* *is* *okay*. The second instance will exit and the
first will continue to serve the update tree.

## Triggering package updates

In the future certain updates may happen automatically, but today the update
agent on the target must be told to look for an update. To accomplish this a SSH
connection is made from the host to the target and a command is run to tell the
update agent to look for a new package. To trigger the update invoke
`fx push-package <package_name>`. The &lt;package_name&gt; argument can be
repeated to push multiple packages. The &lt;package_name&gt; argument can also
be omitted to cause *all* packages to be pushed. It is worth noting that pushing
all packages can take a considerable amount of time because of the
implementation of the host-side tool.

The update package(s) will be available until the target is rebooted. Following
a reboot the package data will still be on local storage, but will be
inaccessible. This is a limitation of the current implementation which will
improve over time.

## Just the commands

  * `fx full-build` or `fx build <target_name>`
  * `fx serve-updates` (messages about a port in use are okay)
  * `fx push-package <package_name>`
  * `fx shell "killall sysmgr"` (optional, depending on your component)

## Issues and considerations

### You can fill up your disk

Every update pushed is stored in the content-addressed file system, blobfs.
Following a reboot the updated packages may not be available because the index
that locates them in blobfs is only held in RAM. The system currently does not
garbage collect inaccessible or no-longer-used packages (having garbage to
collect is a recent innovation!), but will eventually. Until then, the easiest
solution is to re-pave the device, which will clear out blobfs.

### Restarting without rebooting

If the package being updated hosts a service managed by Fuchsia that service
may need to be restarted. Rebooting is undesirable both because it is slow and
because the package will revert to the version paved on the device. In this
case 'fuchsia' can be restarted. More accurately, `sysmgr` can be restarted.
`sysmgr` can be restarted by running `fx shell "killall sysmgr"`.

### Updating things in the system package

If a package is part of the system image (because its package rule sets
`system_image = "true"`) then it can not be updated with the package update flow.
It is a goal of the update flow to include updating the system package, but even
when this is supported the target will probably need a reboot.

The system package is intended for a few key pieces of code and data that are
involved in booting the system. There are very few reasons that code should need
to live in the system package. Being a driver, for example, is not a reason
something should live in the system package. If there is an architectural reason
for something to be in the system package it is likely that either the
architecture is expected to change or a redesign should be considered to remove
the system package constraint.

### Packaging code outside the Fuchsia tree

Packaging and pushing code that lives outside the Fuchsia tree is possible, but
will require more work. The Fuchsia package format is quite simple. It consists
of a metdata file describing the package contents which is described in more
detail in the [Fuchsia package][pkg-struct] docuentation. The metadata file is
added to a TUF file tree and each of the contents are named after their Merkle
root hash and put in a directory at the root of the TUF file tree called 'blobs'.

[pkg-struct]: https://fuchsia.googlesource.com/garnet/+/master/go/src/pm/README.md#structure-of-a-fuchsia-package "Package structure"
[TUF-home]: https://theupdateframework.github.io "TUF Homepage"
[pkg-doc]: https://fuchsia.googlesource.com/docs/+/master/build_packages.md "Packaging docs"
[flutter-gni]: https://fuchsia.googlesource.com/topaz/+/master/runtime/flutter_runner/flutter_app.gni "Flutter GN build template"
[paver]: https://fuchsia.googlesource.com/docs/+/master/fuchsia_paver.md "Fuchsia paver"

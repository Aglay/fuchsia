# FIDL tutorial

***WARNING: work in progress. Some content is out of date or entirely broken.***

TODO(FIDL-61):

* Update for FIDL 2.
* Update to reflect Application->Component rename.
* Run through and validate.

_Audience: Beginning FIDL developers._

_Prerequisites: At least intermediate skills in C++ or Dart._

_Maintained by: jimbe@google.com, shayba@google.com_

[TOC]

## About this tutorial

This tutorial is based on the libraries that are part of the [GoogleSource FIDL repo](https://fuchsia.googlesource.com/fidl/). The FIDL (Fuchsia Interface Definition Language) libraries in that repo that you link with your application are called the FIDL bindings in [Fuchsia](https://fuchsia.googlesource.com/fuchsia/). You'll see classes like "ApplicationRunner" that are part of this C++ library. These libraries are implemented in different ways for different languages.

You can write a C++ application for FIDL without using the FIDL Client, or you could selectively replace parts of the Client. In any case, the interface binding code from the FIDL compiler can handle communication over channels. Replacing all or part of the Client may be a useful strategy if you have a large existing base of code that you wish to run as a FIDL application.

This tutorial depends on Fuchsia. There is no prebuilt binary in the git repo.

## Getting and building the FIDL source code

See the instructions on the web site for getting and building Fuchsia:
[https://fuchsia.googlesource.com/fuchsia/](https://fuchsia.googlesource.com/fuchsia/)

The FIDL source code is located inside of Garnet at: [https://fuchsia.googlesource.com/garnet/+/master/public/lib/fidl/](https://fuchsia.googlesource.com/garnet/+/master/public/lib/fidl/)

The examples we will use for this tutorial are located inside of Garnet at: [https://fuchsia.googlesource.com/garnet/+/master/examples/fidl/](https://fuchsia.googlesource.com/garnet/+/master/examples/fidl/)

## FIDL architecture

FIDL is organized like so:

A FIDL **Application** is software that's designed to work with FIDL interfaces. The primary thread in a FIDL application usually has a run loop to dispatch calls and may have additional threads with run loops.

An application is called through its **Interface(s)**. Interfaces are reusable and can be vended by multiple applications. An interface is defined with the Fuchsia Interface Definition Language (IDL). The classes that bind an interface to a language are generated by the FIDL compiler.

An application almost always implements the **ServiceProvider** interface, which returns interfaces based on the name of the service. The FIDL client library provides default implementations of ServiceProvider for all supported languages.

A **Service** is your implementation of an interface. Therefore, within a particular FIDL application, there is one service per interface. In the FIDL client library, you will see calls like `AddPublicService()` or `ConnectToService()`.

![FIDL Architecture](fidl_architecture.png)

The **Shell** is the interface to a particular FIDL service that knows how to load applications, cache them, and connect them together. You use the Shell interface when you want to connect to another service.

A **[Channel](https://fuchsia.googlesource.com/zircon/+/master/docs/objects/channel.md)** is an [operating system construct for IPC (InterProcess Communication)](https://fuchsia.googlesource.com/zircon/+/master/docs/concepts.md#message-passing_sockets-and-channels), although it works equally well between processes, threads, or even within a thread. FIDL uses channels to communicate between applications.

A **Connection** is the request sent to a FIDL application to return its **ServiceProvider** interface to another application. Requests for subsequent interfaces are _not_ connections. A connection refers to the construction of the initial channel between two applications.

The word **Client** is used in this document to refer to a FIDL application that connects to a **Server** application. The difference between client and server is an artificial distinction for this tutorial. A FIDL application you write can be a client, a server, or both, or many.

## Hello World "Echo" interface

We'll start with a C++ echo service that echoes its input and prints "hello world".

Open [garnet/examples/fidl/services/echo2.fidl](https://fuchsia.googlesource.com/garnet/+/master/examples/fidl/services/echo2.fidl). A .fidl file defines the interfaces and related data structures that a FIDL applications vends (makes available to other FIDL applications). An interface can be used in any language supported by FIDL, which allows you to easily make calls across languages.

The example file `echo2.fidl`, with line numbers added, looks like this:

```
1. library echo2;

2. [Discoverable]
3. interface Echo {
4.   1: EchoString(string? value) -> (string? response);
5. };
```

Let's go through it line by line.

**Line 1:** The library definition is used to define the namespace. FIDL interfaces in different libraries can have the same name. The Java class path is defined separately.

**Line 2:** The `Discoverable` attribute provides a name that can be used to discover the service.

**Line 3:** The name of the interface.

**Line 4:** The function name. There are three unusual aspects of this line:

* Note the `1:` before the function name. This is a **sequence number**, and is used to ensure backwards compatibility when there are multiple versions of the same interface. All functions must have a unique sequence number.
* Note the `string?` declarations with a question mark. The question mark means that these parameters may be null.
* The return type comes after the function declaration, not before. Unlike C++ or Java, a function can return multiple values.

### Generated files

When you [build the tree](#getting-and-building-the-fidl-source-code), the FIDL compiler is run automatically. It writes the glue code that allows the interfaces to be used from different languages. Below are the implementation files created for C++, assuming that your build flavor is `debug-x64`.

```
./out/debug-x64/fidling/gen/garnet/examples/fidl2/services/echo2.fidl.cc
./out/debug-x64/fidling/gen/garnet/examples/fidl2/services/echo2.fidl.cc.h
./out/debug-x64/fidling/gen/garnet/examples/fidl2/services/echo2.fidl.rs
```

## Echo server in C++

Let's take a look at the server implementation in C++:

[garnet/examples/fidl/echo2_server_cpp/echo2_server.cc](https://fuchsia.googlesource.com/garnet/+/master/examples/fidl/echo2_server_cpp/echo2_server.cc)

This file implements the main function, and an implementation of the Echo interface.

To understand how the code works, here's a summary of what happens in the server to execute an IPC call.

1. Fuchsia loads the server executable, and your `main()` function starts.
1. `main` creates an `EchoServerApp` object which will bind to the service interface when it is constructed.
1. `EchoServerApp()` registers itself with the `ApplicationContext` by calling `context->outgoing().AddPublicService<Echo>()`. It passes a lambda function that is called when a connection request arrives.
1. Now `main` starts the run loop, expressed as an `async::Loop`.
1. The run loop receives a request to connect from another application, so calls the lambda created in `EchoServerApp()`.
1. That lambda binds the `EchoServerApp` instance to the request channel.
1. The run loop receives a call to `EchoString()` from the channel and dispatches it to the object bound in the last step.
1. `EchoString()` issues an async call back to the client using `callback(value)`, then returns to the run loop.

Let's go through the details of how this works.

### File headers

First the namespace definition. This matches the namespace defined in the FIDL file in its "library" declaration, but that's incidental:

```cpp
namespace echo2 {
```

Here are the #include files used in the server implementation:

```cpp
#include <fuchsia/cpp/echo2.h>
#include <lib/async-loop/cpp/loop.h>
#include <lib/zx/channel.h>

#include "lib/app/cpp/application_context.h"
```

- `echo2.h` contains the generated C++ definition of our Echo FIDL interface.
- `application_context.h` is used by `EchoServerApp` to expose service implementations.

### main

Most `main()` functions for FIDL applications look very similar. They create a run loop using `async::Loop` or some other construct, and bind service implementations. The `Loop.Run()` function enters the message loop to process requests that arrive over channels.

Eventually, another FIDL application will attempt to connect to our application.

### The `EchoServerApp()` constructor

Before going further, a quick review from the [FIDL Architecture](#fidl-architecture) section. A connection is defined as the _first_ channel with another application. Strictly speaking, the connection is complete when both applications have bound their ServiceProvider to that first channel. Any additional channels are not "connections". Therefore, service registration is performed before the run loop begins and before the first connection is made.

Here's what the `EchoServerApp` constructor looks like:

```cpp
EchoServerApp()
    : context_(component::ApplicationContext::CreateFromStartupInfo()) {
  context_->outgoing().AddPublicService<Echo>(
      [this](fidl::InterfaceRequest<Echo> request) {
        bindings_.AddBinding(this, std::move(request));
      });
```

The function calls `AddPublicService` once for each service it makes available to the other application (remember that each service exposes a single interface). The information is cached by `ApplicationContext` and used to decide which `InterfaceFactory<>` to use for additional incoming channels. A new channel is created every time someone calls `ConnectToService()` on the other end.

If you read the code carefully, you'll see that the parameter to `AddPublicService` is actually a lambda function that captures `this`. This means that the lambda function won't be executed until a channel tries to bind to the interface, at which point the object is bound to the channel and will receive calls from other applications. Note that these calls have thread-affinity, so calls will only be made from the same thread.

The function passed to `AddPublicService` can be implemented in different ways. The default implementation `EchoServerApp` uses the same object for all channels. That's a good choice for the Echo interface because the implementation is stateless. Other, more complex interfaces could create a different object for each channel or perhaps re-use the objects in some sort of a caching scheme.

Connections are always point to point. There are no multicast connections.

### The EchoString function

Finally we reach the end of our server discussion. When the message loop receives a message in the channel to call the `EchoString()` function in the Echo interface, it will be directed to the implementation below:

```cpp
void EchoString(fidl::StringPtr value, EchoStringCallback callback) override {
  printf("EchoString: %s\n", value->data());
  callback(std::move(value));
}
```

Here's what's interesting about this code:

- The first parameter to `EchoString()` is a `fidl::StringPtr`. As the name suggests, a `fidl::StringPtr` can be null.  Strings in FIDL are supposed to be UTF-8, but this is not enforced by the FIDL Client Library.
- The `EchoString()` function returns void because FIDL calls are asynchronous. Any value we might otherwise return wouldn't have anywhere to go.
- The last parameter to `EchoString()` is the client's callback function. In this case, the callback takes a `fidl::StringPtr`.
- `EchoServerApp::EchoString()` returns its response to the client by calling the callback. The callback invocation is also asynchronous, so the call often returns before the callback is run in the client.
- Because the callback is async, the callback also return void.

Any call to an interface in FIDL is asynchronous. This is a big shift if you are used to a procedural world where function calls return after the work is complete. Because it's async, there's no guarantee that the call will ever actually happen, so your callback may never be called. The remote FIDL application might close, crash, be busy, or many other problems beyond your control.

## Echo client in C++

The structure of the client is the same as the server, with a `main` function and an `async::Loop`. The difference is that the client immediately kicks off work once everything is initialized. In contrast, the server does no work until a connection is accepted.

**Note:** an application can be a client, a server, or both, or many. The distinction in this example between Client and Server is purely for demonstration purposes.

Here is the summary of how the client makes a connection to the echo service.

1. The shell loads the client executable and calls `main`.
1. `main()` creates an `EchoClientApp` object to handle connecting to the server, calls `Start()` to initiate the connection, and then starts the message loop.
1. In `Start()`, the client calls `context_->launcher()->CreateApplication` with the url to the server application. If the server application is not already running, it will be created at this point.
1. Next, the client calls `ConnectToService()` to open a channel to the server application.
1. The interface pointer passed to `ConnectToService()` is filled in with the service implementation.
1. `main` calls into `echo_->EchoString(...)` and passes the callback. Because FIDL IPC calls are async, `EchoString()` will probably return before the server processes the call.
1. `main` then blocks on a response on the interface.
1. Eventually, the response arrives, and the callback is called with the result.
1. Blocking on a response returns, and the application exits.

### main

main() in the client is very different from the server, as it's synchronous on the server response.

```cpp
int main(int argc, const char** argv) {
  std::string server_url = "echo2_server_cpp";
  std::string msg = "hello world";
  for (int i = 1; i < argc - 1; ++i) {
    if (!strcmp("--server", argv[i])) {
      server_url = argv[++i];
    } else if (!strcmp("-m", argv[i])) {
      msg = argv[++i];
    }
  }
  async::Loop loop(&kAsyncLoopConfigMakeDefault);
  echo2::EchoClientApp app;
  app.Start(server_url, msg);
  app.echo()->EchoString(msg, [](fidl::StringPtr value) {
    printf("***** Response: %s\n", value->data());
  });
  return app.echo().WaitForResponse();
}
```

### Start

`Start()` is responsible for connecting to the remote Echo service.

```cpp
void Start(std::string server_url, std::string msg) {
  component::ApplicationLaunchInfo launch_info;
  launch_info.url = server_url;
  launch_info.directory_request = echo_provider_.NewRequest();
  context_->launcher()->CreateApplication(std::move(launch_info),
                                          controller_.NewRequest());
  echo_provider_.ConnectToService(echo_.NewRequest().TakeChannel(),
                                  Echo::Name_);
}
```

First, `Start()` calls `CreateApplication()` to load `echo_server`. Then, it calls `ConnectToService()` to bind to the server's Echo interface. The exact mechanism is somewhat hidden, but the particular interface is automatically inferred from the type of `EchoPtr`, which is a typedef for `fidl::InterfacePtr<Echo>`.

The second parameter to `ConnectToService()` is actually a URL. The protocol `"fidl"` is a shortcut to load the given shared library module from the same directory. Do not include the trailing `".fidl"` extension when using the `"FIDL"` protocol in the url passed to `ConnectToService()`. Protocols other than FIDL may be handled by a content handler, depending on the FIDL shebang declaration in the file.

Next the client calls `EchoString()` in the returned interface. FIDL interfaces are asynchronous, so the call itself does not wait for `EchoString()` to complete remotely before returning. `EchoString()` returns void because of the async behavior.

Since the client has nothing to do until the server response arrives, and is done working immediately after, `main()` then blocks using `WaitForResponse()`, then exits. When the response will arrive, then the callback given to `EchoString()`, will execute first, then `WaitForResponse()` will return, allowing `main()` to return and the program to terminate.

### Run the sample

You can run the Hello World example like this:

```
$ system/bin/echo_client_cpp
```

You do not need to specifically run the server because the call to `CreateApplication()` in the client will automatically demand-load the server.

## Echo server in Dart

**Status: Dart section needs to be updated for FIDL 2 (Last reviewed Jan 23, 2017)**

The echo server implementation in Dart can be found at:
[topaz/examples/fidl/echo_server_dart/lib/main.dart](https://fuchsia.googlesource.com/topaz/+/master/examples/fidl/echo_server_dart/lib/main.dart)

This file implements the `main()` function, the EchoApplication class, and the EchoImpl class:

- The `main()` function is executed when the application is loaded.
- The `EchoApplication` class registers the availability of the service with incoming connections from FIDL.
- `EchoImpl` processes requests on the `Echo` interface. A new object is created for each channel.

To understand how the code works, here's a summary of what happens in the server to execute an IPC call. We will dig into what each of these lines means, so it's not necessary to understand all of this before you move on.

1. **Startup.** The FIDL Shell loads the Dart "content handler", which starts the VM, loads `echo_server.mojo` and calls `main()`.
1. **Startup.** `main()` creates an `EchoApplication` object and returns. However, the application doesn't exit because the root base class of `EchoApplication` called `listen()` in the `fromHandle()` named constructor. This means that the Dart isolate will continue running listening for connections.
1. **Registration.** The mojo package receives a request to connect from an `echo_client` application, so calls `acceptConnection()` in `EchoApplication`.
1. **Registration.** `acceptConnection()` must tell the `ServiceProvider` what services/interfaces are supported, so calls `connection.provideService(Echo.serviceName, _createService)`. Note that `_createService` isn't actually called at this point. It's a factory function that is called as necessary by the mojo package to create `EchoImpl` objects to process IPC function calls.
1. **Service Request.** The mojo package receives a request to bind to a new channel, so calls the `_createService()` function passed in the previous step.
1. **Service Request.** `_createService()` constructs a new `EchoImpl` that's bound to the channel (endpoint).
1. **API Request.** The mojo package receives a call to `echoString()` from the channel and dispatches it to `echoString()` in the `EchoImpl` object created in the last step.
1. **API Request.** `echoString()` calls the given `respond()` function to return the response.

### Dart class diagram

![Dart class diagram](dart_class_diagram.png)

Now let's go through the details of how this works.

### File headers

Here are the import declarations in the Dart server implementation:

```dart
import 'package:fidl/fidl.dart';
import 'package:fuchsia.fidl.echo2/echo2.dart';
import 'package:lib.app.dart/app.dart';
```

- `dart:async` is required to define the Future class.
- `mojo/application.dart` defines the Application and ServiceProvider classes.
- `mojo/core.dart` defines the core FIDL functionality for Dart, such as `fidlHandle` and `fidlMessagePipeEndpoint`.
- `fidl/mojo/examples/echo.fidl.dart` is generated from the `echo.fidl` file. It defines the abstract interface, the proxy and the stub for the Echo interface.

### main()

Everything starts with main():

```dart
void main(List<String> args) {
  _context = new ApplicationContext.fromStartupInfo();
  _echo = new _EchoImpl();
  _context.outgoingServices.addServiceForName<Echo>(_echo.bind, 'echo2.Echo');
}
```

`main()` is called by the Dart VM when your service is loaded, similar to `main()` in a C or C++ application. `handleToken` is a handle that expects to be bound to a `fidlHandle` and passed to your application's [Application](https://github.com/domokit/mojo/blob/master/mojo/public/dart/mojo/lib/src/application.dart) implementation. After the `Application` object is constructed, `OnInitialize()` will be called on your `Application` subclass, just like C++.

Most FIDL Dart `main()` functions look very similar. They bind `handleToken` to a `fidlHandle`, create their `Application` object using the `fromHandle()` constructor, and return, which causes the system to start processing incoming connections.

Eventually, another FIDL application will attempt to connect to our application.

### The `acceptConnection` function

Before going further, a quick review from the [FIDL Architecture](#fidl-architecture) section. A connection is defined as the _first_ channel with another application. Strictly speaking, the connection is complete when both applications have bound their `ServiceProvider` to that first channel. Any additional channels are not "connections." The function names will make more sense if you keep this in mind.

Here's what it looks like:

```dart
void acceptConnection(String requestorUrl, String resolvedUrl,
        ApplicationConnection connection) {
    connection.provideService(Echo.serviceName, _createService);
}
```

The `acceptConnection` function is called when the first channel is received from another application. This function calls `provideService()` once for each service it makes available to the other application (remember that each service exposes a single interface). The information is cached by `ServiceProvider` and used to create objects to be the endpoints for additional incoming channels.

#### Tip for C++ developers

C++ developers new to Dart should note that the reference to `_createService` works differently than you might expect. It looks similar to a C++ pointer to member function, but it's not. It's actually a closure bound to the parent's `this` object, which is an `Echo2Application` object. In other words, it's really a shorthand for something like this:

```dart
connection.provideService(Echo.serviceName, (endpoint) {
    this._createService(endpoint));
}
```

---

Finally, unlike C++, Dart only has a single thread per VM, so there's no possible confusion over which thread owns a channel.

#### Advanced FAQ - is there really only one thread?

Both yes and no. There's only one thread in your application's VM, but the handle watcher Isolate (where the code calls `fidlWaitMany` has its own, separate thread so that application Isolates don't have to block. Application Isolates can also spawn new Isolates, which will run on different threads.

---

### Creating the service

Moving along, imagine that ServiceProvider responds to a request for a new channel. The channel needs to be bound to an object that implements the appropriate interface. That's the second parameter to the provideService() function. Here is how it's implemented in this example:

```dart
EchoImpl _createService(fidlMessagePipeEndpoint endpoint) {
  if (_closing) {
    endpoint.close();
    return null;
  }
  var echoService = new EchoImpl(this, endpoint);
  _echoServices.add(echoService);
  return echoService;
}
```

`_createService()` first makes sure that the service isn't in the middle of shutting down. This is necessary because the `_errorHandler()` function is async and uses `await`, which means that other requests can be received while `close()` is waiting. Checking the `_closing` variable prevents a race condition.

Otherwise, `_createService()` constructs a new `EchoImpl` object and passes the `endpoint`, which contains the handle to the channel. The `EchoImpl` object is now bound to the channel and will receive calls from the client application.

`_createService()` also adds the `EchoImpl` object to the `_echoServices` collection of known clients. This collection is used if there is an error in the service so that all client connections can be closed.

### Cleanup

In C++, a `mojo::Binding` object coordinates the work of taking requests from the channel and dispatching them to the bound Impl object. In Dart, the `EchoStub` class is responsible for this work (`EchoStub` inherits from `EchoInterface`, which inherits from `fidlInterface<Echo`>).

However, the bindings layer does not know how you are structuring the relationship between channels and Impl objects, so you need to implement the cleanup logic. Dart has no destructors, so the technique is different than the `mojo::StrongBinding` class found in the C++ library.

The `EchoImpl` constructor says:

```dart
_echo.ctrl.onError = _errorHandler;
```

This causes _errorHandler() to be called when there is an error on the channel. In particular, a channel being closed is considered an error, so when an errors happens, our implementation of _errorHandler calls _application.removeService(this) to remove this object from the collection of active service connections.

### The `echoString` function

Finally we reach the implementation of the server API. Your `EchoImpl` object receives a call to the `echoString()` function. It receives the arguments to the function, as well as a callback function to return the result parameters:

```dart
void echoString(String value, void callback(String response)) {
  print('EchoString: $value');
  callback(value);
}
```

## Echo client in Dart

The echo server implementation in Dart can be found at:
[https://github.com/domokit/mojo/blob/master/examples/dart/echo_client/lib/main.dart](https://github.com/domokit/mojo/blob/master/examples/dart/echo_client/lib/main.dart)

The structure of the client is the same as the server, with a `main()` function and a class derived from `Application`. The difference is that the client immediately kicks off work when FIDL calls the `initialize()` function in your `Application` object. In contrast, the server does no work until a connection is accepted.

***
**Note:** an application can be a client, a service, or both, or many. The distinction in this example between Client and Server is purely for demonstration purposes.
***

Here is the summary of how the client makes a connection to the echo service.

1. **Startup.** The FIDL Shell loads the Dart "content handler", which starts the Dart VM, loads `dart_echo_client.mojo` and calls `main()`.
1. **Startup.** `main()` creates an `EchoClientApplication` object and returns. The FIDL Client Library calls the `initialize()` method, which, despite its name, is where the client does the real work.
1. **Connect.** In `initialize()`, the client calls `connectToService(String url, bindings.fidlInterface interface)` with the url to the application and with the proxy object. On return, the proxy object is initialized and connected to the channel. However, the remote end of the channel is not connected yet. That happens in the next step.
1. **Connect.** The FIDL shell loads the server application, which connects the `ServiceProvider` interface to the remote end of the channel.
1. **Execute.** `initialize()` calls `_echo.echoString(...)` and specifies an anonymous function to handle the return value. The call to `echoString()` returns immediately because FIDL calls are async.
1. **Execute.** The FIDL run loop is idle, waiting for messages from channels.
1. **Execute.** Eventually, the server returns the result on the channel, which the mojo package passes to our anonymous function, which prints the result.
1. **Shutdown.** The `whenComplete()` block of the Completer closes all handles.
1. **Shutdown.** The server calls `Quit()`, which closes the channel.
1. **Shutdown.** `dart_echo_client` exits.

### main()

The `main()` function in the client is almost identical to the server.

```dart
main(List args, Object handleToken) {
  fidlHandle appHandle = new fidlHandle(handleToken);
  new EchoClientApplication.fromHandle(appHandle);
}
```

Again, remember that everything in FIDL is async. The call to `new EchoClientApplication.fromHandle()` returns immediately and then `main()` returns. The FIDL client library keeps its own pointer to the application object, which prevents the application from exiting.

### EchoClientApplication

FIDL calls the `initialize()` function of your `Application` object once setup is complete.

```dart
@override
void initialize(List<String> arguments, String url) {
  // See README.md for how to specify an alternate server on the cmd line.
  final server = (arguments.length > 0) ? arguments[1] : "dart_echo_server";
  connectToService(url.replaceAll("dart_echo_client", server), _echo);

  var c = new Completer();
  _echo.echoString("hello world", (String response) {
    print("${response}");
    c.complete(null);
  });
  c.future.whenComplete(_closeHandles);
}
```

The `initialize()` method receives two parameters, `arguments` and `url`. The `arguments` parameter contains the `args-for` parameters from the `mojo_shell` command as described in the `README.md` file. The `url` parameter contains the URL used to start the `dart_echo_client`. To start the server, the code replaces `"dart_echo_client"` with `"dart_echo_server"`, then calls connectToService() to load dart_echo_server and bind to its `Echo` service. The desired interface is defined by the `_echo` object.

Next the client calls `echoString()` on the newly-bound `_echo` proxy object. FIDL interface calls are asynchronous, so `echoString()` immediately returns and `initialize()` returns. After the call to `echoString()` in the server returns, the anonymous function will be called to print the result. Notice that a `Completer` is used to close the handles and clean up once the anonymous function finishes.

Once all of the handles are closed, the application will automatically exit after the anonymous function returns.

### Run the sample

You can run the Hello World example like this:

```
$ out/Debug/mojo_shell mojo:echo_client
```

You do not need to specifically run the server because the call to `connectToService()` in the client will automatically demand-load the server.

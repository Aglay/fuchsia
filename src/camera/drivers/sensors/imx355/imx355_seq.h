// Copyright 2018 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SRC_CAMERA_DRIVERS_SENSORS_IMX355_IMX355_SEQ_H_
#define SRC_CAMERA_DRIVERS_SENSORS_IMX355_IMX355_SEQ_H_

#include <array>

#include "ddk/protocol/camerasensor.h"

namespace camera {

struct InitSeqFmt {
  uint16_t address;
  uint8_t value;
  uint8_t mask;
  uint8_t len;
};

//------------------------//
//     INIT SEQUENCES     //
//------------------------//

constexpr uint8_t kSENSOR_IMX355_SEQUENCE_DEFAULT_PREVIEW = 0;

constexpr size_t kArraySize = 120;

constexpr std::array<InitSeqFmt, kArraySize> setting_2200_2720_2lane_996mbps_30fps = {{
    // Extclk_frequency_mhz = 24.00MHz
    {0x0136, 0x18, 0xFF, 1},  // Extclk_frequency_mhz 8.8fp high byte
    {0x0137, 0x00, 0xFF, 1},  // Extclk_frequency_mhz 8.8fp low byte

    // T_VERSION
    {0x304e, 0x03, 0xff, 1},

    // UNDOCUMENTED!
    {0x4348, 0x16, 0xff, 1},
    {0x4350, 0x19, 0xff, 1},
    {0x4408, 0x0a, 0xff, 1},
    {0x440c, 0x0b, 0xff, 1},
    {0x4411, 0x5f, 0xff, 1},
    {0x4412, 0x2c, 0xff, 1},
    {0x4623, 0x00, 0xff, 1},
    {0x462c, 0x0f, 0xff, 1},
    {0x462d, 0x00, 0xff, 1},
    {0x462e, 0x00, 0xff, 1},
    {0x4684, 0x54, 0xff, 1},
    {0x480a, 0x07, 0xff, 1},
    {0x4908, 0x07, 0xff, 1},
    {0x4909, 0x07, 0xff, 1},
    {0x490d, 0x0a, 0xff, 1},
    {0x491e, 0x0f, 0xff, 1},
    {0x4921, 0x06, 0xff, 1},
    {0x4923, 0x28, 0xff, 1},
    {0x4924, 0x28, 0xff, 1},
    {0x4925, 0x29, 0xff, 1},
    {0x4926, 0x29, 0xff, 1},
    {0x4927, 0x1f, 0xff, 1},
    {0x4928, 0x20, 0xff, 1},
    {0x4929, 0x20, 0xff, 1},
    {0x492a, 0x20, 0xff, 1},
    {0x492c, 0x05, 0xff, 1},
    {0x492d, 0x06, 0xff, 1},
    {0x492e, 0x06, 0xff, 1},
    {0x492f, 0x06, 0xff, 1},
    {0x4930, 0x03, 0xff, 1},
    {0x4931, 0x04, 0xff, 1},
    {0x4932, 0x04, 0xff, 1},
    {0x4933, 0x05, 0xff, 1},
    {0x595e, 0x01, 0xff, 1},
    {0x5963, 0x01, 0xff, 1},

    // MIPI setting
    // CSI_data_format = Raw10
    {0x0112, 0x0a, 0xff, 1},
    {0x0113, 0x0a, 0xff, 1},
    {0x0114, 0x03, 0xFF, 1},

    // Frame horizontal clock count
    // line_length_pck = 0x0e58
    {0x0342, 0x0e, 0xFF, 1},
    {0x0343, 0x58, 0xFF, 1},

    // Frame  vertical clock count
    // frame_length_lines = 0x0a36
    {0x0340, 0x0A, 0xFF, 1},
    {0x0341, 0x36, 0xFF, 1},

    // Visible size
    // x_addr_start = 0x0000
    {0x0344, 0x00, 0xFF, 1},
    {0x0345, 0x00, 0xFF, 1},
    // y_addr_start = 0x0000
    {0x0346, 0x00, 0xFF, 1},
    {0x0347, 0x00, 0xFF, 1},
    // x_addr_end = 0x0ccf
    {0x0348, 0x0c, 0xFF, 1},
    {0x0349, 0xcf, 0xFF, 1},
    // y_addr_end = 0x099f
    {0x034A, 0x09, 0xFF, 1},
    {0x034B, 0x9f, 0xFF, 1},

    // Mode setting
    {0x0220, 0x00, 0xff, 1},
    {0x0222, 0x01, 0xff, 1},
    {0x0900, 0x00, 0xff, 1},
    {0x0901, 0x11, 0xff, 1},
    {0x0902, 0x00, 0xff, 1},

    // Output size setting
    // x_output_size = 0x0cd0
    {0x034C, 0x0c, 0xFF, 1},
    {0x034D, 0xd0, 0xFF, 1},
    // y_output_size = 0x09a0
    {0x034E, 0x09, 0xFF, 1},
    {0x034F, 0xA0, 0xFF, 1},

    // Clock setting
    // ivt_pi_clk_div = 0x0005
    {0x0301, 0x05, 0xFF, 1},
    // ivt_sys_clk_div = 0x0001
    {0x0303, 0x01, 0xFF, 1},
    // ivt_pre_pll_clk_div = 0x0002
    {0x0305, 0x02, 0xFF, 1},
    // ivt_pll_multiplier = 0x0078
    {0x0306, 0x00, 0xFF, 1},
    {0x0307, 0x78, 0xFF, 1},
    // iop_sys_clk_div = 0x0001
    {0x030B, 0x01, 0xFF, 1},
    // iop_pre_pll_clk_div = 0x0002
    {0x030D, 0x02, 0xFF, 1},
    // iop_pll_multipler = 0x003c
    {0x030E, 0x00, 0xFF, 1},
    {0x030F, 0x3c, 0xFF, 1},
    // pll_multi_drive = 0 = TBD
    {0x0310, 0x00, 0xFF, 1},
    {0x0700, 0x00, 0xff, 1},
    {0x0701, 0x10, 0xff, 1},
    {0x0820, 0x0b, 0xFF, 1},
    {0x0821, 0x40, 0xFF, 1},
    {0x3088, 0x04, 0xff, 1},
    {0x6813, 0x02, 0xff, 1},
    {0x6835, 0x07, 0xff, 1},
    {0x6836, 0x01, 0xff, 1},
    {0x6837, 0x04, 0xff, 1},
    {0x684d, 0x07, 0xff, 1},
    {0x684e, 0x01, 0xff, 1},
    {0x684f, 0x04, 0xff, 1},

    // CIT Setting
    // coarse_integration_time = 0x0a2c
    {0x0202, 0x0A, 0xFF, 1},  // int time
    {0x0203, 0x2c, 0xFF, 1},

    // Gain Setting
    // analog_gain_code_global = 0x0000 = 1.0
    {0x0204, 0x00, 0xFF, 1},
    {0x0205, 0x00, 0xFF, 1},
    // digital_gain_global = 0x0100 = 1.0
    {0x020E, 0x01, 0xFF, 1},
    {0x020F, 0x00, 0xFF, 1},

    // End of sequence
    {0x0000, 0x0000, 0x0000, 0x0000},
}};

//-------------------------//
//     SUPPORTED MODES     //
//-------------------------//

const std::array<const InitSeqFmt*, 6> kSEQUENCE_TABLE = {
    setting_2200_2720_2lane_996mbps_30fps.data(),
};

constexpr std::array<camera_sensor_mode_t, 4> supported_modes = {{
    {
        // NOTE: SW reference consumes this as (30fps * 256)
        //       We are representing this as fpms.
        //       Take account of the multiplier when needed.
        .fpms = 30000,
        .resolution =
            {
                .width = 3280,
                .height = 2464,
            },
        .exposures = 1,
        .wdr_mode = CAMERASENSOR_WDR_MODE_LINEAR,
        .bits = 10,
        .lanes = 4,
        .mbps = 720,
        .idx = kSENSOR_IMX355_SEQUENCE_DEFAULT_PREVIEW,
        .bayer = BAYER_RGGB,
    },
}};

}  // namespace camera

#endif  // SRC_CAMERA_DRIVERS_SENSORS_IMX355_IMX355_SEQ_H_

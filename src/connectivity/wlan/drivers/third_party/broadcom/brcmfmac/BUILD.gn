#
# Copyright (c) 2018 The Fuchsia Authors.
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import("//build/cipd.gni")
import("//build/config/fuchsia/rules.gni")
import("//build/package.gni")

# By default, targets are only visible here and to subdirectories.
visibility = [ "./*" ]

# The brcmfmac driver can be built with support for different system buses
# (SDIO, and simulated-firmware), and different configurations will require
# different support.  To facilitate consolidating all the potentially messy
# conditional compilation in one place, "bus.cc" is conditionally compiled based
# on the values of the preprocessor #defines:
#
# * CONFIG_BRCMFMAC_SDIO
# * CONFIG_BRCMFMAC_SIM
#
# These #defines are applied as public_configs entries on the targets,
# respectively:
#
# * :sdio
# * :sim
#
# Thus a target that depends on one of the above targets, can include "bus.cc"
# in its sources and will then conditionally compile it with the set of
# preprocessor #defines set by the targets it depends on.
#
# See the targets ":driver_module" and ":driver_sim" to see how this is done.

source_set("debug") {
  sources = [
    "debug.cc",
  ]
  public = [
    "debug.h",
  ]
  public_deps = [
    "//zircon/public/lib/ddk",
    "//zircon/system/public",
  ]
}

source_set("linuxisms") {
  sources = [
    "linuxisms.cc",
    "netbuf.cc",
    "workqueue.cc",
  ]
  public = [
    "linuxisms.h",
    "netbuf.h",
    "workqueue.h",
  ]
  deps = [
    ":debug",
    "//zircon/public/lib/sync",
  ]
  public_deps = [
    "//zircon/system/public",
  ]
}

source_set("core") {
  sources = [
    "bcdc.cc",
    "bits.cc",
    "bits.h",
    "btcoex.cc",
    "btcoex.h",
    "cfg80211.cc",
    "chip.cc",
    "common.cc",
    "core.cc",
    "d11.cc",
    "device.cc",
    "feature.cc",
    "feature.h",
    "firmware.cc",
    "fweh.cc",
    "fwil.cc",
    "fwsignal.cc",
    "fwsignal.h",
    "p2p.cc",
    "p2p.h",
    "pno.cc",
    "pno.h",
    "proto.cc",
    "proto.h",
    "timer.cc",
    "utils.cc",
    "wlan_interface.cc",
    "wlan_interface.h",
  ]
  public = [
    "bcdc.h",
    "brcm_hw_ids.h",
    "brcmu_d11.h",
    "brcmu_utils.h",
    "brcmu_wifi.h",
    "bus.h",
    "cfg80211.h",
    "chip.h",
    "chipcommon.h",
    "common.h",
    "core.h",
    "defs.h",
    "device.h",
    "firmware.h",
    "fweh.h",
    "fwil.h",
    "fwil_types.h",
    "soc.h",
    "timer.h",
  ]
  deps = [
    ":debug",
    "//src/connectivity/wlan/lib/common/cpp:common",
    "//zircon/public/lib/broadcom",
    "//zircon/public/lib/ddk",
    "//zircon/system/banjo/ddk.hw.wlan.wlaninfo",
  ]
  public_deps = [
    ":linuxisms",
    "//garnet/lib/wlan/protocol",
    "//sdk/banjo/ddk.protocol.wlanphyimpl",
    "//zircon/public/lib/async",
    "//zircon/public/lib/async-loop",
    "//zircon/public/lib/async-loop-default",
    "//zircon/public/lib/ddktl",
    "//zircon/public/lib/sync",
    "//zircon/system/banjo/ddk.protocol.ethernet",
    "//zircon/system/public",
  ]
  friend = [ "test/*" ]
}

config("config_sdio") {
  defines = [ "CONFIG_BRCMFMAC_SDIO=1" ]
}

source_set("sdio") {
  sources = [
    "bcmsdh.cc",
    "sdio.cc",
    "sdio_device.cc",
  ]
  public = [
    "sdio.h",
    "sdio_device.h",
  ]
  deps = [
    ":debug",
    "//zircon/public/lib/broadcom",
    "//zircon/public/lib/sync",
    "//zircon/public/lib/trace-driver",
    "//zircon/system/banjo/ddk.protocol.composite",
    "//zircon/system/public",
  ]
  public_deps = [
    ":core",
    ":linuxisms",
    "//zircon/public/lib/ddk",
    "//zircon/system/banjo/ddk.protocol.gpio",
    "//zircon/system/banjo/ddk.protocol.sdio",
  ]
  public_configs = [ ":config_sdio" ]
}

config("config_sim") {
  defines = [ "CONFIG_BRCMFMAC_SIM=1" ]
}

source_set("sim") {
  sources = [
    "sim-fw/sim_fw.cc",
    "sim-fw/sim_fw.h",
    "sim-fw/sim_hw.cc",
    "sim-fw/sim_hw.h",
    "sim.cc",
    "sim.h",
    "sim_device.cc",
  ]
  public = [
    "sim_device.h",
  ]
  deps = [
    ":debug",
    "//zircon/public/lib/broadcom",
    "//zircon/public/lib/ddk",
    "//zircon/system/public",
  ]
  public_deps = [
    ":core",
    "//src/connectivity/wlan/drivers/testing/lib/sim-device",
    "//src/connectivity/wlan/drivers/testing/lib/sim-env",
  ]
  public_configs = [ ":config_sim" ]
}

driver_module("driver_module") {
  output_name = "brcmfmac"
  sources = [
    "binding.cc",
  ]
  deps = [
    ":core",
    ":debug",
    "//zircon/public/lib/driver",
  ]

  # Assume for now that arm64 boards use the SDIO interface.
  if (target_cpu == "arm64") {
    deps += [ ":sdio" ]
  }

  configs -= [ "//build/config/fuchsia:no_cpp_standard_library" ]
  configs += [ "//build/config/fuchsia:static_cpp_standard_library" ]
}

driver_library_files = []
if (internal_access) {
  # Firmware files from git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git
  if (board_name == "astro") {
    copy("brcmfmac-firmware-copy") {
      sources = [
        "firmware/brcmfmac43455-sdio-astro.bin",
      ]
      outputs = [
        "$root_out_dir/firmware/brcmfmac/brcmfmac43455-sdio.bin",
      ]
    }
    copy("brcmfmac-nvram-copy") {
      sources = [
        "firmware/brcmfmac43455-sdio-astro.txt",
      ]
      outputs = [
        "$root_out_dir/firmware/brcmfmac/brcmfmac43455-sdio.txt",
      ]
    }
    copy("brcmfmac-clm-copy") {
      sources = [
        "firmware/brcmfmac43455-sdio-astro.clm_blob",
      ]
      outputs = [
        "$root_out_dir/firmware/brcmfmac/brcmfmac43455-sdio.clm_blob",
      ]
    }
    driver_library_files += [
      "brcmfmac43455-sdio.bin",
      "brcmfmac43455-sdio.txt",
      "brcmfmac43455-sdio.clm_blob",
    ]
  } else if (board_name == "sherlock") {
    copy("brcmfmac-firmware-copy") {
      sources = [
        "firmware/brcmfmac43455-sdio-sherlock.bin",
      ]
      outputs = [
        "$root_out_dir/firmware/brcmfmac/brcmfmac43455-sdio.bin",
      ]
    }
    copy("brcmfmac-nvram-copy") {
      sources = [
        "firmware/brcmfmac43455-sdio-sherlock.txt",
      ]
      outputs = [
        "$root_out_dir/firmware/brcmfmac/brcmfmac43455-sdio.txt",
      ]
    }
    copy("brcmfmac-clm-copy") {
      sources = [
        "firmware/brcmfmac43455-sdio-sherlock.clm_blob",
      ]
      outputs = [
        "$root_out_dir/firmware/brcmfmac/brcmfmac43455-sdio.clm_blob",
      ]
    }
    driver_library_files += [
      "brcmfmac43455-sdio.bin",
      "brcmfmac43455-sdio.txt",
      "brcmfmac43455-sdio.clm_blob",
    ]
  } else {
    copy("brcmfmac-firmware-copy") {
      sources = [
        "firmware/brcmfmac43242a.bin",
        "firmware/brcmfmac43455-sdio.bin",
        "firmware/brcmfmac43455-sdio.txt",
        "firmware/brcmfmac4356-pcie.bin",
        "firmware/brcmfmac4356-sdio.bin",
        "firmware/brcmfmac4356-sdio.txt",
        "firmware/brcmfmac4359-sdio.bin",
        "firmware/brcmfmac4359-sdio.txt",
      ]
      outputs = [
        "$root_out_dir/firmware/brcmfmac/{{source_file_part}}",
      ]
    }
    group("brcmfmac-nvram-copy") {
    }
    group("brcmfmac-clm-copy") {
    }
    driver_library_files += [
      "brcmfmac43242a.bin",
      "brcmfmac43455-sdio.bin",
      "brcmfmac43455-sdio.txt",
      "brcmfmac4356-pcie.bin",
      "brcmfmac4356-sdio.bin",
      "brcmfmac4356-sdio.txt",
      "brcmfmac4359-sdio.bin",
      "brcmfmac4359-sdio.txt",
    ]
  }
} else {
  # Provide an empty target, in case no firmware is available.
  group("brcmfmac-firmware-copy") {
  }
  group("brcmfmac-nvram-copy") {
  }
  group("brcmfmac-clm-copy") {
  }
}

package("brcmfmac") {
  deprecated_system_image = true
  deps = [
    # The copy step has to be in the shared-library toolchain to use the
    # expected output directory, since we treat firmware blobs as if they
    # were libraries which always use the shared-library toolchain to build.
    ":brcmfmac-clm-copy($shlib_toolchain)",
    ":brcmfmac-firmware-copy($shlib_toolchain)",
    ":brcmfmac-nvram-copy($shlib_toolchain)",
    ":driver_module",
  ]
  drivers = [
    {
      name = "brcmfmac.so"
    },
  ]
  libraries = []
  foreach(file, driver_library_files) {
    libraries += [
      {
        name = "firmware/brcmfmac/$file"
      },
    ]
  }
  visibility += [ "*" ]
}

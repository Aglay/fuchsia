// Copyright 2021 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

use {std::fmt, thiserror::Error};

use crate::{
    at::{AtAgMessage, AtHfMessage, IndicatorStatus},
    protocol::features::AgFeatures,
};

/// Defines the implementation of the SLC Initialization Procedure.
pub mod slc_initialization;

/// Defines the implementation of the NR/EC Procedure.
pub mod nrec;

#[derive(Clone, Error, Debug)]
pub enum ProcedureError {
    #[error("Unexpected AG procedural update: {:?}", .0)]
    UnexpectedAg(AtAgMessage),
    #[error("Unexpected HF procedural update: {:?}", .0)]
    UnexpectedHf(AtHfMessage),
    #[error("Procedure has already terminated")]
    AlreadyTerminated,
}

/// A unique identifier associated with an HFP procedure.
// TODO(fxbug.dev/70591): Add to this enum as more procedures are implemented.
#[derive(Debug, Clone, Copy, PartialEq, Hash, Eq)]
pub enum ProcedureMarker {
    /// The Service Level Connection Initialization procedure as defined in HFP v1.8 Section 4.2.
    SlcInitialization,
    /// The Noise Reduction/Echo Cancelation procedure as defined in HFP v1.8 Section 4.24.
    Nrec,
    /// A generic marker typically used for procedures that have yet to be defined.
    Unknown,
}

/// The requests generated by an HFP procedure as it progresses through its state machine.
pub enum ProcedureRequest {
    /// AT message to be sent to the peer (HF) - requires no response.
    SendMessage(AtAgMessage),

    /// Information requests - use the `response` fn to build a response to the request.
    // TODO(fxbug.dev/70591): Add to this list once more procedures are implemented.
    GetAgFeatures {
        response: Box<dyn FnOnce(AgFeatures) -> AtAgMessage>,
    },
    GetAgIndicatorStatus {
        response: Box<dyn FnOnce(IndicatorStatus) -> AtAgMessage>,
    },

    SetNrec {
        enable: bool,
        response: Box<dyn FnOnce(Result<(), ()>) -> AtAgMessage>,
    },

    /// Error from processing an update.
    Error(ProcedureError),

    /// No-op.
    None,
}

impl ProcedureRequest {
    pub fn is_err(&self) -> bool {
        match &self {
            Self::Error(_) => true,
            _ => false,
        }
    }
}

impl fmt::Debug for ProcedureRequest {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let other;
        let output = match &self {
            Self::GetAgFeatures { .. } => "GetAgFeatures",
            Self::GetAgIndicatorStatus { .. } => "GetAgIndicatorStatus",
            Self::SetNrec { enable: true, .. } => "SetNrec(enabled)",
            Self::SetNrec { enable: false, .. } => "SetNrec(disabled)",
            event => {
                other = format!("{:?}", event);
                &other
            }
        }
        .to_string();
        write!(f, "{}", output)
    }
}

/// An interface to interact with an HFP Procedure.
pub trait Procedure {
    /// Returns the unique identifier associated with this procedure.
    fn marker(&self) -> ProcedureMarker;

    /// Receive an HF `update` to progress the procedure. Returns a request
    /// to the update.
    ///
    /// There are no guarantees if `hf_update()` is called on a Procedure that is terminated
    /// (namely, `is_terminated()` returns true) and may result in an error request.
    /// The handling of unexpected or invalid updates is procedure dependent.
    fn hf_update(&mut self, update: AtHfMessage) -> ProcedureRequest;

    /// Receive an AG `update` to progress the procedure. Returns a request
    /// to the update.
    ///
    /// There are no guarantees if `ag_update()` is called on a Procedure that is terminated
    /// (namely, `is_terminated()` returns true) and may result in an error request.
    /// The handling of unexpected or invalid updates is procedure dependent.
    fn ag_update(&mut self, update: AtAgMessage) -> ProcedureRequest;

    /// Returns true if the Procedure is finished.
    fn is_terminated(&self) -> bool {
        false
    }
}

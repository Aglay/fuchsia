// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

use {fidl_fuchsia_bluetooth as fidl, std::fmt};

/// A Bluetooth device address can either be public or private. The controller device address used
/// in BR/EDR (aka BD_ADDR) and LE have the "public" address type. A private address is one that is
/// randomly generated by the controller or the host and can only be used in LE. The identity
/// address can be random (often "static random") but is not typically considered private.
///
/// Some controller procedures depend on knowledge of whether an address is public (i.e. the BD_ADDR
/// assigned to the controller) or randomly assigned by the host. This enum type represents that
/// information.
///
/// This type represents a Bluetooth device address. `Address` can be converted to/from a FIDL
/// Bluetooth device address type.
#[derive(Copy, Clone, Debug, Eq, Hash, PartialEq)]
pub enum Address {
    Public(AddressBytes),
    Random(AddressBytes),
}

const NUM_ADDRESS_BYTES: usize = 6;
type AddressBytes = [u8; NUM_ADDRESS_BYTES];

fn addr_to_string(bytes: &AddressBytes) -> String {
    format!(
        "{:02X}:{:02X}:{:02X}:{:02X}:{:02X}:{:02X}",
        bytes[5], bytes[4], bytes[3], bytes[2], bytes[1], bytes[0]
    )
}

impl Address {
    /// Returns a string representation of the address bytes.
    // TODO(armansito): This method is temporarily used for the deprecated FIDL APIs that represent
    // addresses as strings. Remove this method once all of those APIs are removed.
    pub fn to_string(&self) -> String {
        match self {
            Address::Public(b) => addr_to_string(b),
            Address::Random(b) => addr_to_string(b),
        }
    }

    pub fn to_fidl(&self) -> fidl::Address {
        match self {
            Address::Public(b) => {
                fidl::Address { type_: fidl::AddressType::Public, bytes: b.clone() }
            }
            Address::Random(b) => {
                fidl::Address { type_: fidl::AddressType::Random, bytes: b.clone() }
            }
        }
    }
}

impl From<&fidl::Address> for Address {
    fn from(src: &fidl::Address) -> Address {
        match src.type_ {
            fidl::AddressType::Public => Address::Public(src.bytes.clone()),
            fidl::AddressType::Random => Address::Random(src.bytes.clone()),
        }
    }
}

impl From<fidl::Address> for Address {
    fn from(src: fidl::Address) -> Address {
        Address::from(&src)
    }
}

impl Into<fidl::Address> for Address {
    fn into(self) -> fidl::Address {
        self.to_fidl()
    }
}

impl Into<fidl::Address> for &Address {
    fn into(self) -> fidl::Address {
        self.to_fidl()
    }
}

impl fmt::Display for Address {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Address::Public(b) => write!(fmt, "[address (public) {}]", self.to_string()),
            Address::Random(b) => write!(fmt, "[address (random) {}]", self.to_string()),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn address_to_string() {
        let address = Address::Public([0x01, 0x02, 0x03, 0xDD, 0xEE, 0xFF]);
        assert_eq!("FF:EE:DD:03:02:01", address.to_string());
    }

    #[test]
    fn public_address_from_fidl() {
        let fidl_address =
            fidl::Address { type_: fidl::AddressType::Public, bytes: [1, 2, 3, 4, 5, 6] };
        let address: Address = fidl_address.into();
        assert_eq!(Address::Public([1, 2, 3, 4, 5, 6]), address);
    }

    #[test]
    fn random_address_from_fidl() {
        let fidl_address =
            fidl::Address { type_: fidl::AddressType::Random, bytes: [1, 2, 3, 4, 5, 6] };
        let address: Address = fidl_address.into();
        assert_eq!(Address::Random([1, 2, 3, 4, 5, 6]), address);
    }

    #[test]
    fn public_address_into_fidl() {
        let address = Address::Public([1, 2, 3, 4, 5, 6]);
        let fidl_address: fidl::Address = address.into();
        assert_eq!(fidl::AddressType::Public, fidl_address.type_);
        assert_eq!([1, 2, 3, 4, 5, 6], fidl_address.bytes);
    }

    #[test]
    fn random_address_into_fidl() {
        let address = Address::Random([1, 2, 3, 4, 5, 6]);
        let fidl_address: fidl::Address = address.into();
        assert_eq!(fidl::AddressType::Random, fidl_address.type_);
        assert_eq!([1, 2, 3, 4, 5, 6], fidl_address.bytes);
    }
}

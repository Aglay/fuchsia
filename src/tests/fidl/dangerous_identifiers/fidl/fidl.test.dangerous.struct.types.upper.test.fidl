// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Generated by //src/tests/fidl/dangerous_identifiers/generate.
library fidl.test.dangerous.struct.types.upper;
using membertype = uint32;

struct ABSTRACT {
    membertype member = 1;
};

struct ALIGNAS {
    membertype member = 1;
};

struct ALIGNOF {
    membertype member = 1;
};

struct AND {
    membertype member = 1;
};

struct AND_EQ {
    membertype member = 1;
};

struct AS {
    membertype member = 1;
};

struct ASM {
    membertype member = 1;
};

struct ASSERT {
    membertype member = 1;
};

struct ASYNC {
    membertype member = 1;
};

struct ATOMIC_CANCEL {
    membertype member = 1;
};

struct ATOMIC_COMMIT {
    membertype member = 1;
};

struct ATOMIC_NOEXCEPT {
    membertype member = 1;
};

struct AUTO {
    membertype member = 1;
};

struct AWAIT {
    membertype member = 1;
};

struct BECOME {
    membertype member = 1;
};

struct BITAND {
    membertype member = 1;
};

struct BITOR {
    membertype member = 1;
};

struct BOOL {
    membertype member = 1;
};

struct BOX {
    membertype member = 1;
};

struct BREAK {
    membertype member = 1;
};

struct BYTE {
    membertype member = 1;
};

struct BYTES {
    membertype member = 1;
};

struct CASE {
    membertype member = 1;
};

struct CATCH {
    membertype member = 1;
};

struct CHAN {
    membertype member = 1;
};

struct CHAR {
    membertype member = 1;
};

struct CHAR16_T {
    membertype member = 1;
};

struct CHAR32_T {
    membertype member = 1;
};

struct CLASS {
    membertype member = 1;
};

struct CO_AWAIT {
    membertype member = 1;
};

struct CO_RETURN {
    membertype member = 1;
};

struct CO_YIELD {
    membertype member = 1;
};

struct CODING_TRAITS {
    membertype member = 1;
};

struct COMPL {
    membertype member = 1;
};

struct CONCEPT {
    membertype member = 1;
};

struct CONST {
    membertype member = 1;
};

struct CONST_CAST {
    membertype member = 1;
};

struct CONSTEXPR {
    membertype member = 1;
};

struct CONTINUE {
    membertype member = 1;
};

struct CONTROLLER {
    membertype member = 1;
};

struct COVARIANT {
    membertype member = 1;
};

struct CRATE {
    membertype member = 1;
};

struct DECLTYPE {
    membertype member = 1;
};

struct DECODER {
    membertype member = 1;
};

struct DEFAULT {
    membertype member = 1;
};

struct DEFER {
    membertype member = 1;
};

struct DEFERRED {
    membertype member = 1;
};

struct DELETE {
    membertype member = 1;
};

struct DO {
    membertype member = 1;
};

struct DOUBLE {
    membertype member = 1;
};

struct DYNAMIC {
    membertype member = 1;
};

struct DYNAMIC_CAST {
    membertype member = 1;
};

struct ELSE {
    membertype member = 1;
};

struct ENCODER {
    membertype member = 1;
};

struct ENSURE_VALUES_INSTANTIATED {
    membertype member = 1;
};

struct ENUM {
    membertype member = 1;
};

struct EMPTY {
    membertype member = 1;
};

struct ERR {
    membertype member = 1;
};

struct EXPLICIT {
    membertype member = 1;
};

struct EXPORT {
    membertype member = 1;
};

struct EXTENDS {
    membertype member = 1;
};

struct EXTERN {
    membertype member = 1;
};

struct EXTERNAL {
    membertype member = 1;
};

struct FACTORY {
    membertype member = 1;
};

struct FALLTHROUGH {
    membertype member = 1;
};

struct FALSE {
    membertype member = 1;
};

struct FIDL {
    membertype member = 1;
};

struct FIDL_TYPE {
    membertype member = 1;
};

struct FINAL {
    membertype member = 1;
};

struct FINALLY {
    membertype member = 1;
};

struct FLOAT {
    membertype member = 1;
};

struct FN {
    membertype member = 1;
};

struct FOR {
    membertype member = 1;
};

struct FRIEND {
    membertype member = 1;
};

struct FUNC {
    membertype member = 1;
};

struct FUTURE {
    membertype member = 1;
};

struct FUTURES {
    membertype member = 1;
};

struct GET {
    membertype member = 1;
};

struct GO {
    membertype member = 1;
};

struct GOTO {
    membertype member = 1;
};

struct HAS_INVALID_TAG {
    membertype member = 1;
};

struct HASH_CODE {
    membertype member = 1;
};

struct IF {
    membertype member = 1;
};

struct IMPL {
    membertype member = 1;
};

struct IMPLEMENTS {
    membertype member = 1;
};

struct IMPORT {
    membertype member = 1;
};

struct IN {
    membertype member = 1;
};

struct INDEX {
    membertype member = 1;
};

struct INLINE {
    membertype member = 1;
};

struct INT {
    membertype member = 1;
};

struct INT16 {
    membertype member = 1;
};

struct INT32 {
    membertype member = 1;
};

struct INT64 {
    membertype member = 1;
};

struct INT8 {
    membertype member = 1;
};

struct INTERFACE {
    membertype member = 1;
};

struct INTERNAL_TAG {
    membertype member = 1;
};

struct IS {
    membertype member = 1;
};

struct LET {
    membertype member = 1;
};

struct LHS {
    membertype member = 1;
};

struct LIBRARY {
    membertype member = 1;
};

struct LIST {
    membertype member = 1;
};

struct LONG {
    membertype member = 1;
};

struct LOOP {
    membertype member = 1;
};

struct MACRO {
    membertype member = 1;
};

struct MAP {
    membertype member = 1;
};

struct MATCH {
    membertype member = 1;
};

struct MIXIN {
    membertype member = 1;
};

struct MOD {
    membertype member = 1;
};

struct MODULE {
    membertype member = 1;
};

struct MOVE {
    membertype member = 1;
};

struct MUT {
    membertype member = 1;
};

struct MUTABLE {
    membertype member = 1;
};

struct NAMESPACE {
    membertype member = 1;
};

struct NEVER {
    membertype member = 1;
};

struct NEW {
    membertype member = 1;
};

struct NO_SUCH_METHOD {
    membertype member = 1;
};

struct NOEXCEPT {
    membertype member = 1;
};

struct NONE {
    membertype member = 1;
};

struct NOT {
    membertype member = 1;
};

struct NOT_EQ {
    membertype member = 1;
};

struct NULL {
    membertype member = 1;
};

struct NULLPTR {
    membertype member = 1;
};

struct NUM {
    membertype member = 1;
};

struct OBJECT {
    membertype member = 1;
};

struct OFFSET {
    membertype member = 1;
};

struct OFFSETOF {
    membertype member = 1;
};

struct OK {
    membertype member = 1;
};

struct ON_OPEN {
    membertype member = 1;
};

struct OPERATOR {
    membertype member = 1;
};

struct OPTION {
    membertype member = 1;
};

struct OR {
    membertype member = 1;
};

struct OR_EQ {
    membertype member = 1;
};

struct OVERRIDE {
    membertype member = 1;
};

struct PACKAGE {
    membertype member = 1;
};

struct PART {
    membertype member = 1;
};

struct PRIV {
    membertype member = 1;
};

struct PRIVATE {
    membertype member = 1;
};

struct PROC {
    membertype member = 1;
};

struct PROTECTED {
    membertype member = 1;
};

struct PROXY {
    membertype member = 1;
};

struct PUB {
    membertype member = 1;
};

struct PUBLIC {
    membertype member = 1;
};

struct PURE {
    membertype member = 1;
};

struct RANGE {
    membertype member = 1;
};

struct REF {
    membertype member = 1;
};

struct REGISTER {
    membertype member = 1;
};

struct REINTERPRET_CAST {
    membertype member = 1;
};

struct REQUIRES {
    membertype member = 1;
};

struct RESULT {
    membertype member = 1;
};

struct RETHROW {
    membertype member = 1;
};

struct RETURN {
    membertype member = 1;
};

struct RHS {
    membertype member = 1;
};

struct RUNE {
    membertype member = 1;
};

struct RUNTIME_TYPE {
    membertype member = 1;
};

struct SELECT {
    membertype member = 1;
};

struct SELF {
    membertype member = 1;
};

struct SEND {
    membertype member = 1;
};

struct SET {
    membertype member = 1;
};

struct SET_CONTROLLER {
    membertype member = 1;
};

struct SHORT {
    membertype member = 1;
};

struct SIGNED {
    membertype member = 1;
};

struct SIZEOF {
    membertype member = 1;
};

struct SOME {
    membertype member = 1;
};

struct STATIC {
    membertype member = 1;
};

struct STATIC_ASSERT {
    membertype member = 1;
};

struct STATIC_CAST {
    membertype member = 1;
};

struct STREAM {
    membertype member = 1;
};

struct STRING {
    membertype member = 1;
};

struct STRUCT {
    membertype member = 1;
};

struct STUB {
    membertype member = 1;
};

struct SUPER {
    membertype member = 1;
};

struct SWITCH {
    membertype member = 1;
};

struct SYNCHRONIZED {
    membertype member = 1;
};

struct TEMPLATE {
    membertype member = 1;
};

struct THIS {
    membertype member = 1;
};

struct THREAD_LOCAL {
    membertype member = 1;
};

struct THROW {
    membertype member = 1;
};

struct TO_STRING {
    membertype member = 1;
};

struct TRAIT {
    membertype member = 1;
};

struct TRUE {
    membertype member = 1;
};

struct TRY {
    membertype member = 1;
};

struct TYPE {
    membertype member = 1;
};

struct TYPEDEF {
    membertype member = 1;
};

struct TYPEID {
    membertype member = 1;
};

struct TYPENAME {
    membertype member = 1;
};

struct TYPEOF {
    membertype member = 1;
};

struct UINT16 {
    membertype member = 1;
};

struct UINT32 {
    membertype member = 1;
};

struct UINT64 {
    membertype member = 1;
};

struct UINT8 {
    membertype member = 1;
};

struct UNION {
    membertype member = 1;
};

struct UNKNOWN {
    membertype member = 1;
};

struct UNKNOWN_BYTES {
    membertype member = 1;
};

[BindingsDenylist = "dart"]
struct UNKNOWN_DATA {
    membertype member = 1;
};

struct UNSAFE {
    membertype member = 1;
};

struct UNSIGNED {
    membertype member = 1;
};

struct UNSIZED {
    membertype member = 1;
};

struct USE {
    membertype member = 1;
};

struct USING {
    membertype member = 1;
};

struct VALUE {
    membertype member = 1;
};

struct VALUE_OF {
    membertype member = 1;
};

struct VALUE_UNION {
    membertype member = 1;
};

struct VALUES_MAP {
    membertype member = 1;
};

struct VAR {
    membertype member = 1;
};

struct VEC {
    membertype member = 1;
};

struct VIRTUAL {
    membertype member = 1;
};

struct VOID {
    membertype member = 1;
};

struct VOLATILE {
    membertype member = 1;
};

struct WCHAR_T {
    membertype member = 1;
};

struct WHERE {
    membertype member = 1;
};

struct WHICH {
    membertype member = 1;
};

struct WHILE {
    membertype member = 1;
};

struct WITH {
    membertype member = 1;
};

struct XOR {
    membertype member = 1;
};

struct XOR_EQ {
    membertype member = 1;
};

struct XUNION {
    membertype member = 1;
};

struct YIELD {
    membertype member = 1;
};

struct ZX {
    membertype member = 1;
};

struct DangerousMembers {
    ABSTRACT f0;
    ALIGNAS f1;
    ALIGNOF f2;
    AND f3;
    AND_EQ f4;
    AS f5;
    ASM f6;
    ASSERT f7;
    ASYNC f8;
    ATOMIC_CANCEL f9;
    ATOMIC_COMMIT f10;
    ATOMIC_NOEXCEPT f11;
    AUTO f12;
    AWAIT f13;
    BECOME f14;
    BITAND f15;
    BITOR f16;
    BOOL f17;
    BOX f18;
    BREAK f19;
    BYTE f20;
    BYTES f214;
    CASE f21;
    CATCH f22;
    CHAN f23;
    CHAR f24;
    CHAR16_T f25;
    CHAR32_T f26;
    CLASS f27;
    CO_AWAIT f28;
    CO_RETURN f29;
    CO_YIELD f30;
    CODING_TRAITS f31;
    COMPL f32;
    CONCEPT f33;
    CONST f34;
    CONST_CAST f35;
    CONSTEXPR f36;
    CONTINUE f37;
    CONTROLLER f38;
    COVARIANT f39;
    CRATE f40;
    DECLTYPE f41;
    DECODER f42;
    DEFAULT f43;
    DEFER f44;
    DEFERRED f45;
    DELETE f46;
    DO f47;
    DOUBLE f48;
    DYNAMIC f49;
    DYNAMIC_CAST f50;
    ELSE f51;
    ENCODER f52;
    ENSURE_VALUES_INSTANTIATED f53;
    ENUM f54;
    EMPTY f55;
    ERR f56;
    EXPLICIT f57;
    EXPORT f58;
    EXTENDS f59;
    EXTERN f60;
    EXTERNAL f61;
    FACTORY f62;
    FALLTHROUGH f63;
    FALSE f64;
    FIDL f65;
    FIDL_TYPE f66;
    FINAL f67;
    FINALLY f68;
    FLOAT f69;
    FN f70;
    FOR f71;
    FRIEND f72;
    FUNC f73;
    FUTURE f74;
    FUTURES f75;
    GET f76;
    GO f77;
    GOTO f78;
    HAS_INVALID_TAG f79;
    HASH_CODE f80;
    IF f81;
    IMPL f82;
    IMPLEMENTS f83;
    IMPORT f84;
    IN f85;
    INDEX f86;
    INLINE f87;
    INT f88;
    INT16 f89;
    INT32 f90;
    INT64 f91;
    INT8 f92;
    INTERFACE f93;
    INTERNAL_TAG f94;
    IS f95;
    LET f96;
    LHS f97;
    LIBRARY f98;
    LIST f99;
    LONG f100;
    LOOP f101;
    MACRO f102;
    MAP f103;
    MATCH f104;
    MIXIN f105;
    MOD f106;
    MODULE f107;
    MOVE f108;
    MUT f109;
    MUTABLE f110;
    NAMESPACE f111;
    NEVER f112;
    NEW f113;
    NO_SUCH_METHOD f114;
    NOEXCEPT f115;
    NONE f116;
    NOT f117;
    NOT_EQ f118;
    NULL f119;
    NULLPTR f120;
    NUM f121;
    OBJECT f122;
    OFFSET f123;
    OFFSETOF f124;
    OK f125;
    ON_OPEN f126;
    OPERATOR f127;
    OPTION f128;
    OR f129;
    OR_EQ f130;
    OVERRIDE f131;
    PACKAGE f132;
    PART f133;
    PRIV f134;
    PRIVATE f135;
    PROC f136;
    PROTECTED f137;
    PROXY f138;
    PUB f139;
    PUBLIC f140;
    PURE f141;
    RANGE f142;
    REF f143;
    REGISTER f144;
    REINTERPRET_CAST f145;
    REQUIRES f146;
    RESULT f147;
    RETHROW f148;
    RETURN f149;
    RHS f150;
    RUNE f151;
    RUNTIME_TYPE f152;
    SELECT f153;
    SELF f154;
    SEND f155;
    SET f156;
    SET_CONTROLLER f157;
    SHORT f158;
    SIGNED f159;
    SIZEOF f160;
    SOME f161;
    STATIC f162;
    STATIC_ASSERT f163;
    STATIC_CAST f164;
    STREAM f165;
    STRING f166;
    STRUCT f167;
    STUB f168;
    SUPER f169;
    SWITCH f170;
    SYNCHRONIZED f171;
    TEMPLATE f172;
    THIS f173;
    THREAD_LOCAL f174;
    THROW f175;
    TO_STRING f176;
    TRAIT f177;
    TRUE f178;
    TRY f179;
    TYPE f180;
    TYPEDEF f181;
    TYPEID f182;
    TYPENAME f183;
    TYPEOF f184;
    UINT16 f185;
    UINT32 f186;
    UINT64 f187;
    UINT8 f188;
    UNION f189;
    UNKNOWN f215;
    UNKNOWN_BYTES f216;
    [BindingsDenylist = "dart"]
    UNKNOWN_DATA f217;
    UNSAFE f190;
    UNSIGNED f191;
    UNSIZED f192;
    USE f193;
    USING f194;
    VALUE f195;
    VALUE_OF f196;
    VALUE_UNION f197;
    VALUES_MAP f198;
    VAR f199;
    VEC f200;
    VIRTUAL f201;
    VOID f202;
    VOLATILE f203;
    WCHAR_T f204;
    WHERE f205;
    WHICH f206;
    WHILE f207;
    WITH f208;
    XOR f209;
    XOR_EQ f210;
    XUNION f211;
    YIELD f212;
    ZX f213;
};

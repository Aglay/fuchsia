// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Generated by generate.py.
library fidl.test.dangerous.enums.lower;

enum abstract {
    MEMBER = 1;
};

enum alignas {
    MEMBER = 1;
};

enum alignof {
    MEMBER = 1;
};

enum and {
    MEMBER = 1;
};

enum and_eq {
    MEMBER = 1;
};

enum as {
    MEMBER = 1;
};

enum asm {
    MEMBER = 1;
};

enum assert {
    MEMBER = 1;
};

enum async {
    MEMBER = 1;
};

enum atomic_cancel {
    MEMBER = 1;
};

enum atomic_commit {
    MEMBER = 1;
};

enum atomic_noexcept {
    MEMBER = 1;
};

enum auto {
    MEMBER = 1;
};

enum await {
    MEMBER = 1;
};

enum become {
    MEMBER = 1;
};

enum bitand {
    MEMBER = 1;
};

enum bitor {
    MEMBER = 1;
};

enum bool {
    MEMBER = 1;
};

enum box {
    MEMBER = 1;
};

enum break {
    MEMBER = 1;
};

enum byte {
    MEMBER = 1;
};

enum bytes {
    MEMBER = 1;
};

enum case {
    MEMBER = 1;
};

enum catch {
    MEMBER = 1;
};

enum chan {
    MEMBER = 1;
};

enum char {
    MEMBER = 1;
};

enum char16_t {
    MEMBER = 1;
};

enum char32_t {
    MEMBER = 1;
};

enum class {
    MEMBER = 1;
};

enum co_await {
    MEMBER = 1;
};

enum co_return {
    MEMBER = 1;
};

enum co_yield {
    MEMBER = 1;
};

enum coding_traits {
    MEMBER = 1;
};

enum compl {
    MEMBER = 1;
};

enum concept {
    MEMBER = 1;
};

enum const {
    MEMBER = 1;
};

enum const_cast {
    MEMBER = 1;
};

enum constexpr {
    MEMBER = 1;
};

enum continue {
    MEMBER = 1;
};

enum controller {
    MEMBER = 1;
};

enum covariant {
    MEMBER = 1;
};

enum crate {
    MEMBER = 1;
};

enum decltype {
    MEMBER = 1;
};

enum decoder {
    MEMBER = 1;
};

enum default {
    MEMBER = 1;
};

enum defer {
    MEMBER = 1;
};

enum deferred {
    MEMBER = 1;
};

enum delete {
    MEMBER = 1;
};

enum do {
    MEMBER = 1;
};

enum double {
    MEMBER = 1;
};

enum dynamic {
    MEMBER = 1;
};

enum dynamic_cast {
    MEMBER = 1;
};

enum else {
    MEMBER = 1;
};

enum encoder {
    MEMBER = 1;
};

enum ensure_values_instantiated {
    MEMBER = 1;
};

enum enum {
    MEMBER = 1;
};

enum empty {
    MEMBER = 1;
};

enum err {
    MEMBER = 1;
};

enum explicit {
    MEMBER = 1;
};

enum export {
    MEMBER = 1;
};

enum extends {
    MEMBER = 1;
};

enum extern {
    MEMBER = 1;
};

enum external {
    MEMBER = 1;
};

enum factory {
    MEMBER = 1;
};

enum fallthrough {
    MEMBER = 1;
};

enum false {
    MEMBER = 1;
};

enum fidl {
    MEMBER = 1;
};

enum fidl_type {
    MEMBER = 1;
};

enum final {
    MEMBER = 1;
};

enum finally {
    MEMBER = 1;
};

enum float {
    MEMBER = 1;
};

enum fn {
    MEMBER = 1;
};

enum for {
    MEMBER = 1;
};

enum friend {
    MEMBER = 1;
};

enum func {
    MEMBER = 1;
};

enum future {
    MEMBER = 1;
};

enum futures {
    MEMBER = 1;
};

enum get {
    MEMBER = 1;
};

enum go {
    MEMBER = 1;
};

enum goto {
    MEMBER = 1;
};

enum has_invalid_tag {
    MEMBER = 1;
};

enum hash_code {
    MEMBER = 1;
};

enum if {
    MEMBER = 1;
};

enum impl {
    MEMBER = 1;
};

enum implements {
    MEMBER = 1;
};

enum import {
    MEMBER = 1;
};

enum in {
    MEMBER = 1;
};

enum index {
    MEMBER = 1;
};

enum inline {
    MEMBER = 1;
};

enum int {
    MEMBER = 1;
};

enum int16 {
    MEMBER = 1;
};

enum int32 {
    MEMBER = 1;
};

enum int64 {
    MEMBER = 1;
};

enum int8 {
    MEMBER = 1;
};

enum interface {
    MEMBER = 1;
};

enum internal_tag {
    MEMBER = 1;
};

enum is {
    MEMBER = 1;
};

enum let {
    MEMBER = 1;
};

enum lhs {
    MEMBER = 1;
};

enum library {
    MEMBER = 1;
};

enum list {
    MEMBER = 1;
};

enum long {
    MEMBER = 1;
};

enum loop {
    MEMBER = 1;
};

enum macro {
    MEMBER = 1;
};

enum map {
    MEMBER = 1;
};

enum match {
    MEMBER = 1;
};

enum mixin {
    MEMBER = 1;
};

enum mod {
    MEMBER = 1;
};

enum module {
    MEMBER = 1;
};

enum move {
    MEMBER = 1;
};

enum mut {
    MEMBER = 1;
};

enum mutable {
    MEMBER = 1;
};

enum namespace {
    MEMBER = 1;
};

enum never {
    MEMBER = 1;
};

enum new {
    MEMBER = 1;
};

enum no_such_method {
    MEMBER = 1;
};

enum noexcept {
    MEMBER = 1;
};

enum none {
    MEMBER = 1;
};

enum not {
    MEMBER = 1;
};

enum not_eq {
    MEMBER = 1;
};

enum null {
    MEMBER = 1;
};

enum nullptr {
    MEMBER = 1;
};

enum num {
    MEMBER = 1;
};

enum object {
    MEMBER = 1;
};

enum offset {
    MEMBER = 1;
};

enum offsetof {
    MEMBER = 1;
};

enum ok {
    MEMBER = 1;
};

enum on_open {
    MEMBER = 1;
};

enum operator {
    MEMBER = 1;
};

enum option {
    MEMBER = 1;
};

enum or {
    MEMBER = 1;
};

enum or_eq {
    MEMBER = 1;
};

enum override {
    MEMBER = 1;
};

enum package {
    MEMBER = 1;
};

enum part {
    MEMBER = 1;
};

enum priv {
    MEMBER = 1;
};

enum private {
    MEMBER = 1;
};

enum proc {
    MEMBER = 1;
};

enum protected {
    MEMBER = 1;
};

enum proxy {
    MEMBER = 1;
};

enum pub {
    MEMBER = 1;
};

enum public {
    MEMBER = 1;
};

enum pure {
    MEMBER = 1;
};

enum range {
    MEMBER = 1;
};

enum ref {
    MEMBER = 1;
};

enum register {
    MEMBER = 1;
};

enum reinterpret_cast {
    MEMBER = 1;
};

enum requires {
    MEMBER = 1;
};

enum result {
    MEMBER = 1;
};

enum rethrow {
    MEMBER = 1;
};

enum return {
    MEMBER = 1;
};

enum rhs {
    MEMBER = 1;
};

enum rune {
    MEMBER = 1;
};

enum runtime_type {
    MEMBER = 1;
};

enum select {
    MEMBER = 1;
};

enum self {
    MEMBER = 1;
};

enum send {
    MEMBER = 1;
};

enum set {
    MEMBER = 1;
};

enum set_controller {
    MEMBER = 1;
};

enum short {
    MEMBER = 1;
};

enum signed {
    MEMBER = 1;
};

enum sizeof {
    MEMBER = 1;
};

enum some {
    MEMBER = 1;
};

enum static {
    MEMBER = 1;
};

enum static_assert {
    MEMBER = 1;
};

enum static_cast {
    MEMBER = 1;
};

enum stream {
    MEMBER = 1;
};

enum string {
    MEMBER = 1;
};

enum struct {
    MEMBER = 1;
};

enum stub {
    MEMBER = 1;
};

enum super {
    MEMBER = 1;
};

enum switch {
    MEMBER = 1;
};

enum synchronized {
    MEMBER = 1;
};

enum template {
    MEMBER = 1;
};

enum this {
    MEMBER = 1;
};

enum thread_local {
    MEMBER = 1;
};

enum throw {
    MEMBER = 1;
};

enum to_string {
    MEMBER = 1;
};

enum trait {
    MEMBER = 1;
};

enum true {
    MEMBER = 1;
};

enum try {
    MEMBER = 1;
};

enum type {
    MEMBER = 1;
};

enum typedef {
    MEMBER = 1;
};

enum typeid {
    MEMBER = 1;
};

enum typename {
    MEMBER = 1;
};

enum typeof {
    MEMBER = 1;
};

enum uint16 {
    MEMBER = 1;
};

enum uint32 {
    MEMBER = 1;
};

enum uint64 {
    MEMBER = 1;
};

enum uint8 {
    MEMBER = 1;
};

enum union {
    MEMBER = 1;
};

enum unknown {
    MEMBER = 1;
};

enum unknown_bytes {
    MEMBER = 1;
};

[BindingsDenylist = "dart"]
enum unknown_data {
    MEMBER = 1;
};

enum unsafe {
    MEMBER = 1;
};

enum unsigned {
    MEMBER = 1;
};

enum unsized {
    MEMBER = 1;
};

enum use {
    MEMBER = 1;
};

enum using {
    MEMBER = 1;
};

enum value {
    MEMBER = 1;
};

enum value_of {
    MEMBER = 1;
};

enum value_union {
    MEMBER = 1;
};

enum values_map {
    MEMBER = 1;
};

enum var {
    MEMBER = 1;
};

enum vec {
    MEMBER = 1;
};

enum virtual {
    MEMBER = 1;
};

enum void {
    MEMBER = 1;
};

enum volatile {
    MEMBER = 1;
};

enum wchar_t {
    MEMBER = 1;
};

enum where {
    MEMBER = 1;
};

enum which {
    MEMBER = 1;
};

enum while {
    MEMBER = 1;
};

enum with {
    MEMBER = 1;
};

enum xor {
    MEMBER = 1;
};

enum xor_eq {
    MEMBER = 1;
};

enum xunion {
    MEMBER = 1;
};

enum yield {
    MEMBER = 1;
};

enum zx {
    MEMBER = 1;
};

enum DangerousMembers {
    abstract = 0;
    alignas = 1;
    alignof = 2;
    and = 3;
    and_eq = 4;
    as = 5;
    asm = 6;
    assert = 7;
    async = 8;
    atomic_cancel = 9;
    atomic_commit = 10;
    atomic_noexcept = 11;
    auto = 12;
    await = 13;
    become = 14;
    bitand = 15;
    bitor = 16;
    bool = 17;
    box = 18;
    break = 19;
    byte = 20;
    bytes = 214;
    case = 21;
    catch = 22;
    chan = 23;
    char = 24;
    char16_t = 25;
    char32_t = 26;
    class = 27;
    co_await = 28;
    co_return = 29;
    co_yield = 30;
    coding_traits = 31;
    compl = 32;
    concept = 33;
    const = 34;
    const_cast = 35;
    constexpr = 36;
    continue = 37;
    controller = 38;
    covariant = 39;
    crate = 40;
    decltype = 41;
    decoder = 42;
    default = 43;
    defer = 44;
    deferred = 45;
    delete = 46;
    do = 47;
    double = 48;
    dynamic = 49;
    dynamic_cast = 50;
    else = 51;
    encoder = 52;
    ensure_values_instantiated = 53;
    enum = 54;
    empty = 55;
    err = 56;
    explicit = 57;
    export = 58;
    extends = 59;
    extern = 60;
    external = 61;
    factory = 62;
    fallthrough = 63;
    false = 64;
    fidl = 65;
    fidl_type = 66;
    final = 67;
    finally = 68;
    float = 69;
    fn = 70;
    for = 71;
    friend = 72;
    func = 73;
    future = 74;
    futures = 75;
    get = 76;
    go = 77;
    goto = 78;
    has_invalid_tag = 79;
    hash_code = 80;
    if = 81;
    impl = 82;
    implements = 83;
    import = 84;
    in = 85;
    index = 86;
    inline = 87;
    int = 88;
    int16 = 89;
    int32 = 90;
    int64 = 91;
    int8 = 92;
    interface = 93;
    internal_tag = 94;
    is = 95;
    let = 96;
    lhs = 97;
    library = 98;
    list = 99;
    long = 100;
    loop = 101;
    macro = 102;
    map = 103;
    match = 104;
    mixin = 105;
    mod = 106;
    module = 107;
    move = 108;
    mut = 109;
    mutable = 110;
    namespace = 111;
    never = 112;
    new = 113;
    no_such_method = 114;
    noexcept = 115;
    none = 116;
    not = 117;
    not_eq = 118;
    null = 119;
    nullptr = 120;
    num = 121;
    object = 122;
    offset = 123;
    offsetof = 124;
    ok = 125;
    on_open = 126;
    operator = 127;
    option = 128;
    or = 129;
    or_eq = 130;
    override = 131;
    package = 132;
    part = 133;
    priv = 134;
    private = 135;
    proc = 136;
    protected = 137;
    proxy = 138;
    pub = 139;
    public = 140;
    pure = 141;
    range = 142;
    ref = 143;
    register = 144;
    reinterpret_cast = 145;
    requires = 146;
    result = 147;
    rethrow = 148;
    return = 149;
    rhs = 150;
    rune = 151;
    runtime_type = 152;
    select = 153;
    self = 154;
    send = 155;
    set = 156;
    set_controller = 157;
    short = 158;
    signed = 159;
    sizeof = 160;
    some = 161;
    static = 162;
    static_assert = 163;
    static_cast = 164;
    stream = 165;
    string = 166;
    struct = 167;
    stub = 168;
    super = 169;
    switch = 170;
    synchronized = 171;
    template = 172;
    this = 173;
    thread_local = 174;
    throw = 175;
    to_string = 176;
    trait = 177;
    true = 178;
    try = 179;
    type = 180;
    typedef = 181;
    typeid = 182;
    typename = 183;
    typeof = 184;
    uint16 = 185;
    uint32 = 186;
    uint64 = 187;
    uint8 = 188;
    union = 189;
    unknown = 215;
    unknown_bytes = 216;
    [BindingsDenylist = "dart"]
    unknown_data = 217;
    unsafe = 190;
    unsigned = 191;
    unsized = 192;
    use = 193;
    using = 194;
    value = 195;
    value_of = 196;
    value_union = 197;
    values_map = 198;
    var = 199;
    vec = 200;
    virtual = 201;
    void = 202;
    volatile = 203;
    wchar_t = 204;
    where = 205;
    which = 206;
    while = 207;
    with = 208;
    xor = 209;
    xor_eq = 210;
    xunion = 211;
    yield = 212;
    zx = 213;
};

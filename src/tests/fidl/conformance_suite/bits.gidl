// Copyright 2020 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

success("StrictBitsUint8KnownValue") {
    value = StrictBitsUint8Struct {
        b: 1,
    },
    bytes = {
        v1 = [
            0x01, padding:7,
        ],
    },
}

success("StrictBitsUint8CombinedValue") {
    value = StrictBitsUint8Struct {
        b: 3,
    },
    bytes = {
        v1 = [
            0x03, padding:7,
        ],
    },
}

success("StrictBitsUint16KnownValue") {
    value = StrictBitsUint16Struct {
        b: 1,
    },
    bytes = {
        v1 = [
            0x01, 0x00, padding:6,
        ],
    },
}

success("StrictBitsUint16CombinedValue") {
    value = StrictBitsUint16Struct {
        b: 3,
    },
    bytes = {
        v1 = [
            0x03, 0x00, padding:6,
        ],
    },
}

success("StrictBitsUint32KnownValue") {
    value = StrictBitsUint32Struct {
        b: 1,
    },
    bytes = {
        v1 = [
            0x01, 0x00, 0x00, 0x00, padding:4,
        ],
    },
}

success("StrictBitsUint32CombinedValue") {
    value = StrictBitsUint32Struct {
        b: 3,
    },
    bytes = {
        v1 = [
            0x03, 0x00, 0x00, 0x00, padding:4,
        ],
    },
}
success("StrictBitsUint64KnownValue") {
    value = StrictBitsUint64Struct {
        b: 1,
    },
    bytes = {
        v1 = [
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ],
    },
}

success("StrictBitsUint64CombinedValue") {
    value = StrictBitsUint64Struct {
        b: 3,
    },
    bytes = {
        v1 = [
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ],
    },
}

success("FlexibleBitsKnownValue") {
    value = FlexibleBitsStruct {
        b: 1,
    },
    bytes = {
        v1 = [
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ],
    },
}

success("FlexibleBitsUnknownValue") {
    // TODO(fxb/7847): Implement flexible bits
    // NOTE: Go does not validate bits so passes this test, but does not yet fully
    // implement flexible bits
    bindings_denylist = [dart,rust,cpp,llcpp],
    value = FlexibleBitsStruct {
        b: 0xffffffff,
    },
    bytes = {
        v1 = [
            0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        ],
    },
}

success("FlexibleBitsUint64UnknownValue") {
    // TODO(fxb/7847): Implement flexible bits
    // NOTE: Go does not validate bits so passes this test, but does not yet fully
    // implement flexible bits
    bindings_denylist = [dart,rust,cpp,llcpp],
    value = FlexibleBitsUint64Struct {
        b: 0x0102030405060708,
    },
    bytes = {
        v1 = [
            0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01,
        ],
    },
}

encode_failure("StrictBitsUint8UnknownBit") {
    // TODO(fxb/7847): Implement strict bits in Go.
    // Rust: cannot construct invalid bits.
    bindings_denylist = [go,rust],
    value = StrictBitsUint8Struct {
        b: 4,
    },
    err = STRICT_BITS_UNKNOWN_BIT,
}

encode_failure("StrictBitsUint16UnknownBit") {
    // TODO(fxb/7847): Implement strict bits in Go.
    // Rust: cannot construct invalid bits.
    bindings_denylist = [go,rust],
    value = StrictBitsUint16Struct {
        b: 4,
    },
    err = STRICT_BITS_UNKNOWN_BIT,
}

encode_failure("StrictBitsUint32UnknownBit") {
    // TODO(fxb/7847): Implement strict bits in Go.
    // Rust: cannot construct invalid bits.
    bindings_denylist = [go,rust],
    value = StrictBitsUint32Struct {
        b: 4,
    },
    err = STRICT_BITS_UNKNOWN_BIT,
}

encode_failure("StrictBitsUint64UnknownBit") {
    // TODO(fxb/7847): Implement strict bits in Go.
    // Rust: cannot construct invalid bits.
    bindings_denylist = [go,rust],
    value = StrictBitsUint64Struct {
        b: 4,
    },
    err = STRICT_BITS_UNKNOWN_BIT,
}

decode_failure("StrictBitsUint8UnknownBit") {
    // TODO(fxb/7847): Implement strict bits in Go.
    bindings_denylist = [go],
    type = StrictBitsUint8Struct,
    bytes = {
        v1 = [
            0x04, padding:7,
        ],
    },
    err = STRICT_BITS_UNKNOWN_BIT,
}

decode_failure("StrictBitsUint16UnknownBit") {
    // TODO(fxb/7847): Implement strict bits in Go.
    bindings_denylist = [go],
    type = StrictBitsUint16Struct,
    bytes = {
        v1 = [
            0x04, 0x00, padding:6
        ],
    },
    err = STRICT_BITS_UNKNOWN_BIT,
}

decode_failure("StrictBitsUint32UnknownBit") {
    // TODO(fxb/7847): Implement strict bits in Go.
    bindings_denylist = [go],
    type = StrictBitsUint32Struct,
    bytes = {
        v1 = [
            0x04, 0x00, 0x00, 0x00, padding:4,
        ],
    },
    err = STRICT_BITS_UNKNOWN_BIT,
}

decode_failure("StrictBitsUint64UnknownBit") {
    // TODO(fxb/7847): Implement strict bits in Go.
    bindings_denylist = [go],
    type = StrictBitsUint64Struct,
    bytes = {
        v1 = [
            0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ],
    },
    err = STRICT_BITS_UNKNOWN_BIT,
}

// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

success("EmptyStruct") {
    value = EmptyStruct {
    },
    bytes = [
        8:raw(
            0x00, // one byte
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // padding
        ),
    ],
}

success("EmptyStructSandwich") {
    value = EmptyStructSandwich {
        before: "before",
        es: EmptyStruct {},
        after: "after",
    },
    bytes = [
        56:raw(
            6, 0, 0, 0, 0, 0, 0, 0, // length of "before"
            255, 255, 255, 255, 255, 255, 255, 255, // "before" is present
            0,                   // empty struct zero field
            0, 0, 0, 0, 0, 0, 0, // 7 bytes of padding after empty struct, to align to 64 bits
            5, 0, 0, 0, 0, 0, 0, 0, // length of "after"
            255, 255, 255, 255, 255, 255, 255, 255, // "after" is present
            'b', 'e', 'f', 'o', 'r', 'e',
            0, 0, // 2 bytes of padding after "before", to align to 64 bits
            'a', 'f', 't', 'e', 'r', // "after" string
            0, 0, 0, // 3 bytes of padding after "after", to align to 64 bits
        ),
    ],
}

success("Uint8Uint16Uint32Uint64") {
    value = Uint8Uint16Uint32Uint64 {
        f1: 0x01,
        f2: 0x0203,
        f3: 0x04050607,
        f4: 0x08090a0b0c0d0e0f,
    },
    bytes = [
        16:raw(
            0x01, // f1
            0x00, // padding
            0x03, 0x02, // f2
            0x07, 0x06, 0x05, 0x04, // f3
            0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a, 0x09, 0x08, // f4
        ),
    ],
}

success("Uint64Uint32Uint16Uint8") {
    value = Uint64Uint32Uint16Uint8 {
        f1: 0x08090a0b0c0d0e0f,
        f2: 0x04050607,
        f3: 0x0203,
        f4: 0x01,
    },
    bytes = [
        16:raw(
            0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a, 0x09, 0x08, // f1
            0x07, 0x06, 0x05, 0x04, // f2
            0x03, 0x02, // f3
            0x01, // f4
            0x00, // padding
        ),
    ],
}

success("SimpleTableEmpty") {
    value = StructOfSimpleTable {
        table: SimpleTable {},
    },
    bytes = [
        16:raw(
            0, 0, 0, 0, 0, 0, 0, 0, // max ordinal
            255, 255, 255, 255, 255, 255, 255, 255, // alloc present
        ),
    ],
}

success("SimpleTableXAndY") {
    value = StructOfSimpleTable {
        table: SimpleTable {
            x: 42,
            y: 67,
        },
    },
    bytes = [
        112:raw(
            5, 0, 0, 0, 0, 0, 0, 0, // max ordinal
            255, 255, 255, 255, 255, 255, 255, 255, // alloc present
            8, 0, 0, 0, 0, 0, 0, 0, // envelope 1: num bytes / num handles
            255, 255, 255, 255, 255, 255, 255, 255, // alloc present
            0, 0, 0, 0, 0, 0, 0, 0, // envelope 2: num bytes / num handles
            0, 0, 0, 0, 0, 0, 0, 0, // no alloc
            0, 0, 0, 0, 0, 0, 0, 0, // envelope 3: num bytes / num handles
            0, 0, 0, 0, 0, 0, 0, 0, // no alloc
            0, 0, 0, 0, 0, 0, 0, 0, // envelope 4: num bytes / num handles
            0, 0, 0, 0, 0, 0, 0, 0, // no alloc
            8, 0, 0, 0, 0, 0, 0, 0, // envelope 5: num bytes / num handles
            255, 255, 255, 255, 255, 255, 255, 255, // alloc present
            42, 0, 0, 0, 0, 0, 0, 0, // field X
            67, 0, 0, 0, 0, 0, 0, 0, // field Y
        ),
    ],
}

success("SimpleTableJustY") {
    value = StructOfSimpleTable {
        table: SimpleTable {
            y: 67,
        },
    },
    bytes = [
        104:raw(
            5, 0, 0, 0, 0, 0, 0, 0, // max ordinal
            255, 255, 255, 255, 255, 255, 255, 255, // alloc present
            0, 0, 0, 0, 0, 0, 0, 0, // envelope 1: num bytes / num handles
            0, 0, 0, 0, 0, 0, 0, 0, // no alloc
            0, 0, 0, 0, 0, 0, 0, 0, // envelope 2: num bytes / num handles
            0, 0, 0, 0, 0, 0, 0, 0, // no alloc
            0, 0, 0, 0, 0, 0, 0, 0, // envelope 3: num bytes / num handles
            0, 0, 0, 0, 0, 0, 0, 0, // no alloc
            0, 0, 0, 0, 0, 0, 0, 0, // envelope 4: num bytes / num handles
            0, 0, 0, 0, 0, 0, 0, 0, // no alloc
            8, 0, 0, 0, 0, 0, 0, 0, // envelope 5: num bytes / num handles
            255, 255, 255, 255, 255, 255, 255, 255, // alloc present
            67, 0, 0, 0, 0, 0, 0, 0, // field Y
        ),
    ],
}

success("TableWithStringAndVectorNoVectorContent") {
    value = StructOfTableWithStringAndVector {
        table: TableWithStringAndVector {
            foo: "hello",
            bar: 27,
        },
    },
    bytes = [
        80:raw(
            2, 0, 0, 0, 0, 0, 0, 0, // max ordinal
            255, 255, 255, 255, 255, 255, 255, 255, // alloc present
            24, 0, 0, 0, 0, 0, 0, 0, // envelope 1: num bytes / num handles
            255, 255, 255, 255, 255, 255, 255, 255, // envelope 1: alloc present
            8, 0, 0, 0, 0, 0, 0, 0, // envelope 2: num bytes / num handles
            255, 255, 255, 255, 255, 255, 255, 255, // envelope 2: alloc present
            5, 0, 0, 0, 0, 0, 0, 0, // element 1: length
            255, 255, 255, 255, 255, 255, 255, 255, // element 1: alloc present
            104, 101, 108, 108, 111, 0, 0, 0, // element 1: hello
            27, 0, 0, 0, 0, 0, 0, 0, // element 2: value
        ),
    ],
}

// TODO(FIDL-626): Create test with TableWithStringAndVectorHasVectorContent.

success("SimpleTableThenUint64") {
    value = SimpleTableThenUint64 {
        table: SimpleTable {
            x: 42,
            y: 67,
        },
        number: 0xdeadbeefdeadbeef,
    },
    bytes = [
        120:raw(
            5, 0, 0, 0, 0, 0, 0, 0, // max ordinal
            255, 255, 255, 255, 255, 255, 255, 255, // alloc present
            0xef, 0xbe, 0xad, 0xde, 0xef, 0xbe, 0xad, 0xde, // uint64 number
            8, 0, 0, 0, 0, 0, 0, 0, // envelope 1: num bytes / num handles
            255, 255, 255, 255, 255, 255, 255, 255, // alloc present
            0, 0, 0, 0, 0, 0, 0, 0, // envelope 2: num bytes / num handles
            0, 0, 0, 0, 0, 0, 0, 0, // no alloc
            0, 0, 0, 0, 0, 0, 0, 0, // envelope 3: num bytes / num handles
            0, 0, 0, 0, 0, 0, 0, 0, // no alloc
            0, 0, 0, 0, 0, 0, 0, 0, // envelope 4: num bytes / num handles
            0, 0, 0, 0, 0, 0, 0, 0, // no alloc
            8, 0, 0, 0, 0, 0, 0, 0, // envelope 5: num bytes / num handles
            255, 255, 255, 255, 255, 255, 255, 255, // alloc present
            42, 0, 0, 0, 0, 0, 0, 0, // field X
            67, 0, 0, 0, 0, 0, 0, 0, // field Y
        ),
    ],
}

success("ReverseOrdinalTable") {
    value = StructOfReverseOrdinalTable {
        table: ReverseOrdinalTable {
            x: 0xaa,
            y: 0xbb,
            z: 0xcc,
        },
    },
    bytes = [
        104:raw(
            // table
            0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // max ordinal 4
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // present
            // z envelope (ordinal 1)
            0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 8 bytes, 0 handles
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // present
            // y envelope (ordinal 2)
            0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 8 bytes, 0 handles
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // present
            // empty envelope (reserved ordinal 3)
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0 bytes, 0 handles
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // null
            // x envelope (ordinal 4)
            0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 8 bytes, 0 handles
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // present

            0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // z
            0xbb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // y
            0xaa, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // x
        ),
    ],
}

decode_success("TableWithUnknownReservedFields") {
    bytes = [
        120:raw(
            5, 0, 0, 0, 0, 0, 0, 0, // max ordinal
            255, 255, 255, 255, 255, 255, 255, 255, // alloc present
            8, 0, 0, 0, 0, 0, 0, 0, // envelope 1: num bytes / num handles
            255, 255, 255, 255, 255, 255, 255, 255, // alloc present
            0, 0, 0, 0, 0, 0, 0, 0, // envelope 2: num bytes / num handles
            0, 0, 0, 0, 0, 0, 0, 0, // no alloc
            8, 0, 0, 0, 0, 0, 0, 0, // envelope 3: num bytes / num handles
            255, 255, 255, 255, 255, 255, 255, 255, // alloc present
            0, 0, 0, 0, 0, 0, 0, 0, // envelope 4: num bytes / num handles
            0, 0, 0, 0, 0, 0, 0, 0, // no alloc
            8, 0, 0, 0, 0, 0, 0, 0, // envelope 5: num bytes / num handles
            255, 255, 255, 255, 255, 255, 255, 255, // alloc present
            42, 0, 0, 0, 0, 0, 0, 0, // field X
            1,  2, 3, 4, 5, 6, 7, 8, // 8 unknown bytes for envelope 3
            67, 0, 0, 0, 0, 0, 0, 0, // field Y
        ),
    ],
    value = StructOfSimpleTable {
        table: SimpleTable {
            x: 42,
            y: 67,
        },
    },
}

decode_success("TableWithUnknownTrailingFields") {
    bytes = [
        136:raw(
            6, 0, 0, 0, 0, 0, 0, 0, // max ordinal
            255, 255, 255, 255, 255, 255, 255, 255, // alloc present
            8, 0, 0, 0, 0, 0, 0, 0, // envelope 1: num bytes / num handles
            255, 255, 255, 255, 255, 255, 255, 255, // alloc present
            0, 0, 0, 0, 0, 0, 0, 0, // envelope 2: num bytes / num handles
            0, 0, 0, 0, 0, 0, 0, 0, // no alloc
            0, 0, 0, 0, 0, 0, 0, 0, // envelope 3: num bytes / num handles
            0, 0, 0, 0, 0, 0, 0, 0, // no alloc
            0, 0, 0, 0, 0, 0, 0, 0, // envelope 4: num bytes / num handles
            0, 0, 0, 0, 0, 0, 0, 0, // no alloc
            8, 0, 0, 0, 0, 0, 0, 0, // envelope 5: num bytes / num handles
            255, 255, 255, 255, 255, 255, 255, 255, // alloc present
            8, 0, 0, 0, 0, 0, 0, 0, // envelope 6: num bytes / num handles
            255, 255, 255, 255, 255, 255, 255, 255, // alloc present
            42, 0, 0, 0, 0, 0, 0, 0, // field X
            67, 0, 0, 0, 0, 0, 0, 0, // field Y
            1,  2, 3, 4, 5, 6, 7, 8, // 8 unknown bytes for envelope 6
        ),
    ],
    value = StructOfSimpleTable {
        table: SimpleTable {
            x: 42,
            y: 67,
        },
    },
}

success("InlineXUnionInStruct") {
    value = TestInlineXUnionInStruct {
        before: "before",
        xu: SampleXUnion {
            u: 0xdeadbeef,
        },
        after: "after",
    },
    bytes = [
        80:raw(
            0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // "before" length
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // "before" presence

            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // xunion discriminator + padding
            0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // num bytes + num handles
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // envelope data is present

            0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // "after" length
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // "before" presence

            // secondary object 1: "before"
            'b', 'e', 'f', 'o', 'r', 'e', 0x00, 0x00,

            // secondary object 2: xunion content
            0xef, 0xbe, 0xad, 0xde, 0x00, 0x00, 0x00, 0x00, // xunion envelope content (0xdeadbeef) + padding

            // secondary object 3: "after"
            'a', 'f', 't', 'e', 'r', 0x00, 0x00, 0x00,
        ),
    ],
    bindings_denylist = [transformer],
}

success("OptionalXUnionInStructAbsent") {
    value = TestOptionalXUnionInStruct {
        before: "before",
        // no SampleXUnion
        after: "after",
    },
    bytes = [
        72:raw(
            0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // "before" length
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // "before" presence

            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // xunion discriminator + padding
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // num bytes + num handles
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // envelope data is absent

            0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // "after" length
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // "before" presence

            // secondary object 1: "before"
            'b', 'e', 'f', 'o', 'r', 'e', 0x00, 0x00,

            // secondary object 2: "after"
            'a', 'f', 't', 'e', 'r', 0x00, 0x00, 0x00,
        ),
    ],
    bindings_denylist = [transformer],
}

success("OptionalXUnionInStructPresent") {
    value = TestOptionalXUnionInStruct {
        before: "before",
        xu: SampleXUnion {
            u: 0xdeadbeef,
        },
        after: "after",
    },
    bytes = [
        80:raw(
            0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // "before" length
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // "before" presence

            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // xunion discriminator + padding
            0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // num bytes + num handles
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // envelope data is present

            0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // "after" length
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // "after" presence

            // secondary object 1: "before"
            'b', 'e', 'f', 'o', 'r', 'e', 0x00, 0x00,

            // secondary object 2: xunion content
            0xef, 0xbe, 0xad, 0xde, 0x00, 0x00, 0x00, 0x00, // xunion envelope content (0xdeadbeef) + padding

            // secondary object 3: "after"
            'a', 'f', 't', 'e', 'r', 0x00, 0x00, 0x00,
        ),
    ],
    bindings_denylist = [transformer],
}

success("XUnionInTableXUnionAbsent") {
    value = TestXUnionInTable {
        value: XUnionInTable {
            before: "before",
            // no SampleXUnion
            after: "after",
        },
    },
    bytes = [
        112:raw(
            // primary object
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // vector<envelope> element count
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // vector<envelope> present

            // secondary object 1: vector data
            // vector[0]: envelope<string before>
            0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // size + handle count
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // "before" is present
            // vector[1]: envelope<SampleXUnion xu>
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // size + handle count
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // xunion is absent
            // vector[2]: envelope<string after>
            0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // size + handle count
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // "after" is present

            // secondary object 2: "before" length + pointer
            0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // "before" length
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // "before" present

            // secondary object 3: "before"
            'b', 'e', 'f', 'o', 'r', 'e', 0x00, 0x00, // "before"

            // secondary object 4: "after" length + pointer
            0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // "after" length
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // "after" present

            // secondary object 5: "before"
            'a', 'f', 't', 'e', 'r', 0x00, 0x00, 0x00, // "after"
        ),
    ],
}

success("XUnionInTableXUnionPresent") {
    value = TestXUnionInTable {
        value: XUnionInTable {
            before: "before",
            xu: SampleXUnion {
                u: 0xdeadbeef,
            },
            after: "after",
        },
    },
    bytes = [
        144:raw(
            // primary object
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // vector<envelope> element count
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // vector<envelope> present

            // secondary object 1: vector data
            // vector[0]: envelope<string before>
            0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // size + handle count
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // "before" is present
            // vector[1]: envelope<SampleXUnion xu>
            0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // size + handle count
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // xunion is present
            // vector[2]: envelope<string after>
            0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // size + handle count
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // "after" is present

            // secondary object 2: "before" length + pointer
            0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // "before" length
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // "before" present

            // secondary object 3: "before"
            'b', 'e', 'f', 'o', 'r', 'e', 0x00, 0x00, // "before"

            // secondary object 4: xunion
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // xunion discriminator + padding
            0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // num bytes + num handles
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // envelope data is present

            // secondary object 5: xunion content
            0xef, 0xbe, 0xad, 0xde, 0x00, 0x00, 0x00, 0x00, // 0xdeadbeef + padding

            // secondary object 6: "after" length + pointer
            0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // "after" length
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // "after" present

            // secondary object 7: "before"
            'a', 'f', 't', 'e', 'r', 0x00, 0x00, 0x00, // "after"
        ),
    ],
    bindings_denylist = [transformer],
}

success("Flexible XUnion Field Unknown") {
    // TODO(8047) Enable support for this in language bindings after determining how it should
    // be handled in each binding.
    bindings_allowlist = [],
    value = TestFlexibleXUnionInStruct {
        xu: SampleXUnion{
            0x01020304: Int64Struct {
                x: 5,
            },
        },
    },
    bytes = [
        32:raw(
            0x04, 0x03, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00,  // invalid ordinal + padding
            0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // envelope: # of bytes + # of handles
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,  // envelope: data is present
            0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // fake out-of-line data
        ),
    ],
}

success("StrictXUnion") {
    value = TestStrictXUnionInStruct {
        xu: SampleStrictXUnion {
            u: 0xdeadbeef,
        },
    },
    bytes = [
        32:raw(
            0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
            0xef,0xbe,0xad,0xde,0x00,0x00,0x00,0x00,
        ),
    ],
    bindings_denylist = [transformer],
}

encode_failure("StrictXUnion Field Not Set") {
    // TODO(8047) Enable this. Currently only go supports this error.
    bindings_allowlist = [go,],
    value = TestStrictXUnionInStruct {
        xu: SampleStrictXUnion {},
    },
    err = STRICT_UNION_FIELD_NOT_SET,
}

decode_failure("StrictXUnion Field Unknown") {
    // TODO(8047) Enable this. Currently only go supports this error.
    bindings_allowlist = [dart,go,],
    type = TestStrictXUnionInStruct,
    bytes = [
        32:raw(
            0x11, 0xba, 0x5e, 0xba, 0x00, 0x00, 0x00, 0x00,  // invalid ordinal + padding
            0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // envelope: # of bytes + # of handles
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,  // envelope: data is present
            0xde, 0xad, 0xbe, 0xef, 0x5c, 0xa1, 0xab, 0x1e,  // fake out-of-line data
        ),
    ],
    err = STRICT_UNION_UNKNOWN_FIELD,
}

success("AddEthernetDeviceRequest") {
    value = TestAddEthernetDeviceRequest {
        topological_path: "@/dev/sys/pci/00:03.0/e1000/ethernet",
        config: InterfaceConfig {
            name: "ethp0003",
            ip_address_config: IpAddressConfig {
                dhcp: true,
            },
        },
        // TODO(FIDL-625): This should be a handle.
        this_should_be_a_handle: 0xffffffff,
    },
    bytes = {
        old = [
            120:raw(
                0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // topological_path
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // topological_path
                0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // name
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // name
                0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, // subnet (dhcp variant)
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // padding
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // padding
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // padding
                0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, // device (handle present)
                0x40, 0x2f, 0x64, 0x65, 0x76, 0x2f, 0x73, 0x79, // @/dev/sy
                0x73, 0x2f, 0x70, 0x63, 0x69, 0x2f, 0x30, 0x30, // s/pci/00
                0x3a, 0x30, 0x33, 0x2e, 0x30, 0x2f, 0x65, 0x31, // :03.0/e1
                0x30, 0x30, 0x30, 0x2f, 0x65, 0x74, 0x68, 0x65, // 000/ethe
                0x72, 0x6e, 0x65, 0x74, 0x00, 0x00, 0x00, 0x00, // rnet
                0x65, 0x74, 0x68, 0x70, 0x30, 0x30, 0x30, 0x33, // ethp0003
            ),
        ],
        v1 = [
            120:raw(
                0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // topological_path
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // topological_path
                0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // name
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // name
                0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // subnet (dhcp ordinal)
                0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //   8 bytes, 0 handles
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //   present
                0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, // device (handle present)
                0x40, 0x2f, 0x64, 0x65, 0x76, 0x2f, 0x73, 0x79, // @/dev/sy
                0x73, 0x2f, 0x70, 0x63, 0x69, 0x2f, 0x30, 0x30, // s/pci/00
                0x3a, 0x30, 0x33, 0x2e, 0x30, 0x2f, 0x65, 0x31, // :03.0/e1
                0x30, 0x30, 0x30, 0x2f, 0x65, 0x74, 0x68, 0x65, // 000/ethe
                0x72, 0x6e, 0x65, 0x74, 0x00, 0x00, 0x00, 0x00, // rnet
                0x65, 0x74, 0x68, 0x70, 0x30, 0x30, 0x30, 0x33, // ethp0003
                0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // dhcp = true
            ),
        ],
    },
}

success("FileGetAttrResponse") {
    value = FileGetAttrResponse {
        s: 0x7eadbeaf,
        attributes: NodeAttributes {
            mode: 0x962381a4,
            id: 1,
            content_size: 231,
            storage_size: 231,
            link_count: 1,
            creation_time: 0x8877665544332211,
            modification_time: 0x00ffeeddccbbaa99,
        },
    },
    bytes = [
        64:raw(
            0xaf, 0xbe, 0xad, 0x7e, 0x00, 0x00, 0x00, 0x00,
            0xa4, 0x81, 0x23, 0x96, 0x00, 0x00, 0x00, 0x00,
            1, 0, 0, 0, 0, 0, 0, 0,
            231, 0, 0, 0, 0, 0, 0, 0,
            231, 0, 0, 0, 0, 0, 0, 0,
            1, 0, 0, 0, 0, 0, 0, 0,
            0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
            0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00,
        ),
    ],
}

// See comment in optionals.test.fidl for why this test case exists.
success("Optionals") {
    value = StructWithOptionals {
        s: EmptyStruct {
        },
        s2: EmptyStruct {
        },
        t: TableWithEmptyStruct {
            s: EmptyStruct {},
        },
        xu: XUnionWithEmptyStruct {
            s: EmptyStruct {},
        },
        xu2: XUnionWithEmptyStruct {
            s: EmptyStruct {},
        },
        u: UnionWithEmptyStruct {
            s: EmptyStruct {},
        },
        u2: UnionWithEmptyStruct {
            s: EmptyStruct {},
        },
    },
    bytes = {
        old = [
            128:raw(
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // EmptyStruct
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // EmptyStruct? present
                0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // TableWithEmptyStruct length 1
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //   present
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // XUnionWithEmptyStruct tag 0
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // XUnionWithEmptyStruct? present
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // UnionWithEmptyStruct tag 0
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // padding
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // UnionWithEmptyStruct? present

                // secondary objects
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // EmptyStruct
                0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // envelope 8 bytes, 0 handles
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //   present
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // EmptyStruct (table t)
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // XUnionWithEmptyStruct tag 0
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // UnionWithEmptyStruct tag 0
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // padding
            ),
        ],
        v1 = [
            192:raw(
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // EmptyStruct
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // EmptyStruct? present
                0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // TableWithEmptyStruct length 1
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //   present
                0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // XUnionWithEmptyStruct ordinal
                0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //   8 bytes, 0 handles
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //   present
                0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // XUnionWithEmptyStruct? ordinal
                0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //   8 bytes, 0 handles
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //   present
                0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // UnionWithEmptyStruct ordinal
                0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //   8 bytes, 0 handles
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //   present
                0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // UnionWithEmptyStruct? ordinal
                0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //   8 bytes, 0 handles
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //   present

                // secondary objects
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // EmptyStruct
                0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // envelope 8 bytes, 0 handles
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //   present
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // EmptyStruct (table t)
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // EmptyStruct (xunion xu)
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // EmptyStruct (xunion xu2)
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // EmptyStruct (union u)
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // EmptyStruct (union u2)
            ),
        ],
    },
}

success("Arrays") {
    value = StructWithArrays {
        arr_int: [1, 2,],
        arr_string: ["a", "b",],
        arr_nullable_string: ["c", null,],
        arr_struct: [StructWithInt{x: 1,},StructWithInt{x: 2,},],
        arr_nullable_struct: [null,StructWithInt{x: 0x01020304,},],
        arr_arr_int: [[1, 2, 3,], [4, 5, 6,],],
    },
    bytes = [
        152:raw(
            // primary object
            0x01,0x00,0x00,0x00,0x02,0x00,0x00,0x00, // arr_int: 1, 2
            0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // arr_string: "a" size 1
            0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, //   "a" present
            0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //   "b" size 1
            0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, //   "b" present
            0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // arr_nullable_string: "c" size 1
            0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, //   "c" present
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //   null size 0
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //   null not present
            0x01,0x00,0x00,0x00,0x02,0x00,0x00,0x00, // arr_struct: {x: 1}, {x: 2}
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // arr_nullable_struct: null not present
            0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, //   {x: 0x01020304} present
            0x01,0x00,0x00,0x00,0x02,0x00,0x00,0x00, // arr_arr_int: 1, 2,
            0x03,0x00,0x00,0x00,0x04,0x00,0x00,0x00, //   3, 4,
            0x05,0x00,0x00,0x00,0x06,0x00,0x00,0x00, //   5, 6,

            // secondary objects
            0x61,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // "a"
            0x62,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // "b"
            0x63,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // "c"
            0x04,0x03,0x02,0x01,0x00,0x00,0x00,0x00, // {x: 0x01020304} + padding
        ),
    ],
}

success("Vectors") {
    value = StructWithVectors {
        vec_empty: [],
        vec_int: [1, 2,],
        vec_string: ["a", "b",],
        vec_nullable_string: [null, "c", null,],
        vec_struct: [StructWithInt{x: 1,},],
        vec_nullable_struct: [null, null, StructWithInt{x: 2,},],
        vec_vec_int: [[1, 2,], [3,],],
    },
    bytes = [
        312:raw(
            // primary object
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // vec_empty: size 0
            0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, //   present
            0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // vec_int: size 2
            0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, //   present
            0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // vec_string: size 2
            0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, //   present
            0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // vec_nullable_string: size 3
            0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, //   present
            0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // vec_struct: size 1
            0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, //   present
            0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // vec_nullable_struct: size 3
            0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, //   present
            0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // vec_vec_int: size 2
            0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, //   present

            // secondary objects
            0x01,0x00,0x00,0x00,0x02,0x00,0x00,0x00, // vec_int: 1, 2
            0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // vec_string: "a" size 1
            0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, //   "a" present
            0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //   "b" size 1
            0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, //   "b" present
            0x61,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // "a"
            0x62,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // "b"
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // vec_nullable_string: null size 0
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //   null not present
            0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //   "c" size 1
            0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, //   "c" present
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //   null size 0
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //   null not present
            0x63,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // "c"
            0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // vec_struct: {x: 1}
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // vec_nullable_struct: null not present
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //   null not present
            0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, //   {x: 2} present
            0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // {x: 2}
            0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // vec_vec_int: [1, 2] size 2
            0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, //   [1, 2] present
            0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //   [3] size 1
            0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, //   [3] present
            0x01,0x00,0x00,0x00,0x02,0x00,0x00,0x00, // [1, 2]
            0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // [3]
        ),
    ],
}

encode_failure("StringExceedsLimit") {
    // TODO(fxb/37304) Enforce size bounds in rust
    bindings_denylist = [rust],
    value = Length2StringWrapper {
        length_2_string: "abc", // exceeds the string length
    },
    err = STRING_TOO_LONG,
}

decode_failure("NonEmptyStringWithNullPtrBody") {
    type = StringWrapper,
    bytes = [
        16:raw(
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // length of string data
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // invalid null pointer to content
        ),
    ],
    err = NON_EMPTY_STRING_WITH_NULL_BODY,
}

success("StrictBitsKnownValue") {
    value = StrictBitsStruct {
        b: 1,
    },
    bytes = [
        8:raw(
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        )
    ],
}

success("StrictBitsCombinedValue") {
    value = StrictBitsStruct {
        b: 3,
    },
    bytes = [
        8:raw(
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        )
    ],
}

encode_failure("StrictBitsUnknownBit") {
    // TODO(fxb/7874): Implement strict bits in Dart and Go.
    // Rust: cannot construct invalid bits.
    bindings_denylist = [dart,go,rust],
    value = StrictBitsStruct {
        b: 4,
    },
    err = STRICT_BITS_UNKNOWN_BIT,
}

decode_failure("StrictBitsUnknownBit") {
    // TODO(fxb/7874): Implement strict bits in Dart and Go.
    bindings_denylist = [dart,go],
    type = StrictBitsStruct,
    bytes = [
        8:raw(
            0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ),
    ],
    err = STRICT_BITS_UNKNOWN_BIT,
}

success("FlexibleBitsKnownValue") {
    value = FlexibleBitsStruct {
        b: 1,
    },
    bytes = [
        8:raw(
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        )
    ],
}

success("FlexibleBitsUnknownValue") {
    // TODO(fxb/7874): Implement flexible bits in Rust, HLCPP, and LLCPP.
    bindings_denylist = [rust,cpp,llcpp],
    value = FlexibleBitsStruct {
        b: 0xffffffff,
    },
    bytes = [
        8:raw(
            0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        )
    ],
}

success("FlexibleBitsUint64UnknownValue") {
    // TODO(fxb/7874): Implement flexible bits in Rust, HLCPP, and LLCPP.
    bindings_denylist = [rust,cpp,llcpp],
    value = FlexibleBitsUint64Struct {
        b: 0x0102030405060708,
    },
    bytes = [
        8:raw(
            0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01,
        )
    ],
}

success("StrictEnumKnownValue") {
    value = StrictEnumStruct {
        e: 1,
    },
    bytes = [
        8:raw(
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ),
    ],
}

encode_failure("StrictEnumUnknownValue") {
    // TODO(fxb/7874): Implement strict enums in Dart and Go.
    // Rust: cannot construct invalid enum.
    bindings_denylist = [dart,go,rust],
    value = StrictEnumStruct {
        e: 3,
    },
    err = STRICT_ENUM_UNKOWN_VALUE,
}

decode_failure("StrictEnumUnknownValue") {
    // TODO(fxb/7874): Implement strict enums in Dart and Go.
    bindings_denylist = [dart,go],
    type = StrictEnumStruct,
    bytes = [
        8:raw(
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ),
    ],
    err = STRICT_ENUM_UNKOWN_VALUE,
}

success("FlexibleEnumKnownValue") {
    value = FlexibleEnumStruct {
        e: 1,
    },
    bytes = [
        8:raw(
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        )
    ],
}

success("FlexibleEnumUnknownValue") {
    // TODO(fxb/7874): Implement flexible enums in Dart, Rust, HLCPP, and LLCPP.
    bindings_denylist = [dart,rust,cpp,llcpp],
    value = FlexibleEnumStruct {
        e: 0xffffffff,
    },
    bytes = [
        8:raw(
            0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        )
    ],
}

success("FlexibleEnumUint64UnknownValue") {
    // TODO(fxb/7874): Implement flexible enums in Dart, Rust, HLCPP, and LLCPP.
    bindings_denylist = [dart,rust,cpp,llcpp],
    value = FlexibleEnumUint64Struct {
        e: 0x0102030405060708,
    },
    bytes = [
        8:raw(
            0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01,
        )
    ],
}

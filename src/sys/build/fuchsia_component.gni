# Copyright 2020 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/unification/zbi/resource.gni")
import("//src/sys/cmc/build/cml.gni")
import("//src/sys/cmc/build/cmx.gni")

# Defines a Fuchsia component.
# See: https://fuchsia.dev/fuchsia-src/development/components/build
#
# A component is defined by a component manifest.
# Component manifests typically reference files in the package that they are
# distributed in. Therefore a component can also have dependencies on
# `resource()`, such that any package that depends on the component # will
# also include that resource.
#
# A component is launched by a URL.
# See: https://fuchsia.dev/fuchsia-src/glossary#component_url
#
# A component's URL is a function of the name of a package that includes it,
# and the path within that package to the component's manifest. For instance if
# you defined the following:
# ```
# executable("my_program") {
#   ...
# }
#
# fuchsia_component("my-component") {
#   manifest = "manifest.cml"
#   deps = [ ":my_program" ]
# }
#
# fuchsia_package("my-package") {
#   components = [ ":my-component" ]
# }
# ```
# The component above will have the following launch URL:
# `fuchsia-pkg://fuchsia.com/my-package#meta/my-component.cm`
#
# Since the component depends on the exeuctable target, the binary produced by
# the executable will be packaged with the manifest. Therefore the manifest
# author can reference the path `bin/my_program`.
#
# Components may depend on any number of `resources()` to ensure that any
# `fuchsia_package()` that includes them will include the same resources.
# It's also possible to specify resources within the component definition as a
# shorter form, as demonstrated above.
#
# The following target:
# ```
# fuchsia_component("my-component") {
#   resources = [
#     {
#       source = "my_file.txt"
#       destination = "data/my_file.txt"
#     }
#   ]
#   ...
# }
# ```
# Is equivalent to:
# ```
# resources("my_file") {
#   sources = [ "my_file.txt" ]
#   destination = "data/{{source_file_part}}"
# }
#
# fuchsia_component("my-component") {
#   deps = [ ":my_file" ]
#   ...
# }
# ```
#
# Parameters
#
#   manifest (required)
#     The component manifest.
#     Type: path
#
#   component_name (optional)
#     The name of the component.
#     Type: string
#     Default: target_name
#
#   resources (optional)
#     Resources to include.
#     This is a short form for adding `deps` on `resources` targets.
#     Type: list(scopes)
#     Scopes contain a required `source` and an optional `destination`.
#     If a `destination` is not specified, the file name of `source` is used.
#
#   data_deps
#   deps
#   public_deps
#   testonly
#   visibility
template("fuchsia_component") {
  assert(defined(invoker.manifest),
         "fuchsia_component($target_name): missing `manifest` parameter")

  component_name = target_name
  if (defined(invoker.component_name)) {
    component_name = invoker.component_name
  }
  assert(string_replace(component_name, "_", "-") == component_name,
         "fuchsia_component($target_name): must not have underscores in " +
             "`component_name`")

  # Handle different manifest versions
  if (get_path_info(invoker.manifest, "extension") == "cml") {
    manifest_processor = "cm"
    manifest_name = "$component_name.cm"
  } else if (get_path_info(invoker.manifest, "extension") == "cmx") {
    manifest_processor = "cmx"
    manifest_name = "$component_name.cmx"
  } else {
    assert(false,
           "fuchsia_component($target_name): unknown manifest format for " +
               "\"$manifest\"")
  }

  # Add resources
  manifest_resource_target = "${target_name}_manifest_resource"
  resources_deps = [ ":$manifest_resource_target" ]
  if (defined(invoker.resources)) {
    foreach(resource, invoker.resources) {
      destination = get_path_info(resource.source, "file")
      if (defined(resource.destination)) {
        destination = resource.destination
      }
      resource_target = "${target_name}_resource_${destination}"
      resource(resource_target) {
        sources = [ resource.source ]
        outputs = [ destination ]
        visibility = [ ":*" ]
      }
      resources_deps += [ ":$resource_target" ]
    }
  }

  # Process the manifest
  target(manifest_processor, target_name) {
    output_name = manifest_name
    forward_variables_from(invoker,
                           [
                             "data_deps",
                             "deps",
                             "public_deps",
                             "manifest",
                             "testonly",
                             "visibility",
                           ])
    if (!defined(deps)) {
      deps = []
    }
    deps += resources_deps
  }

  # Add the manifest
  resource(manifest_resource_target) {
    sources = get_target_outputs(":${invoker.target_name}")
    outputs = [ "meta/$manifest_name" ]
    visibility = [ ":*" ]
  }
}

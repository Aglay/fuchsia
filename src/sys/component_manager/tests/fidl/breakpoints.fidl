// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

library fuchsia.test.breakpoints;

/// The maximum number of event types to register breakpoints for.
/// This capacity should match the actual number of event types.
const uint64 MAX_NUM_EVENT_TYPES = 3;

/// When a caller expects an Event or waits until a capability is used
/// by a specific component, this constant determines the maximum depth
/// (in terms of components) of that capability. This value is currently
/// set arbitrarily.
const uint64 MAX_COMPONENT_DEPTH = 10;

/// When a caller expects an Event or waits until a capability is used
/// by a specific component, this constant determines the maximum string
/// length of the moniker of each comprising instance.
///
/// For example, if a caller expects an event on a component whose path is
/// "/<A>/<B>/<C>", then this constant determines the maximum length of
/// <A>, <B> and <C>. This value is currently set arbitrarily.
const uint64 MAX_MONIKER_LENGTH = 50;

/// When a caller waits until a specific capability is used by a specific
/// component, this constant determines the maximum string length of the path
/// of that capability. This value is currently set arbitrarily.
const uint64 MAX_CAPABILITY_PATH_LENGTH = 50;

/// These EventTypes are used for the Breakpoints protocol.
/// They are FIDL versions of the EventType enum in hooks.rs and have
/// the same meaning.
enum EventType {
    /// An instance was bound to successfully.
    /// This instance is now running.
    /// TODO(xbhatnag): Rename this event to START_INSTANCE
    BIND_INSTANCE = 0;

    /// An instance was stopped successfully.
    /// This event must occur before PostDestroyInstance.
    STOP_INSTANCE = 1;

    /// The component subtree rooted at this instance is about to be destroyed.
    /// The instance may have been stopped by this point.
    /// This event must occur before PostDestroyInstance.
    /// TODO(fxb/39417): Ensure the instance is stopped before this event.
    PRE_DESTROY_INSTANCE = 2;

    /// The component subtree rooted at this instance has been destroyed.
    /// All instances under this subtree have been stopped by this point.
    POST_DESTROY_INSTANCE = 3;

    /// A capability has been requested for use by the component.
    /// A component uses a capability by creating a channel and providing
    /// the server end of the channel to the component manager for routing
    /// to a particular capability.
    /// TODO(xbhatnag): Rename this event to USE_CAPABILITY
    CAPABILITY_USE = 4;
};

/// A protocol used in testing by a component instance to block the
/// component manager until specific events occur.
[Discoverable]
protocol Breakpoints {
    /// Register breakpoints for the given EventTypes.
    /// Must be called exactly once before Expect or Resume.
    Register(vector<EventType>:MAX_NUM_EVENT_TYPES event_types) -> ();

    /// Blocks until the next invocation of a breakpoint occurs and verifies
    /// that the EventType and component list are as expected.
    ///
    /// Note: The component manager is blocked after this call and will not be
    /// allowed to proceed until resumed explicitly by calling Resume().
    Expect(EventType event_type, vector<string:MAX_MONIKER_LENGTH>:MAX_COMPONENT_DEPTH component) -> ();

    /// Blocks until a CapabilityUse invocation matching the specified component
    /// and capability path. All other invocations are ignored.
    ///
    /// Note: The component manager is blocked after this call and will not be
    /// allowed to proceed until resumed explicitly by calling Resume().
    WaitUntilCapabilityUse(vector<string:MAX_MONIKER_LENGTH>:MAX_COMPONENT_DEPTH component, string:MAX_CAPABILITY_PATH_LENGTH requested_capability_path) -> ();

    /// Resume the component manager from the last expected invocation.
    Resume() -> ();
};

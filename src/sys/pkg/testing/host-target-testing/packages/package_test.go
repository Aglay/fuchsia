// Copyright 2020 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package packages

import (
	"encoding/json"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"fuchsia.googlesource.com/pm/build"
	"fuchsia.googlesource.com/pm/repo"
)

// InitRepo fills the given directory with a new repository.
func initRepo(t *testing.T, tempDir string) (*Repository, string) {
	// Initialize a repo.
	pmRepo, err := repo.New(tempDir)
	if err != nil {
		t.Fatalf("Failed to create repo. %s", err)
	}
	if err = pmRepo.Init(); err != nil {
		t.Fatalf("Failed to init repo. %s", err)
	}
	if err = pmRepo.GenKeys(); err != nil {
		t.Fatalf("Failed to generate keys for repo. %s", err)
	}

	// Create a config.
	config := build.TestConfig()
	log.Printf("Creating meta.far in %s", config.OutputDir)
	build.BuildTestPackage(config)
	defer os.RemoveAll(filepath.Dir(config.OutputDir))

	// Grab the merkle of the config's package manifest.
	manifestDir := filepath.Join(config.OutputDir, "package_manifest.json")
	manifest, err := ioutil.ReadFile(manifestDir)
	var packageManifest build.PackageManifest
	if err := json.Unmarshal(manifest, &packageManifest); err != nil {
		t.Fatalf("Could not decode package_manifest.json. %s", err)
	}
	metaMerkle := ""
	for _, blob := range packageManifest.Blobs {
		if blob.Path == "meta/" {
			metaMerkle = blob.Merkle.String()
		}
	}
	if metaMerkle == "" {
		t.Fatalf("Did not find meta.far in manifest")
	}

	// Publish the config to the repo.
	_, err = pmRepo.PublishManifest(manifestDir)
	if err != nil {
		t.Fatalf("Failed to publish manifest. %s", err)
	}
	if err = pmRepo.CommitUpdates(true); err != nil {
		t.Fatalf("Failed to commit updates to repo. %s", err)
	}
	pkgRepo, err := NewRepository(tempDir)
	if err != nil {
		t.Fatalf("Failed to read repo. %s", err)
	}

	return pkgRepo, metaMerkle
}

func TestExpand(t *testing.T) {
	// Create temporary work directory.
	parentDir, err := ioutil.TempDir("", "omaha-pkg-test-expand")
	if err != nil {
		t.Fatalf("Failed to create directory %s, %s", parentDir, err)
	}
	defer os.RemoveAll(parentDir)
	log.Printf("TestExpand working dir: %s", parentDir)

	repoDir := filepath.Join(parentDir, "repo")
	if err := os.MkdirAll(repoDir, 0755); err != nil {
		t.Fatalf("Failed to create directory %s", repoDir)
	}

	// Open the repo within the directory.
	pkgRepo, metaMerkle := initRepo(t, repoDir)
	if pkgRepo == nil {
		t.Fatalf("Unable to create repo.")
	}

	// Parse the package we want.
	pkg, err := newPackage(pkgRepo, metaMerkle)
	if err != nil {
		t.Fatalf("Failed to read package. %s", err)
	}

	expandDir := filepath.Join(parentDir, "expand")
	if err := os.MkdirAll(expandDir, 0755); err != nil {
		t.Fatalf("Failed to create directory %s", expandDir)
	}

	// Expand to the given directory.
	if err = pkg.Expand(expandDir); err != nil {
		t.Fatalf("Failed to expand to dir. %s", err)
	}

	// Make a "set" of all files we expect to see in the expand directory.
	expectedFiles := make(map[string]bool)
	expectedFiles["meta/contents"] = true
	expectedFiles["meta/package"] = true
	for _, item := range build.TestFiles {
		expectedFiles[item] = true
	}

	expandedData := make(map[string]FileData)

	// Check that the contents of match expectations.
	filepath.Walk(expandDir,
		func(path string, info os.FileInfo, err error) error {
			if err != nil {
				log.Printf("Walk of expand directory failed with %s", err)
				return err
			}
			if !info.IsDir() {
				relativePath := strings.Replace(path, expandDir+"/", "", 1)
				expandedData[relativePath], err = ioutil.ReadFile(path)
				if err != nil {
					t.Fatalf("Could not read file %s. %s", path, err)
				}
				// Confirm all files we find are expected to be found
				if _, ok := expectedFiles[relativePath]; !ok {
					t.Fatalf("TestFiles does not contain %s.", relativePath)
				}
			}
			return nil
		})

	// Confirm we found the same number of files as we expected.
	if len(expectedFiles) != len(expandedData) {
		t.Fatalf("Expanded directory has %d files when %d are expected.",
			len(expandedData), len(expectedFiles))
	}

	// Compare file contents
	for key, val := range expandedData {
		valStr := strings.TrimSpace(string(val))
		// Skipping autogenerated file contents and "rand*" files as they do not have
		// consistent contents.
		if !strings.Contains(key, "rand") && key != "meta/contents" &&
			key != "meta/package" {
			if !strings.Contains(key, valStr) {
				t.Fatalf("File %s should have '%s' but has '%s'", key, key, valStr)
			}
		}
	}
}

# Copyright 2019 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/compiled_action.gni")

_hotsort_dir = "//src/graphics/lib/compute/hotsort"

#
# Generates a HotSort target by performing the following steps:
#
#   1. Determine what compute shaders will be generated by the
#      hotsort_gen executable.
#
#   2. Generate compute shaders and supporting files with the
#      hotsort_gen executable.
#
#   3. Compile compute shaders to SPIR-V modules.
#
#   4. Optimize SPIR-V modules.
#
#   5. Remap SPIR-V modules.
#
#   6. Return the target as either:
#      - a source set
#      - a binary image produced by the host toolchain
#
# If $hotsort_target_name is provided, the generated HotSort target
# and its artifacts are output to the root of $target_gen_dir.
#
# Otherwise, the outputs are found in $target_gen_dir/$target_name.
#
# The subdirectories contain the compute shaders and successive stages
# of processed SPIR-V modules.
#
template("hotsort_target") {
  #
  # Expects:
  #
  #   $hotsort_target_config_files:
  #
  #   A list of vendor and arch-specific configuration files.
  #
  #   $hotsort_target_name:
  #
  #   A name that conveys the configuration of the generated HotSort
  #   algorithm. If not provided, defaults to the short name of
  #   ${target_name}.
  #
  #   $hotsort_target_args:
  #
  #   The arguments passed to the 'hotsort_gen' HotSort algorithm code
  #   generator.
  #
  #   $hotsort_target_dump:
  #
  #   If defined the target is group that references a target binary
  #   produced by the host toolchain.  Otherwise, a source set is
  #   produced on the current toolchain.
  #
  # The hotsort target name and args are passed to 'hotsort_gen' as
  # follows:
  #
  #   'hotsort_gen -D $hotsort_target_name $hotsort_target_args'
  #
  # Validation of the args will be performed by 'hotsort_gen'.
  #
  # Note that $hotsort_target_name is split from the args list as it
  # serves a dual role of providing the name of files as well as being
  # a symbol in the GLSL source and C include files.
  #
  assert(defined(invoker.hotsort_target_config_files),
         "config file list must be defined for hotsort_target")

  if (defined(invoker.hotsort_target_name)) {

    _hs_target_name = invoker.hotsort_target_name

    # Location of all generated files.
    _hs_output_dir = "${target_gen_dir}"

  } else {

    _hs_target_name = get_label_info(target_name, "name")

    # Location of all generated files.
    _hs_output_dir = "${target_gen_dir}/${_hs_target_name}"
  }

  assert(defined(invoker.hotsort_target_args),
         "args must be defined for hotsort_target")

  #
  # Either dump a binary or produce a source set
  #
  _hs_target_dump =
      defined(invoker.hotsort_target_dump) && invoker.hotsort_target_dump

  #
  # prefix target args with implicit args
  #
  _hs_target_gen_args = [
                          "-o",
                          rebase_path(_hs_output_dir, root_build_dir),
                        ] + invoker.hotsort_target_args

  #
  # define generated sources, includes and deps
  #
  _hs_target_gen_includes_public = [ "${_hs_output_dir}/hs_target.h" ]

  _hs_target_gen_includes =
      [ "${_hs_output_dir}/hs_config.h" ] + _hs_target_gen_includes_public

  _hs_target_gen_sources = [ "${_hs_output_dir}/" + _hs_target_name + ".c" ]

  _hs_target_gen_inlines = [ "${_hs_output_dir}/hs_modules.inl" ]

  #
  # define source set sources
  #
  _hs_target_include_dirs = [
    _hs_output_dir,
    "${_hotsort_dir}/platforms/vk/targets",
    "${_hotsort_dir}/platforms/vk",
  ]

  _hs_target_sources =
      _hs_target_gen_includes + _hs_target_gen_sources + _hs_target_gen_inlines

  #
  # generated compute shaders
  #
  _hs_comp_names =
      exec_script("${_hotsort_dir}/platforms/vk/targets/hotsort_comp_names.py",
                  _hs_target_gen_args,
                  "list lines")

  _hs_comp_sources =
      process_file_template(_hs_comp_names,
                            "${_hs_output_dir}/comp/{{source_file_part}}")

  #
  # generate the .comp shaders
  #
  # Note that hs_modules.txt should match names returned by script
  #
  _gen_comp_target_name = "gen_comp_${_hs_target_name}"
  compiled_action(_gen_comp_target_name) {
    tool = "${_hotsort_dir}/hotsort_gen"
    outputs =
        _hs_comp_sources + _hs_target_gen_sources + _hs_target_gen_includes
    args = [
             "-D",
             _hs_target_name,
           ] + _hs_target_gen_args
  }

  #
  # copy any configuration files to the target directory
  #
  _gen_copy_target_name = "gen_copy_${_hs_target_name}"
  copy(_gen_copy_target_name) {
    sources = invoker.hotsort_target_config_files
    outputs = [
      "${_hs_output_dir}/{{source_file_part}}",
    ]
  }

  #
  # compile the .comp shaders to SPIR-V modules
  #
  _gen_spv_target_name = "gen_spv_${_hs_target_name}"
  compiled_action_foreach(_gen_spv_target_name) {
    tool = "//third_party/shaderc/third_party/glslang:glslangValidator"
    sources = _hs_comp_sources
    inputs = _hs_target_gen_includes +
             get_target_outputs(":${_gen_copy_target_name}")
    outputs = [
      "${_hs_output_dir}/spv/{{source_name_part}}.spv",
    ]
    args = [
      "-s",  # Note: '-s' silences glslangValidator printing filename
             # but detailed error messages are also silenced

      "--target-env",
      "vulkan1.1",
      "-o",
      rebase_path(outputs[0], root_build_dir),
      "{{source}}",
    ]
    foreach(include_dir, _hs_target_include_dirs) {
      args += [ "-I" + rebase_path(include_dir, root_build_dir) ]
    }
    deps = [
      ":${_gen_comp_target_name}",
      ":${_gen_copy_target_name}",
    ]
  }

  #
  # optimize the modules
  #
  _gen_opt_target_name = "gen_opt_${_hs_target_name}"
  compiled_action_foreach(_gen_opt_target_name) {
    tool = "//third_party/shaderc/third_party/spirv-tools:spirv-opt"
    sources = get_target_outputs(":${_gen_spv_target_name}")
    outputs = [
      "${_hs_output_dir}/opt/{{source_name_part}}.spv",
    ]
    args = [
      "-O",
      "{{source}}",
      "-o",
      rebase_path(outputs[0], root_build_dir),
    ]
    deps = [
      ":${_gen_spv_target_name}",
    ]
  }

  #
  # remap the optimized modules
  #
  _gen_remap_target_name = "gen_remap_${_hs_target_name}"
  compiled_action_foreach(_gen_remap_target_name) {
    tool = "//third_party/shaderc/third_party/glslang:spirv-remap"
    sources = get_target_outputs(":${_gen_opt_target_name}")
    _output_dir = "${_hs_output_dir}/remap"
    outputs = [
      "${_output_dir}/{{source_name_part}}.spv",
    ]
    args = [
      "--do-everything",
      "--input",
      "{{source}}",
      "--output",
      rebase_path(_output_dir, root_build_dir),
    ]
    deps = [
      ":${_gen_opt_target_name}",
    ]
  }

  #
  # dump the modules as uint32_t literals
  #
  _gen_modules_target_name = "gen_modules_${_hs_target_name}"
  compiled_action(_gen_modules_target_name) {
    tool = "${_hotsort_dir}/platforms/vk/targets:hotsort_modules_to_literals"
    inputs = get_target_outputs(":${_gen_remap_target_name}")
    outputs = _hs_target_gen_inlines
    args = rebase_path(outputs, root_build_dir) +
           rebase_path(inputs, root_build_dir)
    deps = [
      ":${_gen_remap_target_name}",
    ]
  }

  #
  # either dump a binary or return a source set
  #
  if (_hs_target_dump) {
    #
    # executable for dumping a binary image of target
    #
    _hs_target_dump_name = "hotsort_dump_" + invoker.hotsort_target_name

    executable(_hs_target_dump_name) {
      defines = [ "HS_DUMP" ]
      sources = _hs_target_gen_sources
      include_dirs = _hs_target_include_dirs
      deps = [
        "${_gen_comp_target_name}",
      ]
    }

    #
    # dump a binary image of target
    #
    _gen_bin_target_name = "gen_bin_${_hs_target_name}"
    compiled_action(_gen_bin_target_name) {
      tool = ":$_hs_target_dump_name"
      sources = _hs_target_sources
      outputs = [
        "${_hs_output_dir}/hs_target.bin",
      ]
      args = rebase_path(outputs, root_build_dir)
      public_deps = [
        ":$_hs_target_dump_name",
      ]
    }

    #
    # dummy group invokes $host_toolchain
    #
    group(target_name) {
      public_deps = [
        ":${_gen_bin_target_name}($host_toolchain)",
      ]
    }
  } else {
    #
    # target is a source set
    #
    source_set(target_name) {
      public = [
        "${_hs_output_dir}/hs_target.h",
      ]
      sources = _hs_target_sources
      include_dirs = _hs_target_include_dirs
      deps = [
        ":${_gen_comp_target_name}",
        ":${_gen_modules_target_name}",
        ":${_gen_remap_target_name}",
      ]
    }
  }
}

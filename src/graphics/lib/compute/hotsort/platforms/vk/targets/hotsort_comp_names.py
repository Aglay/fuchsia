#!/usr/bin/python
# Copyright 2019 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

#
# The arguments passed to the 'hotsort_gen' code generator determine
# the compute shaders that are emitted.
#
# GN requires the list of compute shaders that *will* be generated by
# 'hotsort_gen'.
#
# This script accepts the exact same getopt() string as hotsort_gen
# but only uses the relevant arguments to determine which shader names
# will be produced by 'hotsort_gen'.
#

import getopt, sys

#
# Note that the inputs to these two functions are the number of
# warps/waves/subgroups supported by a GPU block.
#
# Currently, the largest GPU only supports 2^6 warps per block.
#

def msb(n):
    """Given an integer >= 0, return the most significant bit position."""
    assert n < 2 ** 32
    c = 0
    while n > 0:
        n >>= 1
        c  += 1
    return c

def pow2_ru(n):
    """Given an integer >= 1, return the next power of 2 >= to n."""
    assert n <= 2 ** 31
    n -= 1
    n |= n >> 1
    n |= n >> 2
    n |= n >> 4
    n |= n >> 8
    n |= n >> 16
    n += 1
    return n

#
# Duplicate the shader file generation logic of 'hotsort_gen' for a
# glsl platform target.
#

bs_hi = 1
fm_lo = 1
fm_hi = 1
hm_lo = 1
hm_hi = 1

try:
    # option list must always match hotsort_gen/main.c
    opts, args = getopt.getopt(sys.argv[1:],'hvzo:a:g:G:s:S:w:b:B:m:M:k:r:x:t:f:F:c:C:p:P:D:L:')
except getopt.GetoptError as err:
    print str(err)
    sys.exit(2)

for o, v in opts:
    if   o == '-b':
        bs_hi = int(v)
    elif o == '-f':
        fm_lo = int(v)
    elif o == '-F':
        fm_hi = int(v)
    elif o == '-c':
        hm_lo = int(v)
    elif o == '-C':
        hm_hi = int(v)

#
# BS
#

bs_lo_log = 0

while (1<<bs_lo_log) <= bs_hi:
    print 'hs_bs_%d.comp' % bs_lo_log
    bs_lo_log += 1

#
# BC
#

bc_lo_log = 0

while bc_lo_log <= msb(bs_hi) - 1:
    print 'hs_bc_%d.comp' % bc_lo_log
    bc_lo_log += 1

#
# FM
#

for fm_scale in range(fm_lo,fm_hi+1):
    span_left    = (bs_hi << fm_scale) / 2
    span_left_ru = pow2_ru(span_left)
    span_right   = 1
    while (span_right <= span_left_ru):
        fm_log = msb(pow2_ru(min(span_left,span_right))) - 1
        print 'hs_fm_%d_%d.comp' % (fm_scale, fm_log)
        span_right *= 2

#
# HM
#

for hm_scale in range(hm_lo,hm_hi+1):
    print 'hs_hm_%d.comp' % hm_scale

#
# EXTRAS
#

print 'hs_fill_in.comp'
print 'hs_fill_out.comp'
print 'hs_transpose.comp'

// WARNING: This file is machine generated by fidlgen.

#include <protocols.test.json.llcpp.h>

#include <memory>

namespace llcpp {

namespace test {
namespace name {

void ::llcpp::test::name::WithErrorSyntax_ResponseAsStruct_Result::
    SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(WithErrorSyntax_ResponseAsStruct_Result) ==
                sizeof(fidl_xunion_t));
  static_assert(offsetof(WithErrorSyntax_ResponseAsStruct_Result, ordinal_) ==
                offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(WithErrorSyntax_ResponseAsStruct_Result, envelope_) ==
                offsetof(fidl_xunion_t, envelope));
}

void ::llcpp::test::name::WithErrorSyntax_ErrorAsPrimitive_Result::
    SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(WithErrorSyntax_ErrorAsPrimitive_Result) ==
                sizeof(fidl_xunion_t));
  static_assert(offsetof(WithErrorSyntax_ErrorAsPrimitive_Result, ordinal_) ==
                offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(WithErrorSyntax_ErrorAsPrimitive_Result, envelope_) ==
                offsetof(fidl_xunion_t, envelope));
}

namespace {

[[maybe_unused]] constexpr uint64_t kTransitional_Request_Ordinal =
    8417059970765918690lu;
extern "C" const fidl_type_t test_name_TransitionalRequestRequestTable;
extern "C" const fidl_type_t test_name_TransitionalRequestResponseTable;
[[maybe_unused]] constexpr uint64_t kTransitional_OneWay_Ordinal =
    4736529736500432226lu;
extern "C" const fidl_type_t test_name_TransitionalOneWayRequestTable;
extern "C" const fidl_type_t test_name_TransitionalOneWayResponseTable;
[[maybe_unused]] constexpr uint64_t kTransitional_Event_Ordinal =
    1744293851714922796lu;
extern "C" const fidl_type_t test_name_TransitionalEventRequestTable;
extern "C" const fidl_type_t test_name_TransitionalEventEventTable;

}  // namespace
Transitional::ResultOf::Request::Request(zx_handle_t _client, int64_t x) {
  RequestOwnedRequest _request(0, x);
  _request.GetFidlMessage().Call(
      RequestResponse::Type, _client, bytes_,
      RequestResponse::PrimarySize + RequestResponse::MaxOutOfLine);
  status_ = _request.status();
  error_ = _request.error();
}

Transitional::ResultOf::Request Transitional::SyncClient::Request(int64_t x) {
  return ResultOf::Request(this->channel().get(), x);
}

Transitional::ResultOf::Request Transitional::Call::Request(
    ::zx::unowned_channel _client_end, int64_t x) {
  return ResultOf::Request(_client_end->get(), x);
}

Transitional::UnownedResultOf::Request::Request(
    zx_handle_t _client, uint8_t* _request_bytes,
    uint32_t _request_byte_capacity, int64_t x, uint8_t* _response_bytes,
    uint32_t _response_byte_capacity)
    : bytes_(_response_bytes) {
  RequestUnownedRequest _request(_request_bytes, _request_byte_capacity, 0, x);
  _request.GetFidlMessage().Call(RequestResponse::Type, _client,
                                 _response_bytes, _response_byte_capacity);
  status_ = _request.status();
  error_ = _request.error();
}

Transitional::UnownedResultOf::Request Transitional::SyncClient::Request(
    ::fidl::BytePart _request_buffer, int64_t x,
    ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Request(
      this->channel().get(), _request_buffer.data(), _request_buffer.capacity(),
      x, _response_buffer.data(), _response_buffer.capacity());
}

Transitional::UnownedResultOf::Request Transitional::Call::Request(
    ::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer,
    int64_t x, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Request(
      _client_end->get(), _request_buffer.data(), _request_buffer.capacity(), x,
      _response_buffer.data(), _response_buffer.capacity());
}

Transitional::ResultOf::OneWay::OneWay(zx_handle_t _client, int64_t x) {
  OneWayOwnedRequest _request(0, x);
  _request.GetFidlMessage().Write(_client);
  status_ = _request.status();
  error_ = _request.error();
}

Transitional::ResultOf::OneWay Transitional::SyncClient::OneWay(int64_t x) {
  return ResultOf::OneWay(this->channel().get(), x);
}

Transitional::ResultOf::OneWay Transitional::Call::OneWay(
    ::zx::unowned_channel _client_end, int64_t x) {
  return ResultOf::OneWay(_client_end->get(), x);
}

Transitional::UnownedResultOf::OneWay::OneWay(zx_handle_t _client,
                                              uint8_t* _request_bytes,
                                              uint32_t _request_byte_capacity,
                                              int64_t x) {
  OneWayUnownedRequest _request(_request_bytes, _request_byte_capacity, 0, x);
  _request.GetFidlMessage().Write(_client);
  status_ = _request.status();
  error_ = _request.error();
}

Transitional::UnownedResultOf::OneWay Transitional::SyncClient::OneWay(
    ::fidl::BytePart _request_buffer, int64_t x) {
  return UnownedResultOf::OneWay(this->channel().get(), _request_buffer.data(),
                                 _request_buffer.capacity(), x);
}

Transitional::UnownedResultOf::OneWay Transitional::Call::OneWay(
    ::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer,
    int64_t x) {
  return UnownedResultOf::OneWay(_client_end->get(), _request_buffer.data(),
                                 _request_buffer.capacity(), x);
}

Transitional::ResultOf::Request Transitional::ClientImpl::Request_Sync(
    int64_t x) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return ResultOf::Request(_binding->handle(), x);
  }
  return Transitional::ResultOf::Request(
      ::fidl::Result(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound));
}

Transitional::UnownedResultOf::Request Transitional::ClientImpl::Request_Sync(
    ::fidl::BytePart _request_buffer, int64_t x,
    ::fidl::BytePart _response_buffer) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return UnownedResultOf::Request(
        _binding->handle(), _request_buffer.data(), _request_buffer.capacity(),
        x, _response_buffer.data(), _response_buffer.capacity());
  }
  return Transitional::UnownedResultOf::Request(
      ::fidl::Result(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound));
}

Transitional::RequestResponseContext::RequestResponseContext()
    : ::fidl::internal::ResponseContext(RequestResponse::Type,
                                        kTransitional_Request_Ordinal) {}

void Transitional::RequestResponseContext::OnReply(uint8_t* reply) {
  OnReply(reinterpret_cast<RequestResponse*>(reply));
}

::fidl::Result Transitional::ClientImpl::Request(
    int64_t x, ::fit::callback<void(int64_t y)> _cb) {
  class ResponseContext final : public RequestResponseContext {
   public:
    ResponseContext(::fit::callback<void(int64_t y)> cb) : cb_(std::move(cb)) {}

    void OnReply(RequestResponse* message) override {
      cb_(std::move(message->y));

      delete this;
    }

    void OnError() override { delete this; }

   private:
    ::fit::callback<void(int64_t y)> cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::ClientBase::PrepareAsyncTxn(_context);
  RequestOwnedRequest _request(_context->Txid(), x);
  return _request.GetFidlMessage().Write(this, _context);
}

::fidl::Result Transitional::ClientImpl::Request(
    ::fidl::BytePart _request_buffer, int64_t x,
    RequestResponseContext* _context) {
  ::fidl::internal::ClientBase::PrepareAsyncTxn(_context);

  RequestUnownedRequest _request(
      _request_buffer.data(), _request_buffer.capacity(), _context->Txid(), x);
  return _request.GetFidlMessage().Write(this, _context);
}

::fidl::Result Transitional::ClientImpl::OneWay(int64_t x) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    auto _res = ResultOf::OneWay(_binding->handle(), x);
    return ::fidl::Result(_res.status(), _res.error());
  }
  return ::fidl::Result(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

::fidl::Result Transitional::ClientImpl::OneWay(
    ::fidl::BytePart _request_buffer, int64_t x) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    auto _res =
        UnownedResultOf::OneWay(_binding->handle(), _request_buffer.data(),
                                _request_buffer.capacity(), x);
    return ::fidl::Result(_res.status(), _res.error());
  }
  return ::fidl::Result(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

std::optional<::fidl::UnbindInfo> Transitional::ClientImpl::DispatchEvent(
    fidl_msg_t* msg) {
  fidl_message_header_t* hdr =
      reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kTransitional_Event_Ordinal: {
      auto result = ::fidl::DecodeAs<EventResponse>(msg);
      if (result.status != ZX_OK) {
        return ::fidl::UnbindInfo{::fidl::UnbindInfo::kDecodeError,
                                  result.status};
      }
      if (auto* managed = std::get_if<0>(&handlers_.event)) {
        if (!(*managed))
          return ::fidl::UnbindInfo{::fidl::UnbindInfo::kUnexpectedMessage,
                                    ZX_ERR_NOT_SUPPORTED};
        auto message = result.message.message();
        (*managed)(std::move(message->x));
      } else {
        std::get<1>(handlers_.event)(std::move(result.message));
      }
      break;
    }
    default:
      zx_handle_close_many(msg->handles, msg->num_handles);
      return ::fidl::UnbindInfo{::fidl::UnbindInfo::kUnexpectedMessage,
                                ZX_ERR_NOT_SUPPORTED};
  }
  return {};
}

::fidl::Result Transitional::Call::HandleEvents(
    ::zx::unowned_channel client_end, Transitional::EventHandlers& handlers) {
  zx_status_t status =
      client_end->wait_one(ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED,
                           ::zx::time::infinite(), nullptr);
  if (status != ZX_OK) {
    return ::fidl::Result(status, ::fidl::kErrorWaitOneFailed);
  }
  constexpr uint32_t kReadAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::internal::ClampedMessageSize<
            EventResponse, ::fidl::MessageDirection::kReceiving>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<
          EventResponse, ::fidl::MessageDirection::kReceiving>();
    }
    return x;
  })();
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (EventResponse::MaxNumHandles >= x) {
      x = EventResponse::MaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  ::fidl::internal::ByteStorage<kReadAllocSize> read_storage;
  uint8_t* read_bytes = read_storage.buffer().data();
  zx_handle_t read_handles[kHandleAllocSize];
  uint32_t actual_bytes;
  uint32_t actual_handles;
  status = client_end->read(ZX_CHANNEL_READ_MAY_DISCARD, read_bytes,
                            read_handles, kReadAllocSize, kHandleAllocSize,
                            &actual_bytes, &actual_handles);
  if (status == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new
    // event, whose size exceeds the maximum of known events in the current
    // protocol.
    return ::fidl::Result(handlers.unknown(), nullptr);
  }
  if (status != ZX_OK) {
    return ::fidl::Result(status, ::fidl::kErrorReadFailed);
  }
  if (actual_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(read_handles, actual_handles);
    return ::fidl::Result(ZX_ERR_INVALID_ARGS, ::fidl::kErrorInvalidHeader);
  }
  fidl_message_header_t* hdr =
      reinterpret_cast<fidl_message_header_t*>(read_bytes);
  status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    zx_handle_close_many(read_handles, actual_handles);
    return ::fidl::Result(status, ::fidl::kErrorInvalidHeader);
  }
  switch (hdr->ordinal) {
    case kTransitional_Event_Ordinal: {
      const char* error_message;
      zx_status_t status =
          fidl_decode(EventResponse::Type, read_bytes, actual_bytes,
                      read_handles, actual_handles, &error_message);
      if (status != ZX_OK) {
        return ::fidl::Result(status, error_message);
      }
      return ::fidl::Result(
          handlers.event(reinterpret_cast<EventResponse*>(read_bytes)),
          nullptr);
    }
    default: {
      zx_handle_close_many(read_handles, actual_handles);
      return ::fidl::Result(handlers.unknown(), nullptr);
    }
  }
}

bool Transitional::TryDispatch(Interface* impl, fidl_msg_t* msg,
                               ::fidl::Transaction* txn) {
  fidl_message_header_t* hdr =
      reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kTransitional_Request_Ordinal: {
      auto result = ::fidl::DecodeAs<RequestRequest>(msg);
      if (result.status != ZX_OK) {
        txn->InternalError({::fidl::UnbindInfo::kDecodeError, result.status});
        return true;
      }
      auto message = result.message.message();
      impl->Request(std::move(message->x),
                    Interface::RequestCompleter::Sync(txn));
      return true;
    }
    case kTransitional_OneWay_Ordinal: {
      auto result = ::fidl::DecodeAs<OneWayRequest>(msg);
      if (result.status != ZX_OK) {
        txn->InternalError({::fidl::UnbindInfo::kDecodeError, result.status});
        return true;
      }
      auto message = result.message.message();
      impl->OneWay(std::move(message->x),
                   Interface::OneWayCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Transitional::Dispatch(Interface* impl, fidl_msg_t* msg,
                            ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->InternalError(
        {::fidl::UnbindInfo::kUnexpectedMessage, ZX_ERR_NOT_SUPPORTED});
  }
  return found;
}

::fidl::Result Transitional::Interface::RequestCompleterBase::Reply(int64_t y) {
  RequestOwnedResponse _response{y};
  return CompleterBase::SendReply(_response.GetFidlMessage());
}

::fidl::Result Transitional::Interface::RequestCompleterBase::Reply(
    ::fidl::BytePart _buffer, int64_t y) {
  RequestUnownedResponse _response(_buffer.data(), _buffer.capacity(), y);
  return CompleterBase::SendReply(_response.GetFidlMessage());
}

zx_status_t Transitional::SendEventEvent(::zx::unowned_channel _chan,
                                         int64_t x) {
  // Destructors can't be called because it will lead to handle double close
  // (here and in fidl::Encode).
  FIDL_ALIGNDECL uint8_t _response_buffer[sizeof(EventResponse)];
  auto& _response = *new (_response_buffer) EventResponse{x};

  auto _encoded =
      ::fidl::internal::LinearizedAndEncoded<EventResponse>(&_response);
  auto& _encode_result = _encoded.result();
  if (_encode_result.status != ZX_OK) {
    return _encode_result.status;
  }
  return ::fidl::Write(::zx::unowned_channel(_chan),
                       std::move(_encode_result.message));
}

zx_status_t Transitional::SendEventEvent(::zx::unowned_channel _chan,
                                         ::fidl::BytePart _buffer, int64_t x) {
  if (_buffer.capacity() < EventResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  new (_buffer.data()) EventResponse{x};
  _buffer.set_actual(sizeof(EventResponse));
  return ::fidl::Write(
      ::zx::unowned_channel(_chan),
      ::fidl::DecodedMessage<EventResponse>(std::move(_buffer)));
}

zx_status_t Transitional::SendEventEvent(
    ::zx::unowned_channel _chan, ::fidl::DecodedMessage<EventResponse> params) {
  ZX_ASSERT(params.message()->_hdr.magic_number ==
            kFidlWireFormatMagicNumberInitial);
  ZX_ASSERT(params.message()->_hdr.ordinal == kTransitional_Event_Ordinal);
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(params));
}

void Transitional::RequestRequest::_InitHeader(zx_txid_t _txid) {
  fidl_init_txn_header(&_hdr, _txid, kTransitional_Request_Ordinal);
}

void Transitional::RequestResponse::_InitHeader() {
  fidl_init_txn_header(&_hdr, 0, kTransitional_Request_Ordinal);
}

void Transitional::OneWayRequest::_InitHeader(zx_txid_t _txid) {
  fidl_init_txn_header(&_hdr, _txid, kTransitional_OneWay_Ordinal);
}

void Transitional::EventResponse::_InitHeader() {
  fidl_init_txn_header(&_hdr, 0, kTransitional_Event_Ordinal);
}

namespace {

[[maybe_unused]] constexpr uint64_t kChannelProtocol_MethodA_Ordinal =
    1954005452660588540lu;
extern "C" const fidl_type_t test_name_ChannelProtocolMethodARequestTable;
extern "C" const fidl_type_t test_name_ChannelProtocolMethodAResponseTable;
[[maybe_unused]] constexpr uint64_t kChannelProtocol_EventA_Ordinal =
    2691096518916888736lu;
extern "C" const fidl_type_t test_name_ChannelProtocolEventARequestTable;
extern "C" const fidl_type_t test_name_ChannelProtocolEventAEventTable;
[[maybe_unused]] constexpr uint64_t kChannelProtocol_MethodB_Ordinal =
    6751311874614576291lu;
extern "C" const fidl_type_t test_name_ChannelProtocolMethodBRequestTable;
extern "C" const fidl_type_t test_name_ChannelProtocolMethodBResponseTable;
[[maybe_unused]] constexpr uint64_t kChannelProtocol_MutateSocket_Ordinal =
    3948151641640179063lu;
extern "C" const fidl_type_t test_name_ChannelProtocolMutateSocketRequestTable;
extern "C" const fidl_type_t test_name_ChannelProtocolMutateSocketResponseTable;

}  // namespace
ChannelProtocol::ResultOf::MethodA::MethodA(zx_handle_t _client, int64_t a,
                                            int64_t b) {
  MethodAOwnedRequest _request(0, a, b);
  _request.GetFidlMessage().Write(_client);
  status_ = _request.status();
  error_ = _request.error();
}

ChannelProtocol::ResultOf::MethodA ChannelProtocol::SyncClient::MethodA(
    int64_t a, int64_t b) {
  return ResultOf::MethodA(this->channel().get(), a, b);
}

ChannelProtocol::ResultOf::MethodA ChannelProtocol::Call::MethodA(
    ::zx::unowned_channel _client_end, int64_t a, int64_t b) {
  return ResultOf::MethodA(_client_end->get(), a, b);
}

ChannelProtocol::UnownedResultOf::MethodA::MethodA(
    zx_handle_t _client, uint8_t* _request_bytes,
    uint32_t _request_byte_capacity, int64_t a, int64_t b) {
  MethodAUnownedRequest _request(_request_bytes, _request_byte_capacity, 0, a,
                                 b);
  _request.GetFidlMessage().Write(_client);
  status_ = _request.status();
  error_ = _request.error();
}

ChannelProtocol::UnownedResultOf::MethodA ChannelProtocol::SyncClient::MethodA(
    ::fidl::BytePart _request_buffer, int64_t a, int64_t b) {
  return UnownedResultOf::MethodA(this->channel().get(), _request_buffer.data(),
                                  _request_buffer.capacity(), a, b);
}

ChannelProtocol::UnownedResultOf::MethodA ChannelProtocol::Call::MethodA(
    ::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer,
    int64_t a, int64_t b) {
  return UnownedResultOf::MethodA(_client_end->get(), _request_buffer.data(),
                                  _request_buffer.capacity(), a, b);
}

ChannelProtocol::ResultOf::MethodB::MethodB(zx_handle_t _client, int64_t a,
                                            int64_t b) {
  MethodBOwnedRequest _request(0, a, b);
  _request.GetFidlMessage().Call(
      MethodBResponse::Type, _client, bytes_,
      MethodBResponse::PrimarySize + MethodBResponse::MaxOutOfLine);
  status_ = _request.status();
  error_ = _request.error();
}

ChannelProtocol::ResultOf::MethodB ChannelProtocol::SyncClient::MethodB(
    int64_t a, int64_t b) {
  return ResultOf::MethodB(this->channel().get(), a, b);
}

ChannelProtocol::ResultOf::MethodB ChannelProtocol::Call::MethodB(
    ::zx::unowned_channel _client_end, int64_t a, int64_t b) {
  return ResultOf::MethodB(_client_end->get(), a, b);
}

ChannelProtocol::UnownedResultOf::MethodB::MethodB(
    zx_handle_t _client, uint8_t* _request_bytes,
    uint32_t _request_byte_capacity, int64_t a, int64_t b,
    uint8_t* _response_bytes, uint32_t _response_byte_capacity)
    : bytes_(_response_bytes) {
  MethodBUnownedRequest _request(_request_bytes, _request_byte_capacity, 0, a,
                                 b);
  _request.GetFidlMessage().Call(MethodBResponse::Type, _client,
                                 _response_bytes, _response_byte_capacity);
  status_ = _request.status();
  error_ = _request.error();
}

ChannelProtocol::UnownedResultOf::MethodB ChannelProtocol::SyncClient::MethodB(
    ::fidl::BytePart _request_buffer, int64_t a, int64_t b,
    ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::MethodB(
      this->channel().get(), _request_buffer.data(), _request_buffer.capacity(),
      a, b, _response_buffer.data(), _response_buffer.capacity());
}

ChannelProtocol::UnownedResultOf::MethodB ChannelProtocol::Call::MethodB(
    ::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer,
    int64_t a, int64_t b, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::MethodB(
      _client_end->get(), _request_buffer.data(), _request_buffer.capacity(), a,
      b, _response_buffer.data(), _response_buffer.capacity());
}

ChannelProtocol::ResultOf::MutateSocket::MutateSocket(zx_handle_t _client,
                                                      ::zx::socket& a) {
  MutateSocketOwnedRequest _request(0, a);
  _request.GetFidlMessage().Call(
      MutateSocketResponse::Type, _client, bytes_,
      MutateSocketResponse::PrimarySize + MutateSocketResponse::MaxOutOfLine);
  status_ = _request.status();
  error_ = _request.error();
}

ChannelProtocol::ResultOf::MutateSocket
ChannelProtocol::SyncClient::MutateSocket(::zx::socket a) {
  return ResultOf::MutateSocket(this->channel().get(), a);
}

ChannelProtocol::ResultOf::MutateSocket ChannelProtocol::Call::MutateSocket(
    ::zx::unowned_channel _client_end, ::zx::socket a) {
  return ResultOf::MutateSocket(_client_end->get(), a);
}

ChannelProtocol::UnownedResultOf::MutateSocket::MutateSocket(
    zx_handle_t _client, uint8_t* _request_bytes,
    uint32_t _request_byte_capacity, ::zx::socket& a, uint8_t* _response_bytes,
    uint32_t _response_byte_capacity)
    : bytes_(_response_bytes) {
  MutateSocketUnownedRequest _request(_request_bytes, _request_byte_capacity, 0,
                                      a);
  _request.GetFidlMessage().Call(MutateSocketResponse::Type, _client,
                                 _response_bytes, _response_byte_capacity);
  status_ = _request.status();
  error_ = _request.error();
}

ChannelProtocol::UnownedResultOf::MutateSocket
ChannelProtocol::SyncClient::MutateSocket(::fidl::BytePart _request_buffer,
                                          ::zx::socket a,
                                          ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::MutateSocket(
      this->channel().get(), _request_buffer.data(), _request_buffer.capacity(),
      a, _response_buffer.data(), _response_buffer.capacity());
}

ChannelProtocol::UnownedResultOf::MutateSocket
ChannelProtocol::Call::MutateSocket(::zx::unowned_channel _client_end,
                                    ::fidl::BytePart _request_buffer,
                                    ::zx::socket a,
                                    ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::MutateSocket(
      _client_end->get(), _request_buffer.data(), _request_buffer.capacity(), a,
      _response_buffer.data(), _response_buffer.capacity());
}

::fidl::Result ChannelProtocol::ClientImpl::MethodA(int64_t a, int64_t b) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    auto _res = ResultOf::MethodA(_binding->handle(), a, b);
    return ::fidl::Result(_res.status(), _res.error());
  }
  return ::fidl::Result(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

::fidl::Result ChannelProtocol::ClientImpl::MethodA(
    ::fidl::BytePart _request_buffer, int64_t a, int64_t b) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    auto _res =
        UnownedResultOf::MethodA(_binding->handle(), _request_buffer.data(),
                                 _request_buffer.capacity(), a, b);
    return ::fidl::Result(_res.status(), _res.error());
  }
  return ::fidl::Result(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

ChannelProtocol::ResultOf::MethodB ChannelProtocol::ClientImpl::MethodB_Sync(
    int64_t a, int64_t b) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return ResultOf::MethodB(_binding->handle(), a, b);
  }
  return ChannelProtocol::ResultOf::MethodB(
      ::fidl::Result(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound));
}

ChannelProtocol::UnownedResultOf::MethodB
ChannelProtocol::ClientImpl::MethodB_Sync(::fidl::BytePart _request_buffer,
                                          int64_t a, int64_t b,
                                          ::fidl::BytePart _response_buffer) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return UnownedResultOf::MethodB(
        _binding->handle(), _request_buffer.data(), _request_buffer.capacity(),
        a, b, _response_buffer.data(), _response_buffer.capacity());
  }
  return ChannelProtocol::UnownedResultOf::MethodB(
      ::fidl::Result(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound));
}

ChannelProtocol::MethodBResponseContext::MethodBResponseContext()
    : ::fidl::internal::ResponseContext(MethodBResponse::Type,
                                        kChannelProtocol_MethodB_Ordinal) {}

void ChannelProtocol::MethodBResponseContext::OnReply(uint8_t* reply) {
  OnReply(reinterpret_cast<MethodBResponse*>(reply));
}

::fidl::Result ChannelProtocol::ClientImpl::MethodB(
    int64_t a, int64_t b, ::fit::callback<void(int64_t result)> _cb) {
  class ResponseContext final : public MethodBResponseContext {
   public:
    ResponseContext(::fit::callback<void(int64_t result)> cb)
        : cb_(std::move(cb)) {}

    void OnReply(MethodBResponse* message) override {
      cb_(std::move(message->result));

      delete this;
    }

    void OnError() override { delete this; }

   private:
    ::fit::callback<void(int64_t result)> cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::ClientBase::PrepareAsyncTxn(_context);
  MethodBOwnedRequest _request(_context->Txid(), a, b);
  return _request.GetFidlMessage().Write(this, _context);
}

::fidl::Result ChannelProtocol::ClientImpl::MethodB(
    ::fidl::BytePart _request_buffer, int64_t a, int64_t b,
    MethodBResponseContext* _context) {
  ::fidl::internal::ClientBase::PrepareAsyncTxn(_context);

  MethodBUnownedRequest _request(_request_buffer.data(),
                                 _request_buffer.capacity(), _context->Txid(),
                                 a, b);
  return _request.GetFidlMessage().Write(this, _context);
}

ChannelProtocol::ResultOf::MutateSocket
ChannelProtocol::ClientImpl::MutateSocket_Sync(::zx::socket a) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return ResultOf::MutateSocket(_binding->handle(), a);
  }
  return ChannelProtocol::ResultOf::MutateSocket(
      ::fidl::Result(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound));
}

ChannelProtocol::UnownedResultOf::MutateSocket
ChannelProtocol::ClientImpl::MutateSocket_Sync(
    ::fidl::BytePart _request_buffer, ::zx::socket a,
    ::fidl::BytePart _response_buffer) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return UnownedResultOf::MutateSocket(
        _binding->handle(), _request_buffer.data(), _request_buffer.capacity(),
        a, _response_buffer.data(), _response_buffer.capacity());
  }
  return ChannelProtocol::UnownedResultOf::MutateSocket(
      ::fidl::Result(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound));
}

ChannelProtocol::MutateSocketResponseContext::MutateSocketResponseContext()
    : ::fidl::internal::ResponseContext(
          MutateSocketResponse::Type, kChannelProtocol_MutateSocket_Ordinal) {}

void ChannelProtocol::MutateSocketResponseContext::OnReply(uint8_t* reply) {
  OnReply(reinterpret_cast<MutateSocketResponse*>(reply));
}

::fidl::Result ChannelProtocol::ClientImpl::MutateSocket(
    ::zx::socket a, ::fit::callback<void(::zx::socket b)> _cb) {
  class ResponseContext final : public MutateSocketResponseContext {
   public:
    ResponseContext(::fit::callback<void(::zx::socket b)> cb)
        : cb_(std::move(cb)) {}

    void OnReply(MutateSocketResponse* message) override {
      cb_(std::move(message->b));

      fidl_close_handles(type(), message, nullptr);

      delete this;
    }

    void OnError() override { delete this; }

   private:
    ::fit::callback<void(::zx::socket b)> cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::ClientBase::PrepareAsyncTxn(_context);
  MutateSocketOwnedRequest _request(_context->Txid(), a);
  return _request.GetFidlMessage().Write(this, _context);
}

::fidl::Result ChannelProtocol::ClientImpl::MutateSocket(
    ::fidl::BytePart _request_buffer, ::zx::socket a,
    MutateSocketResponseContext* _context) {
  ::fidl::internal::ClientBase::PrepareAsyncTxn(_context);

  MutateSocketUnownedRequest _request(
      _request_buffer.data(), _request_buffer.capacity(), _context->Txid(), a);
  return _request.GetFidlMessage().Write(this, _context);
}

std::optional<::fidl::UnbindInfo> ChannelProtocol::ClientImpl::DispatchEvent(
    fidl_msg_t* msg) {
  fidl_message_header_t* hdr =
      reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kChannelProtocol_EventA_Ordinal: {
      auto result = ::fidl::DecodeAs<EventAResponse>(msg);
      if (result.status != ZX_OK) {
        return ::fidl::UnbindInfo{::fidl::UnbindInfo::kDecodeError,
                                  result.status};
      }
      if (auto* managed = std::get_if<0>(&handlers_.event_a)) {
        if (!(*managed))
          return ::fidl::UnbindInfo{::fidl::UnbindInfo::kUnexpectedMessage,
                                    ZX_ERR_NOT_SUPPORTED};
        auto message = result.message.message();
        (*managed)(std::move(message->a), std::move(message->b));
      } else {
        std::get<1>(handlers_.event_a)(std::move(result.message));
      }
      break;
    }
    default:
      zx_handle_close_many(msg->handles, msg->num_handles);
      return ::fidl::UnbindInfo{::fidl::UnbindInfo::kUnexpectedMessage,
                                ZX_ERR_NOT_SUPPORTED};
  }
  return {};
}

::fidl::Result ChannelProtocol::Call::HandleEvents(
    ::zx::unowned_channel client_end,
    ChannelProtocol::EventHandlers& handlers) {
  zx_status_t status =
      client_end->wait_one(ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED,
                           ::zx::time::infinite(), nullptr);
  if (status != ZX_OK) {
    return ::fidl::Result(status, ::fidl::kErrorWaitOneFailed);
  }
  constexpr uint32_t kReadAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::internal::ClampedMessageSize<
            EventAResponse, ::fidl::MessageDirection::kReceiving>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<
          EventAResponse, ::fidl::MessageDirection::kReceiving>();
    }
    return x;
  })();
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (EventAResponse::MaxNumHandles >= x) {
      x = EventAResponse::MaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  ::fidl::internal::ByteStorage<kReadAllocSize> read_storage;
  uint8_t* read_bytes = read_storage.buffer().data();
  zx_handle_t read_handles[kHandleAllocSize];
  uint32_t actual_bytes;
  uint32_t actual_handles;
  status = client_end->read(ZX_CHANNEL_READ_MAY_DISCARD, read_bytes,
                            read_handles, kReadAllocSize, kHandleAllocSize,
                            &actual_bytes, &actual_handles);
  if (status == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new
    // event, whose size exceeds the maximum of known events in the current
    // protocol.
    return ::fidl::Result(handlers.unknown(), nullptr);
  }
  if (status != ZX_OK) {
    return ::fidl::Result(status, ::fidl::kErrorReadFailed);
  }
  if (actual_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(read_handles, actual_handles);
    return ::fidl::Result(ZX_ERR_INVALID_ARGS, ::fidl::kErrorInvalidHeader);
  }
  fidl_message_header_t* hdr =
      reinterpret_cast<fidl_message_header_t*>(read_bytes);
  status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    zx_handle_close_many(read_handles, actual_handles);
    return ::fidl::Result(status, ::fidl::kErrorInvalidHeader);
  }
  switch (hdr->ordinal) {
    case kChannelProtocol_EventA_Ordinal: {
      const char* error_message;
      zx_status_t status =
          fidl_decode(EventAResponse::Type, read_bytes, actual_bytes,
                      read_handles, actual_handles, &error_message);
      if (status != ZX_OK) {
        return ::fidl::Result(status, error_message);
      }
      return ::fidl::Result(
          handlers.event_a(reinterpret_cast<EventAResponse*>(read_bytes)),
          nullptr);
    }
    default: {
      zx_handle_close_many(read_handles, actual_handles);
      return ::fidl::Result(handlers.unknown(), nullptr);
    }
  }
}

bool ChannelProtocol::TryDispatch(Interface* impl, fidl_msg_t* msg,
                                  ::fidl::Transaction* txn) {
  fidl_message_header_t* hdr =
      reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kChannelProtocol_MethodA_Ordinal: {
      auto result = ::fidl::DecodeAs<MethodARequest>(msg);
      if (result.status != ZX_OK) {
        txn->InternalError({::fidl::UnbindInfo::kDecodeError, result.status});
        return true;
      }
      auto message = result.message.message();
      impl->MethodA(std::move(message->a), std::move(message->b),
                    Interface::MethodACompleter::Sync(txn));
      return true;
    }
    case kChannelProtocol_MethodB_Ordinal: {
      auto result = ::fidl::DecodeAs<MethodBRequest>(msg);
      if (result.status != ZX_OK) {
        txn->InternalError({::fidl::UnbindInfo::kDecodeError, result.status});
        return true;
      }
      auto message = result.message.message();
      impl->MethodB(std::move(message->a), std::move(message->b),
                    Interface::MethodBCompleter::Sync(txn));
      return true;
    }
    case kChannelProtocol_MutateSocket_Ordinal: {
      auto result = ::fidl::DecodeAs<MutateSocketRequest>(msg);
      if (result.status != ZX_OK) {
        txn->InternalError({::fidl::UnbindInfo::kDecodeError, result.status});
        return true;
      }
      auto message = result.message.message();
      impl->MutateSocket(std::move(message->a),
                         Interface::MutateSocketCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool ChannelProtocol::Dispatch(Interface* impl, fidl_msg_t* msg,
                               ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->InternalError(
        {::fidl::UnbindInfo::kUnexpectedMessage, ZX_ERR_NOT_SUPPORTED});
  }
  return found;
}

zx_status_t ChannelProtocol::SendEventAEvent(::zx::unowned_channel _chan,
                                             int64_t a, int64_t b) {
  // Destructors can't be called because it will lead to handle double close
  // (here and in fidl::Encode).
  FIDL_ALIGNDECL uint8_t _response_buffer[sizeof(EventAResponse)];
  auto& _response = *new (_response_buffer) EventAResponse{a, b};

  auto _encoded =
      ::fidl::internal::LinearizedAndEncoded<EventAResponse>(&_response);
  auto& _encode_result = _encoded.result();
  if (_encode_result.status != ZX_OK) {
    return _encode_result.status;
  }
  return ::fidl::Write(::zx::unowned_channel(_chan),
                       std::move(_encode_result.message));
}

zx_status_t ChannelProtocol::SendEventAEvent(::zx::unowned_channel _chan,
                                             ::fidl::BytePart _buffer,
                                             int64_t a, int64_t b) {
  if (_buffer.capacity() < EventAResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  new (_buffer.data()) EventAResponse{a, b};
  _buffer.set_actual(sizeof(EventAResponse));
  return ::fidl::Write(
      ::zx::unowned_channel(_chan),
      ::fidl::DecodedMessage<EventAResponse>(std::move(_buffer)));
}

zx_status_t ChannelProtocol::SendEventAEvent(
    ::zx::unowned_channel _chan,
    ::fidl::DecodedMessage<EventAResponse> params) {
  ZX_ASSERT(params.message()->_hdr.magic_number ==
            kFidlWireFormatMagicNumberInitial);
  ZX_ASSERT(params.message()->_hdr.ordinal == kChannelProtocol_EventA_Ordinal);
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(params));
}

::fidl::Result ChannelProtocol::Interface::MethodBCompleterBase::Reply(
    int64_t result) {
  MethodBOwnedResponse _response{result};
  return CompleterBase::SendReply(_response.GetFidlMessage());
}

::fidl::Result ChannelProtocol::Interface::MethodBCompleterBase::Reply(
    ::fidl::BytePart _buffer, int64_t result) {
  MethodBUnownedResponse _response(_buffer.data(), _buffer.capacity(), result);
  return CompleterBase::SendReply(_response.GetFidlMessage());
}

::fidl::Result ChannelProtocol::Interface::MutateSocketCompleterBase::Reply(
    ::zx::socket b) {
  MutateSocketOwnedResponse _response{b};
  return CompleterBase::SendReply(_response.GetFidlMessage());
}

::fidl::Result ChannelProtocol::Interface::MutateSocketCompleterBase::Reply(
    ::fidl::BytePart _buffer, ::zx::socket b) {
  MutateSocketUnownedResponse _response(_buffer.data(), _buffer.capacity(), b);
  return CompleterBase::SendReply(_response.GetFidlMessage());
}

void ChannelProtocol::MethodARequest::_InitHeader(zx_txid_t _txid) {
  fidl_init_txn_header(&_hdr, _txid, kChannelProtocol_MethodA_Ordinal);
}

void ChannelProtocol::EventAResponse::_InitHeader() {
  fidl_init_txn_header(&_hdr, 0, kChannelProtocol_EventA_Ordinal);
}

void ChannelProtocol::MethodBRequest::_InitHeader(zx_txid_t _txid) {
  fidl_init_txn_header(&_hdr, _txid, kChannelProtocol_MethodB_Ordinal);
}

void ChannelProtocol::MethodBResponse::_InitHeader() {
  fidl_init_txn_header(&_hdr, 0, kChannelProtocol_MethodB_Ordinal);
}

void ChannelProtocol::MutateSocketRequest::_InitHeader(zx_txid_t _txid) {
  fidl_init_txn_header(&_hdr, _txid, kChannelProtocol_MutateSocket_Ordinal);
}

void ChannelProtocol::MutateSocketResponse::_InitHeader() {
  fidl_init_txn_header(&_hdr, 0, kChannelProtocol_MutateSocket_Ordinal);
}

namespace {

[[maybe_unused]] constexpr uint64_t
    kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal =
        257584335957785512lu;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseNoRequestNoResponseRequestTable;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseNoRequestNoResponseResponseTable;
[[maybe_unused]] constexpr uint64_t
    kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal =
        8101632395109729785lu;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseNoRequestEmptyResponseRequestTable;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseNoRequestEmptyResponseResponseTable;
[[maybe_unused]] constexpr uint64_t
    kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal =
        5054636755429784136lu;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseNoRequestWithResponseRequestTable;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseNoRequestWithResponseResponseTable;
[[maybe_unused]] constexpr uint64_t
    kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal =
        5108499630221504549lu;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseWithRequestNoResponseResponseTable;
[[maybe_unused]] constexpr uint64_t
    kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal =
        108302452954061159lu;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseWithRequestEmptyResponseResponseTable;
[[maybe_unused]] constexpr uint64_t
    kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal =
        383797738148261568lu;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseWithRequestWithResponseResponseTable;
[[maybe_unused]] constexpr uint64_t
    kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal =
        301337558307652787lu;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseOnEmptyResponseRequestTable;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseOnEmptyResponseEventTable;
[[maybe_unused]] constexpr uint64_t
    kWithAndWithoutRequestResponse_OnWithResponse_Ordinal =
        3069035692499413769lu;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseOnWithResponseRequestTable;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseOnWithResponseEventTable;

}  // namespace
WithAndWithoutRequestResponse::ResultOf::NoRequestNoResponse::
    NoRequestNoResponse(zx_handle_t _client) {
  NoRequestNoResponseOwnedRequest _request(0);
  _request.GetFidlMessage().Write(_client);
  status_ = _request.status();
  error_ = _request.error();
}

WithAndWithoutRequestResponse::ResultOf::NoRequestNoResponse
WithAndWithoutRequestResponse::SyncClient::NoRequestNoResponse() {
  return ResultOf::NoRequestNoResponse(this->channel().get());
}

WithAndWithoutRequestResponse::ResultOf::NoRequestNoResponse
WithAndWithoutRequestResponse::Call::NoRequestNoResponse(
    ::zx::unowned_channel _client_end) {
  return ResultOf::NoRequestNoResponse(_client_end->get());
}

WithAndWithoutRequestResponse::ResultOf::NoRequestEmptyResponse::
    NoRequestEmptyResponse(zx_handle_t _client) {
  NoRequestEmptyResponseOwnedRequest _request(0);
  _request.GetFidlMessage().Call(
      NoRequestEmptyResponseResponse::Type, _client, bytes_,
      NoRequestEmptyResponseResponse::PrimarySize +
          NoRequestEmptyResponseResponse::MaxOutOfLine);
  status_ = _request.status();
  error_ = _request.error();
}

WithAndWithoutRequestResponse::ResultOf::NoRequestEmptyResponse
WithAndWithoutRequestResponse::SyncClient::NoRequestEmptyResponse() {
  return ResultOf::NoRequestEmptyResponse(this->channel().get());
}

WithAndWithoutRequestResponse::ResultOf::NoRequestEmptyResponse
WithAndWithoutRequestResponse::Call::NoRequestEmptyResponse(
    ::zx::unowned_channel _client_end) {
  return ResultOf::NoRequestEmptyResponse(_client_end->get());
}

WithAndWithoutRequestResponse::ResultOf::NoRequestWithResponse::
    NoRequestWithResponse(zx_handle_t _client)
    : bytes_(std::make_unique<
             ::fidl::internal::AlignedBuffer<ZX_CHANNEL_MAX_MSG_BYTES>>()) {
  NoRequestWithResponseOwnedRequest _request(0);
  _request.GetFidlMessage().Call(NoRequestWithResponseResponse::Type, _client,
                                 bytes_->data(), ZX_CHANNEL_MAX_MSG_BYTES);
  status_ = _request.status();
  error_ = _request.error();
}

WithAndWithoutRequestResponse::ResultOf::NoRequestWithResponse
WithAndWithoutRequestResponse::SyncClient::NoRequestWithResponse() {
  return ResultOf::NoRequestWithResponse(this->channel().get());
}

WithAndWithoutRequestResponse::ResultOf::NoRequestWithResponse
WithAndWithoutRequestResponse::Call::NoRequestWithResponse(
    ::zx::unowned_channel _client_end) {
  return ResultOf::NoRequestWithResponse(_client_end->get());
}

WithAndWithoutRequestResponse::UnownedResultOf::NoRequestWithResponse::
    NoRequestWithResponse(zx_handle_t _client, uint8_t* _response_bytes,
                          uint32_t _response_byte_capacity)
    : bytes_(_response_bytes) {
  NoRequestWithResponseOwnedRequest _request(0);
  _request.GetFidlMessage().Call(NoRequestWithResponseResponse::Type, _client,
                                 _response_bytes, _response_byte_capacity);
  status_ = _request.status();
  error_ = _request.error();
}

WithAndWithoutRequestResponse::UnownedResultOf::NoRequestWithResponse
WithAndWithoutRequestResponse::SyncClient::NoRequestWithResponse(
    ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::NoRequestWithResponse(this->channel().get(),
                                                _response_buffer.data(),
                                                _response_buffer.capacity());
}

WithAndWithoutRequestResponse::UnownedResultOf::NoRequestWithResponse
WithAndWithoutRequestResponse::Call::NoRequestWithResponse(
    ::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::NoRequestWithResponse(
      _client_end->get(), _response_buffer.data(), _response_buffer.capacity());
}

WithAndWithoutRequestResponse::ResultOf::WithRequestNoResponse::
    WithRequestNoResponse(zx_handle_t _client, const ::fidl::StringView& arg) {
  WithRequestNoResponseOwnedRequest _request(0, arg);
  _request.GetFidlMessage().Write(_client);
  status_ = _request.status();
  error_ = _request.error();
}

WithAndWithoutRequestResponse::ResultOf::WithRequestNoResponse
WithAndWithoutRequestResponse::SyncClient::WithRequestNoResponse(
    ::fidl::StringView arg) {
  return ResultOf::WithRequestNoResponse(this->channel().get(), arg);
}

WithAndWithoutRequestResponse::ResultOf::WithRequestNoResponse
WithAndWithoutRequestResponse::Call::WithRequestNoResponse(
    ::zx::unowned_channel _client_end, ::fidl::StringView arg) {
  return ResultOf::WithRequestNoResponse(_client_end->get(), arg);
}

WithAndWithoutRequestResponse::UnownedResultOf::WithRequestNoResponse::
    WithRequestNoResponse(zx_handle_t _client, uint8_t* _request_bytes,
                          uint32_t _request_byte_capacity,
                          const ::fidl::StringView& arg) {
  WithRequestNoResponseUnownedRequest _request(_request_bytes,
                                               _request_byte_capacity, 0, arg);
  _request.GetFidlMessage().Write(_client);
  status_ = _request.status();
  error_ = _request.error();
}

WithAndWithoutRequestResponse::UnownedResultOf::WithRequestNoResponse
WithAndWithoutRequestResponse::SyncClient::WithRequestNoResponse(
    ::fidl::BytePart _request_buffer, ::fidl::StringView arg) {
  return UnownedResultOf::WithRequestNoResponse(
      this->channel().get(), _request_buffer.data(), _request_buffer.capacity(),
      arg);
}

WithAndWithoutRequestResponse::UnownedResultOf::WithRequestNoResponse
WithAndWithoutRequestResponse::Call::WithRequestNoResponse(
    ::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer,
    ::fidl::StringView arg) {
  return UnownedResultOf::WithRequestNoResponse(
      _client_end->get(), _request_buffer.data(), _request_buffer.capacity(),
      arg);
}

WithAndWithoutRequestResponse::ResultOf::WithRequestEmptyResponse::
    WithRequestEmptyResponse(zx_handle_t _client,
                             const ::fidl::StringView& arg) {
  WithRequestEmptyResponseOwnedRequest _request(0, arg);
  _request.GetFidlMessage().Call(
      WithRequestEmptyResponseResponse::Type, _client, bytes_,
      WithRequestEmptyResponseResponse::PrimarySize +
          WithRequestEmptyResponseResponse::MaxOutOfLine);
  status_ = _request.status();
  error_ = _request.error();
}

WithAndWithoutRequestResponse::ResultOf::WithRequestEmptyResponse
WithAndWithoutRequestResponse::SyncClient::WithRequestEmptyResponse(
    ::fidl::StringView arg) {
  return ResultOf::WithRequestEmptyResponse(this->channel().get(), arg);
}

WithAndWithoutRequestResponse::ResultOf::WithRequestEmptyResponse
WithAndWithoutRequestResponse::Call::WithRequestEmptyResponse(
    ::zx::unowned_channel _client_end, ::fidl::StringView arg) {
  return ResultOf::WithRequestEmptyResponse(_client_end->get(), arg);
}

WithAndWithoutRequestResponse::UnownedResultOf::WithRequestEmptyResponse::
    WithRequestEmptyResponse(zx_handle_t _client, uint8_t* _request_bytes,
                             uint32_t _request_byte_capacity,
                             const ::fidl::StringView& arg,
                             uint8_t* _response_bytes,
                             uint32_t _response_byte_capacity)
    : bytes_(_response_bytes) {
  WithRequestEmptyResponseUnownedRequest _request(
      _request_bytes, _request_byte_capacity, 0, arg);
  _request.GetFidlMessage().Call(WithRequestEmptyResponseResponse::Type,
                                 _client, _response_bytes,
                                 _response_byte_capacity);
  status_ = _request.status();
  error_ = _request.error();
}

WithAndWithoutRequestResponse::UnownedResultOf::WithRequestEmptyResponse
WithAndWithoutRequestResponse::SyncClient::WithRequestEmptyResponse(
    ::fidl::BytePart _request_buffer, ::fidl::StringView arg,
    ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WithRequestEmptyResponse(
      this->channel().get(), _request_buffer.data(), _request_buffer.capacity(),
      arg, _response_buffer.data(), _response_buffer.capacity());
}

WithAndWithoutRequestResponse::UnownedResultOf::WithRequestEmptyResponse
WithAndWithoutRequestResponse::Call::WithRequestEmptyResponse(
    ::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer,
    ::fidl::StringView arg, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WithRequestEmptyResponse(
      _client_end->get(), _request_buffer.data(), _request_buffer.capacity(),
      arg, _response_buffer.data(), _response_buffer.capacity());
}

WithAndWithoutRequestResponse::ResultOf::WithRequestWithResponse::
    WithRequestWithResponse(zx_handle_t _client, const ::fidl::StringView& arg)
    : bytes_(std::make_unique<
             ::fidl::internal::AlignedBuffer<ZX_CHANNEL_MAX_MSG_BYTES>>()) {
  WithRequestWithResponseOwnedRequest _request(0, arg);
  _request.GetFidlMessage().Call(WithRequestWithResponseResponse::Type, _client,
                                 bytes_->data(), ZX_CHANNEL_MAX_MSG_BYTES);
  status_ = _request.status();
  error_ = _request.error();
}

WithAndWithoutRequestResponse::ResultOf::WithRequestWithResponse
WithAndWithoutRequestResponse::SyncClient::WithRequestWithResponse(
    ::fidl::StringView arg) {
  return ResultOf::WithRequestWithResponse(this->channel().get(), arg);
}

WithAndWithoutRequestResponse::ResultOf::WithRequestWithResponse
WithAndWithoutRequestResponse::Call::WithRequestWithResponse(
    ::zx::unowned_channel _client_end, ::fidl::StringView arg) {
  return ResultOf::WithRequestWithResponse(_client_end->get(), arg);
}

WithAndWithoutRequestResponse::UnownedResultOf::WithRequestWithResponse::
    WithRequestWithResponse(zx_handle_t _client, uint8_t* _request_bytes,
                            uint32_t _request_byte_capacity,
                            const ::fidl::StringView& arg,
                            uint8_t* _response_bytes,
                            uint32_t _response_byte_capacity)
    : bytes_(_response_bytes) {
  WithRequestWithResponseUnownedRequest _request(
      _request_bytes, _request_byte_capacity, 0, arg);
  _request.GetFidlMessage().Call(WithRequestWithResponseResponse::Type, _client,
                                 _response_bytes, _response_byte_capacity);
  status_ = _request.status();
  error_ = _request.error();
}

WithAndWithoutRequestResponse::UnownedResultOf::WithRequestWithResponse
WithAndWithoutRequestResponse::SyncClient::WithRequestWithResponse(
    ::fidl::BytePart _request_buffer, ::fidl::StringView arg,
    ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WithRequestWithResponse(
      this->channel().get(), _request_buffer.data(), _request_buffer.capacity(),
      arg, _response_buffer.data(), _response_buffer.capacity());
}

WithAndWithoutRequestResponse::UnownedResultOf::WithRequestWithResponse
WithAndWithoutRequestResponse::Call::WithRequestWithResponse(
    ::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer,
    ::fidl::StringView arg, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WithRequestWithResponse(
      _client_end->get(), _request_buffer.data(), _request_buffer.capacity(),
      arg, _response_buffer.data(), _response_buffer.capacity());
}

::fidl::Result
WithAndWithoutRequestResponse::ClientImpl::NoRequestNoResponse() {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    auto _res = ResultOf::NoRequestNoResponse(_binding->handle());
    return ::fidl::Result(_res.status(), _res.error());
  }
  return ::fidl::Result(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

WithAndWithoutRequestResponse::ResultOf::NoRequestEmptyResponse
WithAndWithoutRequestResponse::ClientImpl::NoRequestEmptyResponse_Sync() {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return ResultOf::NoRequestEmptyResponse(_binding->handle());
  }
  return WithAndWithoutRequestResponse::ResultOf::NoRequestEmptyResponse(
      ::fidl::Result(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound));
}

WithAndWithoutRequestResponse::NoRequestEmptyResponseResponseContext::
    NoRequestEmptyResponseResponseContext()
    : ::fidl::internal::ResponseContext(
          NoRequestEmptyResponseResponse::Type,
          kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal) {}

void WithAndWithoutRequestResponse::NoRequestEmptyResponseResponseContext::
    OnReply(uint8_t* reply) {
  OnReply(reinterpret_cast<NoRequestEmptyResponseResponse*>(reply));
}

::fidl::Result
WithAndWithoutRequestResponse::ClientImpl::NoRequestEmptyResponse(
    ::fit::callback<void()> _cb) {
  class ResponseContext final : public NoRequestEmptyResponseResponseContext {
   public:
    ResponseContext(::fit::callback<void()> cb) : cb_(std::move(cb)) {}

    void OnReply(NoRequestEmptyResponseResponse* message) override {
      cb_();

      delete this;
    }

    void OnError() override { delete this; }

   private:
    ::fit::callback<void()> cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::ClientBase::PrepareAsyncTxn(_context);
  NoRequestEmptyResponseOwnedRequest _request(_context->Txid());
  return _request.GetFidlMessage().Write(this, _context);
}

::fidl::Result
WithAndWithoutRequestResponse::ClientImpl::NoRequestEmptyResponse(
    NoRequestEmptyResponseResponseContext* _context) {
  ::fidl::internal::ClientBase::PrepareAsyncTxn(_context);

  NoRequestEmptyResponseOwnedRequest _request(_context->Txid());
  return _request.GetFidlMessage().Write(this, _context);
}

WithAndWithoutRequestResponse::ResultOf::NoRequestWithResponse
WithAndWithoutRequestResponse::ClientImpl::NoRequestWithResponse_Sync() {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return ResultOf::NoRequestWithResponse(_binding->handle());
  }
  return WithAndWithoutRequestResponse::ResultOf::NoRequestWithResponse(
      ::fidl::Result(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound));
}

WithAndWithoutRequestResponse::UnownedResultOf::NoRequestWithResponse
WithAndWithoutRequestResponse::ClientImpl::NoRequestWithResponse_Sync(
    ::fidl::BytePart _response_buffer) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return UnownedResultOf::NoRequestWithResponse(_binding->handle(),
                                                  _response_buffer.data(),
                                                  _response_buffer.capacity());
  }
  return WithAndWithoutRequestResponse::UnownedResultOf::NoRequestWithResponse(
      ::fidl::Result(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound));
}

WithAndWithoutRequestResponse::NoRequestWithResponseResponseContext::
    NoRequestWithResponseResponseContext()
    : ::fidl::internal::ResponseContext(
          NoRequestWithResponseResponse::Type,
          kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal) {}

void WithAndWithoutRequestResponse::NoRequestWithResponseResponseContext::
    OnReply(uint8_t* reply) {
  OnReply(reinterpret_cast<NoRequestWithResponseResponse*>(reply));
}

::fidl::Result WithAndWithoutRequestResponse::ClientImpl::NoRequestWithResponse(
    ::fit::callback<void(::fidl::StringView ret)> _cb) {
  class ResponseContext final : public NoRequestWithResponseResponseContext {
   public:
    ResponseContext(::fit::callback<void(::fidl::StringView ret)> cb)
        : cb_(std::move(cb)) {}

    void OnReply(NoRequestWithResponseResponse* message) override {
      cb_(std::move(message->ret));

      delete this;
    }

    void OnError() override { delete this; }

   private:
    ::fit::callback<void(::fidl::StringView ret)> cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::ClientBase::PrepareAsyncTxn(_context);
  NoRequestWithResponseOwnedRequest _request(_context->Txid());
  return _request.GetFidlMessage().Write(this, _context);
}

::fidl::Result WithAndWithoutRequestResponse::ClientImpl::NoRequestWithResponse(
    NoRequestWithResponseResponseContext* _context) {
  ::fidl::internal::ClientBase::PrepareAsyncTxn(_context);

  NoRequestWithResponseOwnedRequest _request(_context->Txid());
  return _request.GetFidlMessage().Write(this, _context);
}

::fidl::Result WithAndWithoutRequestResponse::ClientImpl::WithRequestNoResponse(
    ::fidl::StringView arg) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    auto _res = ResultOf::WithRequestNoResponse(_binding->handle(), arg);
    return ::fidl::Result(_res.status(), _res.error());
  }
  return ::fidl::Result(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

::fidl::Result WithAndWithoutRequestResponse::ClientImpl::WithRequestNoResponse(
    ::fidl::BytePart _request_buffer, ::fidl::StringView arg) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    auto _res = UnownedResultOf::WithRequestNoResponse(
        _binding->handle(), _request_buffer.data(), _request_buffer.capacity(),
        arg);
    return ::fidl::Result(_res.status(), _res.error());
  }
  return ::fidl::Result(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

WithAndWithoutRequestResponse::ResultOf::WithRequestEmptyResponse
WithAndWithoutRequestResponse::ClientImpl::WithRequestEmptyResponse_Sync(
    ::fidl::StringView arg) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return ResultOf::WithRequestEmptyResponse(_binding->handle(), arg);
  }
  return WithAndWithoutRequestResponse::ResultOf::WithRequestEmptyResponse(
      ::fidl::Result(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound));
}

WithAndWithoutRequestResponse::UnownedResultOf::WithRequestEmptyResponse
WithAndWithoutRequestResponse::ClientImpl::WithRequestEmptyResponse_Sync(
    ::fidl::BytePart _request_buffer, ::fidl::StringView arg,
    ::fidl::BytePart _response_buffer) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return UnownedResultOf::WithRequestEmptyResponse(
        _binding->handle(), _request_buffer.data(), _request_buffer.capacity(),
        arg, _response_buffer.data(), _response_buffer.capacity());
  }
  return WithAndWithoutRequestResponse::UnownedResultOf::
      WithRequestEmptyResponse(
          ::fidl::Result(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound));
}

WithAndWithoutRequestResponse::WithRequestEmptyResponseResponseContext::
    WithRequestEmptyResponseResponseContext()
    : ::fidl::internal::ResponseContext(
          WithRequestEmptyResponseResponse::Type,
          kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal) {}

void WithAndWithoutRequestResponse::WithRequestEmptyResponseResponseContext::
    OnReply(uint8_t* reply) {
  OnReply(reinterpret_cast<WithRequestEmptyResponseResponse*>(reply));
}

::fidl::Result
WithAndWithoutRequestResponse::ClientImpl::WithRequestEmptyResponse(
    ::fidl::StringView arg, ::fit::callback<void()> _cb) {
  class ResponseContext final : public WithRequestEmptyResponseResponseContext {
   public:
    ResponseContext(::fit::callback<void()> cb) : cb_(std::move(cb)) {}

    void OnReply(WithRequestEmptyResponseResponse* message) override {
      cb_();

      delete this;
    }

    void OnError() override { delete this; }

   private:
    ::fit::callback<void()> cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::ClientBase::PrepareAsyncTxn(_context);
  WithRequestEmptyResponseOwnedRequest _request(_context->Txid(), arg);
  return _request.GetFidlMessage().Write(this, _context);
}

::fidl::Result
WithAndWithoutRequestResponse::ClientImpl::WithRequestEmptyResponse(
    ::fidl::BytePart _request_buffer, ::fidl::StringView arg,
    WithRequestEmptyResponseResponseContext* _context) {
  ::fidl::internal::ClientBase::PrepareAsyncTxn(_context);

  WithRequestEmptyResponseUnownedRequest _request(_request_buffer.data(),
                                                  _request_buffer.capacity(),
                                                  _context->Txid(), arg);
  return _request.GetFidlMessage().Write(this, _context);
}

WithAndWithoutRequestResponse::ResultOf::WithRequestWithResponse
WithAndWithoutRequestResponse::ClientImpl::WithRequestWithResponse_Sync(
    ::fidl::StringView arg) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return ResultOf::WithRequestWithResponse(_binding->handle(), arg);
  }
  return WithAndWithoutRequestResponse::ResultOf::WithRequestWithResponse(
      ::fidl::Result(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound));
}

WithAndWithoutRequestResponse::UnownedResultOf::WithRequestWithResponse
WithAndWithoutRequestResponse::ClientImpl::WithRequestWithResponse_Sync(
    ::fidl::BytePart _request_buffer, ::fidl::StringView arg,
    ::fidl::BytePart _response_buffer) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return UnownedResultOf::WithRequestWithResponse(
        _binding->handle(), _request_buffer.data(), _request_buffer.capacity(),
        arg, _response_buffer.data(), _response_buffer.capacity());
  }
  return WithAndWithoutRequestResponse::UnownedResultOf::
      WithRequestWithResponse(
          ::fidl::Result(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound));
}

WithAndWithoutRequestResponse::WithRequestWithResponseResponseContext::
    WithRequestWithResponseResponseContext()
    : ::fidl::internal::ResponseContext(
          WithRequestWithResponseResponse::Type,
          kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal) {}

void WithAndWithoutRequestResponse::WithRequestWithResponseResponseContext::
    OnReply(uint8_t* reply) {
  OnReply(reinterpret_cast<WithRequestWithResponseResponse*>(reply));
}

::fidl::Result
WithAndWithoutRequestResponse::ClientImpl::WithRequestWithResponse(
    ::fidl::StringView arg, ::fit::callback<void(::fidl::StringView ret)> _cb) {
  class ResponseContext final : public WithRequestWithResponseResponseContext {
   public:
    ResponseContext(::fit::callback<void(::fidl::StringView ret)> cb)
        : cb_(std::move(cb)) {}

    void OnReply(WithRequestWithResponseResponse* message) override {
      cb_(std::move(message->ret));

      delete this;
    }

    void OnError() override { delete this; }

   private:
    ::fit::callback<void(::fidl::StringView ret)> cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::ClientBase::PrepareAsyncTxn(_context);
  WithRequestWithResponseOwnedRequest _request(_context->Txid(), arg);
  return _request.GetFidlMessage().Write(this, _context);
}

::fidl::Result
WithAndWithoutRequestResponse::ClientImpl::WithRequestWithResponse(
    ::fidl::BytePart _request_buffer, ::fidl::StringView arg,
    WithRequestWithResponseResponseContext* _context) {
  ::fidl::internal::ClientBase::PrepareAsyncTxn(_context);

  WithRequestWithResponseUnownedRequest _request(_request_buffer.data(),
                                                 _request_buffer.capacity(),
                                                 _context->Txid(), arg);
  return _request.GetFidlMessage().Write(this, _context);
}

std::optional<::fidl::UnbindInfo>
WithAndWithoutRequestResponse::ClientImpl::DispatchEvent(fidl_msg_t* msg) {
  fidl_message_header_t* hdr =
      reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal: {
      auto result = ::fidl::DecodeAs<OnEmptyResponseResponse>(msg);
      if (result.status != ZX_OK) {
        return ::fidl::UnbindInfo{::fidl::UnbindInfo::kDecodeError,
                                  result.status};
      }
      if (!handlers_.on_empty_response)
        return ::fidl::UnbindInfo{::fidl::UnbindInfo::kUnexpectedMessage,
                                  ZX_ERR_NOT_SUPPORTED};
      handlers_.on_empty_response();
      break;
    }
    case kWithAndWithoutRequestResponse_OnWithResponse_Ordinal: {
      auto result = ::fidl::DecodeAs<OnWithResponseResponse>(msg);
      if (result.status != ZX_OK) {
        return ::fidl::UnbindInfo{::fidl::UnbindInfo::kDecodeError,
                                  result.status};
      }
      if (auto* managed = std::get_if<0>(&handlers_.on_with_response)) {
        if (!(*managed))
          return ::fidl::UnbindInfo{::fidl::UnbindInfo::kUnexpectedMessage,
                                    ZX_ERR_NOT_SUPPORTED};
        auto message = result.message.message();
        (*managed)(std::move(message->ret));
      } else {
        std::get<1>(handlers_.on_with_response)(std::move(result.message));
      }
      break;
    }
    default:
      zx_handle_close_many(msg->handles, msg->num_handles);
      return ::fidl::UnbindInfo{::fidl::UnbindInfo::kUnexpectedMessage,
                                ZX_ERR_NOT_SUPPORTED};
  }
  return {};
}

::fidl::Result WithAndWithoutRequestResponse::Call::HandleEvents(
    ::zx::unowned_channel client_end,
    WithAndWithoutRequestResponse::EventHandlers& handlers) {
  zx_status_t status =
      client_end->wait_one(ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED,
                           ::zx::time::infinite(), nullptr);
  if (status != ZX_OK) {
    return ::fidl::Result(status, ::fidl::kErrorWaitOneFailed);
  }
  constexpr uint32_t kReadAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::internal::ClampedMessageSize<
            OnEmptyResponseResponse, ::fidl::MessageDirection::kReceiving>() >=
        x) {
      x = ::fidl::internal::ClampedMessageSize<
          OnEmptyResponseResponse, ::fidl::MessageDirection::kReceiving>();
    }
    if (::fidl::internal::ClampedMessageSize<
            OnWithResponseResponse, ::fidl::MessageDirection::kReceiving>() >=
        x) {
      x = ::fidl::internal::ClampedMessageSize<
          OnWithResponseResponse, ::fidl::MessageDirection::kReceiving>();
    }
    return x;
  })();
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (OnEmptyResponseResponse::MaxNumHandles >= x) {
      x = OnEmptyResponseResponse::MaxNumHandles;
    }
    if (OnWithResponseResponse::MaxNumHandles >= x) {
      x = OnWithResponseResponse::MaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  ::fidl::internal::ByteStorage<kReadAllocSize> read_storage;
  uint8_t* read_bytes = read_storage.buffer().data();
  zx_handle_t read_handles[kHandleAllocSize];
  uint32_t actual_bytes;
  uint32_t actual_handles;
  status = client_end->read(ZX_CHANNEL_READ_MAY_DISCARD, read_bytes,
                            read_handles, kReadAllocSize, kHandleAllocSize,
                            &actual_bytes, &actual_handles);
  if (status == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new
    // event, whose size exceeds the maximum of known events in the current
    // protocol.
    return ::fidl::Result(handlers.unknown(), nullptr);
  }
  if (status != ZX_OK) {
    return ::fidl::Result(status, ::fidl::kErrorReadFailed);
  }
  if (actual_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(read_handles, actual_handles);
    return ::fidl::Result(ZX_ERR_INVALID_ARGS, ::fidl::kErrorInvalidHeader);
  }
  fidl_message_header_t* hdr =
      reinterpret_cast<fidl_message_header_t*>(read_bytes);
  status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    zx_handle_close_many(read_handles, actual_handles);
    return ::fidl::Result(status, ::fidl::kErrorInvalidHeader);
  }
  switch (hdr->ordinal) {
    case kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal: {
      const char* error_message;
      zx_status_t status =
          fidl_decode(OnEmptyResponseResponse::Type, read_bytes, actual_bytes,
                      read_handles, actual_handles, &error_message);
      if (status != ZX_OK) {
        return ::fidl::Result(status, error_message);
      }
      return ::fidl::Result(handlers.on_empty_response(), nullptr);
    }
    case kWithAndWithoutRequestResponse_OnWithResponse_Ordinal: {
      const char* error_message;
      zx_status_t status =
          fidl_decode(OnWithResponseResponse::Type, read_bytes, actual_bytes,
                      read_handles, actual_handles, &error_message);
      if (status != ZX_OK) {
        return ::fidl::Result(status, error_message);
      }
      return ::fidl::Result(
          handlers.on_with_response(
              reinterpret_cast<OnWithResponseResponse*>(read_bytes)),
          nullptr);
    }
    default: {
      zx_handle_close_many(read_handles, actual_handles);
      return ::fidl::Result(handlers.unknown(), nullptr);
    }
  }
}

bool WithAndWithoutRequestResponse::TryDispatch(Interface* impl,
                                                fidl_msg_t* msg,
                                                ::fidl::Transaction* txn) {
  fidl_message_header_t* hdr =
      reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal: {
      auto result = ::fidl::DecodeAs<NoRequestNoResponseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->InternalError({::fidl::UnbindInfo::kDecodeError, result.status});
        return true;
      }
      impl->NoRequestNoResponse(
          Interface::NoRequestNoResponseCompleter::Sync(txn));
      return true;
    }
    case kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal: {
      auto result = ::fidl::DecodeAs<NoRequestEmptyResponseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->InternalError({::fidl::UnbindInfo::kDecodeError, result.status});
        return true;
      }
      impl->NoRequestEmptyResponse(
          Interface::NoRequestEmptyResponseCompleter::Sync(txn));
      return true;
    }
    case kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal: {
      auto result = ::fidl::DecodeAs<NoRequestWithResponseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->InternalError({::fidl::UnbindInfo::kDecodeError, result.status});
        return true;
      }
      impl->NoRequestWithResponse(
          Interface::NoRequestWithResponseCompleter::Sync(txn));
      return true;
    }
    case kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal: {
      auto result = ::fidl::DecodeAs<WithRequestNoResponseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->InternalError({::fidl::UnbindInfo::kDecodeError, result.status});
        return true;
      }
      auto message = result.message.message();
      impl->WithRequestNoResponse(
          std::move(message->arg),
          Interface::WithRequestNoResponseCompleter::Sync(txn));
      return true;
    }
    case kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal: {
      auto result = ::fidl::DecodeAs<WithRequestEmptyResponseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->InternalError({::fidl::UnbindInfo::kDecodeError, result.status});
        return true;
      }
      auto message = result.message.message();
      impl->WithRequestEmptyResponse(
          std::move(message->arg),
          Interface::WithRequestEmptyResponseCompleter::Sync(txn));
      return true;
    }
    case kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal: {
      auto result = ::fidl::DecodeAs<WithRequestWithResponseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->InternalError({::fidl::UnbindInfo::kDecodeError, result.status});
        return true;
      }
      auto message = result.message.message();
      impl->WithRequestWithResponse(
          std::move(message->arg),
          Interface::WithRequestWithResponseCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool WithAndWithoutRequestResponse::Dispatch(Interface* impl, fidl_msg_t* msg,
                                             ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->InternalError(
        {::fidl::UnbindInfo::kUnexpectedMessage, ZX_ERR_NOT_SUPPORTED});
  }
  return found;
}

::fidl::Result WithAndWithoutRequestResponse::Interface::
    NoRequestEmptyResponseCompleterBase::Reply() {
  NoRequestEmptyResponseOwnedResponse _response{};
  return CompleterBase::SendReply(_response.GetFidlMessage());
}

::fidl::Result WithAndWithoutRequestResponse::Interface::
    NoRequestWithResponseCompleterBase::Reply(::fidl::StringView ret) {
  NoRequestWithResponseOwnedResponse _response{ret};
  return CompleterBase::SendReply(_response.GetFidlMessage());
}

::fidl::Result WithAndWithoutRequestResponse::Interface::
    NoRequestWithResponseCompleterBase::Reply(::fidl::BytePart _buffer,
                                              ::fidl::StringView ret) {
  NoRequestWithResponseUnownedResponse _response(_buffer.data(),
                                                 _buffer.capacity(), ret);
  return CompleterBase::SendReply(_response.GetFidlMessage());
}

::fidl::Result WithAndWithoutRequestResponse::Interface::
    WithRequestEmptyResponseCompleterBase::Reply() {
  WithRequestEmptyResponseOwnedResponse _response{};
  return CompleterBase::SendReply(_response.GetFidlMessage());
}

::fidl::Result WithAndWithoutRequestResponse::Interface::
    WithRequestWithResponseCompleterBase::Reply(::fidl::StringView ret) {
  WithRequestWithResponseOwnedResponse _response{ret};
  return CompleterBase::SendReply(_response.GetFidlMessage());
}

::fidl::Result WithAndWithoutRequestResponse::Interface::
    WithRequestWithResponseCompleterBase::Reply(::fidl::BytePart _buffer,
                                                ::fidl::StringView ret) {
  WithRequestWithResponseUnownedResponse _response(_buffer.data(),
                                                   _buffer.capacity(), ret);
  return CompleterBase::SendReply(_response.GetFidlMessage());
}

zx_status_t WithAndWithoutRequestResponse::SendOnEmptyResponseEvent(
    ::zx::unowned_channel _chan) {
  // Destructors can't be called because it will lead to handle double close
  // (here and in fidl::Encode).
  FIDL_ALIGNDECL uint8_t _response_buffer[sizeof(OnEmptyResponseResponse)];
  auto& _response = *new (_response_buffer) OnEmptyResponseResponse{};

  auto _encoded =
      ::fidl::internal::LinearizedAndEncoded<OnEmptyResponseResponse>(
          &_response);
  auto& _encode_result = _encoded.result();
  if (_encode_result.status != ZX_OK) {
    return _encode_result.status;
  }
  return ::fidl::Write(::zx::unowned_channel(_chan),
                       std::move(_encode_result.message));
}

zx_status_t WithAndWithoutRequestResponse::SendOnWithResponseEvent(
    ::zx::unowned_channel _chan, ::fidl::StringView ret) {
  OnWithResponseResponse _response{ret};

  auto _encoded =
      ::fidl::internal::LinearizedAndEncoded<OnWithResponseResponse>(
          &_response);
  auto& _encode_result = _encoded.result();
  if (_encode_result.status != ZX_OK) {
    return _encode_result.status;
  }
  return ::fidl::Write(::zx::unowned_channel(_chan),
                       std::move(_encode_result.message));
}

zx_status_t WithAndWithoutRequestResponse::SendOnWithResponseEvent(
    ::zx::unowned_channel _chan, ::fidl::BytePart _buffer,
    ::fidl::StringView ret) {
  if (_buffer.capacity() < OnWithResponseResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  OnWithResponseResponse _response{ret};
  auto _encode_result = ::fidl::LinearizeAndEncode<OnWithResponseResponse>(
      &_response, std::move(_buffer));
  if (_encode_result.status != ZX_OK) {
    return _encode_result.status;
  }
  return ::fidl::Write(::zx::unowned_channel(_chan),
                       std::move(_encode_result.message));
}

zx_status_t WithAndWithoutRequestResponse::SendOnWithResponseEvent(
    ::zx::unowned_channel _chan,
    ::fidl::DecodedMessage<OnWithResponseResponse> params) {
  ZX_ASSERT(params.message()->_hdr.magic_number ==
            kFidlWireFormatMagicNumberInitial);
  ZX_ASSERT(params.message()->_hdr.ordinal ==
            kWithAndWithoutRequestResponse_OnWithResponse_Ordinal);
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(params));
}

void WithAndWithoutRequestResponse::NoRequestNoResponseRequest::_InitHeader(
    zx_txid_t _txid) {
  fidl_init_txn_header(
      &_hdr, _txid, kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal);
}

void WithAndWithoutRequestResponse::NoRequestEmptyResponseRequest::_InitHeader(
    zx_txid_t _txid) {
  fidl_init_txn_header(
      &_hdr, _txid,
      kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal);
}

void WithAndWithoutRequestResponse::NoRequestEmptyResponseResponse::
    _InitHeader() {
  fidl_init_txn_header(
      &_hdr, 0, kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal);
}

void WithAndWithoutRequestResponse::NoRequestWithResponseRequest::_InitHeader(
    zx_txid_t _txid) {
  fidl_init_txn_header(
      &_hdr, _txid,
      kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal);
}

void WithAndWithoutRequestResponse::NoRequestWithResponseResponse::
    _InitHeader() {
  fidl_init_txn_header(
      &_hdr, 0, kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal);
}

void WithAndWithoutRequestResponse::WithRequestNoResponseRequest::_InitHeader(
    zx_txid_t _txid) {
  fidl_init_txn_header(
      &_hdr, _txid,
      kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal);
}

void WithAndWithoutRequestResponse::WithRequestEmptyResponseRequest::
    _InitHeader(zx_txid_t _txid) {
  fidl_init_txn_header(
      &_hdr, _txid,
      kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal);
}

void WithAndWithoutRequestResponse::WithRequestEmptyResponseResponse::
    _InitHeader() {
  fidl_init_txn_header(
      &_hdr, 0,
      kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal);
}

void WithAndWithoutRequestResponse::WithRequestWithResponseRequest::_InitHeader(
    zx_txid_t _txid) {
  fidl_init_txn_header(
      &_hdr, _txid,
      kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal);
}

void WithAndWithoutRequestResponse::WithRequestWithResponseResponse::
    _InitHeader() {
  fidl_init_txn_header(
      &_hdr, 0, kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal);
}

void WithAndWithoutRequestResponse::OnEmptyResponseResponse::_InitHeader() {
  fidl_init_txn_header(&_hdr, 0,
                       kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal);
}

void WithAndWithoutRequestResponse::OnWithResponseResponse::_InitHeader() {
  fidl_init_txn_header(&_hdr, 0,
                       kWithAndWithoutRequestResponse_OnWithResponse_Ordinal);
}

void ::llcpp::test::name::WithErrorSyntax_ErrorAsEnum_Result::
    SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(WithErrorSyntax_ErrorAsEnum_Result) ==
                sizeof(fidl_xunion_t));
  static_assert(offsetof(WithErrorSyntax_ErrorAsEnum_Result, ordinal_) ==
                offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(WithErrorSyntax_ErrorAsEnum_Result, envelope_) ==
                offsetof(fidl_xunion_t, envelope));
}

namespace {

[[maybe_unused]] constexpr uint64_t kWithErrorSyntax_ResponseAsStruct_Ordinal =
    6422511116044938191lu;
extern "C" const fidl_type_t
    test_name_WithErrorSyntaxResponseAsStructRequestTable;
extern "C" const fidl_type_t
    test_name_WithErrorSyntaxResponseAsStructResponseTable;
[[maybe_unused]] constexpr uint64_t kWithErrorSyntax_ErrorAsPrimitive_Ordinal =
    2364249812017832126lu;
extern "C" const fidl_type_t
    test_name_WithErrorSyntaxErrorAsPrimitiveRequestTable;
extern "C" const fidl_type_t
    test_name_WithErrorSyntaxErrorAsPrimitiveResponseTable;
[[maybe_unused]] constexpr uint64_t kWithErrorSyntax_ErrorAsEnum_Ordinal =
    4597390537870356095lu;
extern "C" const fidl_type_t test_name_WithErrorSyntaxErrorAsEnumRequestTable;
extern "C" const fidl_type_t test_name_WithErrorSyntaxErrorAsEnumResponseTable;

}  // namespace
WithErrorSyntax::ResultOf::ResponseAsStruct::ResponseAsStruct(
    zx_handle_t _client) {
  ResponseAsStructOwnedRequest _request(0);
  _request.GetFidlMessage().Call(ResponseAsStructResponse::Type, _client,
                                 bytes_,
                                 ResponseAsStructResponse::PrimarySize +
                                     ResponseAsStructResponse::MaxOutOfLine);
  status_ = _request.status();
  error_ = _request.error();
}

WithErrorSyntax::ResultOf::ResponseAsStruct
WithErrorSyntax::SyncClient::ResponseAsStruct() {
  return ResultOf::ResponseAsStruct(this->channel().get());
}

WithErrorSyntax::ResultOf::ResponseAsStruct
WithErrorSyntax::Call::ResponseAsStruct(::zx::unowned_channel _client_end) {
  return ResultOf::ResponseAsStruct(_client_end->get());
}

WithErrorSyntax::UnownedResultOf::ResponseAsStruct::ResponseAsStruct(
    zx_handle_t _client, uint8_t* _response_bytes,
    uint32_t _response_byte_capacity)
    : bytes_(_response_bytes) {
  ResponseAsStructOwnedRequest _request(0);
  _request.GetFidlMessage().Call(ResponseAsStructResponse::Type, _client,
                                 _response_bytes, _response_byte_capacity);
  status_ = _request.status();
  error_ = _request.error();
}

WithErrorSyntax::UnownedResultOf::ResponseAsStruct
WithErrorSyntax::SyncClient::ResponseAsStruct(
    ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ResponseAsStruct(this->channel().get(),
                                           _response_buffer.data(),
                                           _response_buffer.capacity());
}

WithErrorSyntax::UnownedResultOf::ResponseAsStruct
WithErrorSyntax::Call::ResponseAsStruct(::zx::unowned_channel _client_end,
                                        ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ResponseAsStruct(
      _client_end->get(), _response_buffer.data(), _response_buffer.capacity());
}

WithErrorSyntax::ResultOf::ErrorAsPrimitive::ErrorAsPrimitive(
    zx_handle_t _client) {
  ErrorAsPrimitiveOwnedRequest _request(0);
  _request.GetFidlMessage().Call(ErrorAsPrimitiveResponse::Type, _client,
                                 bytes_,
                                 ErrorAsPrimitiveResponse::PrimarySize +
                                     ErrorAsPrimitiveResponse::MaxOutOfLine);
  status_ = _request.status();
  error_ = _request.error();
}

WithErrorSyntax::ResultOf::ErrorAsPrimitive
WithErrorSyntax::SyncClient::ErrorAsPrimitive() {
  return ResultOf::ErrorAsPrimitive(this->channel().get());
}

WithErrorSyntax::ResultOf::ErrorAsPrimitive
WithErrorSyntax::Call::ErrorAsPrimitive(::zx::unowned_channel _client_end) {
  return ResultOf::ErrorAsPrimitive(_client_end->get());
}

WithErrorSyntax::UnownedResultOf::ErrorAsPrimitive::ErrorAsPrimitive(
    zx_handle_t _client, uint8_t* _response_bytes,
    uint32_t _response_byte_capacity)
    : bytes_(_response_bytes) {
  ErrorAsPrimitiveOwnedRequest _request(0);
  _request.GetFidlMessage().Call(ErrorAsPrimitiveResponse::Type, _client,
                                 _response_bytes, _response_byte_capacity);
  status_ = _request.status();
  error_ = _request.error();
}

WithErrorSyntax::UnownedResultOf::ErrorAsPrimitive
WithErrorSyntax::SyncClient::ErrorAsPrimitive(
    ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ErrorAsPrimitive(this->channel().get(),
                                           _response_buffer.data(),
                                           _response_buffer.capacity());
}

WithErrorSyntax::UnownedResultOf::ErrorAsPrimitive
WithErrorSyntax::Call::ErrorAsPrimitive(::zx::unowned_channel _client_end,
                                        ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ErrorAsPrimitive(
      _client_end->get(), _response_buffer.data(), _response_buffer.capacity());
}

WithErrorSyntax::ResultOf::ErrorAsEnum::ErrorAsEnum(zx_handle_t _client) {
  ErrorAsEnumOwnedRequest _request(0);
  _request.GetFidlMessage().Call(
      ErrorAsEnumResponse::Type, _client, bytes_,
      ErrorAsEnumResponse::PrimarySize + ErrorAsEnumResponse::MaxOutOfLine);
  status_ = _request.status();
  error_ = _request.error();
}

WithErrorSyntax::ResultOf::ErrorAsEnum
WithErrorSyntax::SyncClient::ErrorAsEnum() {
  return ResultOf::ErrorAsEnum(this->channel().get());
}

WithErrorSyntax::ResultOf::ErrorAsEnum WithErrorSyntax::Call::ErrorAsEnum(
    ::zx::unowned_channel _client_end) {
  return ResultOf::ErrorAsEnum(_client_end->get());
}

WithErrorSyntax::UnownedResultOf::ErrorAsEnum::ErrorAsEnum(
    zx_handle_t _client, uint8_t* _response_bytes,
    uint32_t _response_byte_capacity)
    : bytes_(_response_bytes) {
  ErrorAsEnumOwnedRequest _request(0);
  _request.GetFidlMessage().Call(ErrorAsEnumResponse::Type, _client,
                                 _response_bytes, _response_byte_capacity);
  status_ = _request.status();
  error_ = _request.error();
}

WithErrorSyntax::UnownedResultOf::ErrorAsEnum
WithErrorSyntax::SyncClient::ErrorAsEnum(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ErrorAsEnum(this->channel().get(),
                                      _response_buffer.data(),
                                      _response_buffer.capacity());
}

WithErrorSyntax::UnownedResultOf::ErrorAsEnum
WithErrorSyntax::Call::ErrorAsEnum(::zx::unowned_channel _client_end,
                                   ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ErrorAsEnum(
      _client_end->get(), _response_buffer.data(), _response_buffer.capacity());
}

WithErrorSyntax::ResultOf::ResponseAsStruct
WithErrorSyntax::ClientImpl::ResponseAsStruct_Sync() {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return ResultOf::ResponseAsStruct(_binding->handle());
  }
  return WithErrorSyntax::ResultOf::ResponseAsStruct(
      ::fidl::Result(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound));
}

WithErrorSyntax::UnownedResultOf::ResponseAsStruct
WithErrorSyntax::ClientImpl::ResponseAsStruct_Sync(
    ::fidl::BytePart _response_buffer) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return UnownedResultOf::ResponseAsStruct(_binding->handle(),
                                             _response_buffer.data(),
                                             _response_buffer.capacity());
  }
  return WithErrorSyntax::UnownedResultOf::ResponseAsStruct(
      ::fidl::Result(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound));
}

WithErrorSyntax::ResponseAsStructResponseContext::
    ResponseAsStructResponseContext()
    : ::fidl::internal::ResponseContext(
          ResponseAsStructResponse::Type,
          kWithErrorSyntax_ResponseAsStruct_Ordinal) {}

void WithErrorSyntax::ResponseAsStructResponseContext::OnReply(uint8_t* reply) {
  OnReply(reinterpret_cast<ResponseAsStructResponse*>(reply));
}

::fidl::Result WithErrorSyntax::ClientImpl::ResponseAsStruct(
    ::fit::callback<void(
        ::llcpp::test::name::WithErrorSyntax_ResponseAsStruct_Result result)>
        _cb) {
  class ResponseContext final : public ResponseAsStructResponseContext {
   public:
    ResponseContext(
        ::fit::callback<
            void(::llcpp::test::name::WithErrorSyntax_ResponseAsStruct_Result
                     result)>
            cb)
        : cb_(std::move(cb)) {}

    void OnReply(ResponseAsStructResponse* message) override {
      cb_(std::move(message->result));

      delete this;
    }

    void OnError() override { delete this; }

   private:
    ::fit::callback<void(
        ::llcpp::test::name::WithErrorSyntax_ResponseAsStruct_Result result)>
        cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::ClientBase::PrepareAsyncTxn(_context);
  ResponseAsStructOwnedRequest _request(_context->Txid());
  return _request.GetFidlMessage().Write(this, _context);
}

::fidl::Result WithErrorSyntax::ClientImpl::ResponseAsStruct(
    ResponseAsStructResponseContext* _context) {
  ::fidl::internal::ClientBase::PrepareAsyncTxn(_context);

  ResponseAsStructOwnedRequest _request(_context->Txid());
  return _request.GetFidlMessage().Write(this, _context);
}

WithErrorSyntax::ResultOf::ErrorAsPrimitive
WithErrorSyntax::ClientImpl::ErrorAsPrimitive_Sync() {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return ResultOf::ErrorAsPrimitive(_binding->handle());
  }
  return WithErrorSyntax::ResultOf::ErrorAsPrimitive(
      ::fidl::Result(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound));
}

WithErrorSyntax::UnownedResultOf::ErrorAsPrimitive
WithErrorSyntax::ClientImpl::ErrorAsPrimitive_Sync(
    ::fidl::BytePart _response_buffer) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return UnownedResultOf::ErrorAsPrimitive(_binding->handle(),
                                             _response_buffer.data(),
                                             _response_buffer.capacity());
  }
  return WithErrorSyntax::UnownedResultOf::ErrorAsPrimitive(
      ::fidl::Result(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound));
}

WithErrorSyntax::ErrorAsPrimitiveResponseContext::
    ErrorAsPrimitiveResponseContext()
    : ::fidl::internal::ResponseContext(
          ErrorAsPrimitiveResponse::Type,
          kWithErrorSyntax_ErrorAsPrimitive_Ordinal) {}

void WithErrorSyntax::ErrorAsPrimitiveResponseContext::OnReply(uint8_t* reply) {
  OnReply(reinterpret_cast<ErrorAsPrimitiveResponse*>(reply));
}

::fidl::Result WithErrorSyntax::ClientImpl::ErrorAsPrimitive(
    ::fit::callback<void(
        ::llcpp::test::name::WithErrorSyntax_ErrorAsPrimitive_Result result)>
        _cb) {
  class ResponseContext final : public ErrorAsPrimitiveResponseContext {
   public:
    ResponseContext(
        ::fit::callback<
            void(::llcpp::test::name::WithErrorSyntax_ErrorAsPrimitive_Result
                     result)>
            cb)
        : cb_(std::move(cb)) {}

    void OnReply(ErrorAsPrimitiveResponse* message) override {
      cb_(std::move(message->result));

      delete this;
    }

    void OnError() override { delete this; }

   private:
    ::fit::callback<void(
        ::llcpp::test::name::WithErrorSyntax_ErrorAsPrimitive_Result result)>
        cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::ClientBase::PrepareAsyncTxn(_context);
  ErrorAsPrimitiveOwnedRequest _request(_context->Txid());
  return _request.GetFidlMessage().Write(this, _context);
}

::fidl::Result WithErrorSyntax::ClientImpl::ErrorAsPrimitive(
    ErrorAsPrimitiveResponseContext* _context) {
  ::fidl::internal::ClientBase::PrepareAsyncTxn(_context);

  ErrorAsPrimitiveOwnedRequest _request(_context->Txid());
  return _request.GetFidlMessage().Write(this, _context);
}

WithErrorSyntax::ResultOf::ErrorAsEnum
WithErrorSyntax::ClientImpl::ErrorAsEnum_Sync() {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return ResultOf::ErrorAsEnum(_binding->handle());
  }
  return WithErrorSyntax::ResultOf::ErrorAsEnum(
      ::fidl::Result(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound));
}

WithErrorSyntax::UnownedResultOf::ErrorAsEnum
WithErrorSyntax::ClientImpl::ErrorAsEnum_Sync(
    ::fidl::BytePart _response_buffer) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return UnownedResultOf::ErrorAsEnum(_binding->handle(),
                                        _response_buffer.data(),
                                        _response_buffer.capacity());
  }
  return WithErrorSyntax::UnownedResultOf::ErrorAsEnum(
      ::fidl::Result(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound));
}

WithErrorSyntax::ErrorAsEnumResponseContext::ErrorAsEnumResponseContext()
    : ::fidl::internal::ResponseContext(ErrorAsEnumResponse::Type,
                                        kWithErrorSyntax_ErrorAsEnum_Ordinal) {}

void WithErrorSyntax::ErrorAsEnumResponseContext::OnReply(uint8_t* reply) {
  OnReply(reinterpret_cast<ErrorAsEnumResponse*>(reply));
}

::fidl::Result WithErrorSyntax::ClientImpl::ErrorAsEnum(
    ::fit::callback<
        void(::llcpp::test::name::WithErrorSyntax_ErrorAsEnum_Result result)>
        _cb) {
  class ResponseContext final : public ErrorAsEnumResponseContext {
   public:
    ResponseContext(
        ::fit::callback<void(
            ::llcpp::test::name::WithErrorSyntax_ErrorAsEnum_Result result)>
            cb)
        : cb_(std::move(cb)) {}

    void OnReply(ErrorAsEnumResponse* message) override {
      cb_(std::move(message->result));

      delete this;
    }

    void OnError() override { delete this; }

   private:
    ::fit::callback<void(
        ::llcpp::test::name::WithErrorSyntax_ErrorAsEnum_Result result)>
        cb_;
  };

  auto* _context = new ResponseContext(std::move(_cb));
  ::fidl::internal::ClientBase::PrepareAsyncTxn(_context);
  ErrorAsEnumOwnedRequest _request(_context->Txid());
  return _request.GetFidlMessage().Write(this, _context);
}

::fidl::Result WithErrorSyntax::ClientImpl::ErrorAsEnum(
    ErrorAsEnumResponseContext* _context) {
  ::fidl::internal::ClientBase::PrepareAsyncTxn(_context);

  ErrorAsEnumOwnedRequest _request(_context->Txid());
  return _request.GetFidlMessage().Write(this, _context);
}

std::optional<::fidl::UnbindInfo> WithErrorSyntax::ClientImpl::DispatchEvent(
    fidl_msg_t* msg) {
  fidl_message_header_t* hdr =
      reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    default:
      zx_handle_close_many(msg->handles, msg->num_handles);
      return ::fidl::UnbindInfo{::fidl::UnbindInfo::kUnexpectedMessage,
                                ZX_ERR_NOT_SUPPORTED};
  }
  return {};
}

bool WithErrorSyntax::TryDispatch(Interface* impl, fidl_msg_t* msg,
                                  ::fidl::Transaction* txn) {
  fidl_message_header_t* hdr =
      reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kWithErrorSyntax_ResponseAsStruct_Ordinal: {
      auto result = ::fidl::DecodeAs<ResponseAsStructRequest>(msg);
      if (result.status != ZX_OK) {
        txn->InternalError({::fidl::UnbindInfo::kDecodeError, result.status});
        return true;
      }
      impl->ResponseAsStruct(Interface::ResponseAsStructCompleter::Sync(txn));
      return true;
    }
    case kWithErrorSyntax_ErrorAsPrimitive_Ordinal: {
      auto result = ::fidl::DecodeAs<ErrorAsPrimitiveRequest>(msg);
      if (result.status != ZX_OK) {
        txn->InternalError({::fidl::UnbindInfo::kDecodeError, result.status});
        return true;
      }
      impl->ErrorAsPrimitive(Interface::ErrorAsPrimitiveCompleter::Sync(txn));
      return true;
    }
    case kWithErrorSyntax_ErrorAsEnum_Ordinal: {
      auto result = ::fidl::DecodeAs<ErrorAsEnumRequest>(msg);
      if (result.status != ZX_OK) {
        txn->InternalError({::fidl::UnbindInfo::kDecodeError, result.status});
        return true;
      }
      impl->ErrorAsEnum(Interface::ErrorAsEnumCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool WithErrorSyntax::Dispatch(Interface* impl, fidl_msg_t* msg,
                               ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->InternalError(
        {::fidl::UnbindInfo::kUnexpectedMessage, ZX_ERR_NOT_SUPPORTED});
  }
  return found;
}

::fidl::Result WithErrorSyntax::Interface::ResponseAsStructCompleterBase::Reply(
    ::llcpp::test::name::WithErrorSyntax_ResponseAsStruct_Result result) {
  ResponseAsStructOwnedResponse _response{result};
  return CompleterBase::SendReply(_response.GetFidlMessage());
}
::fidl::Result
WithErrorSyntax::Interface::ResponseAsStructCompleterBase::ReplySuccess(
    int64_t a, int64_t b, int64_t c) {
  ::fidl::aligned<WithErrorSyntax_ResponseAsStruct_Response> response;
  response.value.a = std::move(a);
  response.value.b = std::move(b);
  response.value.c = std::move(c);

  return Reply(WithErrorSyntax_ResponseAsStruct_Result::WithResponse(
      ::fidl::unowned_ptr(&response)));
}
::fidl::Result
WithErrorSyntax::Interface::ResponseAsStructCompleterBase::ReplyError(
    uint32_t error) {
  return Reply(WithErrorSyntax_ResponseAsStruct_Result::WithErr(
      ::fidl::unowned_ptr(&error)));
}

::fidl::Result WithErrorSyntax::Interface::ResponseAsStructCompleterBase::Reply(
    ::fidl::BytePart _buffer,
    ::llcpp::test::name::WithErrorSyntax_ResponseAsStruct_Result result) {
  ResponseAsStructUnownedResponse _response(_buffer.data(), _buffer.capacity(),
                                            result);
  return CompleterBase::SendReply(_response.GetFidlMessage());
}
::fidl::Result
WithErrorSyntax::Interface::ResponseAsStructCompleterBase::ReplySuccess(
    ::fidl::BytePart _buffer, int64_t a, int64_t b, int64_t c) {
  ::fidl::aligned<WithErrorSyntax_ResponseAsStruct_Response> response;
  response.value.a = std::move(a);
  response.value.b = std::move(b);
  response.value.c = std::move(c);

  return Reply(std::move(_buffer),
               WithErrorSyntax_ResponseAsStruct_Result::WithResponse(
                   ::fidl::unowned_ptr(&response)));
}

::fidl::Result WithErrorSyntax::Interface::ErrorAsPrimitiveCompleterBase::Reply(
    ::llcpp::test::name::WithErrorSyntax_ErrorAsPrimitive_Result result) {
  ErrorAsPrimitiveOwnedResponse _response{result};
  return CompleterBase::SendReply(_response.GetFidlMessage());
}
::fidl::Result
WithErrorSyntax::Interface::ErrorAsPrimitiveCompleterBase::ReplySuccess() {
  ::fidl::aligned<WithErrorSyntax_ErrorAsPrimitive_Response> response;

  return Reply(WithErrorSyntax_ErrorAsPrimitive_Result::WithResponse(
      ::fidl::unowned_ptr(&response)));
}
::fidl::Result
WithErrorSyntax::Interface::ErrorAsPrimitiveCompleterBase::ReplyError(
    uint32_t error) {
  return Reply(WithErrorSyntax_ErrorAsPrimitive_Result::WithErr(
      ::fidl::unowned_ptr(&error)));
}

::fidl::Result WithErrorSyntax::Interface::ErrorAsPrimitiveCompleterBase::Reply(
    ::fidl::BytePart _buffer,
    ::llcpp::test::name::WithErrorSyntax_ErrorAsPrimitive_Result result) {
  ErrorAsPrimitiveUnownedResponse _response(_buffer.data(), _buffer.capacity(),
                                            result);
  return CompleterBase::SendReply(_response.GetFidlMessage());
}
::fidl::Result
WithErrorSyntax::Interface::ErrorAsPrimitiveCompleterBase::ReplySuccess(
    ::fidl::BytePart _buffer) {
  ::fidl::aligned<WithErrorSyntax_ErrorAsPrimitive_Response> response;

  return Reply(std::move(_buffer),
               WithErrorSyntax_ErrorAsPrimitive_Result::WithResponse(
                   ::fidl::unowned_ptr(&response)));
}

::fidl::Result WithErrorSyntax::Interface::ErrorAsEnumCompleterBase::Reply(
    ::llcpp::test::name::WithErrorSyntax_ErrorAsEnum_Result result) {
  ErrorAsEnumOwnedResponse _response{result};
  return CompleterBase::SendReply(_response.GetFidlMessage());
}
::fidl::Result
WithErrorSyntax::Interface::ErrorAsEnumCompleterBase::ReplySuccess() {
  ::fidl::aligned<WithErrorSyntax_ErrorAsEnum_Response> response;

  return Reply(WithErrorSyntax_ErrorAsEnum_Result::WithResponse(
      ::fidl::unowned_ptr(&response)));
}
::fidl::Result WithErrorSyntax::Interface::ErrorAsEnumCompleterBase::ReplyError(
    ErrorEnun error) {
  return Reply(
      WithErrorSyntax_ErrorAsEnum_Result::WithErr(::fidl::unowned_ptr(&error)));
}

::fidl::Result WithErrorSyntax::Interface::ErrorAsEnumCompleterBase::Reply(
    ::fidl::BytePart _buffer,
    ::llcpp::test::name::WithErrorSyntax_ErrorAsEnum_Result result) {
  ErrorAsEnumUnownedResponse _response(_buffer.data(), _buffer.capacity(),
                                       result);
  return CompleterBase::SendReply(_response.GetFidlMessage());
}
::fidl::Result
WithErrorSyntax::Interface::ErrorAsEnumCompleterBase::ReplySuccess(
    ::fidl::BytePart _buffer) {
  ::fidl::aligned<WithErrorSyntax_ErrorAsEnum_Response> response;

  return Reply(std::move(_buffer),
               WithErrorSyntax_ErrorAsEnum_Result::WithResponse(
                   ::fidl::unowned_ptr(&response)));
}

void WithErrorSyntax::ResponseAsStructRequest::_InitHeader(zx_txid_t _txid) {
  fidl_init_txn_header(&_hdr, _txid, kWithErrorSyntax_ResponseAsStruct_Ordinal);
}

void WithErrorSyntax::ResponseAsStructResponse::_InitHeader() {
  fidl_init_txn_header(&_hdr, 0, kWithErrorSyntax_ResponseAsStruct_Ordinal);
}

void WithErrorSyntax::ErrorAsPrimitiveRequest::_InitHeader(zx_txid_t _txid) {
  fidl_init_txn_header(&_hdr, _txid, kWithErrorSyntax_ErrorAsPrimitive_Ordinal);
}

void WithErrorSyntax::ErrorAsPrimitiveResponse::_InitHeader() {
  fidl_init_txn_header(&_hdr, 0, kWithErrorSyntax_ErrorAsPrimitive_Ordinal);
}

void WithErrorSyntax::ErrorAsEnumRequest::_InitHeader(zx_txid_t _txid) {
  fidl_init_txn_header(&_hdr, _txid, kWithErrorSyntax_ErrorAsEnum_Ordinal);
}

void WithErrorSyntax::ErrorAsEnumResponse::_InitHeader() {
  fidl_init_txn_header(&_hdr, 0, kWithErrorSyntax_ErrorAsEnum_Ordinal);
}

}  // namespace name
}  // namespace test
}  // namespace llcpp

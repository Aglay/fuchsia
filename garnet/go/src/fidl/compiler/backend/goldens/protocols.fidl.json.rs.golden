// WARNING: This file is machine generated by fidlgen.

#![feature(futures_api)]
#![allow(
	deprecated, // FIDL Impl struct pattern is referenced internally
	unused_parens, // one-element-tuple-case is not a tuple
	unused_mut, // not all args require mutation, but many do
	nonstandard_style, // auto-caps does its best, but is not always successful
)]

#[allow(unused_imports)]
use fuchsia_zircon as zx;
#[allow(unused_imports)]
use fidl::{
	fidl_enum,
	fidl_struct,
	fidl_table,
	fidl_union,
	fidl_xunion,
};



#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct OvernetStreamProtocolMarker;

impl fidl::endpoints::ServiceMarker for OvernetStreamProtocolMarker {
	type Proxy = OvernetStreamProtocolProxy;
	type RequestStream = OvernetStreamProtocolRequestStream;
	const NAME: &'static str = "";
}

pub trait OvernetStreamProtocolProxyInterface: Send + Sync {
	fn method_a(&self,
		a: i64,
		b: i64,
	)-> Result<(), fidl::Error>;
	type EventAResponseFut: futures::Future<Output = Result<(i64, i64), fidl::Error>> + Send;
	type MethodBResponseFut: futures::Future<Output = Result<(i64), fidl::Error>> + Send;
	fn method_b(&self,
		a: i64,
		b: i64,
	)-> Self::MethodBResponseFut;
}

#[derive(Debug)]
pub struct OvernetStreamProtocolSynchronousProxy {
	client: fidl::client::sync::Client,
}

impl OvernetStreamProtocolSynchronousProxy {
	pub fn new(channel: zx::Channel) -> Self {
		Self { client: fidl::client::sync::Client::new(channel) }
	}

	pub fn into_channel(self) -> zx::Channel {
		self.client.into_channel()
	}
	pub fn method_a(&mut self,
		mut a: i64,
		mut b: i64,) -> Result<(), fidl::Error> {self.client.send(&mut (a, b),
				411580008,
			)}
	pub fn method_b(&mut self,
		mut a: i64,
		mut b: i64,___deadline: zx::Time,) -> Result<(i64), fidl::Error> {self.client.send_query(&mut (a, b),
				1291000979,
				___deadline,
			)}
}

#[derive(Debug, Clone)]
pub struct OvernetStreamProtocolProxy {
	client: fidl::client::Client,
}

impl fidl::endpoints::Proxy for OvernetStreamProtocolProxy {
	fn from_channel(inner: ::fuchsia_async::Channel) -> Self {
		Self::new(inner)
	}
}

impl ::std::ops::Deref for OvernetStreamProtocolProxy {
	type Target = fidl::client::Client;

	fn deref(&self) -> &Self::Target {
		&self.client
	}
}

/// Proxy object for communicating with interface OvernetStreamProtocol
impl OvernetStreamProtocolProxy {
	/// Create a new Proxy for OvernetStreamProtocol
	pub fn new(channel: ::fuchsia_async::Channel) -> Self {
		Self { client: fidl::client::Client::new(channel) }
	}

	/// Attempt to convert the Proxy back into a channel.
	///
	/// This will only succeed if there are no active clones of this Proxy
	/// and no currently-alive EventStream or response futures that came from
	/// this Proxy.
	pub fn into_channel(self) -> Result<::fuchsia_async::Channel, Self> {
		self.client.into_channel().map_err(|client| Self { client })
	}

	/// Get a Stream of events from the remote end of the OvernetStreamProtocol interface
	pub fn take_event_stream(&self) -> OvernetStreamProtocolEventStream {
		OvernetStreamProtocolEventStream {
			event_receiver: self.client.take_event_receiver(),
		}
	}
	pub fn method_a(&self,
		mut a: i64,
		mut b: i64,
	)-> Result<(), fidl::Error> {
		OvernetStreamProtocolProxyInterface::method_a(self,
		a,
		b,
		)
	}
	pub fn method_b(&self,
		mut a: i64,
		mut b: i64,
	)-> fidl::client::QueryResponseFut<(i64)> {
		OvernetStreamProtocolProxyInterface::method_b(self,
		a,
		b,
		)
	}
}

impl OvernetStreamProtocolProxyInterface for OvernetStreamProtocolProxy {
	fn method_a(&self,
		mut a: i64,
		mut b: i64,
	)-> Result<(), fidl::Error> {
		self.client.send(&mut (a, b), 411580008)
	}
	type EventAResponseFut = fidl::client::QueryResponseFut<(i64, i64)>;
	type MethodBResponseFut = fidl::client::QueryResponseFut<(i64)>;
	fn method_b(&self,
		mut a: i64,
		mut b: i64,
	)-> Self::MethodBResponseFut {
		self.client.send_query(&mut (a, b), 1291000979)
	}}

pub struct OvernetStreamProtocolEventStream {
	event_receiver: fidl::client::EventReceiver,
}

impl ::std::marker::Unpin for OvernetStreamProtocolEventStream {}

impl futures::stream::FusedStream for OvernetStreamProtocolEventStream {
	fn is_terminated(&self) -> bool {
		self.event_receiver.is_terminated()
	}
}

impl futures::Stream for OvernetStreamProtocolEventStream {
	type Item = Result<OvernetStreamProtocolEvent, fidl::Error>;

	fn poll_next(mut self: ::std::pin::Pin<&mut Self>, lw: &futures::task::LocalWaker)
		-> futures::Poll<Option<Self::Item>>
	{
		let mut buf = match futures::ready!(
			futures::stream::StreamExt::poll_next_unpin(&mut self.event_receiver, lw)?
		) {
			Some(buf) => buf,
			None => return futures::Poll::Ready(None),
		};
		let (bytes, _handles) = buf.split_mut();
		let (tx_header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

		#[allow(unreachable_patterns)] // GenOrdinal and Ordinal can overlap
		futures::Poll::Ready(Some(match tx_header.ordinal {
			530966225 | 530966225 => {
				let mut out_tuple: (i64,i64) = fidl::encoding::Decodable::new_empty();
				fidl::encoding::Decoder::decode_into(_body_bytes, _handles, &mut out_tuple)?;
				Ok((
					OvernetStreamProtocolEvent::EventA {a: out_tuple.0,b: out_tuple.1,}
				))
			}
			_ => Err(fidl::Error::UnknownOrdinal {
				ordinal: tx_header.ordinal,
				service_name: <OvernetStreamProtocolMarker as fidl::endpoints::ServiceMarker>::NAME,
			})
		}))
	}
}

#[derive(Debug)]
pub enum OvernetStreamProtocolEvent {
	
	
	
	EventA {
		
		a: i64,
		
		b: i64,
		
	},
	}

pub struct OvernetStreamProtocolEventSender<'a> {
	// Some protocols don't define events which would render this channel unused.
	#[allow(unused)]
	channel: zx::Unowned<'a, zx::Channel>,
}
impl <'a> OvernetStreamProtocolEventSender<'a> {
	pub fn new(channel: zx::Unowned<'a, zx::Channel>) -> Self {
		Self { channel }
	}
	pub fn send_event_a(&self,
		mut a: i64,
		mut b: i64) -> Result<(), fidl::Error> {
		let (bytes, handles) = (&mut vec![], &mut vec![]);
		OvernetStreamProtocolEncoder::encode_event_a_response(
			bytes, handles,a,b,)?;
		self.channel.write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)?;
		Ok(())
	}
	
}

#[deprecated(note = "use OvernetStreamProtocolRequestStream instead")]
pub trait OvernetStreamProtocol {
	type OnOpenFut: futures::Future<Output = ()> + Send;
	fn on_open(&mut self, control_handle: OvernetStreamProtocolControlHandle) -> Self::OnOpenFut;
	type MethodAFut: futures::Future<Output = ()> + Send;
	fn method_a (&mut self,
		a: i64,
		b: i64,
		control_handle: OvernetStreamProtocolControlHandle
	) -> Self::MethodAFut;
	
	type MethodBFut: futures::Future<Output = ()> + Send;
	fn method_b (&mut self,
		a: i64,
		b: i64,
		response_chan: OvernetStreamProtocolMethodBResponder,
	) -> Self::MethodBFut;
	

	fn serve(mut self, channel: ::fuchsia_async::Channel)
		-> OvernetStreamProtocolServer<Self>
	where Self: Sized
	{
		let inner = ::std::sync::Arc::new(fidl::ServeInner::new(channel));
		let on_open_fut = self.on_open(
			OvernetStreamProtocolControlHandle {
				inner: inner.clone(),
			}
		);
		OvernetStreamProtocolServer {
			server: self,
			inner: inner.clone(),
			msg_buf: zx::MessageBuf::new(),
			on_open_fut: Some(on_open_fut),method_a_futures: futures::stream::FuturesUnordered::new(),method_b_futures: futures::stream::FuturesUnordered::new(),
		}
	}
}

pub struct OvernetStreamProtocolServer<T: OvernetStreamProtocol> {
	#[allow(dead_code)] // not used if no methods are present
	server: T,
	inner: ::std::sync::Arc<fidl::ServeInner>,
	msg_buf: zx::MessageBuf,
	on_open_fut: Option<T::OnOpenFut>,method_a_futures: futures::stream::FuturesUnordered<T::MethodAFut>,method_b_futures: futures::stream::FuturesUnordered<T::MethodBFut>,
}

// Safety: only the OnOpen fut is held directly, so it's the only one that
// is projected to, so it's the only one that needs to be Unpin for the Impl
// struct to be Unpin.
impl<T: OvernetStreamProtocol> ::std::marker::Unpin for OvernetStreamProtocolServer<T>
where T::OnOpenFut: ::std::marker::Unpin,
{}

impl<T: OvernetStreamProtocol> OvernetStreamProtocolServer<T> {
	pub fn control_handle(&self) -> OvernetStreamProtocolControlHandle {
		OvernetStreamProtocolControlHandle {
			inner: self.inner.clone(),
		}
	}
}

impl<T: OvernetStreamProtocol> futures::Future for OvernetStreamProtocolServer<T> {
	type Output = Result<(), fidl::Error>;

	fn poll(
		mut self: ::std::pin::Pin<&mut Self>,
		lw: &futures::task::LocalWaker,
	) -> futures::Poll<Self::Output> {
		// safety: the only potentially !Unpin field is on_open_fut, which we make sure
		// isn't moved below
		let this = unsafe { ::std::pin::Pin::get_unchecked_mut(self) };
		loop {
		let mut made_progress_this_loop_iter = false;

		if this.inner.poll_shutdown(lw) {
			return futures::Poll::Ready(Ok(()));
		}

		unsafe {
			// Safety: ensure that on_open isn't moved
			let completed_on_open = if let Some(on_open_fut) = &mut this.on_open_fut {
				match futures::Future::poll(::std::pin::Pin::new_unchecked(on_open_fut), lw) {
					futures::Poll::Ready(()) => true,
					futures::Poll::Pending => false,
				}
			} else {
				false
			};

			if completed_on_open {
				made_progress_this_loop_iter = true;
				this.on_open_fut = None;
			}
		}match futures::stream::StreamExt::poll_next_unpin(
			&mut this.method_a_futures, lw
		) {
			futures::Poll::Ready(Some(())) => made_progress_this_loop_iter = true,
			_ => {},
		}match futures::stream::StreamExt::poll_next_unpin(
			&mut this.method_b_futures, lw
		) {
			futures::Poll::Ready(Some(())) => made_progress_this_loop_iter = true,
			_ => {},
		}

		this.msg_buf.clear();
		match this.inner.channel().recv_from(&mut this.msg_buf, lw) {
			futures::Poll::Ready(Ok(())) => {},
			futures::Poll::Pending => {
				if !made_progress_this_loop_iter {
					return futures::Poll::Pending;
				} else {
					continue;
				}
			}
			futures::Poll::Ready(Err(zx::Status::PEER_CLOSED)) => {
				return futures::Poll::Ready(Ok(()));
			}
			futures::Poll::Ready(Err(e)) =>
				return futures::Poll::Ready(Err(fidl::Error::ServerRequestRead(e))),
		}

		{
			// A message has been received from the channel
			let (bytes, _handles) = this.msg_buf.split_mut();
			let (header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

			#[allow(unreachable_patterns)] // GenOrdinal and Ordinal can overlap
			match header.ordinal {
					411580008 | 411580008 => {
						let mut req: (i64,i64) = fidl::encoding::Decodable::new_empty();
						fidl::encoding::Decoder::decode_into(_body_bytes, _handles, &mut req)?;
						let control_handle = OvernetStreamProtocolControlHandle {
							inner: this.inner.clone(),
						};
						this.method_a_futures.push(
							this.server.method_a(req.0,req.1,control_handle)
						);
					}
					1291000979 | 1291000979 => {
						let mut req: (i64,i64) = fidl::encoding::Decodable::new_empty();
						fidl::encoding::Decoder::decode_into(_body_bytes, _handles, &mut req)?;
						let control_handle = OvernetStreamProtocolControlHandle {
							inner: this.inner.clone(),
						};
						this.method_b_futures.push(
							this.server.method_b(req.0,req.1,OvernetStreamProtocolMethodBResponder {
										control_handle: ::std::mem::ManuallyDrop::new(control_handle),
										tx_id: header.tx_id,
										ordinal: header.ordinal,
									})
						);
					}
				// TODO(cramertj) handle control/fileio messages
				_ => return futures::Poll::Ready(Err(fidl::Error::UnknownOrdinal {
					ordinal: header.ordinal,
					service_name: "unknown fidl", // TODO(cramertj)
				})),
			}
		}
	}}
}

/// A Stream of incoming requests for OvernetStreamProtocol
pub struct OvernetStreamProtocolRequestStream {
	inner: ::std::sync::Arc<fidl::ServeInner>,
	msg_buf: Option<zx::MessageBuf>,
}

impl ::std::marker::Unpin for OvernetStreamProtocolRequestStream {}

impl futures::stream::FusedStream for OvernetStreamProtocolRequestStream {
	fn is_terminated(&self) -> bool {
		self.msg_buf.is_none()
	}
}

impl fidl::endpoints::RequestStream for OvernetStreamProtocolRequestStream {
	/// Consume a channel to make a OvernetStreamProtocolRequestStream
	fn from_channel(channel: ::fuchsia_async::Channel) -> Self {
		Self {
			inner: ::std::sync::Arc::new(fidl::ServeInner::new(channel)),
			msg_buf: Some(zx::MessageBuf::new()),
		}
	}

	/// ControlHandle for the remote connection
	type ControlHandle = OvernetStreamProtocolControlHandle;

	/// ControlHandle for the remote connection
	fn control_handle(&self) -> Self::ControlHandle {
		OvernetStreamProtocolControlHandle { inner: self.inner.clone() }
	}

	fn into_inner(self) -> (::std::sync::Arc<fidl::ServeInner>, Option<zx::MessageBuf>) {
		(self.inner, self.msg_buf)
	}

	fn from_inner(inner: ::std::sync::Arc<fidl::ServeInner>, msg_buf: Option<zx::MessageBuf>)
		-> Self
	{
		Self { inner, msg_buf }
	}
}

impl futures::Stream for OvernetStreamProtocolRequestStream {
	type Item = Result<OvernetStreamProtocolRequest, fidl::Error>;

	fn poll_next(mut self: ::std::pin::Pin<&mut Self>, lw: &futures::task::LocalWaker)
		-> futures::Poll<Option<Self::Item>>
	{
		let this = &mut *self;
		if this.inner.poll_shutdown(lw) {
			this.msg_buf = None;
			return futures::Poll::Ready(None);
		}
		let msg_buf = this.msg_buf.as_mut()
								.expect("polled OvernetStreamProtocolRequestStream after completion");
		msg_buf.clear();
		match this.inner.channel().recv_from(msg_buf, lw) {
			futures::Poll::Ready(Ok(())) => {},
			futures::Poll::Pending => return futures::Poll::Pending,
			futures::Poll::Ready(Err(zx::Status::PEER_CLOSED)) => {
				this.msg_buf = None;
				return futures::Poll::Ready(None)
			},
			futures::Poll::Ready(Err(e)) =>
			return futures::Poll::Ready(Some(Err(fidl::Error::ServerRequestRead(e)))),
		}

		// A message has been received from the channel
		let (bytes, _handles) = msg_buf.split_mut();
		let (header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

		#[allow(unreachable_patterns)] // GenOrdinal and Ordinal can overlap
		futures::Poll::Ready(Some(match header.ordinal {
			411580008 | 411580008 => {
				let mut req: (i64,i64) = fidl::encoding::Decodable::new_empty();
				fidl::encoding::Decoder::decode_into(_body_bytes, _handles, &mut req)?;
				let control_handle = OvernetStreamProtocolControlHandle {
					inner: this.inner.clone(),
				};

				Ok(OvernetStreamProtocolRequest::MethodA {a: req.0,b: req.1,control_handle,})
			}
			1291000979 | 1291000979 => {
				let mut req: (i64,i64) = fidl::encoding::Decodable::new_empty();
				fidl::encoding::Decoder::decode_into(_body_bytes, _handles, &mut req)?;
				let control_handle = OvernetStreamProtocolControlHandle {
					inner: this.inner.clone(),
				};

				Ok(OvernetStreamProtocolRequest::MethodB {a: req.0,b: req.1,responder:OvernetStreamProtocolMethodBResponder {
							control_handle: ::std::mem::ManuallyDrop::new(control_handle),
							tx_id: header.tx_id,
							ordinal: header.ordinal,
						},})
			}
			_ => Err(fidl::Error::UnknownOrdinal {
				ordinal: header.ordinal,
				service_name: <OvernetStreamProtocolMarker as fidl::endpoints::ServiceMarker>::NAME,
			}),
		}))
	}
}
pub enum OvernetStreamProtocolRequest {
	MethodA {
		
		a: i64,
		
		b: i64,
		control_handle: OvernetStreamProtocolControlHandle,},
	MethodB {
		
		a: i64,
		
		b: i64,
		responder: OvernetStreamProtocolMethodBResponder,},
}

pub struct OvernetStreamProtocolEncoder;
impl OvernetStreamProtocolEncoder {
	pub fn encode_method_a_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,mut in_a: i64,mut in_b: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {tx_id: 0,flags: 0,
			ordinal: 411580008,
		};
		let mut body = (in_a,in_b,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_event_a_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,mut in_a: i64,mut in_b: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {tx_id: 0,flags: 0,
			ordinal: 530966225,
		};
		let mut body = (in_a,in_b,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_method_b_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,mut in_a: i64,mut in_b: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 1291000979,
		};
		let mut body = (in_a,in_b,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_method_b_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,mut in_result: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 1291000979,
		};
		let mut body = (in_result,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}}

#[deprecated(note = "use OvernetStreamProtocolRequestStream instead")]
pub struct OvernetStreamProtocolImpl<
	State,
OnOpen: FnMut(&mut State, OvernetStreamProtocolControlHandle) -> OnOpenFut,
OnOpenFut: futures::Future<Output = ()> + Send,
	MethodA: FnMut(&mut State,i64,i64,OvernetStreamProtocolControlHandle) -> MethodAFut,
	MethodAFut: futures::Future<Output = ()> + Send,
	MethodB: FnMut(&mut State,i64,i64,OvernetStreamProtocolMethodBResponder) -> MethodBFut,
	MethodBFut: futures::Future<Output = ()> + Send,
> {
	pub state: State,
	pub on_open: OnOpen,
	pub method_a: MethodA,
	pub method_b: MethodB,
}

// Unpin is never projected for the Impl struct
impl<
	State,
OnOpen: FnMut(&mut State, OvernetStreamProtocolControlHandle) -> OnOpenFut,
OnOpenFut: futures::Future<Output = ()> + Send,
	MethodA: FnMut(&mut State,i64,i64,OvernetStreamProtocolControlHandle) -> MethodAFut,
	MethodAFut: futures::Future<Output = ()> + Send,
	MethodB: FnMut(&mut State,i64,i64,OvernetStreamProtocolMethodBResponder) -> MethodBFut,
	MethodBFut: futures::Future<Output = ()> + Send,
> ::std::marker::Unpin for OvernetStreamProtocolImpl<State, OnOpen, OnOpenFut,
	MethodA,
	MethodAFut,
	MethodB,
	MethodBFut,
>
{}

impl<
	State,
OnOpen: FnMut(&mut State, OvernetStreamProtocolControlHandle) -> OnOpenFut,
OnOpenFut: futures::Future<Output = ()> + Send,
	MethodA: FnMut(&mut State,i64,i64,OvernetStreamProtocolControlHandle) -> MethodAFut,
	MethodAFut: futures::Future<Output = ()> + Send,
	MethodB: FnMut(&mut State,i64,i64,OvernetStreamProtocolMethodBResponder) -> MethodBFut,
	MethodBFut: futures::Future<Output = ()> + Send,
> OvernetStreamProtocol for OvernetStreamProtocolImpl<State, OnOpen, OnOpenFut,
	MethodA,
	MethodAFut,
	MethodB,
	MethodBFut,
>
{
	type OnOpenFut = OnOpenFut;
	fn on_open(&mut self, response_chan: OvernetStreamProtocolControlHandle) -> Self::OnOpenFut {
		(self.on_open)(&mut self.state, response_chan)
	}
	type MethodAFut = MethodAFut;
	fn method_a (&mut self,
		a: i64,
		b: i64,
		response_chan: OvernetStreamProtocolControlHandle
	) -> Self::MethodAFut
	{
		(self.method_a)(
			&mut self.state,
			a,
			b,
			response_chan
		)
	}
	
	type MethodBFut = MethodBFut;
	fn method_b (&mut self,
		a: i64,
		b: i64,
		response_chan: OvernetStreamProtocolMethodBResponder
	) -> Self::MethodBFut
	{
		(self.method_b)(
			&mut self.state,
			a,
			b,
			response_chan
		)
	}
	
}

#[derive(Clone)]
pub struct OvernetStreamProtocolControlHandle {
	inner: ::std::sync::Arc<fidl::ServeInner>,
}

impl ::std::ops::Deref for OvernetStreamProtocolControlHandle {
	type Target = ::std::sync::Arc<fidl::ServeInner>;

	fn deref(&self) -> &Self::Target {
		&self.inner
	}
}


impl OvernetStreamProtocolControlHandle {
	pub fn shutdown(&self) {
		self.inner.shutdown()
	}
	pub fn send_event_a(&self,
		mut a: i64,
		mut b: i64) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id: 0,
			flags: 0,
			ordinal: 530966225,
		};

		let mut response = (a, b);

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		let (bytes, handles) = (&mut vec![], &mut vec![]);
		fidl::encoding::Encoder::encode(bytes, handles, &mut msg)?;
		self.inner.channel().write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)?;
		Ok(())
	}
	}

/* beginning of response types */
#[must_use = "FIDL methods require a response to be sent"]
pub struct OvernetStreamProtocolMethodBResponder {
	control_handle: ::std::mem::ManuallyDrop<OvernetStreamProtocolControlHandle>,
	tx_id: u32,
	ordinal: u32,
}

impl ::std::ops::Drop for OvernetStreamProtocolMethodBResponder {
	fn drop(&mut self) {
		// Shutdown the channel if the responder is dropped without sending a response
		// so that the client doesn't hang. To prevent this behavior, some methods
		// call "drop_without_shutdown"
		self.control_handle.shutdown();
		// Safety: drops once, never accessed again
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
	}
}

impl OvernetStreamProtocolMethodBResponder {
	pub fn control_handle(&self) -> &OvernetStreamProtocolControlHandle {
		&self.control_handle
	}

	/// Drop the Responder without setting the channel to shutdown.
	///
	/// This method shouldn't normally be used-- instead, send a response
	/// to prevent the channel from shutting down.
	pub fn drop_without_shutdown(mut self) {
		// Safety: drops once, never accessed again due to mem::forget
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
		// Prevent Drop from running (which would shut down the channel)
		::std::mem::forget(self);
	}

	/// Sends a response to the FIDL transaction.
	///
	/// Sets the channel to shutdown if an error occurs.
	pub fn send(self,mut result: i64,) -> Result<(), fidl::Error> {
		let r = self.send_raw(result,);
		if r.is_err() {
			self.control_handle.shutdown();
		}
		self.drop_without_shutdown();
		r
	}

	/// Similar to "send" but does not shutdown the channel if
	/// an error occurs.
	pub fn send_no_shutdown_on_err(self,mut result: i64,) -> Result<(), fidl::Error> {
		let r = self.send_raw(result,);
		self.drop_without_shutdown();
		r
	}

	fn send_raw(&self,mut result: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id: self.tx_id,
			flags: 0,
			ordinal: self.ordinal,
		};

		let mut response = (result);

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		let (bytes, handles) = (&mut vec![], &mut vec![]);
		fidl::encoding::Encoder::encode(bytes, handles, &mut msg)?;
		self.control_handle.inner.channel().write(&*bytes, &mut *handles)
			.map_err(fidl::Error::ServerResponseWrite)?;
		Ok(())
	}
}


#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct SocketControlProtocolMarker;

impl fidl::endpoints::ServiceMarker for SocketControlProtocolMarker {
	type Proxy = SocketControlProtocolProxy;
	type RequestStream = SocketControlProtocolRequestStream;
	const NAME: &'static str = "";
}

pub trait SocketControlProtocolProxyInterface: Send + Sync {
	fn method_a(&self,
		a: i64,
		b: i64,
	)-> Result<(), fidl::Error>;
	type EventAResponseFut: futures::Future<Output = Result<(i64, i64), fidl::Error>> + Send;
	type MethodBResponseFut: futures::Future<Output = Result<(i64), fidl::Error>> + Send;
	fn method_b(&self,
		a: i64,
		b: i64,
	)-> Self::MethodBResponseFut;
}

#[derive(Debug)]
pub struct SocketControlProtocolSynchronousProxy {
	client: fidl::client::sync::Client,
}

impl SocketControlProtocolSynchronousProxy {
	pub fn new(channel: zx::Channel) -> Self {
		Self { client: fidl::client::sync::Client::new(channel) }
	}

	pub fn into_channel(self) -> zx::Channel {
		self.client.into_channel()
	}
	pub fn method_a(&mut self,
		mut a: i64,
		mut b: i64,) -> Result<(), fidl::Error> {self.client.send(&mut (a, b),
				1007842318,
			)}
	pub fn method_b(&mut self,
		mut a: i64,
		mut b: i64,___deadline: zx::Time,) -> Result<(i64), fidl::Error> {self.client.send_query(&mut (a, b),
				677342235,
				___deadline,
			)}
}

#[derive(Debug, Clone)]
pub struct SocketControlProtocolProxy {
	client: fidl::client::Client,
}

impl fidl::endpoints::Proxy for SocketControlProtocolProxy {
	fn from_channel(inner: ::fuchsia_async::Channel) -> Self {
		Self::new(inner)
	}
}

impl ::std::ops::Deref for SocketControlProtocolProxy {
	type Target = fidl::client::Client;

	fn deref(&self) -> &Self::Target {
		&self.client
	}
}

/// Proxy object for communicating with interface SocketControlProtocol
impl SocketControlProtocolProxy {
	/// Create a new Proxy for SocketControlProtocol
	pub fn new(channel: ::fuchsia_async::Channel) -> Self {
		Self { client: fidl::client::Client::new(channel) }
	}

	/// Attempt to convert the Proxy back into a channel.
	///
	/// This will only succeed if there are no active clones of this Proxy
	/// and no currently-alive EventStream or response futures that came from
	/// this Proxy.
	pub fn into_channel(self) -> Result<::fuchsia_async::Channel, Self> {
		self.client.into_channel().map_err(|client| Self { client })
	}

	/// Get a Stream of events from the remote end of the SocketControlProtocol interface
	pub fn take_event_stream(&self) -> SocketControlProtocolEventStream {
		SocketControlProtocolEventStream {
			event_receiver: self.client.take_event_receiver(),
		}
	}
	pub fn method_a(&self,
		mut a: i64,
		mut b: i64,
	)-> Result<(), fidl::Error> {
		SocketControlProtocolProxyInterface::method_a(self,
		a,
		b,
		)
	}
	pub fn method_b(&self,
		mut a: i64,
		mut b: i64,
	)-> fidl::client::QueryResponseFut<(i64)> {
		SocketControlProtocolProxyInterface::method_b(self,
		a,
		b,
		)
	}
}

impl SocketControlProtocolProxyInterface for SocketControlProtocolProxy {
	fn method_a(&self,
		mut a: i64,
		mut b: i64,
	)-> Result<(), fidl::Error> {
		self.client.send(&mut (a, b), 1007842318)
	}
	type EventAResponseFut = fidl::client::QueryResponseFut<(i64, i64)>;
	type MethodBResponseFut = fidl::client::QueryResponseFut<(i64)>;
	fn method_b(&self,
		mut a: i64,
		mut b: i64,
	)-> Self::MethodBResponseFut {
		self.client.send_query(&mut (a, b), 677342235)
	}}

pub struct SocketControlProtocolEventStream {
	event_receiver: fidl::client::EventReceiver,
}

impl ::std::marker::Unpin for SocketControlProtocolEventStream {}

impl futures::stream::FusedStream for SocketControlProtocolEventStream {
	fn is_terminated(&self) -> bool {
		self.event_receiver.is_terminated()
	}
}

impl futures::Stream for SocketControlProtocolEventStream {
	type Item = Result<SocketControlProtocolEvent, fidl::Error>;

	fn poll_next(mut self: ::std::pin::Pin<&mut Self>, lw: &futures::task::LocalWaker)
		-> futures::Poll<Option<Self::Item>>
	{
		let mut buf = match futures::ready!(
			futures::stream::StreamExt::poll_next_unpin(&mut self.event_receiver, lw)?
		) {
			Some(buf) => buf,
			None => return futures::Poll::Ready(None),
		};
		let (bytes, _handles) = buf.split_mut();
		let (tx_header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

		#[allow(unreachable_patterns)] // GenOrdinal and Ordinal can overlap
		futures::Poll::Ready(Some(match tx_header.ordinal {
			955483393 | 955483393 => {
				let mut out_tuple: (i64,i64) = fidl::encoding::Decodable::new_empty();
				fidl::encoding::Decoder::decode_into(_body_bytes, _handles, &mut out_tuple)?;
				Ok((
					SocketControlProtocolEvent::EventA {a: out_tuple.0,b: out_tuple.1,}
				))
			}
			_ => Err(fidl::Error::UnknownOrdinal {
				ordinal: tx_header.ordinal,
				service_name: <SocketControlProtocolMarker as fidl::endpoints::ServiceMarker>::NAME,
			})
		}))
	}
}

#[derive(Debug)]
pub enum SocketControlProtocolEvent {
	
	
	
	EventA {
		
		a: i64,
		
		b: i64,
		
	},
	}

pub struct SocketControlProtocolEventSender<'a> {
	// Some protocols don't define events which would render this channel unused.
	#[allow(unused)]
	channel: zx::Unowned<'a, zx::Channel>,
}
impl <'a> SocketControlProtocolEventSender<'a> {
	pub fn new(channel: zx::Unowned<'a, zx::Channel>) -> Self {
		Self { channel }
	}
	pub fn send_event_a(&self,
		mut a: i64,
		mut b: i64) -> Result<(), fidl::Error> {
		let (bytes, handles) = (&mut vec![], &mut vec![]);
		SocketControlProtocolEncoder::encode_event_a_response(
			bytes, handles,a,b,)?;
		self.channel.write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)?;
		Ok(())
	}
	
}

#[deprecated(note = "use SocketControlProtocolRequestStream instead")]
pub trait SocketControlProtocol {
	type OnOpenFut: futures::Future<Output = ()> + Send;
	fn on_open(&mut self, control_handle: SocketControlProtocolControlHandle) -> Self::OnOpenFut;
	type MethodAFut: futures::Future<Output = ()> + Send;
	fn method_a (&mut self,
		a: i64,
		b: i64,
		control_handle: SocketControlProtocolControlHandle
	) -> Self::MethodAFut;
	
	type MethodBFut: futures::Future<Output = ()> + Send;
	fn method_b (&mut self,
		a: i64,
		b: i64,
		response_chan: SocketControlProtocolMethodBResponder,
	) -> Self::MethodBFut;
	

	fn serve(mut self, channel: ::fuchsia_async::Channel)
		-> SocketControlProtocolServer<Self>
	where Self: Sized
	{
		let inner = ::std::sync::Arc::new(fidl::ServeInner::new(channel));
		let on_open_fut = self.on_open(
			SocketControlProtocolControlHandle {
				inner: inner.clone(),
			}
		);
		SocketControlProtocolServer {
			server: self,
			inner: inner.clone(),
			msg_buf: zx::MessageBuf::new(),
			on_open_fut: Some(on_open_fut),method_a_futures: futures::stream::FuturesUnordered::new(),method_b_futures: futures::stream::FuturesUnordered::new(),
		}
	}
}

pub struct SocketControlProtocolServer<T: SocketControlProtocol> {
	#[allow(dead_code)] // not used if no methods are present
	server: T,
	inner: ::std::sync::Arc<fidl::ServeInner>,
	msg_buf: zx::MessageBuf,
	on_open_fut: Option<T::OnOpenFut>,method_a_futures: futures::stream::FuturesUnordered<T::MethodAFut>,method_b_futures: futures::stream::FuturesUnordered<T::MethodBFut>,
}

// Safety: only the OnOpen fut is held directly, so it's the only one that
// is projected to, so it's the only one that needs to be Unpin for the Impl
// struct to be Unpin.
impl<T: SocketControlProtocol> ::std::marker::Unpin for SocketControlProtocolServer<T>
where T::OnOpenFut: ::std::marker::Unpin,
{}

impl<T: SocketControlProtocol> SocketControlProtocolServer<T> {
	pub fn control_handle(&self) -> SocketControlProtocolControlHandle {
		SocketControlProtocolControlHandle {
			inner: self.inner.clone(),
		}
	}
}

impl<T: SocketControlProtocol> futures::Future for SocketControlProtocolServer<T> {
	type Output = Result<(), fidl::Error>;

	fn poll(
		mut self: ::std::pin::Pin<&mut Self>,
		lw: &futures::task::LocalWaker,
	) -> futures::Poll<Self::Output> {
		// safety: the only potentially !Unpin field is on_open_fut, which we make sure
		// isn't moved below
		let this = unsafe { ::std::pin::Pin::get_unchecked_mut(self) };
		loop {
		let mut made_progress_this_loop_iter = false;

		if this.inner.poll_shutdown(lw) {
			return futures::Poll::Ready(Ok(()));
		}

		unsafe {
			// Safety: ensure that on_open isn't moved
			let completed_on_open = if let Some(on_open_fut) = &mut this.on_open_fut {
				match futures::Future::poll(::std::pin::Pin::new_unchecked(on_open_fut), lw) {
					futures::Poll::Ready(()) => true,
					futures::Poll::Pending => false,
				}
			} else {
				false
			};

			if completed_on_open {
				made_progress_this_loop_iter = true;
				this.on_open_fut = None;
			}
		}match futures::stream::StreamExt::poll_next_unpin(
			&mut this.method_a_futures, lw
		) {
			futures::Poll::Ready(Some(())) => made_progress_this_loop_iter = true,
			_ => {},
		}match futures::stream::StreamExt::poll_next_unpin(
			&mut this.method_b_futures, lw
		) {
			futures::Poll::Ready(Some(())) => made_progress_this_loop_iter = true,
			_ => {},
		}

		this.msg_buf.clear();
		match this.inner.channel().recv_from(&mut this.msg_buf, lw) {
			futures::Poll::Ready(Ok(())) => {},
			futures::Poll::Pending => {
				if !made_progress_this_loop_iter {
					return futures::Poll::Pending;
				} else {
					continue;
				}
			}
			futures::Poll::Ready(Err(zx::Status::PEER_CLOSED)) => {
				return futures::Poll::Ready(Ok(()));
			}
			futures::Poll::Ready(Err(e)) =>
				return futures::Poll::Ready(Err(fidl::Error::ServerRequestRead(e))),
		}

		{
			// A message has been received from the channel
			let (bytes, _handles) = this.msg_buf.split_mut();
			let (header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

			#[allow(unreachable_patterns)] // GenOrdinal and Ordinal can overlap
			match header.ordinal {
					1007842318 | 1007842318 => {
						let mut req: (i64,i64) = fidl::encoding::Decodable::new_empty();
						fidl::encoding::Decoder::decode_into(_body_bytes, _handles, &mut req)?;
						let control_handle = SocketControlProtocolControlHandle {
							inner: this.inner.clone(),
						};
						this.method_a_futures.push(
							this.server.method_a(req.0,req.1,control_handle)
						);
					}
					677342235 | 677342235 => {
						let mut req: (i64,i64) = fidl::encoding::Decodable::new_empty();
						fidl::encoding::Decoder::decode_into(_body_bytes, _handles, &mut req)?;
						let control_handle = SocketControlProtocolControlHandle {
							inner: this.inner.clone(),
						};
						this.method_b_futures.push(
							this.server.method_b(req.0,req.1,SocketControlProtocolMethodBResponder {
										control_handle: ::std::mem::ManuallyDrop::new(control_handle),
										tx_id: header.tx_id,
										ordinal: header.ordinal,
									})
						);
					}
				// TODO(cramertj) handle control/fileio messages
				_ => return futures::Poll::Ready(Err(fidl::Error::UnknownOrdinal {
					ordinal: header.ordinal,
					service_name: "unknown fidl", // TODO(cramertj)
				})),
			}
		}
	}}
}

/// A Stream of incoming requests for SocketControlProtocol
pub struct SocketControlProtocolRequestStream {
	inner: ::std::sync::Arc<fidl::ServeInner>,
	msg_buf: Option<zx::MessageBuf>,
}

impl ::std::marker::Unpin for SocketControlProtocolRequestStream {}

impl futures::stream::FusedStream for SocketControlProtocolRequestStream {
	fn is_terminated(&self) -> bool {
		self.msg_buf.is_none()
	}
}

impl fidl::endpoints::RequestStream for SocketControlProtocolRequestStream {
	/// Consume a channel to make a SocketControlProtocolRequestStream
	fn from_channel(channel: ::fuchsia_async::Channel) -> Self {
		Self {
			inner: ::std::sync::Arc::new(fidl::ServeInner::new(channel)),
			msg_buf: Some(zx::MessageBuf::new()),
		}
	}

	/// ControlHandle for the remote connection
	type ControlHandle = SocketControlProtocolControlHandle;

	/// ControlHandle for the remote connection
	fn control_handle(&self) -> Self::ControlHandle {
		SocketControlProtocolControlHandle { inner: self.inner.clone() }
	}

	fn into_inner(self) -> (::std::sync::Arc<fidl::ServeInner>, Option<zx::MessageBuf>) {
		(self.inner, self.msg_buf)
	}

	fn from_inner(inner: ::std::sync::Arc<fidl::ServeInner>, msg_buf: Option<zx::MessageBuf>)
		-> Self
	{
		Self { inner, msg_buf }
	}
}

impl futures::Stream for SocketControlProtocolRequestStream {
	type Item = Result<SocketControlProtocolRequest, fidl::Error>;

	fn poll_next(mut self: ::std::pin::Pin<&mut Self>, lw: &futures::task::LocalWaker)
		-> futures::Poll<Option<Self::Item>>
	{
		let this = &mut *self;
		if this.inner.poll_shutdown(lw) {
			this.msg_buf = None;
			return futures::Poll::Ready(None);
		}
		let msg_buf = this.msg_buf.as_mut()
								.expect("polled SocketControlProtocolRequestStream after completion");
		msg_buf.clear();
		match this.inner.channel().recv_from(msg_buf, lw) {
			futures::Poll::Ready(Ok(())) => {},
			futures::Poll::Pending => return futures::Poll::Pending,
			futures::Poll::Ready(Err(zx::Status::PEER_CLOSED)) => {
				this.msg_buf = None;
				return futures::Poll::Ready(None)
			},
			futures::Poll::Ready(Err(e)) =>
			return futures::Poll::Ready(Some(Err(fidl::Error::ServerRequestRead(e)))),
		}

		// A message has been received from the channel
		let (bytes, _handles) = msg_buf.split_mut();
		let (header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

		#[allow(unreachable_patterns)] // GenOrdinal and Ordinal can overlap
		futures::Poll::Ready(Some(match header.ordinal {
			1007842318 | 1007842318 => {
				let mut req: (i64,i64) = fidl::encoding::Decodable::new_empty();
				fidl::encoding::Decoder::decode_into(_body_bytes, _handles, &mut req)?;
				let control_handle = SocketControlProtocolControlHandle {
					inner: this.inner.clone(),
				};

				Ok(SocketControlProtocolRequest::MethodA {a: req.0,b: req.1,control_handle,})
			}
			677342235 | 677342235 => {
				let mut req: (i64,i64) = fidl::encoding::Decodable::new_empty();
				fidl::encoding::Decoder::decode_into(_body_bytes, _handles, &mut req)?;
				let control_handle = SocketControlProtocolControlHandle {
					inner: this.inner.clone(),
				};

				Ok(SocketControlProtocolRequest::MethodB {a: req.0,b: req.1,responder:SocketControlProtocolMethodBResponder {
							control_handle: ::std::mem::ManuallyDrop::new(control_handle),
							tx_id: header.tx_id,
							ordinal: header.ordinal,
						},})
			}
			_ => Err(fidl::Error::UnknownOrdinal {
				ordinal: header.ordinal,
				service_name: <SocketControlProtocolMarker as fidl::endpoints::ServiceMarker>::NAME,
			}),
		}))
	}
}
pub enum SocketControlProtocolRequest {
	MethodA {
		
		a: i64,
		
		b: i64,
		control_handle: SocketControlProtocolControlHandle,},
	MethodB {
		
		a: i64,
		
		b: i64,
		responder: SocketControlProtocolMethodBResponder,},
}

pub struct SocketControlProtocolEncoder;
impl SocketControlProtocolEncoder {
	pub fn encode_method_a_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,mut in_a: i64,mut in_b: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {tx_id: 0,flags: 0,
			ordinal: 1007842318,
		};
		let mut body = (in_a,in_b,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_event_a_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,mut in_a: i64,mut in_b: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {tx_id: 0,flags: 0,
			ordinal: 955483393,
		};
		let mut body = (in_a,in_b,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_method_b_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,mut in_a: i64,mut in_b: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 677342235,
		};
		let mut body = (in_a,in_b,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_method_b_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,mut in_result: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 677342235,
		};
		let mut body = (in_result,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}}

#[deprecated(note = "use SocketControlProtocolRequestStream instead")]
pub struct SocketControlProtocolImpl<
	State,
OnOpen: FnMut(&mut State, SocketControlProtocolControlHandle) -> OnOpenFut,
OnOpenFut: futures::Future<Output = ()> + Send,
	MethodA: FnMut(&mut State,i64,i64,SocketControlProtocolControlHandle) -> MethodAFut,
	MethodAFut: futures::Future<Output = ()> + Send,
	MethodB: FnMut(&mut State,i64,i64,SocketControlProtocolMethodBResponder) -> MethodBFut,
	MethodBFut: futures::Future<Output = ()> + Send,
> {
	pub state: State,
	pub on_open: OnOpen,
	pub method_a: MethodA,
	pub method_b: MethodB,
}

// Unpin is never projected for the Impl struct
impl<
	State,
OnOpen: FnMut(&mut State, SocketControlProtocolControlHandle) -> OnOpenFut,
OnOpenFut: futures::Future<Output = ()> + Send,
	MethodA: FnMut(&mut State,i64,i64,SocketControlProtocolControlHandle) -> MethodAFut,
	MethodAFut: futures::Future<Output = ()> + Send,
	MethodB: FnMut(&mut State,i64,i64,SocketControlProtocolMethodBResponder) -> MethodBFut,
	MethodBFut: futures::Future<Output = ()> + Send,
> ::std::marker::Unpin for SocketControlProtocolImpl<State, OnOpen, OnOpenFut,
	MethodA,
	MethodAFut,
	MethodB,
	MethodBFut,
>
{}

impl<
	State,
OnOpen: FnMut(&mut State, SocketControlProtocolControlHandle) -> OnOpenFut,
OnOpenFut: futures::Future<Output = ()> + Send,
	MethodA: FnMut(&mut State,i64,i64,SocketControlProtocolControlHandle) -> MethodAFut,
	MethodAFut: futures::Future<Output = ()> + Send,
	MethodB: FnMut(&mut State,i64,i64,SocketControlProtocolMethodBResponder) -> MethodBFut,
	MethodBFut: futures::Future<Output = ()> + Send,
> SocketControlProtocol for SocketControlProtocolImpl<State, OnOpen, OnOpenFut,
	MethodA,
	MethodAFut,
	MethodB,
	MethodBFut,
>
{
	type OnOpenFut = OnOpenFut;
	fn on_open(&mut self, response_chan: SocketControlProtocolControlHandle) -> Self::OnOpenFut {
		(self.on_open)(&mut self.state, response_chan)
	}
	type MethodAFut = MethodAFut;
	fn method_a (&mut self,
		a: i64,
		b: i64,
		response_chan: SocketControlProtocolControlHandle
	) -> Self::MethodAFut
	{
		(self.method_a)(
			&mut self.state,
			a,
			b,
			response_chan
		)
	}
	
	type MethodBFut = MethodBFut;
	fn method_b (&mut self,
		a: i64,
		b: i64,
		response_chan: SocketControlProtocolMethodBResponder
	) -> Self::MethodBFut
	{
		(self.method_b)(
			&mut self.state,
			a,
			b,
			response_chan
		)
	}
	
}

#[derive(Clone)]
pub struct SocketControlProtocolControlHandle {
	inner: ::std::sync::Arc<fidl::ServeInner>,
}

impl ::std::ops::Deref for SocketControlProtocolControlHandle {
	type Target = ::std::sync::Arc<fidl::ServeInner>;

	fn deref(&self) -> &Self::Target {
		&self.inner
	}
}


impl SocketControlProtocolControlHandle {
	pub fn shutdown(&self) {
		self.inner.shutdown()
	}
	pub fn send_event_a(&self,
		mut a: i64,
		mut b: i64) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id: 0,
			flags: 0,
			ordinal: 955483393,
		};

		let mut response = (a, b);

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		let (bytes, handles) = (&mut vec![], &mut vec![]);
		fidl::encoding::Encoder::encode(bytes, handles, &mut msg)?;
		self.inner.channel().write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)?;
		Ok(())
	}
	}

/* beginning of response types */
#[must_use = "FIDL methods require a response to be sent"]
pub struct SocketControlProtocolMethodBResponder {
	control_handle: ::std::mem::ManuallyDrop<SocketControlProtocolControlHandle>,
	tx_id: u32,
	ordinal: u32,
}

impl ::std::ops::Drop for SocketControlProtocolMethodBResponder {
	fn drop(&mut self) {
		// Shutdown the channel if the responder is dropped without sending a response
		// so that the client doesn't hang. To prevent this behavior, some methods
		// call "drop_without_shutdown"
		self.control_handle.shutdown();
		// Safety: drops once, never accessed again
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
	}
}

impl SocketControlProtocolMethodBResponder {
	pub fn control_handle(&self) -> &SocketControlProtocolControlHandle {
		&self.control_handle
	}

	/// Drop the Responder without setting the channel to shutdown.
	///
	/// This method shouldn't normally be used-- instead, send a response
	/// to prevent the channel from shutting down.
	pub fn drop_without_shutdown(mut self) {
		// Safety: drops once, never accessed again due to mem::forget
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
		// Prevent Drop from running (which would shut down the channel)
		::std::mem::forget(self);
	}

	/// Sends a response to the FIDL transaction.
	///
	/// Sets the channel to shutdown if an error occurs.
	pub fn send(self,mut result: i64,) -> Result<(), fidl::Error> {
		let r = self.send_raw(result,);
		if r.is_err() {
			self.control_handle.shutdown();
		}
		self.drop_without_shutdown();
		r
	}

	/// Similar to "send" but does not shutdown the channel if
	/// an error occurs.
	pub fn send_no_shutdown_on_err(self,mut result: i64,) -> Result<(), fidl::Error> {
		let r = self.send_raw(result,);
		self.drop_without_shutdown();
		r
	}

	fn send_raw(&self,mut result: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id: self.tx_id,
			flags: 0,
			ordinal: self.ordinal,
		};

		let mut response = (result);

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		let (bytes, handles) = (&mut vec![], &mut vec![]);
		fidl::encoding::Encoder::encode(bytes, handles, &mut msg)?;
		self.control_handle.inner.channel().write(&*bytes, &mut *handles)
			.map_err(fidl::Error::ServerResponseWrite)?;
		Ok(())
	}
}


#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ChannelProtocolMarker;

impl fidl::endpoints::ServiceMarker for ChannelProtocolMarker {
	type Proxy = ChannelProtocolProxy;
	type RequestStream = ChannelProtocolRequestStream;
	const NAME: &'static str = "";
}

pub trait ChannelProtocolProxyInterface: Send + Sync {
	fn method_a(&self,
		a: i64,
		b: i64,
	)-> Result<(), fidl::Error>;
	type EventAResponseFut: futures::Future<Output = Result<(i64, i64), fidl::Error>> + Send;
	type MethodBResponseFut: futures::Future<Output = Result<(i64), fidl::Error>> + Send;
	fn method_b(&self,
		a: i64,
		b: i64,
	)-> Self::MethodBResponseFut;
}

#[derive(Debug)]
pub struct ChannelProtocolSynchronousProxy {
	client: fidl::client::sync::Client,
}

impl ChannelProtocolSynchronousProxy {
	pub fn new(channel: zx::Channel) -> Self {
		Self { client: fidl::client::sync::Client::new(channel) }
	}

	pub fn into_channel(self) -> zx::Channel {
		self.client.into_channel()
	}
	pub fn method_a(&mut self,
		mut a: i64,
		mut b: i64,) -> Result<(), fidl::Error> {self.client.send(&mut (a, b),
				1432785874,
			)}
	pub fn method_b(&mut self,
		mut a: i64,
		mut b: i64,___deadline: zx::Time,) -> Result<(i64), fidl::Error> {self.client.send_query(&mut (a, b),
				180770075,
				___deadline,
			)}
}

#[derive(Debug, Clone)]
pub struct ChannelProtocolProxy {
	client: fidl::client::Client,
}

impl fidl::endpoints::Proxy for ChannelProtocolProxy {
	fn from_channel(inner: ::fuchsia_async::Channel) -> Self {
		Self::new(inner)
	}
}

impl ::std::ops::Deref for ChannelProtocolProxy {
	type Target = fidl::client::Client;

	fn deref(&self) -> &Self::Target {
		&self.client
	}
}

/// Proxy object for communicating with interface ChannelProtocol
impl ChannelProtocolProxy {
	/// Create a new Proxy for ChannelProtocol
	pub fn new(channel: ::fuchsia_async::Channel) -> Self {
		Self { client: fidl::client::Client::new(channel) }
	}

	/// Attempt to convert the Proxy back into a channel.
	///
	/// This will only succeed if there are no active clones of this Proxy
	/// and no currently-alive EventStream or response futures that came from
	/// this Proxy.
	pub fn into_channel(self) -> Result<::fuchsia_async::Channel, Self> {
		self.client.into_channel().map_err(|client| Self { client })
	}

	/// Get a Stream of events from the remote end of the ChannelProtocol interface
	pub fn take_event_stream(&self) -> ChannelProtocolEventStream {
		ChannelProtocolEventStream {
			event_receiver: self.client.take_event_receiver(),
		}
	}
	pub fn method_a(&self,
		mut a: i64,
		mut b: i64,
	)-> Result<(), fidl::Error> {
		ChannelProtocolProxyInterface::method_a(self,
		a,
		b,
		)
	}
	pub fn method_b(&self,
		mut a: i64,
		mut b: i64,
	)-> fidl::client::QueryResponseFut<(i64)> {
		ChannelProtocolProxyInterface::method_b(self,
		a,
		b,
		)
	}
}

impl ChannelProtocolProxyInterface for ChannelProtocolProxy {
	fn method_a(&self,
		mut a: i64,
		mut b: i64,
	)-> Result<(), fidl::Error> {
		self.client.send(&mut (a, b), 1432785874)
	}
	type EventAResponseFut = fidl::client::QueryResponseFut<(i64, i64)>;
	type MethodBResponseFut = fidl::client::QueryResponseFut<(i64)>;
	fn method_b(&self,
		mut a: i64,
		mut b: i64,
	)-> Self::MethodBResponseFut {
		self.client.send_query(&mut (a, b), 180770075)
	}}

pub struct ChannelProtocolEventStream {
	event_receiver: fidl::client::EventReceiver,
}

impl ::std::marker::Unpin for ChannelProtocolEventStream {}

impl futures::stream::FusedStream for ChannelProtocolEventStream {
	fn is_terminated(&self) -> bool {
		self.event_receiver.is_terminated()
	}
}

impl futures::Stream for ChannelProtocolEventStream {
	type Item = Result<ChannelProtocolEvent, fidl::Error>;

	fn poll_next(mut self: ::std::pin::Pin<&mut Self>, lw: &futures::task::LocalWaker)
		-> futures::Poll<Option<Self::Item>>
	{
		let mut buf = match futures::ready!(
			futures::stream::StreamExt::poll_next_unpin(&mut self.event_receiver, lw)?
		) {
			Some(buf) => buf,
			None => return futures::Poll::Ready(None),
		};
		let (bytes, _handles) = buf.split_mut();
		let (tx_header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

		#[allow(unreachable_patterns)] // GenOrdinal and Ordinal can overlap
		futures::Poll::Ready(Some(match tx_header.ordinal {
			477676034 | 477676034 => {
				let mut out_tuple: (i64,i64) = fidl::encoding::Decodable::new_empty();
				fidl::encoding::Decoder::decode_into(_body_bytes, _handles, &mut out_tuple)?;
				Ok((
					ChannelProtocolEvent::EventA {a: out_tuple.0,b: out_tuple.1,}
				))
			}
			_ => Err(fidl::Error::UnknownOrdinal {
				ordinal: tx_header.ordinal,
				service_name: <ChannelProtocolMarker as fidl::endpoints::ServiceMarker>::NAME,
			})
		}))
	}
}

#[derive(Debug)]
pub enum ChannelProtocolEvent {
	
	
	
	EventA {
		
		a: i64,
		
		b: i64,
		
	},
	}

pub struct ChannelProtocolEventSender<'a> {
	// Some protocols don't define events which would render this channel unused.
	#[allow(unused)]
	channel: zx::Unowned<'a, zx::Channel>,
}
impl <'a> ChannelProtocolEventSender<'a> {
	pub fn new(channel: zx::Unowned<'a, zx::Channel>) -> Self {
		Self { channel }
	}
	pub fn send_event_a(&self,
		mut a: i64,
		mut b: i64) -> Result<(), fidl::Error> {
		let (bytes, handles) = (&mut vec![], &mut vec![]);
		ChannelProtocolEncoder::encode_event_a_response(
			bytes, handles,a,b,)?;
		self.channel.write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)?;
		Ok(())
	}
	
}

#[deprecated(note = "use ChannelProtocolRequestStream instead")]
pub trait ChannelProtocol {
	type OnOpenFut: futures::Future<Output = ()> + Send;
	fn on_open(&mut self, control_handle: ChannelProtocolControlHandle) -> Self::OnOpenFut;
	type MethodAFut: futures::Future<Output = ()> + Send;
	fn method_a (&mut self,
		a: i64,
		b: i64,
		control_handle: ChannelProtocolControlHandle
	) -> Self::MethodAFut;
	
	type MethodBFut: futures::Future<Output = ()> + Send;
	fn method_b (&mut self,
		a: i64,
		b: i64,
		response_chan: ChannelProtocolMethodBResponder,
	) -> Self::MethodBFut;
	

	fn serve(mut self, channel: ::fuchsia_async::Channel)
		-> ChannelProtocolServer<Self>
	where Self: Sized
	{
		let inner = ::std::sync::Arc::new(fidl::ServeInner::new(channel));
		let on_open_fut = self.on_open(
			ChannelProtocolControlHandle {
				inner: inner.clone(),
			}
		);
		ChannelProtocolServer {
			server: self,
			inner: inner.clone(),
			msg_buf: zx::MessageBuf::new(),
			on_open_fut: Some(on_open_fut),method_a_futures: futures::stream::FuturesUnordered::new(),method_b_futures: futures::stream::FuturesUnordered::new(),
		}
	}
}

pub struct ChannelProtocolServer<T: ChannelProtocol> {
	#[allow(dead_code)] // not used if no methods are present
	server: T,
	inner: ::std::sync::Arc<fidl::ServeInner>,
	msg_buf: zx::MessageBuf,
	on_open_fut: Option<T::OnOpenFut>,method_a_futures: futures::stream::FuturesUnordered<T::MethodAFut>,method_b_futures: futures::stream::FuturesUnordered<T::MethodBFut>,
}

// Safety: only the OnOpen fut is held directly, so it's the only one that
// is projected to, so it's the only one that needs to be Unpin for the Impl
// struct to be Unpin.
impl<T: ChannelProtocol> ::std::marker::Unpin for ChannelProtocolServer<T>
where T::OnOpenFut: ::std::marker::Unpin,
{}

impl<T: ChannelProtocol> ChannelProtocolServer<T> {
	pub fn control_handle(&self) -> ChannelProtocolControlHandle {
		ChannelProtocolControlHandle {
			inner: self.inner.clone(),
		}
	}
}

impl<T: ChannelProtocol> futures::Future for ChannelProtocolServer<T> {
	type Output = Result<(), fidl::Error>;

	fn poll(
		mut self: ::std::pin::Pin<&mut Self>,
		lw: &futures::task::LocalWaker,
	) -> futures::Poll<Self::Output> {
		// safety: the only potentially !Unpin field is on_open_fut, which we make sure
		// isn't moved below
		let this = unsafe { ::std::pin::Pin::get_unchecked_mut(self) };
		loop {
		let mut made_progress_this_loop_iter = false;

		if this.inner.poll_shutdown(lw) {
			return futures::Poll::Ready(Ok(()));
		}

		unsafe {
			// Safety: ensure that on_open isn't moved
			let completed_on_open = if let Some(on_open_fut) = &mut this.on_open_fut {
				match futures::Future::poll(::std::pin::Pin::new_unchecked(on_open_fut), lw) {
					futures::Poll::Ready(()) => true,
					futures::Poll::Pending => false,
				}
			} else {
				false
			};

			if completed_on_open {
				made_progress_this_loop_iter = true;
				this.on_open_fut = None;
			}
		}match futures::stream::StreamExt::poll_next_unpin(
			&mut this.method_a_futures, lw
		) {
			futures::Poll::Ready(Some(())) => made_progress_this_loop_iter = true,
			_ => {},
		}match futures::stream::StreamExt::poll_next_unpin(
			&mut this.method_b_futures, lw
		) {
			futures::Poll::Ready(Some(())) => made_progress_this_loop_iter = true,
			_ => {},
		}

		this.msg_buf.clear();
		match this.inner.channel().recv_from(&mut this.msg_buf, lw) {
			futures::Poll::Ready(Ok(())) => {},
			futures::Poll::Pending => {
				if !made_progress_this_loop_iter {
					return futures::Poll::Pending;
				} else {
					continue;
				}
			}
			futures::Poll::Ready(Err(zx::Status::PEER_CLOSED)) => {
				return futures::Poll::Ready(Ok(()));
			}
			futures::Poll::Ready(Err(e)) =>
				return futures::Poll::Ready(Err(fidl::Error::ServerRequestRead(e))),
		}

		{
			// A message has been received from the channel
			let (bytes, _handles) = this.msg_buf.split_mut();
			let (header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

			#[allow(unreachable_patterns)] // GenOrdinal and Ordinal can overlap
			match header.ordinal {
					1432785874 | 1432785874 => {
						let mut req: (i64,i64) = fidl::encoding::Decodable::new_empty();
						fidl::encoding::Decoder::decode_into(_body_bytes, _handles, &mut req)?;
						let control_handle = ChannelProtocolControlHandle {
							inner: this.inner.clone(),
						};
						this.method_a_futures.push(
							this.server.method_a(req.0,req.1,control_handle)
						);
					}
					180770075 | 180770075 => {
						let mut req: (i64,i64) = fidl::encoding::Decodable::new_empty();
						fidl::encoding::Decoder::decode_into(_body_bytes, _handles, &mut req)?;
						let control_handle = ChannelProtocolControlHandle {
							inner: this.inner.clone(),
						};
						this.method_b_futures.push(
							this.server.method_b(req.0,req.1,ChannelProtocolMethodBResponder {
										control_handle: ::std::mem::ManuallyDrop::new(control_handle),
										tx_id: header.tx_id,
										ordinal: header.ordinal,
									})
						);
					}
				// TODO(cramertj) handle control/fileio messages
				_ => return futures::Poll::Ready(Err(fidl::Error::UnknownOrdinal {
					ordinal: header.ordinal,
					service_name: "unknown fidl", // TODO(cramertj)
				})),
			}
		}
	}}
}

/// A Stream of incoming requests for ChannelProtocol
pub struct ChannelProtocolRequestStream {
	inner: ::std::sync::Arc<fidl::ServeInner>,
	msg_buf: Option<zx::MessageBuf>,
}

impl ::std::marker::Unpin for ChannelProtocolRequestStream {}

impl futures::stream::FusedStream for ChannelProtocolRequestStream {
	fn is_terminated(&self) -> bool {
		self.msg_buf.is_none()
	}
}

impl fidl::endpoints::RequestStream for ChannelProtocolRequestStream {
	/// Consume a channel to make a ChannelProtocolRequestStream
	fn from_channel(channel: ::fuchsia_async::Channel) -> Self {
		Self {
			inner: ::std::sync::Arc::new(fidl::ServeInner::new(channel)),
			msg_buf: Some(zx::MessageBuf::new()),
		}
	}

	/// ControlHandle for the remote connection
	type ControlHandle = ChannelProtocolControlHandle;

	/// ControlHandle for the remote connection
	fn control_handle(&self) -> Self::ControlHandle {
		ChannelProtocolControlHandle { inner: self.inner.clone() }
	}

	fn into_inner(self) -> (::std::sync::Arc<fidl::ServeInner>, Option<zx::MessageBuf>) {
		(self.inner, self.msg_buf)
	}

	fn from_inner(inner: ::std::sync::Arc<fidl::ServeInner>, msg_buf: Option<zx::MessageBuf>)
		-> Self
	{
		Self { inner, msg_buf }
	}
}

impl futures::Stream for ChannelProtocolRequestStream {
	type Item = Result<ChannelProtocolRequest, fidl::Error>;

	fn poll_next(mut self: ::std::pin::Pin<&mut Self>, lw: &futures::task::LocalWaker)
		-> futures::Poll<Option<Self::Item>>
	{
		let this = &mut *self;
		if this.inner.poll_shutdown(lw) {
			this.msg_buf = None;
			return futures::Poll::Ready(None);
		}
		let msg_buf = this.msg_buf.as_mut()
								.expect("polled ChannelProtocolRequestStream after completion");
		msg_buf.clear();
		match this.inner.channel().recv_from(msg_buf, lw) {
			futures::Poll::Ready(Ok(())) => {},
			futures::Poll::Pending => return futures::Poll::Pending,
			futures::Poll::Ready(Err(zx::Status::PEER_CLOSED)) => {
				this.msg_buf = None;
				return futures::Poll::Ready(None)
			},
			futures::Poll::Ready(Err(e)) =>
			return futures::Poll::Ready(Some(Err(fidl::Error::ServerRequestRead(e)))),
		}

		// A message has been received from the channel
		let (bytes, _handles) = msg_buf.split_mut();
		let (header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

		#[allow(unreachable_patterns)] // GenOrdinal and Ordinal can overlap
		futures::Poll::Ready(Some(match header.ordinal {
			1432785874 | 1432785874 => {
				let mut req: (i64,i64) = fidl::encoding::Decodable::new_empty();
				fidl::encoding::Decoder::decode_into(_body_bytes, _handles, &mut req)?;
				let control_handle = ChannelProtocolControlHandle {
					inner: this.inner.clone(),
				};

				Ok(ChannelProtocolRequest::MethodA {a: req.0,b: req.1,control_handle,})
			}
			180770075 | 180770075 => {
				let mut req: (i64,i64) = fidl::encoding::Decodable::new_empty();
				fidl::encoding::Decoder::decode_into(_body_bytes, _handles, &mut req)?;
				let control_handle = ChannelProtocolControlHandle {
					inner: this.inner.clone(),
				};

				Ok(ChannelProtocolRequest::MethodB {a: req.0,b: req.1,responder:ChannelProtocolMethodBResponder {
							control_handle: ::std::mem::ManuallyDrop::new(control_handle),
							tx_id: header.tx_id,
							ordinal: header.ordinal,
						},})
			}
			_ => Err(fidl::Error::UnknownOrdinal {
				ordinal: header.ordinal,
				service_name: <ChannelProtocolMarker as fidl::endpoints::ServiceMarker>::NAME,
			}),
		}))
	}
}
pub enum ChannelProtocolRequest {
	MethodA {
		
		a: i64,
		
		b: i64,
		control_handle: ChannelProtocolControlHandle,},
	MethodB {
		
		a: i64,
		
		b: i64,
		responder: ChannelProtocolMethodBResponder,},
}

pub struct ChannelProtocolEncoder;
impl ChannelProtocolEncoder {
	pub fn encode_method_a_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,mut in_a: i64,mut in_b: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {tx_id: 0,flags: 0,
			ordinal: 1432785874,
		};
		let mut body = (in_a,in_b,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_event_a_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,mut in_a: i64,mut in_b: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {tx_id: 0,flags: 0,
			ordinal: 477676034,
		};
		let mut body = (in_a,in_b,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_method_b_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,mut in_a: i64,mut in_b: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 180770075,
		};
		let mut body = (in_a,in_b,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_method_b_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,mut in_result: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 180770075,
		};
		let mut body = (in_result,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}}

#[deprecated(note = "use ChannelProtocolRequestStream instead")]
pub struct ChannelProtocolImpl<
	State,
OnOpen: FnMut(&mut State, ChannelProtocolControlHandle) -> OnOpenFut,
OnOpenFut: futures::Future<Output = ()> + Send,
	MethodA: FnMut(&mut State,i64,i64,ChannelProtocolControlHandle) -> MethodAFut,
	MethodAFut: futures::Future<Output = ()> + Send,
	MethodB: FnMut(&mut State,i64,i64,ChannelProtocolMethodBResponder) -> MethodBFut,
	MethodBFut: futures::Future<Output = ()> + Send,
> {
	pub state: State,
	pub on_open: OnOpen,
	pub method_a: MethodA,
	pub method_b: MethodB,
}

// Unpin is never projected for the Impl struct
impl<
	State,
OnOpen: FnMut(&mut State, ChannelProtocolControlHandle) -> OnOpenFut,
OnOpenFut: futures::Future<Output = ()> + Send,
	MethodA: FnMut(&mut State,i64,i64,ChannelProtocolControlHandle) -> MethodAFut,
	MethodAFut: futures::Future<Output = ()> + Send,
	MethodB: FnMut(&mut State,i64,i64,ChannelProtocolMethodBResponder) -> MethodBFut,
	MethodBFut: futures::Future<Output = ()> + Send,
> ::std::marker::Unpin for ChannelProtocolImpl<State, OnOpen, OnOpenFut,
	MethodA,
	MethodAFut,
	MethodB,
	MethodBFut,
>
{}

impl<
	State,
OnOpen: FnMut(&mut State, ChannelProtocolControlHandle) -> OnOpenFut,
OnOpenFut: futures::Future<Output = ()> + Send,
	MethodA: FnMut(&mut State,i64,i64,ChannelProtocolControlHandle) -> MethodAFut,
	MethodAFut: futures::Future<Output = ()> + Send,
	MethodB: FnMut(&mut State,i64,i64,ChannelProtocolMethodBResponder) -> MethodBFut,
	MethodBFut: futures::Future<Output = ()> + Send,
> ChannelProtocol for ChannelProtocolImpl<State, OnOpen, OnOpenFut,
	MethodA,
	MethodAFut,
	MethodB,
	MethodBFut,
>
{
	type OnOpenFut = OnOpenFut;
	fn on_open(&mut self, response_chan: ChannelProtocolControlHandle) -> Self::OnOpenFut {
		(self.on_open)(&mut self.state, response_chan)
	}
	type MethodAFut = MethodAFut;
	fn method_a (&mut self,
		a: i64,
		b: i64,
		response_chan: ChannelProtocolControlHandle
	) -> Self::MethodAFut
	{
		(self.method_a)(
			&mut self.state,
			a,
			b,
			response_chan
		)
	}
	
	type MethodBFut = MethodBFut;
	fn method_b (&mut self,
		a: i64,
		b: i64,
		response_chan: ChannelProtocolMethodBResponder
	) -> Self::MethodBFut
	{
		(self.method_b)(
			&mut self.state,
			a,
			b,
			response_chan
		)
	}
	
}

#[derive(Clone)]
pub struct ChannelProtocolControlHandle {
	inner: ::std::sync::Arc<fidl::ServeInner>,
}

impl ::std::ops::Deref for ChannelProtocolControlHandle {
	type Target = ::std::sync::Arc<fidl::ServeInner>;

	fn deref(&self) -> &Self::Target {
		&self.inner
	}
}


impl ChannelProtocolControlHandle {
	pub fn shutdown(&self) {
		self.inner.shutdown()
	}
	pub fn send_event_a(&self,
		mut a: i64,
		mut b: i64) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id: 0,
			flags: 0,
			ordinal: 477676034,
		};

		let mut response = (a, b);

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		let (bytes, handles) = (&mut vec![], &mut vec![]);
		fidl::encoding::Encoder::encode(bytes, handles, &mut msg)?;
		self.inner.channel().write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)?;
		Ok(())
	}
	}

/* beginning of response types */
#[must_use = "FIDL methods require a response to be sent"]
pub struct ChannelProtocolMethodBResponder {
	control_handle: ::std::mem::ManuallyDrop<ChannelProtocolControlHandle>,
	tx_id: u32,
	ordinal: u32,
}

impl ::std::ops::Drop for ChannelProtocolMethodBResponder {
	fn drop(&mut self) {
		// Shutdown the channel if the responder is dropped without sending a response
		// so that the client doesn't hang. To prevent this behavior, some methods
		// call "drop_without_shutdown"
		self.control_handle.shutdown();
		// Safety: drops once, never accessed again
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
	}
}

impl ChannelProtocolMethodBResponder {
	pub fn control_handle(&self) -> &ChannelProtocolControlHandle {
		&self.control_handle
	}

	/// Drop the Responder without setting the channel to shutdown.
	///
	/// This method shouldn't normally be used-- instead, send a response
	/// to prevent the channel from shutting down.
	pub fn drop_without_shutdown(mut self) {
		// Safety: drops once, never accessed again due to mem::forget
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
		// Prevent Drop from running (which would shut down the channel)
		::std::mem::forget(self);
	}

	/// Sends a response to the FIDL transaction.
	///
	/// Sets the channel to shutdown if an error occurs.
	pub fn send(self,mut result: i64,) -> Result<(), fidl::Error> {
		let r = self.send_raw(result,);
		if r.is_err() {
			self.control_handle.shutdown();
		}
		self.drop_without_shutdown();
		r
	}

	/// Similar to "send" but does not shutdown the channel if
	/// an error occurs.
	pub fn send_no_shutdown_on_err(self,mut result: i64,) -> Result<(), fidl::Error> {
		let r = self.send_raw(result,);
		self.drop_without_shutdown();
		r
	}

	fn send_raw(&self,mut result: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id: self.tx_id,
			flags: 0,
			ordinal: self.ordinal,
		};

		let mut response = (result);

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		let (bytes, handles) = (&mut vec![], &mut vec![]);
		fidl::encoding::Encoder::encode(bytes, handles, &mut msg)?;
		self.control_handle.inner.channel().write(&*bytes, &mut *handles)
			.map_err(fidl::Error::ServerResponseWrite)?;
		Ok(())
	}
}


#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct KitchenSinkMarker;

impl fidl::endpoints::ServiceMarker for KitchenSinkMarker {
	type Proxy = KitchenSinkProxy;
	type RequestStream = KitchenSinkRequestStream;
	const NAME: &'static str = "";
}

pub trait KitchenSinkProxyInterface: Send + Sync {
	fn method_a(&self,
		a: i64,
		b: i64,
	)-> Result<(), fidl::Error>;
	type EventAResponseFut: futures::Future<Output = Result<(i64, i64), fidl::Error>> + Send;
	type MethodBResponseFut: futures::Future<Output = Result<(i64), fidl::Error>> + Send;
	fn method_b(&self,
		a: i64,
		b: i64,
	)-> Self::MethodBResponseFut;
}

#[derive(Debug)]
pub struct KitchenSinkSynchronousProxy {
	client: fidl::client::sync::Client,
}

impl KitchenSinkSynchronousProxy {
	pub fn new(channel: zx::Channel) -> Self {
		Self { client: fidl::client::sync::Client::new(channel) }
	}

	pub fn into_channel(self) -> zx::Channel {
		self.client.into_channel()
	}
	pub fn method_a(&mut self,
		mut a: i64,
		mut b: i64,) -> Result<(), fidl::Error> {self.client.send(&mut (a, b),
				450577456,
			)}
	pub fn method_b(&mut self,
		mut a: i64,
		mut b: i64,___deadline: zx::Time,) -> Result<(i64), fidl::Error> {self.client.send_query(&mut (a, b),
				1999489700,
				___deadline,
			)}
}

#[derive(Debug, Clone)]
pub struct KitchenSinkProxy {
	client: fidl::client::Client,
}

impl fidl::endpoints::Proxy for KitchenSinkProxy {
	fn from_channel(inner: ::fuchsia_async::Channel) -> Self {
		Self::new(inner)
	}
}

impl ::std::ops::Deref for KitchenSinkProxy {
	type Target = fidl::client::Client;

	fn deref(&self) -> &Self::Target {
		&self.client
	}
}

/// Proxy object for communicating with interface KitchenSink
impl KitchenSinkProxy {
	/// Create a new Proxy for KitchenSink
	pub fn new(channel: ::fuchsia_async::Channel) -> Self {
		Self { client: fidl::client::Client::new(channel) }
	}

	/// Attempt to convert the Proxy back into a channel.
	///
	/// This will only succeed if there are no active clones of this Proxy
	/// and no currently-alive EventStream or response futures that came from
	/// this Proxy.
	pub fn into_channel(self) -> Result<::fuchsia_async::Channel, Self> {
		self.client.into_channel().map_err(|client| Self { client })
	}

	/// Get a Stream of events from the remote end of the KitchenSink interface
	pub fn take_event_stream(&self) -> KitchenSinkEventStream {
		KitchenSinkEventStream {
			event_receiver: self.client.take_event_receiver(),
		}
	}
	pub fn method_a(&self,
		mut a: i64,
		mut b: i64,
	)-> Result<(), fidl::Error> {
		KitchenSinkProxyInterface::method_a(self,
		a,
		b,
		)
	}
	pub fn method_b(&self,
		mut a: i64,
		mut b: i64,
	)-> fidl::client::QueryResponseFut<(i64)> {
		KitchenSinkProxyInterface::method_b(self,
		a,
		b,
		)
	}
}

impl KitchenSinkProxyInterface for KitchenSinkProxy {
	fn method_a(&self,
		mut a: i64,
		mut b: i64,
	)-> Result<(), fidl::Error> {
		self.client.send(&mut (a, b), 450577456)
	}
	type EventAResponseFut = fidl::client::QueryResponseFut<(i64, i64)>;
	type MethodBResponseFut = fidl::client::QueryResponseFut<(i64)>;
	fn method_b(&self,
		mut a: i64,
		mut b: i64,
	)-> Self::MethodBResponseFut {
		self.client.send_query(&mut (a, b), 1999489700)
	}}

pub struct KitchenSinkEventStream {
	event_receiver: fidl::client::EventReceiver,
}

impl ::std::marker::Unpin for KitchenSinkEventStream {}

impl futures::stream::FusedStream for KitchenSinkEventStream {
	fn is_terminated(&self) -> bool {
		self.event_receiver.is_terminated()
	}
}

impl futures::Stream for KitchenSinkEventStream {
	type Item = Result<KitchenSinkEvent, fidl::Error>;

	fn poll_next(mut self: ::std::pin::Pin<&mut Self>, lw: &futures::task::LocalWaker)
		-> futures::Poll<Option<Self::Item>>
	{
		let mut buf = match futures::ready!(
			futures::stream::StreamExt::poll_next_unpin(&mut self.event_receiver, lw)?
		) {
			Some(buf) => buf,
			None => return futures::Poll::Ready(None),
		};
		let (bytes, _handles) = buf.split_mut();
		let (tx_header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

		#[allow(unreachable_patterns)] // GenOrdinal and Ordinal can overlap
		futures::Poll::Ready(Some(match tx_header.ordinal {
			1795426833 | 1795426833 => {
				let mut out_tuple: (i64,i64) = fidl::encoding::Decodable::new_empty();
				fidl::encoding::Decoder::decode_into(_body_bytes, _handles, &mut out_tuple)?;
				Ok((
					KitchenSinkEvent::EventA {a: out_tuple.0,b: out_tuple.1,}
				))
			}
			_ => Err(fidl::Error::UnknownOrdinal {
				ordinal: tx_header.ordinal,
				service_name: <KitchenSinkMarker as fidl::endpoints::ServiceMarker>::NAME,
			})
		}))
	}
}

#[derive(Debug)]
pub enum KitchenSinkEvent {
	
	
	
	EventA {
		
		a: i64,
		
		b: i64,
		
	},
	}

pub struct KitchenSinkEventSender<'a> {
	// Some protocols don't define events which would render this channel unused.
	#[allow(unused)]
	channel: zx::Unowned<'a, zx::Channel>,
}
impl <'a> KitchenSinkEventSender<'a> {
	pub fn new(channel: zx::Unowned<'a, zx::Channel>) -> Self {
		Self { channel }
	}
	pub fn send_event_a(&self,
		mut a: i64,
		mut b: i64) -> Result<(), fidl::Error> {
		let (bytes, handles) = (&mut vec![], &mut vec![]);
		KitchenSinkEncoder::encode_event_a_response(
			bytes, handles,a,b,)?;
		self.channel.write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)?;
		Ok(())
	}
	
}

#[deprecated(note = "use KitchenSinkRequestStream instead")]
pub trait KitchenSink {
	type OnOpenFut: futures::Future<Output = ()> + Send;
	fn on_open(&mut self, control_handle: KitchenSinkControlHandle) -> Self::OnOpenFut;
	type MethodAFut: futures::Future<Output = ()> + Send;
	fn method_a (&mut self,
		a: i64,
		b: i64,
		control_handle: KitchenSinkControlHandle
	) -> Self::MethodAFut;
	
	type MethodBFut: futures::Future<Output = ()> + Send;
	fn method_b (&mut self,
		a: i64,
		b: i64,
		response_chan: KitchenSinkMethodBResponder,
	) -> Self::MethodBFut;
	

	fn serve(mut self, channel: ::fuchsia_async::Channel)
		-> KitchenSinkServer<Self>
	where Self: Sized
	{
		let inner = ::std::sync::Arc::new(fidl::ServeInner::new(channel));
		let on_open_fut = self.on_open(
			KitchenSinkControlHandle {
				inner: inner.clone(),
			}
		);
		KitchenSinkServer {
			server: self,
			inner: inner.clone(),
			msg_buf: zx::MessageBuf::new(),
			on_open_fut: Some(on_open_fut),method_a_futures: futures::stream::FuturesUnordered::new(),method_b_futures: futures::stream::FuturesUnordered::new(),
		}
	}
}

pub struct KitchenSinkServer<T: KitchenSink> {
	#[allow(dead_code)] // not used if no methods are present
	server: T,
	inner: ::std::sync::Arc<fidl::ServeInner>,
	msg_buf: zx::MessageBuf,
	on_open_fut: Option<T::OnOpenFut>,method_a_futures: futures::stream::FuturesUnordered<T::MethodAFut>,method_b_futures: futures::stream::FuturesUnordered<T::MethodBFut>,
}

// Safety: only the OnOpen fut is held directly, so it's the only one that
// is projected to, so it's the only one that needs to be Unpin for the Impl
// struct to be Unpin.
impl<T: KitchenSink> ::std::marker::Unpin for KitchenSinkServer<T>
where T::OnOpenFut: ::std::marker::Unpin,
{}

impl<T: KitchenSink> KitchenSinkServer<T> {
	pub fn control_handle(&self) -> KitchenSinkControlHandle {
		KitchenSinkControlHandle {
			inner: self.inner.clone(),
		}
	}
}

impl<T: KitchenSink> futures::Future for KitchenSinkServer<T> {
	type Output = Result<(), fidl::Error>;

	fn poll(
		mut self: ::std::pin::Pin<&mut Self>,
		lw: &futures::task::LocalWaker,
	) -> futures::Poll<Self::Output> {
		// safety: the only potentially !Unpin field is on_open_fut, which we make sure
		// isn't moved below
		let this = unsafe { ::std::pin::Pin::get_unchecked_mut(self) };
		loop {
		let mut made_progress_this_loop_iter = false;

		if this.inner.poll_shutdown(lw) {
			return futures::Poll::Ready(Ok(()));
		}

		unsafe {
			// Safety: ensure that on_open isn't moved
			let completed_on_open = if let Some(on_open_fut) = &mut this.on_open_fut {
				match futures::Future::poll(::std::pin::Pin::new_unchecked(on_open_fut), lw) {
					futures::Poll::Ready(()) => true,
					futures::Poll::Pending => false,
				}
			} else {
				false
			};

			if completed_on_open {
				made_progress_this_loop_iter = true;
				this.on_open_fut = None;
			}
		}match futures::stream::StreamExt::poll_next_unpin(
			&mut this.method_a_futures, lw
		) {
			futures::Poll::Ready(Some(())) => made_progress_this_loop_iter = true,
			_ => {},
		}match futures::stream::StreamExt::poll_next_unpin(
			&mut this.method_b_futures, lw
		) {
			futures::Poll::Ready(Some(())) => made_progress_this_loop_iter = true,
			_ => {},
		}

		this.msg_buf.clear();
		match this.inner.channel().recv_from(&mut this.msg_buf, lw) {
			futures::Poll::Ready(Ok(())) => {},
			futures::Poll::Pending => {
				if !made_progress_this_loop_iter {
					return futures::Poll::Pending;
				} else {
					continue;
				}
			}
			futures::Poll::Ready(Err(zx::Status::PEER_CLOSED)) => {
				return futures::Poll::Ready(Ok(()));
			}
			futures::Poll::Ready(Err(e)) =>
				return futures::Poll::Ready(Err(fidl::Error::ServerRequestRead(e))),
		}

		{
			// A message has been received from the channel
			let (bytes, _handles) = this.msg_buf.split_mut();
			let (header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

			#[allow(unreachable_patterns)] // GenOrdinal and Ordinal can overlap
			match header.ordinal {
					450577456 | 450577456 => {
						let mut req: (i64,i64) = fidl::encoding::Decodable::new_empty();
						fidl::encoding::Decoder::decode_into(_body_bytes, _handles, &mut req)?;
						let control_handle = KitchenSinkControlHandle {
							inner: this.inner.clone(),
						};
						this.method_a_futures.push(
							this.server.method_a(req.0,req.1,control_handle)
						);
					}
					1999489700 | 1999489700 => {
						let mut req: (i64,i64) = fidl::encoding::Decodable::new_empty();
						fidl::encoding::Decoder::decode_into(_body_bytes, _handles, &mut req)?;
						let control_handle = KitchenSinkControlHandle {
							inner: this.inner.clone(),
						};
						this.method_b_futures.push(
							this.server.method_b(req.0,req.1,KitchenSinkMethodBResponder {
										control_handle: ::std::mem::ManuallyDrop::new(control_handle),
										tx_id: header.tx_id,
										ordinal: header.ordinal,
									})
						);
					}
				// TODO(cramertj) handle control/fileio messages
				_ => return futures::Poll::Ready(Err(fidl::Error::UnknownOrdinal {
					ordinal: header.ordinal,
					service_name: "unknown fidl", // TODO(cramertj)
				})),
			}
		}
	}}
}

/// A Stream of incoming requests for KitchenSink
pub struct KitchenSinkRequestStream {
	inner: ::std::sync::Arc<fidl::ServeInner>,
	msg_buf: Option<zx::MessageBuf>,
}

impl ::std::marker::Unpin for KitchenSinkRequestStream {}

impl futures::stream::FusedStream for KitchenSinkRequestStream {
	fn is_terminated(&self) -> bool {
		self.msg_buf.is_none()
	}
}

impl fidl::endpoints::RequestStream for KitchenSinkRequestStream {
	/// Consume a channel to make a KitchenSinkRequestStream
	fn from_channel(channel: ::fuchsia_async::Channel) -> Self {
		Self {
			inner: ::std::sync::Arc::new(fidl::ServeInner::new(channel)),
			msg_buf: Some(zx::MessageBuf::new()),
		}
	}

	/// ControlHandle for the remote connection
	type ControlHandle = KitchenSinkControlHandle;

	/// ControlHandle for the remote connection
	fn control_handle(&self) -> Self::ControlHandle {
		KitchenSinkControlHandle { inner: self.inner.clone() }
	}

	fn into_inner(self) -> (::std::sync::Arc<fidl::ServeInner>, Option<zx::MessageBuf>) {
		(self.inner, self.msg_buf)
	}

	fn from_inner(inner: ::std::sync::Arc<fidl::ServeInner>, msg_buf: Option<zx::MessageBuf>)
		-> Self
	{
		Self { inner, msg_buf }
	}
}

impl futures::Stream for KitchenSinkRequestStream {
	type Item = Result<KitchenSinkRequest, fidl::Error>;

	fn poll_next(mut self: ::std::pin::Pin<&mut Self>, lw: &futures::task::LocalWaker)
		-> futures::Poll<Option<Self::Item>>
	{
		let this = &mut *self;
		if this.inner.poll_shutdown(lw) {
			this.msg_buf = None;
			return futures::Poll::Ready(None);
		}
		let msg_buf = this.msg_buf.as_mut()
								.expect("polled KitchenSinkRequestStream after completion");
		msg_buf.clear();
		match this.inner.channel().recv_from(msg_buf, lw) {
			futures::Poll::Ready(Ok(())) => {},
			futures::Poll::Pending => return futures::Poll::Pending,
			futures::Poll::Ready(Err(zx::Status::PEER_CLOSED)) => {
				this.msg_buf = None;
				return futures::Poll::Ready(None)
			},
			futures::Poll::Ready(Err(e)) =>
			return futures::Poll::Ready(Some(Err(fidl::Error::ServerRequestRead(e)))),
		}

		// A message has been received from the channel
		let (bytes, _handles) = msg_buf.split_mut();
		let (header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

		#[allow(unreachable_patterns)] // GenOrdinal and Ordinal can overlap
		futures::Poll::Ready(Some(match header.ordinal {
			450577456 | 450577456 => {
				let mut req: (i64,i64) = fidl::encoding::Decodable::new_empty();
				fidl::encoding::Decoder::decode_into(_body_bytes, _handles, &mut req)?;
				let control_handle = KitchenSinkControlHandle {
					inner: this.inner.clone(),
				};

				Ok(KitchenSinkRequest::MethodA {a: req.0,b: req.1,control_handle,})
			}
			1999489700 | 1999489700 => {
				let mut req: (i64,i64) = fidl::encoding::Decodable::new_empty();
				fidl::encoding::Decoder::decode_into(_body_bytes, _handles, &mut req)?;
				let control_handle = KitchenSinkControlHandle {
					inner: this.inner.clone(),
				};

				Ok(KitchenSinkRequest::MethodB {a: req.0,b: req.1,responder:KitchenSinkMethodBResponder {
							control_handle: ::std::mem::ManuallyDrop::new(control_handle),
							tx_id: header.tx_id,
							ordinal: header.ordinal,
						},})
			}
			_ => Err(fidl::Error::UnknownOrdinal {
				ordinal: header.ordinal,
				service_name: <KitchenSinkMarker as fidl::endpoints::ServiceMarker>::NAME,
			}),
		}))
	}
}
pub enum KitchenSinkRequest {
	MethodA {
		
		a: i64,
		
		b: i64,
		control_handle: KitchenSinkControlHandle,},
	MethodB {
		
		a: i64,
		
		b: i64,
		responder: KitchenSinkMethodBResponder,},
}

pub struct KitchenSinkEncoder;
impl KitchenSinkEncoder {
	pub fn encode_method_a_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,mut in_a: i64,mut in_b: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {tx_id: 0,flags: 0,
			ordinal: 450577456,
		};
		let mut body = (in_a,in_b,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_event_a_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,mut in_a: i64,mut in_b: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {tx_id: 0,flags: 0,
			ordinal: 1795426833,
		};
		let mut body = (in_a,in_b,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_method_b_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,mut in_a: i64,mut in_b: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 1999489700,
		};
		let mut body = (in_a,in_b,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_method_b_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,mut in_result: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 1999489700,
		};
		let mut body = (in_result,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}}

#[deprecated(note = "use KitchenSinkRequestStream instead")]
pub struct KitchenSinkImpl<
	State,
OnOpen: FnMut(&mut State, KitchenSinkControlHandle) -> OnOpenFut,
OnOpenFut: futures::Future<Output = ()> + Send,
	MethodA: FnMut(&mut State,i64,i64,KitchenSinkControlHandle) -> MethodAFut,
	MethodAFut: futures::Future<Output = ()> + Send,
	MethodB: FnMut(&mut State,i64,i64,KitchenSinkMethodBResponder) -> MethodBFut,
	MethodBFut: futures::Future<Output = ()> + Send,
> {
	pub state: State,
	pub on_open: OnOpen,
	pub method_a: MethodA,
	pub method_b: MethodB,
}

// Unpin is never projected for the Impl struct
impl<
	State,
OnOpen: FnMut(&mut State, KitchenSinkControlHandle) -> OnOpenFut,
OnOpenFut: futures::Future<Output = ()> + Send,
	MethodA: FnMut(&mut State,i64,i64,KitchenSinkControlHandle) -> MethodAFut,
	MethodAFut: futures::Future<Output = ()> + Send,
	MethodB: FnMut(&mut State,i64,i64,KitchenSinkMethodBResponder) -> MethodBFut,
	MethodBFut: futures::Future<Output = ()> + Send,
> ::std::marker::Unpin for KitchenSinkImpl<State, OnOpen, OnOpenFut,
	MethodA,
	MethodAFut,
	MethodB,
	MethodBFut,
>
{}

impl<
	State,
OnOpen: FnMut(&mut State, KitchenSinkControlHandle) -> OnOpenFut,
OnOpenFut: futures::Future<Output = ()> + Send,
	MethodA: FnMut(&mut State,i64,i64,KitchenSinkControlHandle) -> MethodAFut,
	MethodAFut: futures::Future<Output = ()> + Send,
	MethodB: FnMut(&mut State,i64,i64,KitchenSinkMethodBResponder) -> MethodBFut,
	MethodBFut: futures::Future<Output = ()> + Send,
> KitchenSink for KitchenSinkImpl<State, OnOpen, OnOpenFut,
	MethodA,
	MethodAFut,
	MethodB,
	MethodBFut,
>
{
	type OnOpenFut = OnOpenFut;
	fn on_open(&mut self, response_chan: KitchenSinkControlHandle) -> Self::OnOpenFut {
		(self.on_open)(&mut self.state, response_chan)
	}
	type MethodAFut = MethodAFut;
	fn method_a (&mut self,
		a: i64,
		b: i64,
		response_chan: KitchenSinkControlHandle
	) -> Self::MethodAFut
	{
		(self.method_a)(
			&mut self.state,
			a,
			b,
			response_chan
		)
	}
	
	type MethodBFut = MethodBFut;
	fn method_b (&mut self,
		a: i64,
		b: i64,
		response_chan: KitchenSinkMethodBResponder
	) -> Self::MethodBFut
	{
		(self.method_b)(
			&mut self.state,
			a,
			b,
			response_chan
		)
	}
	
}

#[derive(Clone)]
pub struct KitchenSinkControlHandle {
	inner: ::std::sync::Arc<fidl::ServeInner>,
}

impl ::std::ops::Deref for KitchenSinkControlHandle {
	type Target = ::std::sync::Arc<fidl::ServeInner>;

	fn deref(&self) -> &Self::Target {
		&self.inner
	}
}


impl KitchenSinkControlHandle {
	pub fn shutdown(&self) {
		self.inner.shutdown()
	}
	pub fn send_event_a(&self,
		mut a: i64,
		mut b: i64) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id: 0,
			flags: 0,
			ordinal: 1795426833,
		};

		let mut response = (a, b);

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		let (bytes, handles) = (&mut vec![], &mut vec![]);
		fidl::encoding::Encoder::encode(bytes, handles, &mut msg)?;
		self.inner.channel().write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)?;
		Ok(())
	}
	}

/* beginning of response types */
#[must_use = "FIDL methods require a response to be sent"]
pub struct KitchenSinkMethodBResponder {
	control_handle: ::std::mem::ManuallyDrop<KitchenSinkControlHandle>,
	tx_id: u32,
	ordinal: u32,
}

impl ::std::ops::Drop for KitchenSinkMethodBResponder {
	fn drop(&mut self) {
		// Shutdown the channel if the responder is dropped without sending a response
		// so that the client doesn't hang. To prevent this behavior, some methods
		// call "drop_without_shutdown"
		self.control_handle.shutdown();
		// Safety: drops once, never accessed again
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
	}
}

impl KitchenSinkMethodBResponder {
	pub fn control_handle(&self) -> &KitchenSinkControlHandle {
		&self.control_handle
	}

	/// Drop the Responder without setting the channel to shutdown.
	///
	/// This method shouldn't normally be used-- instead, send a response
	/// to prevent the channel from shutting down.
	pub fn drop_without_shutdown(mut self) {
		// Safety: drops once, never accessed again due to mem::forget
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
		// Prevent Drop from running (which would shut down the channel)
		::std::mem::forget(self);
	}

	/// Sends a response to the FIDL transaction.
	///
	/// Sets the channel to shutdown if an error occurs.
	pub fn send(self,mut result: i64,) -> Result<(), fidl::Error> {
		let r = self.send_raw(result,);
		if r.is_err() {
			self.control_handle.shutdown();
		}
		self.drop_without_shutdown();
		r
	}

	/// Similar to "send" but does not shutdown the channel if
	/// an error occurs.
	pub fn send_no_shutdown_on_err(self,mut result: i64,) -> Result<(), fidl::Error> {
		let r = self.send_raw(result,);
		self.drop_without_shutdown();
		r
	}

	fn send_raw(&self,mut result: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id: self.tx_id,
			flags: 0,
			ordinal: self.ordinal,
		};

		let mut response = (result);

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		let (bytes, handles) = (&mut vec![], &mut vec![]);
		fidl::encoding::Encoder::encode(bytes, handles, &mut msg)?;
		self.control_handle.inner.channel().write(&*bytes, &mut *handles)
			.map_err(fidl::Error::ServerResponseWrite)?;
		Ok(())
	}
}

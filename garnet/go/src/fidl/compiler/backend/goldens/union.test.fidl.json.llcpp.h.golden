// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/txn_header.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/connect_service.h>
#include <lib/fidl/llcpp/service_handler_interface.h>
#include <lib/fidl/llcpp/string_view.h>
#include <lib/fidl/llcpp/sync_call.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/fidl/llcpp/vector_view.h>
#include <lib/fit/function.h>
#include <zircon/fidl.h>

namespace llcpp {

namespace test {
namespace name {

struct Union;
struct ReverseOrdinalUnion;
struct NullableUnionStruct;
struct FieldCollision;
struct ExplicitUnion;

extern "C" const fidl_type_t v1_test_name_UnionTable;

struct Union {
  Union() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kPrimitive = 1,  // 0x1
    kStringNeedsConstructor = 2,  // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_Primitive() const { return ordinal() == Ordinal::kPrimitive; }

  static Union WithPrimitive(int32_t* val) {
    Union result;
    result.set_Primitive(val);
    return result;
  }

  void set_Primitive(int32_t* elem) {
    ordinal_ = Ordinal::kPrimitive;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_Primitive() {
    ZX_ASSERT(ordinal() == Ordinal::kPrimitive);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& Primitive() const {
    ZX_ASSERT(ordinal() == Ordinal::kPrimitive);
    return *static_cast<int32_t*>(envelope_.data);
  }

  bool is_StringNeedsConstructor() const { return ordinal() == Ordinal::kStringNeedsConstructor; }

  static Union WithStringNeedsConstructor(::fidl::StringView* val) {
    Union result;
    result.set_StringNeedsConstructor(val);
    return result;
  }

  void set_StringNeedsConstructor(::fidl::StringView* elem) {
    ordinal_ = Ordinal::kStringNeedsConstructor;
    envelope_.data = static_cast<void*>(elem);
  }

  ::fidl::StringView& mutable_StringNeedsConstructor() {
    ZX_ASSERT(ordinal() == Ordinal::kStringNeedsConstructor);
    return *static_cast<::fidl::StringView*>(envelope_.data);
  }
  const ::fidl::StringView& StringNeedsConstructor() const {
    ZX_ASSERT(ordinal() == Ordinal::kStringNeedsConstructor);
    return *static_cast<::fidl::StringView*>(envelope_.data);
  }

  bool is_VectorStringAlsoNeedsConstructor() const { return ordinal() == Ordinal::kVectorStringAlsoNeedsConstructor; }

  static Union WithVectorStringAlsoNeedsConstructor(::fidl::VectorView<::fidl::StringView>* val) {
    Union result;
    result.set_VectorStringAlsoNeedsConstructor(val);
    return result;
  }

  void set_VectorStringAlsoNeedsConstructor(::fidl::VectorView<::fidl::StringView>* elem) {
    ordinal_ = Ordinal::kVectorStringAlsoNeedsConstructor;
    envelope_.data = static_cast<void*>(elem);
  }

  ::fidl::VectorView<::fidl::StringView>& mutable_VectorStringAlsoNeedsConstructor() {
    ZX_ASSERT(ordinal() == Ordinal::kVectorStringAlsoNeedsConstructor);
    return *static_cast<::fidl::VectorView<::fidl::StringView>*>(envelope_.data);
  }
  const ::fidl::VectorView<::fidl::StringView>& VectorStringAlsoNeedsConstructor() const {
    ZX_ASSERT(ordinal() == Ordinal::kVectorStringAlsoNeedsConstructor);
    return *static_cast<::fidl::VectorView<::fidl::StringView>*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_test_name_UnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPrimitive = 1,  // 0x1
    kStringNeedsConstructor = 2,  // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_test_name_ReverseOrdinalUnionTable;

struct ReverseOrdinalUnion {
  ReverseOrdinalUnion() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kFirst = 1,  // 0x1
    kSecond = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_first() const { return ordinal() == Ordinal::kFirst; }

  static ReverseOrdinalUnion WithFirst(uint32_t* val) {
    ReverseOrdinalUnion result;
    result.set_first(val);
    return result;
  }

  void set_first(uint32_t* elem) {
    ordinal_ = Ordinal::kFirst;
    envelope_.data = static_cast<void*>(elem);
  }

  uint32_t& mutable_first() {
    ZX_ASSERT(ordinal() == Ordinal::kFirst);
    return *static_cast<uint32_t*>(envelope_.data);
  }
  const uint32_t& first() const {
    ZX_ASSERT(ordinal() == Ordinal::kFirst);
    return *static_cast<uint32_t*>(envelope_.data);
  }

  bool is_second() const { return ordinal() == Ordinal::kSecond; }

  static ReverseOrdinalUnion WithSecond(uint32_t* val) {
    ReverseOrdinalUnion result;
    result.set_second(val);
    return result;
  }

  void set_second(uint32_t* elem) {
    ordinal_ = Ordinal::kSecond;
    envelope_.data = static_cast<void*>(elem);
  }

  uint32_t& mutable_second() {
    ZX_ASSERT(ordinal() == Ordinal::kSecond);
    return *static_cast<uint32_t*>(envelope_.data);
  }
  const uint32_t& second() const {
    ZX_ASSERT(ordinal() == Ordinal::kSecond);
    return *static_cast<uint32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_test_name_ReverseOrdinalUnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kFirst = 1,  // 0x1
    kSecond = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_test_name_FieldCollisionTable;

struct FieldCollision {
  FieldCollision() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kFieldCollisionTag = 1,  // 0x1
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_field_collision_tag() const { return ordinal() == Ordinal::kFieldCollisionTag; }

  static FieldCollision WithFieldCollisionTag(int32_t* val) {
    FieldCollision result;
    result.set_field_collision_tag(val);
    return result;
  }

  void set_field_collision_tag(int32_t* elem) {
    ordinal_ = Ordinal::kFieldCollisionTag;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_field_collision_tag() {
    ZX_ASSERT(ordinal() == Ordinal::kFieldCollisionTag);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& field_collision_tag() const {
    ZX_ASSERT(ordinal() == Ordinal::kFieldCollisionTag);
    return *static_cast<int32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_test_name_FieldCollisionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kFieldCollisionTag = 1,  // 0x1
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_test_name_ExplicitUnionTable;

struct ExplicitUnion {
  ExplicitUnion() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kPrimitive = 1,  // 0x1
    kStringNeedsConstructor = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_Primitive() const { return ordinal() == Ordinal::kPrimitive; }

  static ExplicitUnion WithPrimitive(int32_t* val) {
    ExplicitUnion result;
    result.set_Primitive(val);
    return result;
  }

  void set_Primitive(int32_t* elem) {
    ordinal_ = Ordinal::kPrimitive;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_Primitive() {
    ZX_ASSERT(ordinal() == Ordinal::kPrimitive);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& Primitive() const {
    ZX_ASSERT(ordinal() == Ordinal::kPrimitive);
    return *static_cast<int32_t*>(envelope_.data);
  }

  bool is_StringNeedsConstructor() const { return ordinal() == Ordinal::kStringNeedsConstructor; }

  static ExplicitUnion WithStringNeedsConstructor(::fidl::StringView* val) {
    ExplicitUnion result;
    result.set_StringNeedsConstructor(val);
    return result;
  }

  void set_StringNeedsConstructor(::fidl::StringView* elem) {
    ordinal_ = Ordinal::kStringNeedsConstructor;
    envelope_.data = static_cast<void*>(elem);
  }

  ::fidl::StringView& mutable_StringNeedsConstructor() {
    ZX_ASSERT(ordinal() == Ordinal::kStringNeedsConstructor);
    return *static_cast<::fidl::StringView*>(envelope_.data);
  }
  const ::fidl::StringView& StringNeedsConstructor() const {
    ZX_ASSERT(ordinal() == Ordinal::kStringNeedsConstructor);
    return *static_cast<::fidl::StringView*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_test_name_ExplicitUnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPrimitive = 1,  // 0x1
    kStringNeedsConstructor = 3,  // 0x3
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_test_name_NullableUnionStructTable;

struct NullableUnionStruct {
  static constexpr const fidl_type_t* Type = &v1_test_name_NullableUnionStructTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

  ::llcpp::test::name::Union the_union = {};
};

}  // namespace name
}  // namespace test
}  // namespace llcpp

namespace fidl {

template <>
struct IsFidlType<::llcpp::test::name::Union> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::test::name::Union>);

template <>
struct IsFidlType<::llcpp::test::name::ReverseOrdinalUnion> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::test::name::ReverseOrdinalUnion>);

template <>
struct IsFidlType<::llcpp::test::name::NullableUnionStruct> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::test::name::NullableUnionStruct>);
static_assert(offsetof(::llcpp::test::name::NullableUnionStruct, the_union) == 0);
static_assert(sizeof(::llcpp::test::name::NullableUnionStruct) == ::llcpp::test::name::NullableUnionStruct::PrimarySize);

template <>
struct IsFidlType<::llcpp::test::name::FieldCollision> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::test::name::FieldCollision>);

template <>
struct IsFidlType<::llcpp::test::name::ExplicitUnion> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::test::name::ExplicitUnion>);

}  // namespace fidl

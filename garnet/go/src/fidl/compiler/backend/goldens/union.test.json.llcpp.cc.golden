// WARNING: This file is machine generated by fidlgen.

#include <union.test.json.llcpp.h>
#include <memory>

namespace llcpp {

namespace fidl {
namespace test {
namespace json {

void ::llcpp::fidl::test::json::Union::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(Union) == sizeof(fidl_xunion_t));
  static_assert(offsetof(Union, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(Union, envelope_) == offsetof(fidl_xunion_t, envelope));
}

void ::llcpp::fidl::test::json::StrictUnion::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(StrictUnion) == sizeof(fidl_xunion_t));
  static_assert(offsetof(StrictUnion, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(StrictUnion, envelope_) == offsetof(fidl_xunion_t, envelope));
}

void ::llcpp::fidl::test::json::ReverseOrdinalUnion::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(ReverseOrdinalUnion) == sizeof(fidl_xunion_t));
  static_assert(offsetof(ReverseOrdinalUnion, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(ReverseOrdinalUnion, envelope_) == offsetof(fidl_xunion_t, envelope));
}

void ::llcpp::fidl::test::json::StrictPizzaOrPasta::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(StrictPizzaOrPasta) == sizeof(fidl_xunion_t));
  static_assert(offsetof(StrictPizzaOrPasta, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(StrictPizzaOrPasta, envelope_) == offsetof(fidl_xunion_t, envelope));
}

void ::llcpp::fidl::test::json::PizzaOrPasta::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(PizzaOrPasta) == sizeof(fidl_xunion_t));
  static_assert(offsetof(PizzaOrPasta, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(PizzaOrPasta, envelope_) == offsetof(fidl_xunion_t, envelope));
}
auto ::llcpp::fidl::test::json::FlexiblePizzaOrPasta::which() const -> Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case Ordinal::kPizza:
  case Ordinal::kPasta:
    return static_cast<Tag>(ordinal_);
  default:
    return Tag::kUnknown;
  }
}

void ::llcpp::fidl::test::json::FlexiblePizzaOrPasta::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(FlexiblePizzaOrPasta) == sizeof(fidl_xunion_t));
  static_assert(offsetof(FlexiblePizzaOrPasta, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(FlexiblePizzaOrPasta, envelope_) == offsetof(fidl_xunion_t, envelope));
}

void ::llcpp::fidl::test::json::ExplicitPizzaOrPasta::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(ExplicitPizzaOrPasta) == sizeof(fidl_xunion_t));
  static_assert(offsetof(ExplicitPizzaOrPasta, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(ExplicitPizzaOrPasta, envelope_) == offsetof(fidl_xunion_t, envelope));
}
auto ::llcpp::fidl::test::json::FlexibleUnion::which() const -> Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case Ordinal::kPrimitive:
  case Ordinal::kStringNeedsConstructor:
  case Ordinal::kVectorStringAlsoNeedsConstructor:
    return static_cast<Tag>(ordinal_);
  default:
    return Tag::kUnknown;
  }
}

void ::llcpp::fidl::test::json::FlexibleUnion::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(FlexibleUnion) == sizeof(fidl_xunion_t));
  static_assert(offsetof(FlexibleUnion, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(FlexibleUnion, envelope_) == offsetof(fidl_xunion_t, envelope));
}

void ::llcpp::fidl::test::json::FieldCollision::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(FieldCollision) == sizeof(fidl_xunion_t));
  static_assert(offsetof(FieldCollision, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(FieldCollision, envelope_) == offsetof(fidl_xunion_t, envelope));
}

void ::llcpp::fidl::test::json::ExplicitUnion::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(ExplicitUnion) == sizeof(fidl_xunion_t));
  static_assert(offsetof(ExplicitUnion, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(ExplicitUnion, envelope_) == offsetof(fidl_xunion_t, envelope));
}

}  // namespace json
}  // namespace test
}  // namespace fidl
}  // namespace llcpp

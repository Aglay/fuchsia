// WARNING: This file is machine generated by fidlgen.

#include <protocols.fidl.json.h>

#include "lib/fidl/cpp/internal/implementation.h"
namespace test {
namespace name {

namespace {
  
constexpr uint32_t kKitchenSink_MethodA_Ordinal = 450577456u;
extern "C" const fidl_type_t test_name_KitchenSinkMethodARequestTable;
  
constexpr uint32_t kKitchenSink_EventA_Ordinal = 1795426833u;
extern "C" const fidl_type_t test_name_KitchenSinkEventAEventTable;
  
constexpr uint32_t kKitchenSink_MethodB_Ordinal = 1999489700u;
extern "C" const fidl_type_t test_name_KitchenSinkMethodBRequestTable;
extern "C" const fidl_type_t test_name_KitchenSinkMethodBResponseTable;

}  // namespace

KitchenSink::~KitchenSink() = default;

KitchenSink_EventSender::~KitchenSink_EventSender() = default;

KitchenSink_Sync::~KitchenSink_Sync() = default;

KitchenSink_Proxy::KitchenSink_Proxy(::fidl::internal::ProxyController* controller)
    : controller_(controller) {
  (void)controller_;
}

KitchenSink_Proxy::~KitchenSink_Proxy() = default;

zx_status_t KitchenSink_Proxy::Dispatch_(::fidl::Message message) {
  zx_status_t status = ZX_OK;
  switch (message.ordinal()) {
    case kKitchenSink_EventA_Ordinal: {
      if (!EventA) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_KitchenSinkEventAEventTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_KitchenSinkEventAEventTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
      auto arg1 = ::fidl::DecodeAs<int64_t>(&decoder, 24);
      EventA(std::move(arg0), std::move(arg1));
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}


void KitchenSink_Proxy::MethodA(int64_t a, int64_t b) {
  ::fidl::Encoder _encoder(kKitchenSink_MethodA_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  controller_->Send(&test_name_KitchenSinkMethodARequestTable, _encoder.GetMessage(), nullptr);
}
namespace {

class KitchenSink_MethodB_ResponseHandler : public ::fidl::internal::MessageHandler {
 public:
  KitchenSink_MethodB_ResponseHandler(KitchenSink::MethodBCallback callback)
      : callback_(std::move(callback)) {
    ZX_DEBUG_ASSERT_MSG(callback_,
                        "Callback must not be empty for KitchenSink::MethodB\n");
  }

  zx_status_t OnMessage(::fidl::Message message) override {
    const char* error_msg = nullptr;
    zx_status_t status = message.Decode(&test_name_KitchenSinkMethodBResponseTable, &error_msg);
    if (status != ZX_OK) {
      FIDL_REPORT_DECODING_ERROR(message, &test_name_KitchenSinkMethodBResponseTable, error_msg);
      return status;
    }
    ::fidl::Decoder decoder(std::move(message));
    auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
    callback_(std::move(arg0));
    return ZX_OK;
  }

 private:
  KitchenSink::MethodBCallback callback_;

  KitchenSink_MethodB_ResponseHandler(const KitchenSink_MethodB_ResponseHandler&) = delete;
  KitchenSink_MethodB_ResponseHandler& operator=(const KitchenSink_MethodB_ResponseHandler&) = delete;
};

}  // namespace
void KitchenSink_Proxy::MethodB(int64_t a, int64_t b, MethodBCallback callback) {
  ::fidl::Encoder _encoder(kKitchenSink_MethodB_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  controller_->Send(&test_name_KitchenSinkMethodBRequestTable, _encoder.GetMessage(), std::make_unique<KitchenSink_MethodB_ResponseHandler>(std::move(callback)));
}

KitchenSink_Stub::KitchenSink_Stub(KitchenSink_clazz* impl) : impl_(impl) {
  (void)impl_;
}

KitchenSink_Stub::~KitchenSink_Stub() = default;

namespace {

class KitchenSink_MethodB_Responder {
 public:
  KitchenSink_MethodB_Responder(::fidl::internal::PendingResponse response, uint32_t ordinal)
      : response_(std::move(response)), ordinal_(ordinal) {}

  void operator()(int64_t result) {
    ::fidl::Encoder _encoder(ordinal_);
    _encoder.Alloc(24 - sizeof(fidl_message_header_t));
    ::fidl::Encode(&_encoder, &result, 16);
    response_.Send(&test_name_KitchenSinkMethodBResponseTable, _encoder.GetMessage());
  }

 private:
  ::fidl::internal::PendingResponse response_;
  uint32_t ordinal_;
};

}  // namespace

zx_status_t KitchenSink_Stub::Dispatch_(
    ::fidl::Message message,
    ::fidl::internal::PendingResponse response) {
  zx_status_t status = ZX_OK;
  uint32_t ordinal = message.ordinal();
  switch (ordinal) {
    case kKitchenSink_MethodA_Ordinal: {
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_KitchenSinkMethodARequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_KitchenSinkMethodARequestTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
      auto arg1 = ::fidl::DecodeAs<int64_t>(&decoder, 24);
      impl_->MethodA(std::move(arg0), std::move(arg1));
      break;
    }
    case kKitchenSink_MethodB_Ordinal: {
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_KitchenSinkMethodBRequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_KitchenSinkMethodBRequestTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
      auto arg1 = ::fidl::DecodeAs<int64_t>(&decoder, 24);
      impl_->MethodB(std::move(arg0), std::move(arg1), KitchenSink_MethodB_Responder(std::move(response), ordinal));
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}
void KitchenSink_Stub::EventA(int64_t a, int64_t b) {
  ::fidl::Encoder _encoder(kKitchenSink_EventA_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  controller()->Send(&test_name_KitchenSinkEventAEventTable, _encoder.GetMessage());
}

KitchenSink_SyncProxy::KitchenSink_SyncProxy(::zx::channel channel)
    : proxy_(::std::move(channel)) {}

KitchenSink_SyncProxy::~KitchenSink_SyncProxy() = default;
zx_status_t KitchenSink_SyncProxy::MethodA(int64_t a, int64_t b) {
  ::fidl::Encoder _encoder(kKitchenSink_MethodA_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  return proxy_.Send(&test_name_KitchenSinkMethodARequestTable, _encoder.GetMessage());
}
zx_status_t KitchenSink_SyncProxy::MethodB(int64_t a, int64_t b, int64_t* out_result) {
  ::fidl::Encoder _encoder(kKitchenSink_MethodB_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  ::fidl::MessageBuffer buffer_;
  ::fidl::Message response_ = buffer_.CreateEmptyMessage();
  zx_status_t status_ = proxy_.Call(&test_name_KitchenSinkMethodBRequestTable, &test_name_KitchenSinkMethodBResponseTable, _encoder.GetMessage(), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_result = ::fidl::DecodeAs<int64_t>(&decoder_, 16);
  return ZX_OK;
}


namespace {


constexpr uint32_t kKitchenSink_MethodA_Ordinal = 450577456u;
extern "C" const fidl_type_t test_name_KitchenSinkMethodARequestTable;
constexpr uint32_t kKitchenSink_EventA_Ordinal = 1795426833u;
extern "C" const fidl_type_t test_name_KitchenSinkEventAEventTable;
constexpr uint32_t kKitchenSink_MethodB_Ordinal = 1999489700u;
extern "C" const fidl_type_t test_name_KitchenSinkMethodBRequestTable;
extern "C" const fidl_type_t test_name_KitchenSinkMethodBResponseTable;

}  // namespace

KitchenSink::~KitchenSink() = default;

KitchenSink_Proxy::~KitchenSink_Proxy() = default;

zx_status_t KitchenSink_Proxy::Dispatch_(::fidl::Message* message) {
  zx_status_t status = ZX_OK;
  switch (message->ordinal()) {
    case kKitchenSink_EventA_Ordinal: {
      const char* error_msg = nullptr;
      status = message->Decode(&test_name_KitchenSinkEventAEventTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(*message, &test_name_KitchenSinkEventAEventTable, error_msg);
        ZX_ASSERT(status != ZX_ERR_NOT_SUPPORTED);
        break;
      }
      ::fidl::Decoder decoder(std::move(*message));
      auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
      auto arg1 = ::fidl::DecodeAs<int64_t>(&decoder, 24);
      EventA(std::move(arg0), std::move(arg1));
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}


void KitchenSink_Proxy::MethodA(int64_t a, int64_t b) {
  ::fidl::Encoder _encoder(kKitchenSink_MethodA_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  Send_(_encoder.GetMessage());
}
void KitchenSink_Proxy::MethodB(int64_t a, int64_t b, MethodBCallback callback) {
  ::fidl::Encoder _encoder(kKitchenSink_MethodB_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  Send_(_encoder.GetMessage(), [callback=std::move(callback)](::fidl::Message message) {
    const char* error_msg = nullptr;
    zx_status_t status = message.Decode(&test_name_KitchenSinkMethodBResponseTable, &error_msg);
    if (status != ZX_OK) {
      FIDL_REPORT_DECODING_ERROR(message, &test_name_KitchenSinkMethodBResponseTable, error_msg);
      return status;
    }
    ::fidl::Decoder decoder(std::move(message));
    auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
    callback(std::move(arg0));
    return ZX_OK;
  });
}

KitchenSink_Stub::~KitchenSink_Stub() = default;

zx_status_t KitchenSink_Stub::Dispatch_(::fidl::Message* message) {
  zx_status_t status = ZX_OK;
  switch (message->ordinal()) {
    case kKitchenSink_MethodA_Ordinal: {
      const char* error_msg = nullptr;
      status = message->Decode(&test_name_KitchenSinkMethodARequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(*message, &test_name_KitchenSinkMethodARequestTable, error_msg);
        ZX_ASSERT(status != ZX_ERR_NOT_SUPPORTED);
        break;
      }
      ::fidl::Decoder decoder(std::move(*message));
      auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
      auto arg1 = ::fidl::DecodeAs<int64_t>(&decoder, 24);
      MethodA(std::move(arg0), std::move(arg1));
      break;
    }
    case kKitchenSink_MethodB_Ordinal: {
      const char* error_msg = nullptr;
      status = message->Decode(&test_name_KitchenSinkMethodBRequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(*message, &test_name_KitchenSinkMethodBRequestTable, error_msg);
        ZX_ASSERT(status != ZX_ERR_NOT_SUPPORTED);
        break;
      }
      ::fidl::Decoder decoder(std::move(*message));
      auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
      auto arg1 = ::fidl::DecodeAs<int64_t>(&decoder, 24);
      MethodB(std::move(arg0), std::move(arg1), [this](int64_t result) {
            ::fidl::Encoder _encoder(kKitchenSink_MethodB_Ordinal);
            _encoder.Alloc(24 - sizeof(fidl_message_header_t));
            ::fidl::Encode(&_encoder, &result, 16);
            Send_(_encoder.GetMessage());
          });
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}
void KitchenSink_Stub::EventA(int64_t a, int64_t b) {
  ::fidl::Encoder _encoder(kKitchenSink_EventA_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  Send_(_encoder.GetMessage());
}


namespace {
  
constexpr uint32_t kKitchenSink_MethodA_Ordinal = 450577456u;
extern "C" const fidl_type_t test_name_KitchenSinkMethodARequestTable;
  
constexpr uint32_t kKitchenSink_EventA_Ordinal = 1795426833u;
extern "C" const fidl_type_t test_name_KitchenSinkEventAEventTable;
  
constexpr uint32_t kKitchenSink_MethodB_Ordinal = 1999489700u;
extern "C" const fidl_type_t test_name_KitchenSinkMethodBRequestTable;
extern "C" const fidl_type_t test_name_KitchenSinkMethodBResponseTable;

}  // namespace

KitchenSink::~KitchenSink() = default;

KitchenSink_EventSender::~KitchenSink_EventSender() = default;

KitchenSink_Sync::~KitchenSink_Sync() = default;

KitchenSink_Proxy::KitchenSink_Proxy(::fidl::internal::ProxyController* controller)
    : controller_(controller) {
  (void)controller_;
}

KitchenSink_Proxy::~KitchenSink_Proxy() = default;

zx_status_t KitchenSink_Proxy::Dispatch_(::fidl::Message message) {
  zx_status_t status = ZX_OK;
  switch (message.ordinal()) {
    case kKitchenSink_EventA_Ordinal: {
      if (!EventA) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_KitchenSinkEventAEventTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_KitchenSinkEventAEventTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
      auto arg1 = ::fidl::DecodeAs<int64_t>(&decoder, 24);
      EventA(std::move(arg0), std::move(arg1));
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}


void KitchenSink_Proxy::MethodA(int64_t a, int64_t b) {
  ::fidl::Encoder _encoder(kKitchenSink_MethodA_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  controller_->Send(&test_name_KitchenSinkMethodARequestTable, _encoder.GetMessage(), nullptr);
}
namespace {

class KitchenSink_MethodB_ResponseHandler : public ::fidl::internal::MessageHandler {
 public:
  KitchenSink_MethodB_ResponseHandler(KitchenSink::MethodBCallback callback)
      : callback_(std::move(callback)) {
    ZX_DEBUG_ASSERT_MSG(callback_,
                        "Callback must not be empty for KitchenSink::MethodB\n");
  }

  zx_status_t OnMessage(::fidl::Message message) override {
    const char* error_msg = nullptr;
    zx_status_t status = message.Decode(&test_name_KitchenSinkMethodBResponseTable, &error_msg);
    if (status != ZX_OK) {
      FIDL_REPORT_DECODING_ERROR(message, &test_name_KitchenSinkMethodBResponseTable, error_msg);
      return status;
    }
    ::fidl::Decoder decoder(std::move(message));
    auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
    callback_(std::move(arg0));
    return ZX_OK;
  }

 private:
  KitchenSink::MethodBCallback callback_;

  KitchenSink_MethodB_ResponseHandler(const KitchenSink_MethodB_ResponseHandler&) = delete;
  KitchenSink_MethodB_ResponseHandler& operator=(const KitchenSink_MethodB_ResponseHandler&) = delete;
};

}  // namespace
void KitchenSink_Proxy::MethodB(int64_t a, int64_t b, MethodBCallback callback) {
  ::fidl::Encoder _encoder(kKitchenSink_MethodB_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  controller_->Send(&test_name_KitchenSinkMethodBRequestTable, _encoder.GetMessage(), std::make_unique<KitchenSink_MethodB_ResponseHandler>(std::move(callback)));
}

KitchenSink_Stub::KitchenSink_Stub(KitchenSink_clazz* impl) : impl_(impl) {
  (void)impl_;
}

KitchenSink_Stub::~KitchenSink_Stub() = default;

namespace {

class KitchenSink_MethodB_Responder {
 public:
  KitchenSink_MethodB_Responder(::fidl::internal::PendingResponse response, uint32_t ordinal)
      : response_(std::move(response)), ordinal_(ordinal) {}

  void operator()(int64_t result) {
    ::fidl::Encoder _encoder(ordinal_);
    _encoder.Alloc(24 - sizeof(fidl_message_header_t));
    ::fidl::Encode(&_encoder, &result, 16);
    response_.Send(&test_name_KitchenSinkMethodBResponseTable, _encoder.GetMessage());
  }

 private:
  ::fidl::internal::PendingResponse response_;
  uint32_t ordinal_;
};

}  // namespace

zx_status_t KitchenSink_Stub::Dispatch_(
    ::fidl::Message message,
    ::fidl::internal::PendingResponse response) {
  zx_status_t status = ZX_OK;
  uint32_t ordinal = message.ordinal();
  switch (ordinal) {
    case kKitchenSink_MethodA_Ordinal: {
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_KitchenSinkMethodARequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_KitchenSinkMethodARequestTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
      auto arg1 = ::fidl::DecodeAs<int64_t>(&decoder, 24);
      impl_->MethodA(std::move(arg0), std::move(arg1));
      break;
    }
    case kKitchenSink_MethodB_Ordinal: {
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_KitchenSinkMethodBRequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_KitchenSinkMethodBRequestTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
      auto arg1 = ::fidl::DecodeAs<int64_t>(&decoder, 24);
      impl_->MethodB(std::move(arg0), std::move(arg1), KitchenSink_MethodB_Responder(std::move(response), ordinal));
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}
void KitchenSink_Stub::EventA(int64_t a, int64_t b) {
  ::fidl::Encoder _encoder(kKitchenSink_EventA_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  controller()->Send(&test_name_KitchenSinkEventAEventTable, _encoder.GetMessage());
}

KitchenSink_SyncProxy::KitchenSink_SyncProxy(::zx::channel channel)
    : proxy_(::std::move(channel)) {}

KitchenSink_SyncProxy::~KitchenSink_SyncProxy() = default;
zx_status_t KitchenSink_SyncProxy::MethodA(int64_t a, int64_t b) {
  ::fidl::Encoder _encoder(kKitchenSink_MethodA_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  return proxy_.Send(&test_name_KitchenSinkMethodARequestTable, _encoder.GetMessage());
}
zx_status_t KitchenSink_SyncProxy::MethodB(int64_t a, int64_t b, int64_t* out_result) {
  ::fidl::Encoder _encoder(kKitchenSink_MethodB_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  ::fidl::MessageBuffer buffer_;
  ::fidl::Message response_ = buffer_.CreateEmptyMessage();
  zx_status_t status_ = proxy_.Call(&test_name_KitchenSinkMethodBRequestTable, &test_name_KitchenSinkMethodBResponseTable, _encoder.GetMessage(), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_result = ::fidl::DecodeAs<int64_t>(&decoder_, 16);
  return ZX_OK;
}


namespace {
  
constexpr uint32_t kChannelProtocol_MethodA_Ordinal = 1432785874u;
extern "C" const fidl_type_t test_name_ChannelProtocolMethodARequestTable;
  
constexpr uint32_t kChannelProtocol_EventA_Ordinal = 477676034u;
extern "C" const fidl_type_t test_name_ChannelProtocolEventAEventTable;
  
constexpr uint32_t kChannelProtocol_MethodB_Ordinal = 180770075u;
extern "C" const fidl_type_t test_name_ChannelProtocolMethodBRequestTable;
extern "C" const fidl_type_t test_name_ChannelProtocolMethodBResponseTable;

}  // namespace

ChannelProtocol::~ChannelProtocol() = default;

ChannelProtocol_EventSender::~ChannelProtocol_EventSender() = default;

ChannelProtocol_Sync::~ChannelProtocol_Sync() = default;

ChannelProtocol_Proxy::ChannelProtocol_Proxy(::fidl::internal::ProxyController* controller)
    : controller_(controller) {
  (void)controller_;
}

ChannelProtocol_Proxy::~ChannelProtocol_Proxy() = default;

zx_status_t ChannelProtocol_Proxy::Dispatch_(::fidl::Message message) {
  zx_status_t status = ZX_OK;
  switch (message.ordinal()) {
    case kChannelProtocol_EventA_Ordinal: {
      if (!EventA) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_ChannelProtocolEventAEventTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_ChannelProtocolEventAEventTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
      auto arg1 = ::fidl::DecodeAs<int64_t>(&decoder, 24);
      EventA(std::move(arg0), std::move(arg1));
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}


void ChannelProtocol_Proxy::MethodA(int64_t a, int64_t b) {
  ::fidl::Encoder _encoder(kChannelProtocol_MethodA_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  controller_->Send(&test_name_ChannelProtocolMethodARequestTable, _encoder.GetMessage(), nullptr);
}
namespace {

class ChannelProtocol_MethodB_ResponseHandler : public ::fidl::internal::MessageHandler {
 public:
  ChannelProtocol_MethodB_ResponseHandler(ChannelProtocol::MethodBCallback callback)
      : callback_(std::move(callback)) {
    ZX_DEBUG_ASSERT_MSG(callback_,
                        "Callback must not be empty for ChannelProtocol::MethodB\n");
  }

  zx_status_t OnMessage(::fidl::Message message) override {
    const char* error_msg = nullptr;
    zx_status_t status = message.Decode(&test_name_ChannelProtocolMethodBResponseTable, &error_msg);
    if (status != ZX_OK) {
      FIDL_REPORT_DECODING_ERROR(message, &test_name_ChannelProtocolMethodBResponseTable, error_msg);
      return status;
    }
    ::fidl::Decoder decoder(std::move(message));
    auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
    callback_(std::move(arg0));
    return ZX_OK;
  }

 private:
  ChannelProtocol::MethodBCallback callback_;

  ChannelProtocol_MethodB_ResponseHandler(const ChannelProtocol_MethodB_ResponseHandler&) = delete;
  ChannelProtocol_MethodB_ResponseHandler& operator=(const ChannelProtocol_MethodB_ResponseHandler&) = delete;
};

}  // namespace
void ChannelProtocol_Proxy::MethodB(int64_t a, int64_t b, MethodBCallback callback) {
  ::fidl::Encoder _encoder(kChannelProtocol_MethodB_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  controller_->Send(&test_name_ChannelProtocolMethodBRequestTable, _encoder.GetMessage(), std::make_unique<ChannelProtocol_MethodB_ResponseHandler>(std::move(callback)));
}

ChannelProtocol_Stub::ChannelProtocol_Stub(ChannelProtocol_clazz* impl) : impl_(impl) {
  (void)impl_;
}

ChannelProtocol_Stub::~ChannelProtocol_Stub() = default;

namespace {

class ChannelProtocol_MethodB_Responder {
 public:
  ChannelProtocol_MethodB_Responder(::fidl::internal::PendingResponse response, uint32_t ordinal)
      : response_(std::move(response)), ordinal_(ordinal) {}

  void operator()(int64_t result) {
    ::fidl::Encoder _encoder(ordinal_);
    _encoder.Alloc(24 - sizeof(fidl_message_header_t));
    ::fidl::Encode(&_encoder, &result, 16);
    response_.Send(&test_name_ChannelProtocolMethodBResponseTable, _encoder.GetMessage());
  }

 private:
  ::fidl::internal::PendingResponse response_;
  uint32_t ordinal_;
};

}  // namespace

zx_status_t ChannelProtocol_Stub::Dispatch_(
    ::fidl::Message message,
    ::fidl::internal::PendingResponse response) {
  zx_status_t status = ZX_OK;
  uint32_t ordinal = message.ordinal();
  switch (ordinal) {
    case kChannelProtocol_MethodA_Ordinal: {
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_ChannelProtocolMethodARequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_ChannelProtocolMethodARequestTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
      auto arg1 = ::fidl::DecodeAs<int64_t>(&decoder, 24);
      impl_->MethodA(std::move(arg0), std::move(arg1));
      break;
    }
    case kChannelProtocol_MethodB_Ordinal: {
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_ChannelProtocolMethodBRequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_ChannelProtocolMethodBRequestTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
      auto arg1 = ::fidl::DecodeAs<int64_t>(&decoder, 24);
      impl_->MethodB(std::move(arg0), std::move(arg1), ChannelProtocol_MethodB_Responder(std::move(response), ordinal));
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}
void ChannelProtocol_Stub::EventA(int64_t a, int64_t b) {
  ::fidl::Encoder _encoder(kChannelProtocol_EventA_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  controller()->Send(&test_name_ChannelProtocolEventAEventTable, _encoder.GetMessage());
}

ChannelProtocol_SyncProxy::ChannelProtocol_SyncProxy(::zx::channel channel)
    : proxy_(::std::move(channel)) {}

ChannelProtocol_SyncProxy::~ChannelProtocol_SyncProxy() = default;
zx_status_t ChannelProtocol_SyncProxy::MethodA(int64_t a, int64_t b) {
  ::fidl::Encoder _encoder(kChannelProtocol_MethodA_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  return proxy_.Send(&test_name_ChannelProtocolMethodARequestTable, _encoder.GetMessage());
}
zx_status_t ChannelProtocol_SyncProxy::MethodB(int64_t a, int64_t b, int64_t* out_result) {
  ::fidl::Encoder _encoder(kChannelProtocol_MethodB_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  ::fidl::MessageBuffer buffer_;
  ::fidl::Message response_ = buffer_.CreateEmptyMessage();
  zx_status_t status_ = proxy_.Call(&test_name_ChannelProtocolMethodBRequestTable, &test_name_ChannelProtocolMethodBResponseTable, _encoder.GetMessage(), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_result = ::fidl::DecodeAs<int64_t>(&decoder_, 16);
  return ZX_OK;
}


namespace {
  
constexpr uint32_t kSocketControlProtocol_MethodA_Ordinal = 1007842318u;
extern "C" const fidl_type_t test_name_SocketControlProtocolMethodARequestTable;
  
constexpr uint32_t kSocketControlProtocol_EventA_Ordinal = 955483393u;
extern "C" const fidl_type_t test_name_SocketControlProtocolEventAEventTable;
  
constexpr uint32_t kSocketControlProtocol_MethodB_Ordinal = 677342235u;
extern "C" const fidl_type_t test_name_SocketControlProtocolMethodBRequestTable;
extern "C" const fidl_type_t test_name_SocketControlProtocolMethodBResponseTable;

}  // namespace

SocketControlProtocol::~SocketControlProtocol() = default;

SocketControlProtocol_EventSender::~SocketControlProtocol_EventSender() = default;

SocketControlProtocol_Sync::~SocketControlProtocol_Sync() = default;

SocketControlProtocol_Proxy::SocketControlProtocol_Proxy(::fidl::internal::ProxyController* controller)
    : controller_(controller) {
  (void)controller_;
}

SocketControlProtocol_Proxy::~SocketControlProtocol_Proxy() = default;

zx_status_t SocketControlProtocol_Proxy::Dispatch_(::fidl::Message message) {
  zx_status_t status = ZX_OK;
  switch (message.ordinal()) {
    case kSocketControlProtocol_EventA_Ordinal: {
      if (!EventA) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_SocketControlProtocolEventAEventTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_SocketControlProtocolEventAEventTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
      auto arg1 = ::fidl::DecodeAs<int64_t>(&decoder, 24);
      EventA(std::move(arg0), std::move(arg1));
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}


void SocketControlProtocol_Proxy::MethodA(int64_t a, int64_t b) {
  ::fidl::Encoder _encoder(kSocketControlProtocol_MethodA_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  controller_->Send(&test_name_SocketControlProtocolMethodARequestTable, _encoder.GetMessage(), nullptr);
}
namespace {

class SocketControlProtocol_MethodB_ResponseHandler : public ::fidl::internal::MessageHandler {
 public:
  SocketControlProtocol_MethodB_ResponseHandler(SocketControlProtocol::MethodBCallback callback)
      : callback_(std::move(callback)) {
    ZX_DEBUG_ASSERT_MSG(callback_,
                        "Callback must not be empty for SocketControlProtocol::MethodB\n");
  }

  zx_status_t OnMessage(::fidl::Message message) override {
    const char* error_msg = nullptr;
    zx_status_t status = message.Decode(&test_name_SocketControlProtocolMethodBResponseTable, &error_msg);
    if (status != ZX_OK) {
      FIDL_REPORT_DECODING_ERROR(message, &test_name_SocketControlProtocolMethodBResponseTable, error_msg);
      return status;
    }
    ::fidl::Decoder decoder(std::move(message));
    auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
    callback_(std::move(arg0));
    return ZX_OK;
  }

 private:
  SocketControlProtocol::MethodBCallback callback_;

  SocketControlProtocol_MethodB_ResponseHandler(const SocketControlProtocol_MethodB_ResponseHandler&) = delete;
  SocketControlProtocol_MethodB_ResponseHandler& operator=(const SocketControlProtocol_MethodB_ResponseHandler&) = delete;
};

}  // namespace
void SocketControlProtocol_Proxy::MethodB(int64_t a, int64_t b, MethodBCallback callback) {
  ::fidl::Encoder _encoder(kSocketControlProtocol_MethodB_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  controller_->Send(&test_name_SocketControlProtocolMethodBRequestTable, _encoder.GetMessage(), std::make_unique<SocketControlProtocol_MethodB_ResponseHandler>(std::move(callback)));
}

SocketControlProtocol_Stub::SocketControlProtocol_Stub(SocketControlProtocol_clazz* impl) : impl_(impl) {
  (void)impl_;
}

SocketControlProtocol_Stub::~SocketControlProtocol_Stub() = default;

namespace {

class SocketControlProtocol_MethodB_Responder {
 public:
  SocketControlProtocol_MethodB_Responder(::fidl::internal::PendingResponse response, uint32_t ordinal)
      : response_(std::move(response)), ordinal_(ordinal) {}

  void operator()(int64_t result) {
    ::fidl::Encoder _encoder(ordinal_);
    _encoder.Alloc(24 - sizeof(fidl_message_header_t));
    ::fidl::Encode(&_encoder, &result, 16);
    response_.Send(&test_name_SocketControlProtocolMethodBResponseTable, _encoder.GetMessage());
  }

 private:
  ::fidl::internal::PendingResponse response_;
  uint32_t ordinal_;
};

}  // namespace

zx_status_t SocketControlProtocol_Stub::Dispatch_(
    ::fidl::Message message,
    ::fidl::internal::PendingResponse response) {
  zx_status_t status = ZX_OK;
  uint32_t ordinal = message.ordinal();
  switch (ordinal) {
    case kSocketControlProtocol_MethodA_Ordinal: {
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_SocketControlProtocolMethodARequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_SocketControlProtocolMethodARequestTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
      auto arg1 = ::fidl::DecodeAs<int64_t>(&decoder, 24);
      impl_->MethodA(std::move(arg0), std::move(arg1));
      break;
    }
    case kSocketControlProtocol_MethodB_Ordinal: {
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_SocketControlProtocolMethodBRequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_SocketControlProtocolMethodBRequestTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
      auto arg1 = ::fidl::DecodeAs<int64_t>(&decoder, 24);
      impl_->MethodB(std::move(arg0), std::move(arg1), SocketControlProtocol_MethodB_Responder(std::move(response), ordinal));
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}
void SocketControlProtocol_Stub::EventA(int64_t a, int64_t b) {
  ::fidl::Encoder _encoder(kSocketControlProtocol_EventA_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  controller()->Send(&test_name_SocketControlProtocolEventAEventTable, _encoder.GetMessage());
}

SocketControlProtocol_SyncProxy::SocketControlProtocol_SyncProxy(::zx::channel channel)
    : proxy_(::std::move(channel)) {}

SocketControlProtocol_SyncProxy::~SocketControlProtocol_SyncProxy() = default;
zx_status_t SocketControlProtocol_SyncProxy::MethodA(int64_t a, int64_t b) {
  ::fidl::Encoder _encoder(kSocketControlProtocol_MethodA_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  return proxy_.Send(&test_name_SocketControlProtocolMethodARequestTable, _encoder.GetMessage());
}
zx_status_t SocketControlProtocol_SyncProxy::MethodB(int64_t a, int64_t b, int64_t* out_result) {
  ::fidl::Encoder _encoder(kSocketControlProtocol_MethodB_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  ::fidl::MessageBuffer buffer_;
  ::fidl::Message response_ = buffer_.CreateEmptyMessage();
  zx_status_t status_ = proxy_.Call(&test_name_SocketControlProtocolMethodBRequestTable, &test_name_SocketControlProtocolMethodBResponseTable, _encoder.GetMessage(), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_result = ::fidl::DecodeAs<int64_t>(&decoder_, 16);
  return ZX_OK;
}


namespace {


constexpr uint32_t kOvernetStreamProtocol_MethodA_Ordinal = 411580008u;
extern "C" const fidl_type_t test_name_OvernetStreamProtocolMethodARequestTable;
constexpr uint32_t kOvernetStreamProtocol_EventA_Ordinal = 530966225u;
extern "C" const fidl_type_t test_name_OvernetStreamProtocolEventAEventTable;
constexpr uint32_t kOvernetStreamProtocol_MethodB_Ordinal = 1291000979u;
extern "C" const fidl_type_t test_name_OvernetStreamProtocolMethodBRequestTable;
extern "C" const fidl_type_t test_name_OvernetStreamProtocolMethodBResponseTable;

}  // namespace

OvernetStreamProtocol::~OvernetStreamProtocol() = default;

OvernetStreamProtocol_Proxy::~OvernetStreamProtocol_Proxy() = default;

zx_status_t OvernetStreamProtocol_Proxy::Dispatch_(::fidl::Message* message) {
  zx_status_t status = ZX_OK;
  switch (message->ordinal()) {
    case kOvernetStreamProtocol_EventA_Ordinal: {
      const char* error_msg = nullptr;
      status = message->Decode(&test_name_OvernetStreamProtocolEventAEventTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(*message, &test_name_OvernetStreamProtocolEventAEventTable, error_msg);
        ZX_ASSERT(status != ZX_ERR_NOT_SUPPORTED);
        break;
      }
      ::fidl::Decoder decoder(std::move(*message));
      auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
      auto arg1 = ::fidl::DecodeAs<int64_t>(&decoder, 24);
      EventA(std::move(arg0), std::move(arg1));
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}


void OvernetStreamProtocol_Proxy::MethodA(int64_t a, int64_t b) {
  ::fidl::Encoder _encoder(kOvernetStreamProtocol_MethodA_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  Send_(_encoder.GetMessage());
}
void OvernetStreamProtocol_Proxy::MethodB(int64_t a, int64_t b, MethodBCallback callback) {
  ::fidl::Encoder _encoder(kOvernetStreamProtocol_MethodB_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  Send_(_encoder.GetMessage(), [callback=std::move(callback)](::fidl::Message message) {
    const char* error_msg = nullptr;
    zx_status_t status = message.Decode(&test_name_OvernetStreamProtocolMethodBResponseTable, &error_msg);
    if (status != ZX_OK) {
      FIDL_REPORT_DECODING_ERROR(message, &test_name_OvernetStreamProtocolMethodBResponseTable, error_msg);
      return status;
    }
    ::fidl::Decoder decoder(std::move(message));
    auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
    callback(std::move(arg0));
    return ZX_OK;
  });
}

OvernetStreamProtocol_Stub::~OvernetStreamProtocol_Stub() = default;

zx_status_t OvernetStreamProtocol_Stub::Dispatch_(::fidl::Message* message) {
  zx_status_t status = ZX_OK;
  switch (message->ordinal()) {
    case kOvernetStreamProtocol_MethodA_Ordinal: {
      const char* error_msg = nullptr;
      status = message->Decode(&test_name_OvernetStreamProtocolMethodARequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(*message, &test_name_OvernetStreamProtocolMethodARequestTable, error_msg);
        ZX_ASSERT(status != ZX_ERR_NOT_SUPPORTED);
        break;
      }
      ::fidl::Decoder decoder(std::move(*message));
      auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
      auto arg1 = ::fidl::DecodeAs<int64_t>(&decoder, 24);
      MethodA(std::move(arg0), std::move(arg1));
      break;
    }
    case kOvernetStreamProtocol_MethodB_Ordinal: {
      const char* error_msg = nullptr;
      status = message->Decode(&test_name_OvernetStreamProtocolMethodBRequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(*message, &test_name_OvernetStreamProtocolMethodBRequestTable, error_msg);
        ZX_ASSERT(status != ZX_ERR_NOT_SUPPORTED);
        break;
      }
      ::fidl::Decoder decoder(std::move(*message));
      auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
      auto arg1 = ::fidl::DecodeAs<int64_t>(&decoder, 24);
      MethodB(std::move(arg0), std::move(arg1), [this](int64_t result) {
            ::fidl::Encoder _encoder(kOvernetStreamProtocol_MethodB_Ordinal);
            _encoder.Alloc(24 - sizeof(fidl_message_header_t));
            ::fidl::Encode(&_encoder, &result, 16);
            Send_(_encoder.GetMessage());
          });
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}
void OvernetStreamProtocol_Stub::EventA(int64_t a, int64_t b) {
  ::fidl::Encoder _encoder(kOvernetStreamProtocol_EventA_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  Send_(_encoder.GetMessage());
}


}  // namespace name
}  // namespace test

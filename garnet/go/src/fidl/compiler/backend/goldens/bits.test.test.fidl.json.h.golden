// WARNING: This file is machine generated by fidlgen.

#pragma once

#include "lib/fidl/cpp/internal/header.h"


namespace test {
namespace name {

class MyBits final {
public:
  constexpr MyBits() : value_(0u) {}
  explicit constexpr MyBits(uint32_t value) : value_(value) {}
  const static MyBits MY_FIRST_BIT;
  const static MyBits MY_OTHER_BIT;
  const static MyBits mask;

  explicit constexpr inline operator uint32_t() const { return value_; }
  constexpr inline operator bool() const { return value_; }
  constexpr inline MyBits operator~() const;
  constexpr inline MyBits operator|(const MyBits& other) const;
  constexpr inline MyBits operator&(const MyBits& other) const;
  constexpr inline MyBits operator^(const MyBits& other) const;
  constexpr inline void operator|=(const MyBits& other);
  constexpr inline void operator&=(const MyBits& other);
  constexpr inline void operator^=(const MyBits& other);

private:
  uint32_t value_;
};
constexpr const ::test::name::MyBits MyBits::MY_FIRST_BIT = ::test::name::MyBits(1u);
constexpr const ::test::name::MyBits MyBits::MY_OTHER_BIT = ::test::name::MyBits(2u);
constexpr const ::test::name::MyBits MyBits::mask = ::test::name::MyBits(3u);

inline zx_status_t Clone(::test::name::MyBits value,
                         ::test::name::MyBits* result) {
  *result = value;
  return ZX_OK;
}

constexpr inline ::test::name::MyBits MyBits::operator~() const {
  return ::test::name::MyBits(~this->value_ & static_cast<uint32_t>(mask));
}

constexpr inline ::test::name::MyBits MyBits::operator|(
    const ::test::name::MyBits& other) const {
  return ::test::name::MyBits(this->value_ | other.value_);
}

constexpr inline ::test::name::MyBits MyBits::operator&(
    const ::test::name::MyBits& other) const {
  return ::test::name::MyBits(this->value_ & other.value_);
}

constexpr inline ::test::name::MyBits MyBits::operator^(
    const ::test::name::MyBits& other) const {
  return ::test::name::MyBits(this->value_ ^ other.value_);
}

constexpr inline void MyBits::operator|=(
    const ::test::name::MyBits& other) {
  this->value_ |= other.value_;
}

constexpr inline void MyBits::operator&=(
    const ::test::name::MyBits& other) {
  this->value_ &= other.value_;
}

constexpr inline void MyBits::operator^=(
    const ::test::name::MyBits& other) {
  this->value_ ^= other.value_;
}

}  // namespace name
}  // namespace test
namespace fidl {

template <>
struct CodingTraits<::test::name::MyBits> {
  static constexpr size_t encoded_size = sizeof(::test::name::MyBits);
  static void Encode(Encoder* encoder, ::test::name::MyBits* value, size_t offset) {
    uint32_t underlying = static_cast<uint32_t>(*value);
    ::fidl::Encode(encoder, &underlying, offset);
  }
  static void Decode(Decoder* decoder, ::test::name::MyBits* value, size_t offset) {
    uint32_t underlying = {};
    ::fidl::Decode(decoder, &underlying, offset);
    *value = ::test::name::MyBits(underlying);
  }
};

inline zx_status_t Clone(::test::name::MyBits value,
                         ::test::name::MyBits* result) {
  return ::test::name::Clone(value, result);
}

template<>
struct Equality<::test::name::MyBits> {
  static inline bool Equals(const ::test::name::MyBits& _lhs, const ::test::name::MyBits& _rhs) {
    uint32_t _lhs_underlying = static_cast<uint32_t>(_lhs);
    uint32_t _rhs_underlying = static_cast<uint32_t>(_rhs);
    return Equality<uint32_t>::Equals(_lhs_underlying, _rhs_underlying);
  }
};}  // namespace fidl

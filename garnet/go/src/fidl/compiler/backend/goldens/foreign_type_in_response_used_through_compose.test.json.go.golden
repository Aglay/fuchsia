// Code generated by fidlgen; DO NOT EDIT.

package top


import (
	bottom "fidl/bottom"
	middle "fidl/middle"
	_zx "syscall/zx"
	_bindings "syscall/zx/fidl"
)





type topGetFooResponse struct {
	_ struct{} `fidl:"s" fidl_size_v1:"8" fidl_alignment_v1:"8"`
	Foo bottom.Foo`fidl:"0" fidl_offset_v1:"0"`
}

var _mtopGetFooResponse = _bindings.CreateLazyMarshaler(topGetFooResponse{})

func (msg *topGetFooResponse) Marshaler() _bindings.Marshaler {
	return _mtopGetFooResponse
}
const (
	TopGetFooOrdinal uint64 = 0xb3385a000000000
	TopGetFooGenOrdinal uint64 = 0x6ae8d19bc98f3d92
)

type TopInterface _bindings.ChannelProxy


func (p *TopInterface) GetFoo() (bottom.Foo, error) {
	var req_ _bindings.Message
	resp_ := &topGetFooResponse{}
	err_ := ((*_bindings.ChannelProxy)(p)).Call(TopGetFooGenOrdinal, req_, resp_, TopGetFooOrdinal, TopGetFooGenOrdinal)
	return resp_.Foo, err_
}


type TopWithCtx interface {
	GetFoo(ctx_ _bindings.Context) (bottom.Foo, error)
}



type TopWithCtxTransitionalBase struct {}




type Top interface {
	GetFoo() (bottom.Foo, error)
}

type TopTransitionalBase struct {}


type TopInterfaceRequest _bindings.InterfaceRequest

func NewTopInterfaceRequest() (TopInterfaceRequest, *TopInterface, error) {
	req, cli, err := _bindings.NewInterfaceRequest()
	return TopInterfaceRequest(req), (*TopInterface)(cli), err
}

type TopStub struct {
	Impl Top
}

func (s_ *TopStub) DispatchImpl(ctx_ _bindings.Context, ordinal_ uint64, data_ []byte, handles_ []_zx.Handle) (_bindings.Message, bool, error) {
	return s_.DispatchImplWithCtx(ordinal_, ctx_.GetMarshalerContext(), data_, handles_)
}

func (s_ *TopStub) DispatchImplWithCtx(ordinal_ uint64, ctx_ _bindings.MarshalerContext, data_ []byte, handles_ []_zx.Handle) (_bindings.Message, bool, error) {
	switch ordinal_ {
	case TopGetFooOrdinal:
		fallthrough
	case TopGetFooGenOrdinal:
		foo, err_ := s_.Impl.GetFoo()
		out_ := topGetFooResponse{}
		out_.Foo = foo
		return &out_, true, err_
	}
	return nil, false, _bindings.ErrUnknownOrdinal
}

func (s_ *TopStub) Dispatch(args_ _bindings.DispatchArgs) (_bindings.Message, bool, error) {
	return s_.DispatchImplWithCtx2(args_.Ordinal, args_.Ctx.GetMarshalerContext(), args_.Bytes, args_.HandleInfos)
}

func (s_ *TopStub) DispatchImplWithCtx2(ordinal_ uint64, ctx_ _bindings.MarshalerContext, data_ []byte, handleInfos_ []_zx.HandleInfo) (_bindings.Message, bool, error) {
	switch ordinal_ {
	case TopGetFooOrdinal:
		fallthrough
	case TopGetFooGenOrdinal:
		foo, err_ := s_.Impl.GetFoo()
		out_ := topGetFooResponse{}
		out_.Foo = foo
		return &out_, true, err_
	}
	return nil, false, _bindings.ErrUnknownOrdinal
}

type TopWithCtxStub struct {
	Impl TopWithCtx
}

func (s_ *TopWithCtxStub) DispatchImpl(ctx_ _bindings.Context, ordinal_ uint64, data_ []byte, handles_ []_zx.Handle) (_bindings.Message, bool, error) {
	switch ordinal_ {
	case TopGetFooOrdinal:
		fallthrough
	case TopGetFooGenOrdinal:
		foo, err_ := s_.Impl.GetFoo(ctx_)
		out_ := topGetFooResponse{}
		out_.Foo = foo
		return &out_, true, err_
	}
	return nil, false, _bindings.ErrUnknownOrdinal
}

func (s_ *TopWithCtxStub) Dispatch(args_ _bindings.DispatchArgs) (_bindings.Message, bool, error) {
	switch args_.Ordinal {
	case TopGetFooOrdinal:
		fallthrough
	case TopGetFooGenOrdinal:
		foo, err_ := s_.Impl.GetFoo(args_.Ctx)
		out_ := topGetFooResponse{}
		out_.Foo = foo
		return &out_, true, err_
	}
	return nil, false, _bindings.ErrUnknownOrdinal
}
type TopService struct {
	_bindings.BindingSet
}

func (s *TopService) Add(impl Top, c _zx.Channel, onError func(error)) (_bindings.BindingKey, error) {
	return s.BindingSet.Add(&TopStub{Impl: impl}, c, onError)
}

func (s *TopService) AddWithCtx(impl TopWithCtx, c _zx.Channel, onError func(error)) (_bindings.BindingKey, error) {
	return s.BindingSet.Add(&TopWithCtxStub{Impl: impl}, c, onError)
}

func (s *TopService) EventProxyFor(key _bindings.BindingKey) (*TopEventProxy, bool) {
	pxy, err := s.BindingSet.ProxyFor(key)
	return (*TopEventProxy)(pxy), err
}

type TopEventProxy _bindings.ChannelProxy




// WARNING: This file is machine generated by fidlgen.

#include <xunion.fidl.json.h>

#include "lib/fidl/cpp/internal/implementation.h"
namespace test {
namespace name {

extern "C" const fidl_type_t test_name_OlderSimpleUnionTable;
const fidl_type_t* OlderSimpleUnion::FidlType = &test_name_OlderSimpleUnionTable;

OlderSimpleUnion::OlderSimpleUnion() {}

OlderSimpleUnion::~OlderSimpleUnion() {
  Destroy();
}

OlderSimpleUnion::OlderSimpleUnion(OlderSimpleUnion&& other) : tag_(other.tag_) {
  switch (tag_) {
   case 1026732503:
    i_ = std::move(other.i_);
    break;
   case 1362546558:
    f_ = std::move(other.f_);
    break;
   default:
    break;
  }
}

OlderSimpleUnion& OlderSimpleUnion::operator=(OlderSimpleUnion&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
     case 1026732503:
      i_ = std::move(other.i_);
      break;
     case 1362546558:
      f_ = std::move(other.f_);
      break;
     default:
      break;
    }
  }
  return *this;
}

void OlderSimpleUnion::Encode(::fidl::Encoder* encoder, size_t offset) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  size_t envelope_offset = 0;

  switch (tag_) {
    case 1026732503: {
      envelope_offset = encoder->Alloc(::fidl::CodingTraits<int64_t>::encoded_size);
      ::fidl::Encode(encoder, &i_, envelope_offset);
      break;
    }
    case 1362546558: {
      envelope_offset = encoder->Alloc(::fidl::CodingTraits<float>::encoded_size);
      ::fidl::Encode(encoder, &f_, envelope_offset);
      break;
    }
    case Tag::Empty:
    default:
       break;
  }

  fidl_xunion_t* xunion = encoder->GetPtr<fidl_xunion_t>(offset);
  assert(xunion->envelope.presence == FIDL_ALLOC_ABSENT);

  if (envelope_offset) {
    xunion->tag = tag_;
    xunion->envelope.num_bytes = encoder->CurrentLength() - length_before;
    xunion->envelope.num_handles = encoder->CurrentHandleCount() - handles_before;
    xunion->envelope.presence = FIDL_ALLOC_PRESENT;
  }
}

void OlderSimpleUnion::Decode(::fidl::Decoder* decoder, OlderSimpleUnion* value, size_t offset) {
  fidl_xunion_t* xunion = decoder->GetPtr<fidl_xunion_t>(offset);

  if (!xunion->envelope.data) {
    value->EnsureStorageInitialized(Tag::Empty);
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  const size_t envelope_offset = decoder->GetOffset(xunion->envelope.data);

  switch (value->tag_) {
   case 1026732503:
    ::fidl::Decode(decoder, &value->i_, envelope_offset);
    break;
   case 1362546558:
    ::fidl::Decode(decoder, &value->f_, envelope_offset);
    break;
   default:
    break;
  }

}

zx_status_t OlderSimpleUnion::Clone(OlderSimpleUnion* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case 1026732503:
      return ::fidl::Clone(i_, &result->i_);
    case 1362546558:
      return ::fidl::Clone(f_, &result->f_);
    default:
      return ZX_OK;
  }
}

bool operator==(const OlderSimpleUnion& lhs, const OlderSimpleUnion& rhs) {
  if (lhs.tag_ != rhs.tag_) {
    return false;
  }
  switch (lhs.tag_) {
    case 1026732503:
      return ::fidl::Equals(lhs.i_, rhs.i_);
    case 1362546558:
      return ::fidl::Equals(lhs.f_, rhs.f_);
    case OlderSimpleUnion::Tag::Empty:
      return true;
    default:
      return false;
  }
}

void OlderSimpleUnion::set_i(int64_t value) {
  EnsureStorageInitialized(1026732503);
  i_ = std::move(value);
}

void OlderSimpleUnion::set_f(float value) {
  EnsureStorageInitialized(1362546558);
  f_ = std::move(value);
}

void OlderSimpleUnion::Destroy() {
  switch (tag_) {
   case 1026732503:
    break;
   case 1362546558:
    break;
   default:
    break;
  }
  tag_ = Tag::Empty;
}

void OlderSimpleUnion::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      default:
        break;
    }
  }
}
extern "C" const fidl_type_t test_name_NewerSimpleUnionTable;
const fidl_type_t* NewerSimpleUnion::FidlType = &test_name_NewerSimpleUnionTable;

NewerSimpleUnion::NewerSimpleUnion() {}

NewerSimpleUnion::~NewerSimpleUnion() {
  Destroy();
}

NewerSimpleUnion::NewerSimpleUnion(NewerSimpleUnion&& other) : tag_(other.tag_) {
  switch (tag_) {
   case 693944286:
    i_ = std::move(other.i_);
    break;
   case 473666119:
    s_ = std::move(other.s_);
    break;
   case 1815655055:
    v_ = std::move(other.v_);
    break;
   default:
    break;
  }
}

NewerSimpleUnion& NewerSimpleUnion::operator=(NewerSimpleUnion&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
     case 693944286:
      i_ = std::move(other.i_);
      break;
     case 473666119:
      s_ = std::move(other.s_);
      break;
     case 1815655055:
      v_ = std::move(other.v_);
      break;
     default:
      break;
    }
  }
  return *this;
}

void NewerSimpleUnion::Encode(::fidl::Encoder* encoder, size_t offset) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  size_t envelope_offset = 0;

  switch (tag_) {
    case 693944286: {
      envelope_offset = encoder->Alloc(::fidl::CodingTraits<int64_t>::encoded_size);
      ::fidl::Encode(encoder, &i_, envelope_offset);
      break;
    }
    case 473666119: {
      envelope_offset = encoder->Alloc(::fidl::CodingTraits<::std::string>::encoded_size);
      ::fidl::Encode(encoder, &s_, envelope_offset);
      break;
    }
    case 1815655055: {
      envelope_offset = encoder->Alloc(::fidl::CodingTraits<::std::vector<::std::string>>::encoded_size);
      ::fidl::Encode(encoder, &v_, envelope_offset);
      break;
    }
    case Tag::Empty:
    default:
       break;
  }

  fidl_xunion_t* xunion = encoder->GetPtr<fidl_xunion_t>(offset);
  assert(xunion->envelope.presence == FIDL_ALLOC_ABSENT);

  if (envelope_offset) {
    xunion->tag = tag_;
    xunion->envelope.num_bytes = encoder->CurrentLength() - length_before;
    xunion->envelope.num_handles = encoder->CurrentHandleCount() - handles_before;
    xunion->envelope.presence = FIDL_ALLOC_PRESENT;
  }
}

void NewerSimpleUnion::Decode(::fidl::Decoder* decoder, NewerSimpleUnion* value, size_t offset) {
  fidl_xunion_t* xunion = decoder->GetPtr<fidl_xunion_t>(offset);

  if (!xunion->envelope.data) {
    value->EnsureStorageInitialized(Tag::Empty);
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  const size_t envelope_offset = decoder->GetOffset(xunion->envelope.data);

  switch (value->tag_) {
   case 693944286:
    ::fidl::Decode(decoder, &value->i_, envelope_offset);
    break;
   case 473666119:
    ::fidl::Decode(decoder, &value->s_, envelope_offset);
    break;
   case 1815655055:
    ::fidl::Decode(decoder, &value->v_, envelope_offset);
    break;
   default:
    break;
  }

}

zx_status_t NewerSimpleUnion::Clone(NewerSimpleUnion* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case 693944286:
      return ::fidl::Clone(i_, &result->i_);
    case 473666119:
      return ::fidl::Clone(s_, &result->s_);
    case 1815655055:
      return ::fidl::Clone(v_, &result->v_);
    default:
      return ZX_OK;
  }
}

bool operator==(const NewerSimpleUnion& lhs, const NewerSimpleUnion& rhs) {
  if (lhs.tag_ != rhs.tag_) {
    return false;
  }
  switch (lhs.tag_) {
    case 693944286:
      return ::fidl::Equals(lhs.i_, rhs.i_);
    case 473666119:
      return ::fidl::Equals(lhs.s_, rhs.s_);
    case 1815655055:
      return ::fidl::Equals(lhs.v_, rhs.v_);
    case NewerSimpleUnion::Tag::Empty:
      return true;
    default:
      return false;
  }
}

void NewerSimpleUnion::set_i(int64_t value) {
  EnsureStorageInitialized(693944286);
  i_ = std::move(value);
}

void NewerSimpleUnion::set_s(::std::string value) {
  EnsureStorageInitialized(473666119);
  s_ = std::move(value);
}

void NewerSimpleUnion::set_v(::std::vector<::std::string> value) {
  EnsureStorageInitialized(1815655055);
  v_ = std::move(value);
}

void NewerSimpleUnion::Destroy() {
  switch (tag_) {
   case 693944286:
    break;
   case 473666119:
    break;
   case 1815655055:
    break;
   default:
    break;
  }
  tag_ = Tag::Empty;
}

void NewerSimpleUnion::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      default:
        break;
    }
  }
}
extern "C" const fidl_type_t test_name_EmptyUnionTable;
const fidl_type_t* EmptyUnion::FidlType = &test_name_EmptyUnionTable;

EmptyUnion::EmptyUnion() {}

EmptyUnion::~EmptyUnion() {
  Destroy();
}

EmptyUnion::EmptyUnion(EmptyUnion&& other) : tag_(other.tag_) {
  switch (tag_) {
   default:
    break;
  }
}

EmptyUnion& EmptyUnion::operator=(EmptyUnion&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
     default:
      break;
    }
  }
  return *this;
}

void EmptyUnion::Encode(::fidl::Encoder* encoder, size_t offset) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  size_t envelope_offset = 0;

  switch (tag_) {
    case Tag::Empty:
    default:
       break;
  }

  fidl_xunion_t* xunion = encoder->GetPtr<fidl_xunion_t>(offset);
  assert(xunion->envelope.presence == FIDL_ALLOC_ABSENT);

  if (envelope_offset) {
    xunion->tag = tag_;
    xunion->envelope.num_bytes = encoder->CurrentLength() - length_before;
    xunion->envelope.num_handles = encoder->CurrentHandleCount() - handles_before;
    xunion->envelope.presence = FIDL_ALLOC_PRESENT;
  }
}

void EmptyUnion::Decode(::fidl::Decoder* decoder, EmptyUnion* value, size_t offset) {
  fidl_xunion_t* xunion = decoder->GetPtr<fidl_xunion_t>(offset);

  if (!xunion->envelope.data) {
    value->EnsureStorageInitialized(Tag::Empty);
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


}

zx_status_t EmptyUnion::Clone(EmptyUnion* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    default:
      return ZX_OK;
  }
}

bool operator==(const EmptyUnion& lhs, const EmptyUnion& rhs) {
  if (lhs.tag_ != rhs.tag_) {
    return false;
  }
  switch (lhs.tag_) {
    case EmptyUnion::Tag::Empty:
      return true;
    default:
      return false;
  }
}

void EmptyUnion::Destroy() {
  switch (tag_) {
   default:
    break;
  }
  tag_ = Tag::Empty;
}

void EmptyUnion::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      default:
        break;
    }
  }
}
}  // namespace name
}  // namespace test

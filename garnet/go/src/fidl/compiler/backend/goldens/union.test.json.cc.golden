// WARNING: This file is machine generated by fidlgen.

#include <union.test.json.h>

#include "lib/fidl/cpp/internal/implementation.h"
namespace fidl {
namespace test {
namespace json {

extern "C" const fidl_type_t v1_fidl_test_json_UnionTable;
const fidl_type_t* Union::FidlType = &v1_fidl_test_json_UnionTable;

Union::Union() {}

Union::~Union() {
  Destroy();
}

Union::Union(Union&& other) : tag_(other.tag_) {
  switch (tag_) {
    case Tag::kPrimitive:
      Primitive_ = std::move(other.Primitive_);
      break;
    case Tag::kStringNeedsConstructor:
      new (&StringNeedsConstructor_) ::std::string();
      StringNeedsConstructor_ = std::move(other.StringNeedsConstructor_);
      break;
    case Tag::kVectorStringAlsoNeedsConstructor:
      new (&VectorStringAlsoNeedsConstructor_) ::std::vector<::std::string>();
      VectorStringAlsoNeedsConstructor_ = std::move(other.VectorStringAlsoNeedsConstructor_);
      break;
    case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
      break;
  }
}

Union& Union::operator=(Union&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case Tag::kPrimitive:
        Primitive_ = std::move(other.Primitive_);
        break;
      case Tag::kStringNeedsConstructor:
        new (&StringNeedsConstructor_) ::std::string();
        StringNeedsConstructor_ = std::move(other.StringNeedsConstructor_);
        break;
      case Tag::kVectorStringAlsoNeedsConstructor:
        new (&VectorStringAlsoNeedsConstructor_) ::std::vector<::std::string>();
        VectorStringAlsoNeedsConstructor_ = std::move(other.VectorStringAlsoNeedsConstructor_);
        break;
      case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
        break;
    }
  }
  return *this;
}

Union Union::WithPrimitive(int32_t&& val) {
  Union result;
  result.set_Primitive(std::move(val));
  return result;
}
Union Union::WithStringNeedsConstructor(::std::string&& val) {
  Union result;
  result.set_StringNeedsConstructor(std::move(val));
  return result;
}
Union Union::WithVectorStringAlsoNeedsConstructor(::std::vector<::std::string>&& val) {
  Union result;
  result.set_VectorStringAlsoNeedsConstructor(std::move(val));
  return result;
}


void Union::Encode(::fidl::Encoder* encoder, size_t offset) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  size_t envelope_offset = 0;

  switch (tag_) {
    case Tag::kPrimitive: {
      envelope_offset = encoder->Alloc(::fidl::EncodingInlineSize<int32_t, ::fidl::Encoder>(encoder));
      ::fidl::Encode(encoder, &Primitive_, envelope_offset);
      break;
    }
    case Tag::kStringNeedsConstructor: {
      envelope_offset = encoder->Alloc(::fidl::EncodingInlineSize<::std::string, ::fidl::Encoder>(encoder));
      ::fidl::Encode(encoder, &StringNeedsConstructor_, envelope_offset);
      break;
    }
    case Tag::kVectorStringAlsoNeedsConstructor: {
      envelope_offset = encoder->Alloc(::fidl::EncodingInlineSize<::std::vector<::std::string>, ::fidl::Encoder>(encoder));
      ::fidl::Encode(encoder, &VectorStringAlsoNeedsConstructor_, envelope_offset);
      break;
    }
    default:
       break;
  }

  fidl_xunion_t* xunion = encoder->GetPtr<fidl_xunion_t>(offset);
  assert(xunion->envelope.presence == FIDL_ALLOC_ABSENT);

  if (envelope_offset) {
    xunion->tag = tag_;
    xunion->envelope.num_bytes = encoder->CurrentLength() - length_before;
    xunion->envelope.num_handles = encoder->CurrentHandleCount() - handles_before;
    xunion->envelope.presence = FIDL_ALLOC_PRESENT;
  }
}

void Union::Decode(::fidl::Decoder* decoder, Union* value, size_t offset) {
  fidl_xunion_t* xunion = decoder->GetPtr<fidl_xunion_t>(offset);

  if (!xunion->envelope.data) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  const size_t envelope_offset = decoder->GetOffset(xunion->envelope.data);

  switch (value->tag_) {
    case Tag::kPrimitive:
      ::fidl::Decode(decoder, &value->Primitive_, envelope_offset);
      break;
    case Tag::kStringNeedsConstructor:
      new (&value->StringNeedsConstructor_) ::std::string();
      ::fidl::Decode(decoder, &value->StringNeedsConstructor_, envelope_offset);
      break;
    case Tag::kVectorStringAlsoNeedsConstructor:
      new (&value->VectorStringAlsoNeedsConstructor_) ::std::vector<::std::string>();
      ::fidl::Decode(decoder, &value->VectorStringAlsoNeedsConstructor_, envelope_offset);
      break;
  }

}

zx_status_t Union::Clone(Union* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case Tag::kPrimitive:
      return ::fidl::Clone(Primitive_, &result->Primitive_);
    case Tag::kStringNeedsConstructor:
      new (&result->StringNeedsConstructor_) ::std::string();
      return ::fidl::Clone(StringNeedsConstructor_, &result->StringNeedsConstructor_);
    case Tag::kVectorStringAlsoNeedsConstructor:
      new (&result->VectorStringAlsoNeedsConstructor_) ::std::vector<::std::string>();
      return ::fidl::Clone(VectorStringAlsoNeedsConstructor_, &result->VectorStringAlsoNeedsConstructor_);
    default:
      return ZX_OK;
  }
}

Union& Union::set_Primitive(int32_t value) {
  EnsureStorageInitialized(Tag::kPrimitive);
  Primitive_ = std::move(value);
  return *this;
}

Union& Union::set_StringNeedsConstructor(::std::string value) {
  EnsureStorageInitialized(Tag::kStringNeedsConstructor);
  StringNeedsConstructor_ = std::move(value);
  return *this;
}

Union& Union::set_VectorStringAlsoNeedsConstructor(::std::vector<::std::string> value) {
  EnsureStorageInitialized(Tag::kVectorStringAlsoNeedsConstructor);
  VectorStringAlsoNeedsConstructor_ = std::move(value);
  return *this;
}

void Union::Destroy() {
  switch (tag_) {
    case Tag::kPrimitive:
      break;
    case Tag::kStringNeedsConstructor:
      StringNeedsConstructor_.~decltype(StringNeedsConstructor_)();
      break;
    case Tag::kVectorStringAlsoNeedsConstructor:
      VectorStringAlsoNeedsConstructor_.~decltype(VectorStringAlsoNeedsConstructor_)();
      break;
  
    default:
      break;
  
  }
  tag_ = static_cast<fidl_xunion_tag_t>(Tag::Invalid);
}

void Union::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
        break;
      case Tag::kPrimitive:
        new (&Primitive_) int32_t();
        break;
      case Tag::kStringNeedsConstructor:
        new (&StringNeedsConstructor_) ::std::string();
        break;
      case Tag::kVectorStringAlsoNeedsConstructor:
        new (&VectorStringAlsoNeedsConstructor_) ::std::vector<::std::string>();
        break;
      default:
        break;
    }
  }
}
extern "C" const fidl_type_t v1_fidl_test_json_StrictUnionTable;
const fidl_type_t* StrictUnion::FidlType = &v1_fidl_test_json_StrictUnionTable;

StrictUnion::StrictUnion() {}

StrictUnion::~StrictUnion() {
  Destroy();
}

StrictUnion::StrictUnion(StrictUnion&& other) : tag_(other.tag_) {
  switch (tag_) {
    case Tag::kPrimitive:
      Primitive_ = std::move(other.Primitive_);
      break;
    case Tag::kStringNeedsConstructor:
      new (&StringNeedsConstructor_) ::std::string();
      StringNeedsConstructor_ = std::move(other.StringNeedsConstructor_);
      break;
    case Tag::kVectorStringAlsoNeedsConstructor:
      new (&VectorStringAlsoNeedsConstructor_) ::std::vector<::std::string>();
      VectorStringAlsoNeedsConstructor_ = std::move(other.VectorStringAlsoNeedsConstructor_);
      break;
    case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
      break;
  }
}

StrictUnion& StrictUnion::operator=(StrictUnion&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case Tag::kPrimitive:
        Primitive_ = std::move(other.Primitive_);
        break;
      case Tag::kStringNeedsConstructor:
        new (&StringNeedsConstructor_) ::std::string();
        StringNeedsConstructor_ = std::move(other.StringNeedsConstructor_);
        break;
      case Tag::kVectorStringAlsoNeedsConstructor:
        new (&VectorStringAlsoNeedsConstructor_) ::std::vector<::std::string>();
        VectorStringAlsoNeedsConstructor_ = std::move(other.VectorStringAlsoNeedsConstructor_);
        break;
      case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
        break;
    }
  }
  return *this;
}

StrictUnion StrictUnion::WithPrimitive(int32_t&& val) {
  StrictUnion result;
  result.set_Primitive(std::move(val));
  return result;
}
StrictUnion StrictUnion::WithStringNeedsConstructor(::std::string&& val) {
  StrictUnion result;
  result.set_StringNeedsConstructor(std::move(val));
  return result;
}
StrictUnion StrictUnion::WithVectorStringAlsoNeedsConstructor(::std::vector<::std::string>&& val) {
  StrictUnion result;
  result.set_VectorStringAlsoNeedsConstructor(std::move(val));
  return result;
}


void StrictUnion::Encode(::fidl::Encoder* encoder, size_t offset) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  size_t envelope_offset = 0;

  switch (tag_) {
    case Tag::kPrimitive: {
      envelope_offset = encoder->Alloc(::fidl::EncodingInlineSize<int32_t, ::fidl::Encoder>(encoder));
      ::fidl::Encode(encoder, &Primitive_, envelope_offset);
      break;
    }
    case Tag::kStringNeedsConstructor: {
      envelope_offset = encoder->Alloc(::fidl::EncodingInlineSize<::std::string, ::fidl::Encoder>(encoder));
      ::fidl::Encode(encoder, &StringNeedsConstructor_, envelope_offset);
      break;
    }
    case Tag::kVectorStringAlsoNeedsConstructor: {
      envelope_offset = encoder->Alloc(::fidl::EncodingInlineSize<::std::vector<::std::string>, ::fidl::Encoder>(encoder));
      ::fidl::Encode(encoder, &VectorStringAlsoNeedsConstructor_, envelope_offset);
      break;
    }
    default:
       break;
  }

  fidl_xunion_t* xunion = encoder->GetPtr<fidl_xunion_t>(offset);
  assert(xunion->envelope.presence == FIDL_ALLOC_ABSENT);

  if (envelope_offset) {
    xunion->tag = tag_;
    xunion->envelope.num_bytes = encoder->CurrentLength() - length_before;
    xunion->envelope.num_handles = encoder->CurrentHandleCount() - handles_before;
    xunion->envelope.presence = FIDL_ALLOC_PRESENT;
  }
}

void StrictUnion::Decode(::fidl::Decoder* decoder, StrictUnion* value, size_t offset) {
  fidl_xunion_t* xunion = decoder->GetPtr<fidl_xunion_t>(offset);

  if (!xunion->envelope.data) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  const size_t envelope_offset = decoder->GetOffset(xunion->envelope.data);

  switch (value->tag_) {
    case Tag::kPrimitive:
      ::fidl::Decode(decoder, &value->Primitive_, envelope_offset);
      break;
    case Tag::kStringNeedsConstructor:
      new (&value->StringNeedsConstructor_) ::std::string();
      ::fidl::Decode(decoder, &value->StringNeedsConstructor_, envelope_offset);
      break;
    case Tag::kVectorStringAlsoNeedsConstructor:
      new (&value->VectorStringAlsoNeedsConstructor_) ::std::vector<::std::string>();
      ::fidl::Decode(decoder, &value->VectorStringAlsoNeedsConstructor_, envelope_offset);
      break;
  }

}

zx_status_t StrictUnion::Clone(StrictUnion* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case Tag::kPrimitive:
      return ::fidl::Clone(Primitive_, &result->Primitive_);
    case Tag::kStringNeedsConstructor:
      new (&result->StringNeedsConstructor_) ::std::string();
      return ::fidl::Clone(StringNeedsConstructor_, &result->StringNeedsConstructor_);
    case Tag::kVectorStringAlsoNeedsConstructor:
      new (&result->VectorStringAlsoNeedsConstructor_) ::std::vector<::std::string>();
      return ::fidl::Clone(VectorStringAlsoNeedsConstructor_, &result->VectorStringAlsoNeedsConstructor_);
    default:
      return ZX_OK;
  }
}

StrictUnion& StrictUnion::set_Primitive(int32_t value) {
  EnsureStorageInitialized(Tag::kPrimitive);
  Primitive_ = std::move(value);
  return *this;
}

StrictUnion& StrictUnion::set_StringNeedsConstructor(::std::string value) {
  EnsureStorageInitialized(Tag::kStringNeedsConstructor);
  StringNeedsConstructor_ = std::move(value);
  return *this;
}

StrictUnion& StrictUnion::set_VectorStringAlsoNeedsConstructor(::std::vector<::std::string> value) {
  EnsureStorageInitialized(Tag::kVectorStringAlsoNeedsConstructor);
  VectorStringAlsoNeedsConstructor_ = std::move(value);
  return *this;
}

void StrictUnion::Destroy() {
  switch (tag_) {
    case Tag::kPrimitive:
      break;
    case Tag::kStringNeedsConstructor:
      StringNeedsConstructor_.~decltype(StringNeedsConstructor_)();
      break;
    case Tag::kVectorStringAlsoNeedsConstructor:
      VectorStringAlsoNeedsConstructor_.~decltype(VectorStringAlsoNeedsConstructor_)();
      break;
  
    default:
      break;
  
  }
  tag_ = static_cast<fidl_xunion_tag_t>(Tag::Invalid);
}

void StrictUnion::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
        break;
      case Tag::kPrimitive:
        new (&Primitive_) int32_t();
        break;
      case Tag::kStringNeedsConstructor:
        new (&StringNeedsConstructor_) ::std::string();
        break;
      case Tag::kVectorStringAlsoNeedsConstructor:
        new (&VectorStringAlsoNeedsConstructor_) ::std::vector<::std::string>();
        break;
      default:
        break;
    }
  }
}
extern "C" const fidl_type_t v1_fidl_test_json_ReverseOrdinalUnionTable;
const fidl_type_t* ReverseOrdinalUnion::FidlType = &v1_fidl_test_json_ReverseOrdinalUnionTable;

ReverseOrdinalUnion::ReverseOrdinalUnion() {}

ReverseOrdinalUnion::~ReverseOrdinalUnion() {
  Destroy();
}

ReverseOrdinalUnion::ReverseOrdinalUnion(ReverseOrdinalUnion&& other) : tag_(other.tag_) {
  switch (tag_) {
    case Tag::kFirst:
      first_ = std::move(other.first_);
      break;
    case Tag::kSecond:
      second_ = std::move(other.second_);
      break;
    case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
      break;
  }
}

ReverseOrdinalUnion& ReverseOrdinalUnion::operator=(ReverseOrdinalUnion&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case Tag::kFirst:
        first_ = std::move(other.first_);
        break;
      case Tag::kSecond:
        second_ = std::move(other.second_);
        break;
      case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
        break;
    }
  }
  return *this;
}

ReverseOrdinalUnion ReverseOrdinalUnion::WithFirst(uint32_t&& val) {
  ReverseOrdinalUnion result;
  result.set_first(std::move(val));
  return result;
}
ReverseOrdinalUnion ReverseOrdinalUnion::WithSecond(uint32_t&& val) {
  ReverseOrdinalUnion result;
  result.set_second(std::move(val));
  return result;
}


void ReverseOrdinalUnion::Encode(::fidl::Encoder* encoder, size_t offset) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  size_t envelope_offset = 0;

  switch (tag_) {
    case Tag::kFirst: {
      envelope_offset = encoder->Alloc(::fidl::EncodingInlineSize<uint32_t, ::fidl::Encoder>(encoder));
      ::fidl::Encode(encoder, &first_, envelope_offset);
      break;
    }
    case Tag::kSecond: {
      envelope_offset = encoder->Alloc(::fidl::EncodingInlineSize<uint32_t, ::fidl::Encoder>(encoder));
      ::fidl::Encode(encoder, &second_, envelope_offset);
      break;
    }
    default:
       break;
  }

  fidl_xunion_t* xunion = encoder->GetPtr<fidl_xunion_t>(offset);
  assert(xunion->envelope.presence == FIDL_ALLOC_ABSENT);

  if (envelope_offset) {
    xunion->tag = tag_;
    xunion->envelope.num_bytes = encoder->CurrentLength() - length_before;
    xunion->envelope.num_handles = encoder->CurrentHandleCount() - handles_before;
    xunion->envelope.presence = FIDL_ALLOC_PRESENT;
  }
}

void ReverseOrdinalUnion::Decode(::fidl::Decoder* decoder, ReverseOrdinalUnion* value, size_t offset) {
  fidl_xunion_t* xunion = decoder->GetPtr<fidl_xunion_t>(offset);

  if (!xunion->envelope.data) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  const size_t envelope_offset = decoder->GetOffset(xunion->envelope.data);

  switch (value->tag_) {
    case Tag::kFirst:
      ::fidl::Decode(decoder, &value->first_, envelope_offset);
      break;
    case Tag::kSecond:
      ::fidl::Decode(decoder, &value->second_, envelope_offset);
      break;
  }

}

zx_status_t ReverseOrdinalUnion::Clone(ReverseOrdinalUnion* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case Tag::kFirst:
      return ::fidl::Clone(first_, &result->first_);
    case Tag::kSecond:
      return ::fidl::Clone(second_, &result->second_);
    default:
      return ZX_OK;
  }
}

ReverseOrdinalUnion& ReverseOrdinalUnion::set_first(uint32_t value) {
  EnsureStorageInitialized(Tag::kFirst);
  first_ = std::move(value);
  return *this;
}

ReverseOrdinalUnion& ReverseOrdinalUnion::set_second(uint32_t value) {
  EnsureStorageInitialized(Tag::kSecond);
  second_ = std::move(value);
  return *this;
}

void ReverseOrdinalUnion::Destroy() {
  switch (tag_) {
    case Tag::kFirst:
      break;
    case Tag::kSecond:
      break;
  
    default:
      break;
  
  }
  tag_ = static_cast<fidl_xunion_tag_t>(Tag::Invalid);
}

void ReverseOrdinalUnion::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
        break;
      case Tag::kFirst:
        new (&first_) uint32_t();
        break;
      case Tag::kSecond:
        new (&second_) uint32_t();
        break;
      default:
        break;
    }
  }
}
extern "C" const fidl_type_t v1_fidl_test_json_PizzaTable;
const fidl_type_t* Pizza::FidlType = &v1_fidl_test_json_PizzaTable;

void Pizza::Encode(::fidl::Encoder* _encoder, size_t _offset) {
  ::fidl::Encode(_encoder, &toppings, _offset + 0);
}

void Pizza::Decode(::fidl::Decoder* _decoder, Pizza* value, size_t _offset) {
  ::fidl::Decode(_decoder, &value->toppings, _offset + 0);
}

zx_status_t Pizza::Clone(Pizza* _result) const {
  zx_status_t _status = ::fidl::Clone(toppings, &_result->toppings);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}
extern "C" const fidl_type_t v1_fidl_test_json_PastaTable;
const fidl_type_t* Pasta::FidlType = &v1_fidl_test_json_PastaTable;

void Pasta::Encode(::fidl::Encoder* _encoder, size_t _offset) {
  ::fidl::Encode(_encoder, &sauce, _offset + 0);
}

void Pasta::Decode(::fidl::Decoder* _decoder, Pasta* value, size_t _offset) {
  ::fidl::Decode(_decoder, &value->sauce, _offset + 0);
}

zx_status_t Pasta::Clone(Pasta* _result) const {
  zx_status_t _status = ::fidl::Clone(sauce, &_result->sauce);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}
extern "C" const fidl_type_t v1_fidl_test_json_StrictPizzaOrPastaTable;
const fidl_type_t* StrictPizzaOrPasta::FidlType = &v1_fidl_test_json_StrictPizzaOrPastaTable;

StrictPizzaOrPasta::StrictPizzaOrPasta() {}

StrictPizzaOrPasta::~StrictPizzaOrPasta() {
  Destroy();
}

StrictPizzaOrPasta::StrictPizzaOrPasta(StrictPizzaOrPasta&& other) : tag_(other.tag_) {
  switch (tag_) {
    case Tag::kPizza:
      new (&pizza_) class Pizza();
      pizza_ = std::move(other.pizza_);
      break;
    case Tag::kPasta:
      new (&pasta_) class Pasta();
      pasta_ = std::move(other.pasta_);
      break;
    case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
      break;
  }
}

StrictPizzaOrPasta& StrictPizzaOrPasta::operator=(StrictPizzaOrPasta&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case Tag::kPizza:
        new (&pizza_) class Pizza();
        pizza_ = std::move(other.pizza_);
        break;
      case Tag::kPasta:
        new (&pasta_) class Pasta();
        pasta_ = std::move(other.pasta_);
        break;
      case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
        break;
    }
  }
  return *this;
}

StrictPizzaOrPasta StrictPizzaOrPasta::WithPizza(class Pizza&& val) {
  StrictPizzaOrPasta result;
  result.set_pizza(std::move(val));
  return result;
}
StrictPizzaOrPasta StrictPizzaOrPasta::WithPasta(class Pasta&& val) {
  StrictPizzaOrPasta result;
  result.set_pasta(std::move(val));
  return result;
}


void StrictPizzaOrPasta::Encode(::fidl::Encoder* encoder, size_t offset) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  size_t envelope_offset = 0;

  switch (tag_) {
    case Tag::kPizza: {
      envelope_offset = encoder->Alloc(::fidl::EncodingInlineSize<class Pizza, ::fidl::Encoder>(encoder));
      ::fidl::Encode(encoder, &pizza_, envelope_offset);
      break;
    }
    case Tag::kPasta: {
      envelope_offset = encoder->Alloc(::fidl::EncodingInlineSize<class Pasta, ::fidl::Encoder>(encoder));
      ::fidl::Encode(encoder, &pasta_, envelope_offset);
      break;
    }
    default:
       break;
  }

  fidl_xunion_t* xunion = encoder->GetPtr<fidl_xunion_t>(offset);
  assert(xunion->envelope.presence == FIDL_ALLOC_ABSENT);

  if (envelope_offset) {
    xunion->tag = tag_;
    xunion->envelope.num_bytes = encoder->CurrentLength() - length_before;
    xunion->envelope.num_handles = encoder->CurrentHandleCount() - handles_before;
    xunion->envelope.presence = FIDL_ALLOC_PRESENT;
  }
}

void StrictPizzaOrPasta::Decode(::fidl::Decoder* decoder, StrictPizzaOrPasta* value, size_t offset) {
  fidl_xunion_t* xunion = decoder->GetPtr<fidl_xunion_t>(offset);

  if (!xunion->envelope.data) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  const size_t envelope_offset = decoder->GetOffset(xunion->envelope.data);

  switch (value->tag_) {
    case Tag::kPizza:
      new (&value->pizza_) class Pizza();
      ::fidl::Decode(decoder, &value->pizza_, envelope_offset);
      break;
    case Tag::kPasta:
      new (&value->pasta_) class Pasta();
      ::fidl::Decode(decoder, &value->pasta_, envelope_offset);
      break;
  }

}

zx_status_t StrictPizzaOrPasta::Clone(StrictPizzaOrPasta* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case Tag::kPizza:
      new (&result->pizza_) class Pizza();
      return ::fidl::Clone(pizza_, &result->pizza_);
    case Tag::kPasta:
      new (&result->pasta_) class Pasta();
      return ::fidl::Clone(pasta_, &result->pasta_);
    default:
      return ZX_OK;
  }
}

StrictPizzaOrPasta& StrictPizzaOrPasta::set_pizza(class Pizza value) {
  EnsureStorageInitialized(Tag::kPizza);
  pizza_ = std::move(value);
  return *this;
}

StrictPizzaOrPasta& StrictPizzaOrPasta::set_pasta(class Pasta value) {
  EnsureStorageInitialized(Tag::kPasta);
  pasta_ = std::move(value);
  return *this;
}

void StrictPizzaOrPasta::Destroy() {
  switch (tag_) {
    case Tag::kPizza:
      pizza_.~decltype(pizza_)();
      break;
    case Tag::kPasta:
      pasta_.~decltype(pasta_)();
      break;
  
    default:
      break;
  
  }
  tag_ = static_cast<fidl_xunion_tag_t>(Tag::Invalid);
}

void StrictPizzaOrPasta::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
        break;
      case Tag::kPizza:
        new (&pizza_) class Pizza();
        break;
      case Tag::kPasta:
        new (&pasta_) class Pasta();
        break;
      default:
        break;
    }
  }
}
extern "C" const fidl_type_t v1_fidl_test_json_PizzaOrPastaTable;
const fidl_type_t* PizzaOrPasta::FidlType = &v1_fidl_test_json_PizzaOrPastaTable;

PizzaOrPasta::PizzaOrPasta() {}

PizzaOrPasta::~PizzaOrPasta() {
  Destroy();
}

PizzaOrPasta::PizzaOrPasta(PizzaOrPasta&& other) : tag_(other.tag_) {
  switch (tag_) {
    case Tag::kPizza:
      new (&pizza_) class Pizza();
      pizza_ = std::move(other.pizza_);
      break;
    case Tag::kPasta:
      new (&pasta_) class Pasta();
      pasta_ = std::move(other.pasta_);
      break;
    case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
      break;
  }
}

PizzaOrPasta& PizzaOrPasta::operator=(PizzaOrPasta&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case Tag::kPizza:
        new (&pizza_) class Pizza();
        pizza_ = std::move(other.pizza_);
        break;
      case Tag::kPasta:
        new (&pasta_) class Pasta();
        pasta_ = std::move(other.pasta_);
        break;
      case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
        break;
    }
  }
  return *this;
}

PizzaOrPasta PizzaOrPasta::WithPizza(class Pizza&& val) {
  PizzaOrPasta result;
  result.set_pizza(std::move(val));
  return result;
}
PizzaOrPasta PizzaOrPasta::WithPasta(class Pasta&& val) {
  PizzaOrPasta result;
  result.set_pasta(std::move(val));
  return result;
}


void PizzaOrPasta::Encode(::fidl::Encoder* encoder, size_t offset) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  size_t envelope_offset = 0;

  switch (tag_) {
    case Tag::kPizza: {
      envelope_offset = encoder->Alloc(::fidl::EncodingInlineSize<class Pizza, ::fidl::Encoder>(encoder));
      ::fidl::Encode(encoder, &pizza_, envelope_offset);
      break;
    }
    case Tag::kPasta: {
      envelope_offset = encoder->Alloc(::fidl::EncodingInlineSize<class Pasta, ::fidl::Encoder>(encoder));
      ::fidl::Encode(encoder, &pasta_, envelope_offset);
      break;
    }
    default:
       break;
  }

  fidl_xunion_t* xunion = encoder->GetPtr<fidl_xunion_t>(offset);
  assert(xunion->envelope.presence == FIDL_ALLOC_ABSENT);

  if (envelope_offset) {
    xunion->tag = tag_;
    xunion->envelope.num_bytes = encoder->CurrentLength() - length_before;
    xunion->envelope.num_handles = encoder->CurrentHandleCount() - handles_before;
    xunion->envelope.presence = FIDL_ALLOC_PRESENT;
  }
}

void PizzaOrPasta::Decode(::fidl::Decoder* decoder, PizzaOrPasta* value, size_t offset) {
  fidl_xunion_t* xunion = decoder->GetPtr<fidl_xunion_t>(offset);

  if (!xunion->envelope.data) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  const size_t envelope_offset = decoder->GetOffset(xunion->envelope.data);

  switch (value->tag_) {
    case Tag::kPizza:
      new (&value->pizza_) class Pizza();
      ::fidl::Decode(decoder, &value->pizza_, envelope_offset);
      break;
    case Tag::kPasta:
      new (&value->pasta_) class Pasta();
      ::fidl::Decode(decoder, &value->pasta_, envelope_offset);
      break;
  }

}

zx_status_t PizzaOrPasta::Clone(PizzaOrPasta* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case Tag::kPizza:
      new (&result->pizza_) class Pizza();
      return ::fidl::Clone(pizza_, &result->pizza_);
    case Tag::kPasta:
      new (&result->pasta_) class Pasta();
      return ::fidl::Clone(pasta_, &result->pasta_);
    default:
      return ZX_OK;
  }
}

PizzaOrPasta& PizzaOrPasta::set_pizza(class Pizza value) {
  EnsureStorageInitialized(Tag::kPizza);
  pizza_ = std::move(value);
  return *this;
}

PizzaOrPasta& PizzaOrPasta::set_pasta(class Pasta value) {
  EnsureStorageInitialized(Tag::kPasta);
  pasta_ = std::move(value);
  return *this;
}

void PizzaOrPasta::Destroy() {
  switch (tag_) {
    case Tag::kPizza:
      pizza_.~decltype(pizza_)();
      break;
    case Tag::kPasta:
      pasta_.~decltype(pasta_)();
      break;
  
    default:
      break;
  
  }
  tag_ = static_cast<fidl_xunion_tag_t>(Tag::Invalid);
}

void PizzaOrPasta::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
        break;
      case Tag::kPizza:
        new (&pizza_) class Pizza();
        break;
      case Tag::kPasta:
        new (&pasta_) class Pasta();
        break;
      default:
        break;
    }
  }
}
extern "C" const fidl_type_t v1_fidl_test_json_FlexiblePizzaOrPastaTable;
const fidl_type_t* FlexiblePizzaOrPasta::FidlType = &v1_fidl_test_json_FlexiblePizzaOrPastaTable;

FlexiblePizzaOrPasta::FlexiblePizzaOrPasta() {}

FlexiblePizzaOrPasta::~FlexiblePizzaOrPasta() {
  Destroy();
}

FlexiblePizzaOrPasta::FlexiblePizzaOrPasta(FlexiblePizzaOrPasta&& other) : tag_(other.tag_) {
  switch (tag_) {
    case Tag::kPizza:
      new (&pizza_) class Pizza();
      pizza_ = std::move(other.pizza_);
      break;
    case Tag::kPasta:
      new (&pasta_) class Pasta();
      pasta_ = std::move(other.pasta_);
      break;
    case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
      break;
  }
}

FlexiblePizzaOrPasta& FlexiblePizzaOrPasta::operator=(FlexiblePizzaOrPasta&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case Tag::kPizza:
        new (&pizza_) class Pizza();
        pizza_ = std::move(other.pizza_);
        break;
      case Tag::kPasta:
        new (&pasta_) class Pasta();
        pasta_ = std::move(other.pasta_);
        break;
      case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
        break;
    }
  }
  return *this;
}

FlexiblePizzaOrPasta FlexiblePizzaOrPasta::WithPizza(class Pizza&& val) {
  FlexiblePizzaOrPasta result;
  result.set_pizza(std::move(val));
  return result;
}
FlexiblePizzaOrPasta FlexiblePizzaOrPasta::WithPasta(class Pasta&& val) {
  FlexiblePizzaOrPasta result;
  result.set_pasta(std::move(val));
  return result;
}


void FlexiblePizzaOrPasta::Encode(::fidl::Encoder* encoder, size_t offset) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  size_t envelope_offset = 0;

  switch (tag_) {
    case Tag::kPizza: {
      envelope_offset = encoder->Alloc(::fidl::EncodingInlineSize<class Pizza, ::fidl::Encoder>(encoder));
      ::fidl::Encode(encoder, &pizza_, envelope_offset);
      break;
    }
    case Tag::kPasta: {
      envelope_offset = encoder->Alloc(::fidl::EncodingInlineSize<class Pasta, ::fidl::Encoder>(encoder));
      ::fidl::Encode(encoder, &pasta_, envelope_offset);
      break;
    }
    default:
       break;
  }

  fidl_xunion_t* xunion = encoder->GetPtr<fidl_xunion_t>(offset);
  assert(xunion->envelope.presence == FIDL_ALLOC_ABSENT);

  if (envelope_offset) {
    xunion->tag = tag_;
    xunion->envelope.num_bytes = encoder->CurrentLength() - length_before;
    xunion->envelope.num_handles = encoder->CurrentHandleCount() - handles_before;
    xunion->envelope.presence = FIDL_ALLOC_PRESENT;
  }
}

void FlexiblePizzaOrPasta::Decode(::fidl::Decoder* decoder, FlexiblePizzaOrPasta* value, size_t offset) {
  fidl_xunion_t* xunion = decoder->GetPtr<fidl_xunion_t>(offset);

  if (!xunion->envelope.data) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  const size_t envelope_offset = decoder->GetOffset(xunion->envelope.data);

  switch (value->tag_) {
    case Tag::kPizza:
      new (&value->pizza_) class Pizza();
      ::fidl::Decode(decoder, &value->pizza_, envelope_offset);
      break;
    case Tag::kPasta:
      new (&value->pasta_) class Pasta();
      ::fidl::Decode(decoder, &value->pasta_, envelope_offset);
      break;
  }

}

zx_status_t FlexiblePizzaOrPasta::Clone(FlexiblePizzaOrPasta* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case Tag::kPizza:
      new (&result->pizza_) class Pizza();
      return ::fidl::Clone(pizza_, &result->pizza_);
    case Tag::kPasta:
      new (&result->pasta_) class Pasta();
      return ::fidl::Clone(pasta_, &result->pasta_);
    default:
      return ZX_OK;
  }
}

FlexiblePizzaOrPasta& FlexiblePizzaOrPasta::set_pizza(class Pizza value) {
  EnsureStorageInitialized(Tag::kPizza);
  pizza_ = std::move(value);
  return *this;
}

FlexiblePizzaOrPasta& FlexiblePizzaOrPasta::set_pasta(class Pasta value) {
  EnsureStorageInitialized(Tag::kPasta);
  pasta_ = std::move(value);
  return *this;
}

void FlexiblePizzaOrPasta::Destroy() {
  switch (tag_) {
    case Tag::kPizza:
      pizza_.~decltype(pizza_)();
      break;
    case Tag::kPasta:
      pasta_.~decltype(pasta_)();
      break;
  
    default:
      break;
  
  }
  tag_ = static_cast<fidl_xunion_tag_t>(Tag::Invalid);
}

void FlexiblePizzaOrPasta::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
        break;
      case Tag::kPizza:
        new (&pizza_) class Pizza();
        break;
      case Tag::kPasta:
        new (&pasta_) class Pasta();
        break;
      default:
        break;
    }
  }
}
extern "C" const fidl_type_t v1_fidl_test_json_ExplicitPizzaOrPastaTable;
const fidl_type_t* ExplicitPizzaOrPasta::FidlType = &v1_fidl_test_json_ExplicitPizzaOrPastaTable;

ExplicitPizzaOrPasta::ExplicitPizzaOrPasta() {}

ExplicitPizzaOrPasta::~ExplicitPizzaOrPasta() {
  Destroy();
}

ExplicitPizzaOrPasta::ExplicitPizzaOrPasta(ExplicitPizzaOrPasta&& other) : tag_(other.tag_) {
  switch (tag_) {
    case Tag::kPizza:
      new (&pizza_) class Pizza();
      pizza_ = std::move(other.pizza_);
      break;
    case Tag::kPasta:
      new (&pasta_) class Pasta();
      pasta_ = std::move(other.pasta_);
      break;
    case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
      break;
  }
}

ExplicitPizzaOrPasta& ExplicitPizzaOrPasta::operator=(ExplicitPizzaOrPasta&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case Tag::kPizza:
        new (&pizza_) class Pizza();
        pizza_ = std::move(other.pizza_);
        break;
      case Tag::kPasta:
        new (&pasta_) class Pasta();
        pasta_ = std::move(other.pasta_);
        break;
      case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
        break;
    }
  }
  return *this;
}

ExplicitPizzaOrPasta ExplicitPizzaOrPasta::WithPizza(class Pizza&& val) {
  ExplicitPizzaOrPasta result;
  result.set_pizza(std::move(val));
  return result;
}
ExplicitPizzaOrPasta ExplicitPizzaOrPasta::WithPasta(class Pasta&& val) {
  ExplicitPizzaOrPasta result;
  result.set_pasta(std::move(val));
  return result;
}


void ExplicitPizzaOrPasta::Encode(::fidl::Encoder* encoder, size_t offset) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  size_t envelope_offset = 0;

  switch (tag_) {
    case Tag::kPizza: {
      envelope_offset = encoder->Alloc(::fidl::EncodingInlineSize<class Pizza, ::fidl::Encoder>(encoder));
      ::fidl::Encode(encoder, &pizza_, envelope_offset);
      break;
    }
    case Tag::kPasta: {
      envelope_offset = encoder->Alloc(::fidl::EncodingInlineSize<class Pasta, ::fidl::Encoder>(encoder));
      ::fidl::Encode(encoder, &pasta_, envelope_offset);
      break;
    }
    default:
       break;
  }

  fidl_xunion_t* xunion = encoder->GetPtr<fidl_xunion_t>(offset);
  assert(xunion->envelope.presence == FIDL_ALLOC_ABSENT);

  if (envelope_offset) {
    xunion->tag = tag_;
    xunion->envelope.num_bytes = encoder->CurrentLength() - length_before;
    xunion->envelope.num_handles = encoder->CurrentHandleCount() - handles_before;
    xunion->envelope.presence = FIDL_ALLOC_PRESENT;
  }
}

void ExplicitPizzaOrPasta::Decode(::fidl::Decoder* decoder, ExplicitPizzaOrPasta* value, size_t offset) {
  fidl_xunion_t* xunion = decoder->GetPtr<fidl_xunion_t>(offset);

  if (!xunion->envelope.data) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  const size_t envelope_offset = decoder->GetOffset(xunion->envelope.data);

  switch (value->tag_) {
    case Tag::kPizza:
      new (&value->pizza_) class Pizza();
      ::fidl::Decode(decoder, &value->pizza_, envelope_offset);
      break;
    case Tag::kPasta:
      new (&value->pasta_) class Pasta();
      ::fidl::Decode(decoder, &value->pasta_, envelope_offset);
      break;
  }

}

zx_status_t ExplicitPizzaOrPasta::Clone(ExplicitPizzaOrPasta* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case Tag::kPizza:
      new (&result->pizza_) class Pizza();
      return ::fidl::Clone(pizza_, &result->pizza_);
    case Tag::kPasta:
      new (&result->pasta_) class Pasta();
      return ::fidl::Clone(pasta_, &result->pasta_);
    default:
      return ZX_OK;
  }
}

ExplicitPizzaOrPasta& ExplicitPizzaOrPasta::set_pizza(class Pizza value) {
  EnsureStorageInitialized(Tag::kPizza);
  pizza_ = std::move(value);
  return *this;
}

ExplicitPizzaOrPasta& ExplicitPizzaOrPasta::set_pasta(class Pasta value) {
  EnsureStorageInitialized(Tag::kPasta);
  pasta_ = std::move(value);
  return *this;
}

void ExplicitPizzaOrPasta::Destroy() {
  switch (tag_) {
    case Tag::kPizza:
      pizza_.~decltype(pizza_)();
      break;
    case Tag::kPasta:
      pasta_.~decltype(pasta_)();
      break;
  
    default:
      break;
  
  }
  tag_ = static_cast<fidl_xunion_tag_t>(Tag::Invalid);
}

void ExplicitPizzaOrPasta::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
        break;
      case Tag::kPizza:
        new (&pizza_) class Pizza();
        break;
      case Tag::kPasta:
        new (&pasta_) class Pasta();
        break;
      default:
        break;
    }
  }
}
extern "C" const fidl_type_t v1_fidl_test_json_NullableUnionStructTable;
const fidl_type_t* NullableUnionStruct::FidlType = &v1_fidl_test_json_NullableUnionStructTable;

void NullableUnionStruct::Encode(::fidl::Encoder* _encoder, size_t _offset) {
  ::fidl::Encode(_encoder, &the_union, _offset + 0);
}

void NullableUnionStruct::Decode(::fidl::Decoder* _decoder, NullableUnionStruct* value, size_t _offset) {
  ::fidl::Decode(_decoder, &value->the_union, _offset + 0);
}

zx_status_t NullableUnionStruct::Clone(NullableUnionStruct* _result) const {
  zx_status_t _status = ::fidl::Clone(the_union, &_result->the_union);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}
extern "C" const fidl_type_t v1_fidl_test_json_FlexibleUnionTable;
const fidl_type_t* FlexibleUnion::FidlType = &v1_fidl_test_json_FlexibleUnionTable;

FlexibleUnion::FlexibleUnion() {}

FlexibleUnion::~FlexibleUnion() {
  Destroy();
}

FlexibleUnion::FlexibleUnion(FlexibleUnion&& other) : tag_(other.tag_) {
  switch (tag_) {
    case Tag::kPrimitive:
      Primitive_ = std::move(other.Primitive_);
      break;
    case Tag::kStringNeedsConstructor:
      new (&StringNeedsConstructor_) ::std::string();
      StringNeedsConstructor_ = std::move(other.StringNeedsConstructor_);
      break;
    case Tag::kVectorStringAlsoNeedsConstructor:
      new (&VectorStringAlsoNeedsConstructor_) ::std::vector<::std::string>();
      VectorStringAlsoNeedsConstructor_ = std::move(other.VectorStringAlsoNeedsConstructor_);
      break;
    case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
      break;
  }
}

FlexibleUnion& FlexibleUnion::operator=(FlexibleUnion&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case Tag::kPrimitive:
        Primitive_ = std::move(other.Primitive_);
        break;
      case Tag::kStringNeedsConstructor:
        new (&StringNeedsConstructor_) ::std::string();
        StringNeedsConstructor_ = std::move(other.StringNeedsConstructor_);
        break;
      case Tag::kVectorStringAlsoNeedsConstructor:
        new (&VectorStringAlsoNeedsConstructor_) ::std::vector<::std::string>();
        VectorStringAlsoNeedsConstructor_ = std::move(other.VectorStringAlsoNeedsConstructor_);
        break;
      case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
        break;
    }
  }
  return *this;
}

FlexibleUnion FlexibleUnion::WithPrimitive(int32_t&& val) {
  FlexibleUnion result;
  result.set_Primitive(std::move(val));
  return result;
}
FlexibleUnion FlexibleUnion::WithStringNeedsConstructor(::std::string&& val) {
  FlexibleUnion result;
  result.set_StringNeedsConstructor(std::move(val));
  return result;
}
FlexibleUnion FlexibleUnion::WithVectorStringAlsoNeedsConstructor(::std::vector<::std::string>&& val) {
  FlexibleUnion result;
  result.set_VectorStringAlsoNeedsConstructor(std::move(val));
  return result;
}


void FlexibleUnion::Encode(::fidl::Encoder* encoder, size_t offset) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  size_t envelope_offset = 0;

  switch (tag_) {
    case Tag::kPrimitive: {
      envelope_offset = encoder->Alloc(::fidl::EncodingInlineSize<int32_t, ::fidl::Encoder>(encoder));
      ::fidl::Encode(encoder, &Primitive_, envelope_offset);
      break;
    }
    case Tag::kStringNeedsConstructor: {
      envelope_offset = encoder->Alloc(::fidl::EncodingInlineSize<::std::string, ::fidl::Encoder>(encoder));
      ::fidl::Encode(encoder, &StringNeedsConstructor_, envelope_offset);
      break;
    }
    case Tag::kVectorStringAlsoNeedsConstructor: {
      envelope_offset = encoder->Alloc(::fidl::EncodingInlineSize<::std::vector<::std::string>, ::fidl::Encoder>(encoder));
      ::fidl::Encode(encoder, &VectorStringAlsoNeedsConstructor_, envelope_offset);
      break;
    }
    default:
       break;
  }

  fidl_xunion_t* xunion = encoder->GetPtr<fidl_xunion_t>(offset);
  assert(xunion->envelope.presence == FIDL_ALLOC_ABSENT);

  if (envelope_offset) {
    xunion->tag = tag_;
    xunion->envelope.num_bytes = encoder->CurrentLength() - length_before;
    xunion->envelope.num_handles = encoder->CurrentHandleCount() - handles_before;
    xunion->envelope.presence = FIDL_ALLOC_PRESENT;
  }
}

void FlexibleUnion::Decode(::fidl::Decoder* decoder, FlexibleUnion* value, size_t offset) {
  fidl_xunion_t* xunion = decoder->GetPtr<fidl_xunion_t>(offset);

  if (!xunion->envelope.data) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  const size_t envelope_offset = decoder->GetOffset(xunion->envelope.data);

  switch (value->tag_) {
    case Tag::kPrimitive:
      ::fidl::Decode(decoder, &value->Primitive_, envelope_offset);
      break;
    case Tag::kStringNeedsConstructor:
      new (&value->StringNeedsConstructor_) ::std::string();
      ::fidl::Decode(decoder, &value->StringNeedsConstructor_, envelope_offset);
      break;
    case Tag::kVectorStringAlsoNeedsConstructor:
      new (&value->VectorStringAlsoNeedsConstructor_) ::std::vector<::std::string>();
      ::fidl::Decode(decoder, &value->VectorStringAlsoNeedsConstructor_, envelope_offset);
      break;
  }

}

zx_status_t FlexibleUnion::Clone(FlexibleUnion* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case Tag::kPrimitive:
      return ::fidl::Clone(Primitive_, &result->Primitive_);
    case Tag::kStringNeedsConstructor:
      new (&result->StringNeedsConstructor_) ::std::string();
      return ::fidl::Clone(StringNeedsConstructor_, &result->StringNeedsConstructor_);
    case Tag::kVectorStringAlsoNeedsConstructor:
      new (&result->VectorStringAlsoNeedsConstructor_) ::std::vector<::std::string>();
      return ::fidl::Clone(VectorStringAlsoNeedsConstructor_, &result->VectorStringAlsoNeedsConstructor_);
    default:
      return ZX_OK;
  }
}

FlexibleUnion& FlexibleUnion::set_Primitive(int32_t value) {
  EnsureStorageInitialized(Tag::kPrimitive);
  Primitive_ = std::move(value);
  return *this;
}

FlexibleUnion& FlexibleUnion::set_StringNeedsConstructor(::std::string value) {
  EnsureStorageInitialized(Tag::kStringNeedsConstructor);
  StringNeedsConstructor_ = std::move(value);
  return *this;
}

FlexibleUnion& FlexibleUnion::set_VectorStringAlsoNeedsConstructor(::std::vector<::std::string> value) {
  EnsureStorageInitialized(Tag::kVectorStringAlsoNeedsConstructor);
  VectorStringAlsoNeedsConstructor_ = std::move(value);
  return *this;
}

void FlexibleUnion::Destroy() {
  switch (tag_) {
    case Tag::kPrimitive:
      break;
    case Tag::kStringNeedsConstructor:
      StringNeedsConstructor_.~decltype(StringNeedsConstructor_)();
      break;
    case Tag::kVectorStringAlsoNeedsConstructor:
      VectorStringAlsoNeedsConstructor_.~decltype(VectorStringAlsoNeedsConstructor_)();
      break;
  
    default:
      break;
  
  }
  tag_ = static_cast<fidl_xunion_tag_t>(Tag::Invalid);
}

void FlexibleUnion::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
        break;
      case Tag::kPrimitive:
        new (&Primitive_) int32_t();
        break;
      case Tag::kStringNeedsConstructor:
        new (&StringNeedsConstructor_) ::std::string();
        break;
      case Tag::kVectorStringAlsoNeedsConstructor:
        new (&VectorStringAlsoNeedsConstructor_) ::std::vector<::std::string>();
        break;
      default:
        break;
    }
  }
}
extern "C" const fidl_type_t v1_fidl_test_json_FieldCollisionTable;
const fidl_type_t* FieldCollision::FidlType = &v1_fidl_test_json_FieldCollisionTable;

FieldCollision::FieldCollision() {}

FieldCollision::~FieldCollision() {
  Destroy();
}

FieldCollision::FieldCollision(FieldCollision&& other) : tag_(other.tag_) {
  switch (tag_) {
    case Tag::kFieldCollisionTag:
      field_collision_tag_ = std::move(other.field_collision_tag_);
      break;
    case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
      break;
  }
}

FieldCollision& FieldCollision::operator=(FieldCollision&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case Tag::kFieldCollisionTag:
        field_collision_tag_ = std::move(other.field_collision_tag_);
        break;
      case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
        break;
    }
  }
  return *this;
}

FieldCollision FieldCollision::WithFieldCollisionTag(int32_t&& val) {
  FieldCollision result;
  result.set_field_collision_tag(std::move(val));
  return result;
}


void FieldCollision::Encode(::fidl::Encoder* encoder, size_t offset) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  size_t envelope_offset = 0;

  switch (tag_) {
    case Tag::kFieldCollisionTag: {
      envelope_offset = encoder->Alloc(::fidl::EncodingInlineSize<int32_t, ::fidl::Encoder>(encoder));
      ::fidl::Encode(encoder, &field_collision_tag_, envelope_offset);
      break;
    }
    default:
       break;
  }

  fidl_xunion_t* xunion = encoder->GetPtr<fidl_xunion_t>(offset);
  assert(xunion->envelope.presence == FIDL_ALLOC_ABSENT);

  if (envelope_offset) {
    xunion->tag = tag_;
    xunion->envelope.num_bytes = encoder->CurrentLength() - length_before;
    xunion->envelope.num_handles = encoder->CurrentHandleCount() - handles_before;
    xunion->envelope.presence = FIDL_ALLOC_PRESENT;
  }
}

void FieldCollision::Decode(::fidl::Decoder* decoder, FieldCollision* value, size_t offset) {
  fidl_xunion_t* xunion = decoder->GetPtr<fidl_xunion_t>(offset);

  if (!xunion->envelope.data) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  const size_t envelope_offset = decoder->GetOffset(xunion->envelope.data);

  switch (value->tag_) {
    case Tag::kFieldCollisionTag:
      ::fidl::Decode(decoder, &value->field_collision_tag_, envelope_offset);
      break;
  }

}

zx_status_t FieldCollision::Clone(FieldCollision* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case Tag::kFieldCollisionTag:
      return ::fidl::Clone(field_collision_tag_, &result->field_collision_tag_);
    default:
      return ZX_OK;
  }
}

FieldCollision& FieldCollision::set_field_collision_tag(int32_t value) {
  EnsureStorageInitialized(Tag::kFieldCollisionTag);
  field_collision_tag_ = std::move(value);
  return *this;
}

void FieldCollision::Destroy() {
  switch (tag_) {
    case Tag::kFieldCollisionTag:
      break;
  
    default:
      break;
  
  }
  tag_ = static_cast<fidl_xunion_tag_t>(Tag::Invalid);
}

void FieldCollision::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
        break;
      case Tag::kFieldCollisionTag:
        new (&field_collision_tag_) int32_t();
        break;
      default:
        break;
    }
  }
}
extern "C" const fidl_type_t v1_fidl_test_json_ExplicitUnionTable;
const fidl_type_t* ExplicitUnion::FidlType = &v1_fidl_test_json_ExplicitUnionTable;

ExplicitUnion::ExplicitUnion() {}

ExplicitUnion::~ExplicitUnion() {
  Destroy();
}

ExplicitUnion::ExplicitUnion(ExplicitUnion&& other) : tag_(other.tag_) {
  switch (tag_) {
    case Tag::kPrimitive:
      Primitive_ = std::move(other.Primitive_);
      break;
    case Tag::kStringNeedsConstructor:
      new (&StringNeedsConstructor_) ::std::string();
      StringNeedsConstructor_ = std::move(other.StringNeedsConstructor_);
      break;
    case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
      break;
  }
}

ExplicitUnion& ExplicitUnion::operator=(ExplicitUnion&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case Tag::kPrimitive:
        Primitive_ = std::move(other.Primitive_);
        break;
      case Tag::kStringNeedsConstructor:
        new (&StringNeedsConstructor_) ::std::string();
        StringNeedsConstructor_ = std::move(other.StringNeedsConstructor_);
        break;
      case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
        break;
    }
  }
  return *this;
}

ExplicitUnion ExplicitUnion::WithPrimitive(int32_t&& val) {
  ExplicitUnion result;
  result.set_Primitive(std::move(val));
  return result;
}
ExplicitUnion ExplicitUnion::WithStringNeedsConstructor(::std::string&& val) {
  ExplicitUnion result;
  result.set_StringNeedsConstructor(std::move(val));
  return result;
}


void ExplicitUnion::Encode(::fidl::Encoder* encoder, size_t offset) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  size_t envelope_offset = 0;

  switch (tag_) {
    case Tag::kPrimitive: {
      envelope_offset = encoder->Alloc(::fidl::EncodingInlineSize<int32_t, ::fidl::Encoder>(encoder));
      ::fidl::Encode(encoder, &Primitive_, envelope_offset);
      break;
    }
    case Tag::kStringNeedsConstructor: {
      envelope_offset = encoder->Alloc(::fidl::EncodingInlineSize<::std::string, ::fidl::Encoder>(encoder));
      ::fidl::Encode(encoder, &StringNeedsConstructor_, envelope_offset);
      break;
    }
    default:
       break;
  }

  fidl_xunion_t* xunion = encoder->GetPtr<fidl_xunion_t>(offset);
  assert(xunion->envelope.presence == FIDL_ALLOC_ABSENT);

  if (envelope_offset) {
    xunion->tag = tag_;
    xunion->envelope.num_bytes = encoder->CurrentLength() - length_before;
    xunion->envelope.num_handles = encoder->CurrentHandleCount() - handles_before;
    xunion->envelope.presence = FIDL_ALLOC_PRESENT;
  }
}

void ExplicitUnion::Decode(::fidl::Decoder* decoder, ExplicitUnion* value, size_t offset) {
  fidl_xunion_t* xunion = decoder->GetPtr<fidl_xunion_t>(offset);

  if (!xunion->envelope.data) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  const size_t envelope_offset = decoder->GetOffset(xunion->envelope.data);

  switch (value->tag_) {
    case Tag::kPrimitive:
      ::fidl::Decode(decoder, &value->Primitive_, envelope_offset);
      break;
    case Tag::kStringNeedsConstructor:
      new (&value->StringNeedsConstructor_) ::std::string();
      ::fidl::Decode(decoder, &value->StringNeedsConstructor_, envelope_offset);
      break;
  }

}

zx_status_t ExplicitUnion::Clone(ExplicitUnion* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case Tag::kPrimitive:
      return ::fidl::Clone(Primitive_, &result->Primitive_);
    case Tag::kStringNeedsConstructor:
      new (&result->StringNeedsConstructor_) ::std::string();
      return ::fidl::Clone(StringNeedsConstructor_, &result->StringNeedsConstructor_);
    default:
      return ZX_OK;
  }
}

ExplicitUnion& ExplicitUnion::set_Primitive(int32_t value) {
  EnsureStorageInitialized(Tag::kPrimitive);
  Primitive_ = std::move(value);
  return *this;
}

ExplicitUnion& ExplicitUnion::set_StringNeedsConstructor(::std::string value) {
  EnsureStorageInitialized(Tag::kStringNeedsConstructor);
  StringNeedsConstructor_ = std::move(value);
  return *this;
}

void ExplicitUnion::Destroy() {
  switch (tag_) {
    case Tag::kPrimitive:
      break;
    case Tag::kStringNeedsConstructor:
      StringNeedsConstructor_.~decltype(StringNeedsConstructor_)();
      break;
  
    default:
      break;
  
  }
  tag_ = static_cast<fidl_xunion_tag_t>(Tag::Invalid);
}

void ExplicitUnion::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
        break;
      case Tag::kPrimitive:
        new (&Primitive_) int32_t();
        break;
      case Tag::kStringNeedsConstructor:
        new (&StringNeedsConstructor_) ::std::string();
        break;
      default:
        break;
    }
  }
}
}  // namespace json
}  // namespace test
}  // namespace fidl


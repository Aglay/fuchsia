// WARNING: This file is machine generated by fidlgen.

#pragma once

#include "lib/fidl/cpp/fuzzing/traits.h"
#include "lib/fidl/cpp/internal/header.h"

#include <test/name/cpp/fidl.h>

namespace fidl {
namespace fuzzing {


using StrictSimpleXUnion = ::test::name::StrictSimpleXUnion;
using StrictBoundedXUnion = ::test::name::StrictBoundedXUnion;
using OlderSimpleUnion = ::test::name::OlderSimpleUnion;
using NewerSimpleUnion = ::test::name::NewerSimpleUnion;
using Empty = ::test::name::Empty;
using XUnionContainingEmptyStruct = ::test::name::XUnionContainingEmptyStruct;


template<>
struct MinSize<StrictSimpleXUnion> {
  operator size_t() { return sizeof(StrictSimpleXUnion); }
};
template<>
struct Allocate<StrictSimpleXUnion> {
  StrictSimpleXUnion operator()(FuzzInput* src, size_t* size) {
    StrictSimpleXUnion out;
    ZX_ASSERT(*size >= sizeof(StrictSimpleXUnion));
    ZX_ASSERT(src.CopyObject(&out));
    *size = sizeof(StrictSimpleXUnion);
    return out;
  }
};
template<>
struct MinSize<StrictBoundedXUnion> {
  operator size_t() { return sizeof(StrictBoundedXUnion); }
};
template<>
struct Allocate<StrictBoundedXUnion> {
  StrictBoundedXUnion operator()(FuzzInput* src, size_t* size) {
    StrictBoundedXUnion out;
    ZX_ASSERT(*size >= sizeof(StrictBoundedXUnion));
    ZX_ASSERT(src.CopyObject(&out));
    *size = sizeof(StrictBoundedXUnion);
    return out;
  }
};
template<>
struct MinSize<OlderSimpleUnion> {
  operator size_t() { return sizeof(OlderSimpleUnion); }
};
template<>
struct Allocate<OlderSimpleUnion> {
  OlderSimpleUnion operator()(FuzzInput* src, size_t* size) {
    OlderSimpleUnion out;
    ZX_ASSERT(*size >= sizeof(OlderSimpleUnion));
    ZX_ASSERT(src.CopyObject(&out));
    *size = sizeof(OlderSimpleUnion);
    return out;
  }
};
template<>
struct MinSize<NewerSimpleUnion> {
  operator size_t() { return sizeof(NewerSimpleUnion); }
};
template<>
struct Allocate<NewerSimpleUnion> {
  NewerSimpleUnion operator()(FuzzInput* src, size_t* size) {
    NewerSimpleUnion out;
    ZX_ASSERT(*size >= sizeof(NewerSimpleUnion));
    ZX_ASSERT(src.CopyObject(&out));
    *size = sizeof(NewerSimpleUnion);
    return out;
  }
};
template<>
struct MinSize<Empty> {
  operator size_t() {
    return MinSize<uint8_t>();
  }
};
template<>
struct Allocate<Empty> {
  Empty operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<Empty>());
    const size_t slack_per_member = (*size - MinSize<Empty>()) / 1;
    Empty out;
    size_t out_size;
    out_size = MinSize<uint8_t>() + slack_per_member;
    out.__reserved = Allocate<uint8_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<XUnionContainingEmptyStruct> {
  operator size_t() { return sizeof(XUnionContainingEmptyStruct); }
};
template<>
struct Allocate<XUnionContainingEmptyStruct> {
  XUnionContainingEmptyStruct operator()(FuzzInput* src, size_t* size) {
    XUnionContainingEmptyStruct out;
    ZX_ASSERT(*size >= sizeof(XUnionContainingEmptyStruct));
    ZX_ASSERT(src.CopyObject(&out));
    *size = sizeof(XUnionContainingEmptyStruct);
    return out;
  }
};

}  // namespace fuzzing
}  // namespace fidl

// WARNING: This file is machine generated by fidlgen.

#include <struct_default_value_enum_library_reference.test.json.h>

#include "lib/fidl/cpp/internal/implementation.h"

//
// Domain objects definitions (i.e. "natural types" in unified bindings)
//
namespace fidl {
namespace test {
namespace structdefaultvalueenumlibraryreference {

extern "C" const fidl_type_t
    fidl_test_structdefaultvalueenumlibraryreference_FooTable;
const fidl_type_t* Foo::FidlType =
    &fidl_test_structdefaultvalueenumlibraryreference_FooTable;

void Foo::Encode(::fidl::Encoder* _encoder, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Foo>::value) {
    memcpy(_encoder->template GetPtr<Foo>(_offset), this, sizeof(Foo));
  } else {
    ::fidl::Encode(_encoder, &field, _offset + 0);
  }
}

void Foo::Decode(::fidl::Decoder* _decoder, Foo* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Foo>::value) {
    memcpy(_value, _decoder->template GetPtr<Foo>(_offset), sizeof(Foo));
  } else {
    ::fidl::Decode(_decoder, &_value->field, _offset + 0);
  }
}

zx_status_t Foo::Clone(Foo* _result) const {
  zx_status_t _status = ::fidl::Clone(field, &_result->field);
  if (_status != ZX_OK) return _status;
  return ZX_OK;
}
}  // namespace structdefaultvalueenumlibraryreference
}  // namespace test
}  // namespace fidl

//
// Proxies and stubs definitions
//
namespace fidl {
namespace test {
namespace structdefaultvalueenumlibraryreference {

}  // namespace structdefaultvalueenumlibraryreference
}  // namespace test
}  // namespace fidl

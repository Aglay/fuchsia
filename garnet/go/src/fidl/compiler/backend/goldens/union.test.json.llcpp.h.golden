// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/buffer_allocator.h>
#include <lib/fidl/llcpp/buffer_then_heap_allocator.h>
#include <lib/fidl/llcpp/client.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/connect_service.h>
#include <lib/fidl/llcpp/envelope.h>
#include <lib/fidl/llcpp/errors.h>
#include <lib/fidl/llcpp/linearized_and_encoded.h>
#include <lib/fidl/llcpp/memory.h>
#include <lib/fidl/llcpp/server.h>
#include <lib/fidl/llcpp/service_handler_interface.h>
#include <lib/fidl/llcpp/string_view.h>
#include <lib/fidl/llcpp/sync_call.h>
#include <lib/fidl/llcpp/tracking_ptr.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/fidl/llcpp/vector_view.h>
#include <lib/fidl/txn_header.h>
#include <lib/fit/function.h>
#include <lib/zx/channel.h>
#include <zircon/fidl.h>

#include <variant>

namespace llcpp {

namespace fidl {
namespace test {
namespace json {

class Union;
struct StructWithNullableXUnion;
class StrictUnion;
class StrictSimpleXUnion;
class StrictFoo;
class StrictBoundedXUnion;
class ReverseOrdinalUnion;
struct Pizza;
struct Pasta;
class StrictPizzaOrPasta;
class PizzaOrPasta;
class FlexiblePizzaOrPasta;
class ExplicitPizzaOrPasta;
class OlderSimpleUnion;
class TestProtocol;
struct NullableUnionStruct;
class NewerSimpleUnion;
class FlexibleUnion;
class FlexibleFoo;
class FieldCollision;
class ExplicitXUnion;
class ExplicitUnion;
class ExplicitStrictFoo;
class ExplicitFoo;
struct Empty;
class XUnionContainingEmptyStruct;

extern "C" const fidl_type_t fidl_test_json_UnionTable;

class Union {
 public:
  Union() : ordinal_(Ordinal::Invalid), envelope_{} {}

  Union(Union&&) = default;
  Union& operator=(Union&&) = default;

  ~Union() { reset_ptr(nullptr); }

  enum class Tag : fidl_xunion_tag_t {
    kPrimitive = 1,                         // 0x1
    kStringNeedsConstructor = 2,            // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_Primitive() const { return ordinal_ == Ordinal::kPrimitive; }

  static Union WithPrimitive(::fidl::tracking_ptr<int32_t>&& val) {
    Union result;
    result.set_Primitive(std::move(val));
    return result;
  }

  void set_Primitive(::fidl::tracking_ptr<int32_t>&& elem) {
    ordinal_ = Ordinal::kPrimitive;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  int32_t& mutable_Primitive() {
    ZX_ASSERT(ordinal_ == Ordinal::kPrimitive);
    return *static_cast<int32_t*>(envelope_.data.get());
  }
  const int32_t& Primitive() const {
    ZX_ASSERT(ordinal_ == Ordinal::kPrimitive);
    return *static_cast<int32_t*>(envelope_.data.get());
  }

  bool is_StringNeedsConstructor() const {
    return ordinal_ == Ordinal::kStringNeedsConstructor;
  }

  static Union WithStringNeedsConstructor(
      ::fidl::tracking_ptr<::fidl::StringView>&& val) {
    Union result;
    result.set_StringNeedsConstructor(std::move(val));
    return result;
  }

  void set_StringNeedsConstructor(
      ::fidl::tracking_ptr<::fidl::StringView>&& elem) {
    ordinal_ = Ordinal::kStringNeedsConstructor;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::fidl::StringView& mutable_StringNeedsConstructor() {
    ZX_ASSERT(ordinal_ == Ordinal::kStringNeedsConstructor);
    return *static_cast<::fidl::StringView*>(envelope_.data.get());
  }
  const ::fidl::StringView& StringNeedsConstructor() const {
    ZX_ASSERT(ordinal_ == Ordinal::kStringNeedsConstructor);
    return *static_cast<::fidl::StringView*>(envelope_.data.get());
  }

  bool is_VectorStringAlsoNeedsConstructor() const {
    return ordinal_ == Ordinal::kVectorStringAlsoNeedsConstructor;
  }

  static Union WithVectorStringAlsoNeedsConstructor(
      ::fidl::tracking_ptr<::fidl::VectorView<::fidl::StringView>>&& val) {
    Union result;
    result.set_VectorStringAlsoNeedsConstructor(std::move(val));
    return result;
  }

  void set_VectorStringAlsoNeedsConstructor(
      ::fidl::tracking_ptr<::fidl::VectorView<::fidl::StringView>>&& elem) {
    ordinal_ = Ordinal::kVectorStringAlsoNeedsConstructor;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::fidl::VectorView<::fidl::StringView>&
  mutable_VectorStringAlsoNeedsConstructor() {
    ZX_ASSERT(ordinal_ == Ordinal::kVectorStringAlsoNeedsConstructor);
    return *static_cast<::fidl::VectorView<::fidl::StringView>*>(
        envelope_.data.get());
  }
  const ::fidl::VectorView<::fidl::StringView>&
  VectorStringAlsoNeedsConstructor() const {
    ZX_ASSERT(ordinal_ == Ordinal::kVectorStringAlsoNeedsConstructor);
    return *static_cast<::fidl::VectorView<::fidl::StringView>*>(
        envelope_.data.get());
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &fidl_test_json_UnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;
  static constexpr bool IsResource = false;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPrimitive = 1,                         // 0x1
    kStringNeedsConstructor = 2,            // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  void reset_ptr(::fidl::tracking_ptr<void>&& new_ptr) {
    // To clear the existing value, std::move it and let it go out of scope.
    switch (static_cast<fidl_xunion_tag_t>(ordinal_)) {
      case 1: {
        ::fidl::tracking_ptr<int32_t> to_destroy =
            static_cast<::fidl::tracking_ptr<int32_t>>(
                std::move(envelope_.data));
        break;
      }
      case 2: {
        ::fidl::tracking_ptr<::fidl::StringView> to_destroy =
            static_cast<::fidl::tracking_ptr<::fidl::StringView>>(
                std::move(envelope_.data));
        break;
      }
      case 3: {
        ::fidl::tracking_ptr<::fidl::VectorView<::fidl::StringView>>
            to_destroy = static_cast<
                ::fidl::tracking_ptr<::fidl::VectorView<::fidl::StringView>>>(
                std::move(envelope_.data));
        break;
      }
    }

    envelope_.data = std::move(new_ptr);
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t fidl_test_json_StrictUnionTable;

class StrictUnion {
 public:
  StrictUnion() : ordinal_(Ordinal::Invalid), envelope_{} {}

  StrictUnion(StrictUnion&&) = default;
  StrictUnion& operator=(StrictUnion&&) = default;

  ~StrictUnion() { reset_ptr(nullptr); }

  enum class Tag : fidl_xunion_tag_t {
    kPrimitive = 1,                         // 0x1
    kStringNeedsConstructor = 2,            // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_Primitive() const { return ordinal_ == Ordinal::kPrimitive; }

  static StrictUnion WithPrimitive(::fidl::tracking_ptr<int32_t>&& val) {
    StrictUnion result;
    result.set_Primitive(std::move(val));
    return result;
  }

  void set_Primitive(::fidl::tracking_ptr<int32_t>&& elem) {
    ordinal_ = Ordinal::kPrimitive;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  int32_t& mutable_Primitive() {
    ZX_ASSERT(ordinal_ == Ordinal::kPrimitive);
    return *static_cast<int32_t*>(envelope_.data.get());
  }
  const int32_t& Primitive() const {
    ZX_ASSERT(ordinal_ == Ordinal::kPrimitive);
    return *static_cast<int32_t*>(envelope_.data.get());
  }

  bool is_StringNeedsConstructor() const {
    return ordinal_ == Ordinal::kStringNeedsConstructor;
  }

  static StrictUnion WithStringNeedsConstructor(
      ::fidl::tracking_ptr<::fidl::StringView>&& val) {
    StrictUnion result;
    result.set_StringNeedsConstructor(std::move(val));
    return result;
  }

  void set_StringNeedsConstructor(
      ::fidl::tracking_ptr<::fidl::StringView>&& elem) {
    ordinal_ = Ordinal::kStringNeedsConstructor;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::fidl::StringView& mutable_StringNeedsConstructor() {
    ZX_ASSERT(ordinal_ == Ordinal::kStringNeedsConstructor);
    return *static_cast<::fidl::StringView*>(envelope_.data.get());
  }
  const ::fidl::StringView& StringNeedsConstructor() const {
    ZX_ASSERT(ordinal_ == Ordinal::kStringNeedsConstructor);
    return *static_cast<::fidl::StringView*>(envelope_.data.get());
  }

  bool is_VectorStringAlsoNeedsConstructor() const {
    return ordinal_ == Ordinal::kVectorStringAlsoNeedsConstructor;
  }

  static StrictUnion WithVectorStringAlsoNeedsConstructor(
      ::fidl::tracking_ptr<::fidl::VectorView<::fidl::StringView>>&& val) {
    StrictUnion result;
    result.set_VectorStringAlsoNeedsConstructor(std::move(val));
    return result;
  }

  void set_VectorStringAlsoNeedsConstructor(
      ::fidl::tracking_ptr<::fidl::VectorView<::fidl::StringView>>&& elem) {
    ordinal_ = Ordinal::kVectorStringAlsoNeedsConstructor;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::fidl::VectorView<::fidl::StringView>&
  mutable_VectorStringAlsoNeedsConstructor() {
    ZX_ASSERT(ordinal_ == Ordinal::kVectorStringAlsoNeedsConstructor);
    return *static_cast<::fidl::VectorView<::fidl::StringView>*>(
        envelope_.data.get());
  }
  const ::fidl::VectorView<::fidl::StringView>&
  VectorStringAlsoNeedsConstructor() const {
    ZX_ASSERT(ordinal_ == Ordinal::kVectorStringAlsoNeedsConstructor);
    return *static_cast<::fidl::VectorView<::fidl::StringView>*>(
        envelope_.data.get());
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &fidl_test_json_StrictUnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;
  static constexpr bool IsResource = false;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPrimitive = 1,                         // 0x1
    kStringNeedsConstructor = 2,            // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  void reset_ptr(::fidl::tracking_ptr<void>&& new_ptr) {
    // To clear the existing value, std::move it and let it go out of scope.
    switch (static_cast<fidl_xunion_tag_t>(ordinal_)) {
      case 1: {
        ::fidl::tracking_ptr<int32_t> to_destroy =
            static_cast<::fidl::tracking_ptr<int32_t>>(
                std::move(envelope_.data));
        break;
      }
      case 2: {
        ::fidl::tracking_ptr<::fidl::StringView> to_destroy =
            static_cast<::fidl::tracking_ptr<::fidl::StringView>>(
                std::move(envelope_.data));
        break;
      }
      case 3: {
        ::fidl::tracking_ptr<::fidl::VectorView<::fidl::StringView>>
            to_destroy = static_cast<
                ::fidl::tracking_ptr<::fidl::VectorView<::fidl::StringView>>>(
                std::move(envelope_.data));
        break;
      }
    }

    envelope_.data = std::move(new_ptr);
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t fidl_test_json_StrictSimpleXUnionTable;

class StrictSimpleXUnion {
 public:
  StrictSimpleXUnion() : ordinal_(Ordinal::Invalid), envelope_{} {}

  StrictSimpleXUnion(StrictSimpleXUnion&&) = default;
  StrictSimpleXUnion& operator=(StrictSimpleXUnion&&) = default;

  ~StrictSimpleXUnion() { reset_ptr(nullptr); }

  enum class Tag : fidl_xunion_tag_t {
    kI = 1,  // 0x1
    kF = 2,  // 0x2
    kS = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_i() const { return ordinal_ == Ordinal::kI; }

  static StrictSimpleXUnion WithI(::fidl::tracking_ptr<int32_t>&& val) {
    StrictSimpleXUnion result;
    result.set_i(std::move(val));
    return result;
  }

  void set_i(::fidl::tracking_ptr<int32_t>&& elem) {
    ordinal_ = Ordinal::kI;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  int32_t& mutable_i() {
    ZX_ASSERT(ordinal_ == Ordinal::kI);
    return *static_cast<int32_t*>(envelope_.data.get());
  }
  const int32_t& i() const {
    ZX_ASSERT(ordinal_ == Ordinal::kI);
    return *static_cast<int32_t*>(envelope_.data.get());
  }

  bool is_f() const { return ordinal_ == Ordinal::kF; }

  static StrictSimpleXUnion WithF(::fidl::tracking_ptr<float>&& val) {
    StrictSimpleXUnion result;
    result.set_f(std::move(val));
    return result;
  }

  void set_f(::fidl::tracking_ptr<float>&& elem) {
    ordinal_ = Ordinal::kF;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  float& mutable_f() {
    ZX_ASSERT(ordinal_ == Ordinal::kF);
    return *static_cast<float*>(envelope_.data.get());
  }
  const float& f() const {
    ZX_ASSERT(ordinal_ == Ordinal::kF);
    return *static_cast<float*>(envelope_.data.get());
  }

  bool is_s() const { return ordinal_ == Ordinal::kS; }

  static StrictSimpleXUnion WithS(
      ::fidl::tracking_ptr<::fidl::StringView>&& val) {
    StrictSimpleXUnion result;
    result.set_s(std::move(val));
    return result;
  }

  void set_s(::fidl::tracking_ptr<::fidl::StringView>&& elem) {
    ordinal_ = Ordinal::kS;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::fidl::StringView& mutable_s() {
    ZX_ASSERT(ordinal_ == Ordinal::kS);
    return *static_cast<::fidl::StringView*>(envelope_.data.get());
  }
  const ::fidl::StringView& s() const {
    ZX_ASSERT(ordinal_ == Ordinal::kS);
    return *static_cast<::fidl::StringView*>(envelope_.data.get());
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type =
      &fidl_test_json_StrictSimpleXUnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;
  static constexpr bool IsResource = false;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kI = 1,  // 0x1
    kF = 2,  // 0x2
    kS = 3,  // 0x3
  };

  void reset_ptr(::fidl::tracking_ptr<void>&& new_ptr) {
    // To clear the existing value, std::move it and let it go out of scope.
    switch (static_cast<fidl_xunion_tag_t>(ordinal_)) {
      case 1: {
        ::fidl::tracking_ptr<int32_t> to_destroy =
            static_cast<::fidl::tracking_ptr<int32_t>>(
                std::move(envelope_.data));
        break;
      }
      case 2: {
        ::fidl::tracking_ptr<float> to_destroy =
            static_cast<::fidl::tracking_ptr<float>>(std::move(envelope_.data));
        break;
      }
      case 3: {
        ::fidl::tracking_ptr<::fidl::StringView> to_destroy =
            static_cast<::fidl::tracking_ptr<::fidl::StringView>>(
                std::move(envelope_.data));
        break;
      }
    }

    envelope_.data = std::move(new_ptr);
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t fidl_test_json_StrictFooTable;

class StrictFoo {
 public:
  StrictFoo() : ordinal_(Ordinal::Invalid), envelope_{} {}

  StrictFoo(StrictFoo&&) = default;
  StrictFoo& operator=(StrictFoo&&) = default;

  ~StrictFoo() { reset_ptr(nullptr); }

  enum class Tag : fidl_xunion_tag_t {
    kS = 1,  // 0x1
    kI = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_s() const { return ordinal_ == Ordinal::kS; }

  static StrictFoo WithS(::fidl::tracking_ptr<::fidl::StringView>&& val) {
    StrictFoo result;
    result.set_s(std::move(val));
    return result;
  }

  void set_s(::fidl::tracking_ptr<::fidl::StringView>&& elem) {
    ordinal_ = Ordinal::kS;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::fidl::StringView& mutable_s() {
    ZX_ASSERT(ordinal_ == Ordinal::kS);
    return *static_cast<::fidl::StringView*>(envelope_.data.get());
  }
  const ::fidl::StringView& s() const {
    ZX_ASSERT(ordinal_ == Ordinal::kS);
    return *static_cast<::fidl::StringView*>(envelope_.data.get());
  }

  bool is_i() const { return ordinal_ == Ordinal::kI; }

  static StrictFoo WithI(::fidl::tracking_ptr<int32_t>&& val) {
    StrictFoo result;
    result.set_i(std::move(val));
    return result;
  }

  void set_i(::fidl::tracking_ptr<int32_t>&& elem) {
    ordinal_ = Ordinal::kI;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  int32_t& mutable_i() {
    ZX_ASSERT(ordinal_ == Ordinal::kI);
    return *static_cast<int32_t*>(envelope_.data.get());
  }
  const int32_t& i() const {
    ZX_ASSERT(ordinal_ == Ordinal::kI);
    return *static_cast<int32_t*>(envelope_.data.get());
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &fidl_test_json_StrictFooTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;
  static constexpr bool IsResource = false;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kS = 1,  // 0x1
    kI = 2,  // 0x2
  };

  void reset_ptr(::fidl::tracking_ptr<void>&& new_ptr) {
    // To clear the existing value, std::move it and let it go out of scope.
    switch (static_cast<fidl_xunion_tag_t>(ordinal_)) {
      case 1: {
        ::fidl::tracking_ptr<::fidl::StringView> to_destroy =
            static_cast<::fidl::tracking_ptr<::fidl::StringView>>(
                std::move(envelope_.data));
        break;
      }
      case 2: {
        ::fidl::tracking_ptr<int32_t> to_destroy =
            static_cast<::fidl::tracking_ptr<int32_t>>(
                std::move(envelope_.data));
        break;
      }
    }

    envelope_.data = std::move(new_ptr);
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t fidl_test_json_StrictBoundedXUnionTable;

class StrictBoundedXUnion {
 public:
  StrictBoundedXUnion() : ordinal_(Ordinal::Invalid), envelope_{} {}

  StrictBoundedXUnion(StrictBoundedXUnion&&) = default;
  StrictBoundedXUnion& operator=(StrictBoundedXUnion&&) = default;

  ~StrictBoundedXUnion() { reset_ptr(nullptr); }

  enum class Tag : fidl_xunion_tag_t {
    kV = 1,  // 0x1
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_v() const { return ordinal_ == Ordinal::kV; }

  static StrictBoundedXUnion WithV(
      ::fidl::tracking_ptr<::fidl::VectorView<uint8_t>>&& val) {
    StrictBoundedXUnion result;
    result.set_v(std::move(val));
    return result;
  }

  void set_v(::fidl::tracking_ptr<::fidl::VectorView<uint8_t>>&& elem) {
    ordinal_ = Ordinal::kV;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::fidl::VectorView<uint8_t>& mutable_v() {
    ZX_ASSERT(ordinal_ == Ordinal::kV);
    return *static_cast<::fidl::VectorView<uint8_t>*>(envelope_.data.get());
  }
  const ::fidl::VectorView<uint8_t>& v() const {
    ZX_ASSERT(ordinal_ == Ordinal::kV);
    return *static_cast<::fidl::VectorView<uint8_t>*>(envelope_.data.get());
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type =
      &fidl_test_json_StrictBoundedXUnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 32;
  static constexpr bool HasPointer = true;
  static constexpr bool IsResource = false;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kV = 1,  // 0x1
  };

  void reset_ptr(::fidl::tracking_ptr<void>&& new_ptr) {
    // To clear the existing value, std::move it and let it go out of scope.
    switch (static_cast<fidl_xunion_tag_t>(ordinal_)) {
      case 1: {
        ::fidl::tracking_ptr<::fidl::VectorView<uint8_t>> to_destroy =
            static_cast<::fidl::tracking_ptr<::fidl::VectorView<uint8_t>>>(
                std::move(envelope_.data));
        break;
      }
    }

    envelope_.data = std::move(new_ptr);
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t fidl_test_json_ReverseOrdinalUnionTable;

class ReverseOrdinalUnion {
 public:
  ReverseOrdinalUnion() : ordinal_(Ordinal::Invalid), envelope_{} {}

  ReverseOrdinalUnion(ReverseOrdinalUnion&&) = default;
  ReverseOrdinalUnion& operator=(ReverseOrdinalUnion&&) = default;

  ~ReverseOrdinalUnion() { reset_ptr(nullptr); }

  enum class Tag : fidl_xunion_tag_t {
    kSecond = 2,  // 0x2
    kFirst = 1,   // 0x1
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_second() const { return ordinal_ == Ordinal::kSecond; }

  static ReverseOrdinalUnion WithSecond(::fidl::tracking_ptr<uint32_t>&& val) {
    ReverseOrdinalUnion result;
    result.set_second(std::move(val));
    return result;
  }

  void set_second(::fidl::tracking_ptr<uint32_t>&& elem) {
    ordinal_ = Ordinal::kSecond;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  uint32_t& mutable_second() {
    ZX_ASSERT(ordinal_ == Ordinal::kSecond);
    return *static_cast<uint32_t*>(envelope_.data.get());
  }
  const uint32_t& second() const {
    ZX_ASSERT(ordinal_ == Ordinal::kSecond);
    return *static_cast<uint32_t*>(envelope_.data.get());
  }

  bool is_first() const { return ordinal_ == Ordinal::kFirst; }

  static ReverseOrdinalUnion WithFirst(::fidl::tracking_ptr<uint32_t>&& val) {
    ReverseOrdinalUnion result;
    result.set_first(std::move(val));
    return result;
  }

  void set_first(::fidl::tracking_ptr<uint32_t>&& elem) {
    ordinal_ = Ordinal::kFirst;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  uint32_t& mutable_first() {
    ZX_ASSERT(ordinal_ == Ordinal::kFirst);
    return *static_cast<uint32_t*>(envelope_.data.get());
  }
  const uint32_t& first() const {
    ZX_ASSERT(ordinal_ == Ordinal::kFirst);
    return *static_cast<uint32_t*>(envelope_.data.get());
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type =
      &fidl_test_json_ReverseOrdinalUnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasPointer = true;
  static constexpr bool IsResource = false;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSecond = 2,  // 0x2
    kFirst = 1,   // 0x1
  };

  void reset_ptr(::fidl::tracking_ptr<void>&& new_ptr) {
    // To clear the existing value, std::move it and let it go out of scope.
    switch (static_cast<fidl_xunion_tag_t>(ordinal_)) {
      case 2: {
        ::fidl::tracking_ptr<uint32_t> to_destroy =
            static_cast<::fidl::tracking_ptr<uint32_t>>(
                std::move(envelope_.data));
        break;
      }
      case 1: {
        ::fidl::tracking_ptr<uint32_t> to_destroy =
            static_cast<::fidl::tracking_ptr<uint32_t>>(
                std::move(envelope_.data));
        break;
      }
    }

    envelope_.data = std::move(new_ptr);
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t fidl_test_json_StrictPizzaOrPastaTable;

class StrictPizzaOrPasta {
 public:
  StrictPizzaOrPasta() : ordinal_(Ordinal::Invalid), envelope_{} {}

  StrictPizzaOrPasta(StrictPizzaOrPasta&&) = default;
  StrictPizzaOrPasta& operator=(StrictPizzaOrPasta&&) = default;

  ~StrictPizzaOrPasta() { reset_ptr(nullptr); }

  enum class Tag : fidl_xunion_tag_t {
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_pizza() const { return ordinal_ == Ordinal::kPizza; }

  static StrictPizzaOrPasta WithPizza(
      ::fidl::tracking_ptr<::llcpp::fidl::test::json::Pizza>&& val) {
    StrictPizzaOrPasta result;
    result.set_pizza(std::move(val));
    return result;
  }

  void set_pizza(
      ::fidl::tracking_ptr<::llcpp::fidl::test::json::Pizza>&& elem) {
    ordinal_ = Ordinal::kPizza;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::llcpp::fidl::test::json::Pizza& mutable_pizza() {
    ZX_ASSERT(ordinal_ == Ordinal::kPizza);
    return *static_cast<::llcpp::fidl::test::json::Pizza*>(
        envelope_.data.get());
  }
  const ::llcpp::fidl::test::json::Pizza& pizza() const {
    ZX_ASSERT(ordinal_ == Ordinal::kPizza);
    return *static_cast<::llcpp::fidl::test::json::Pizza*>(
        envelope_.data.get());
  }

  bool is_pasta() const { return ordinal_ == Ordinal::kPasta; }

  static StrictPizzaOrPasta WithPasta(
      ::fidl::tracking_ptr<::llcpp::fidl::test::json::Pasta>&& val) {
    StrictPizzaOrPasta result;
    result.set_pasta(std::move(val));
    return result;
  }

  void set_pasta(
      ::fidl::tracking_ptr<::llcpp::fidl::test::json::Pasta>&& elem) {
    ordinal_ = Ordinal::kPasta;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::llcpp::fidl::test::json::Pasta& mutable_pasta() {
    ZX_ASSERT(ordinal_ == Ordinal::kPasta);
    return *static_cast<::llcpp::fidl::test::json::Pasta*>(
        envelope_.data.get());
  }
  const ::llcpp::fidl::test::json::Pasta& pasta() const {
    ZX_ASSERT(ordinal_ == Ordinal::kPasta);
    return *static_cast<::llcpp::fidl::test::json::Pasta*>(
        envelope_.data.get());
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type =
      &fidl_test_json_StrictPizzaOrPastaTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;
  static constexpr bool IsResource = false;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  void reset_ptr(::fidl::tracking_ptr<void>&& new_ptr) {
    // To clear the existing value, std::move it and let it go out of scope.
    switch (static_cast<fidl_xunion_tag_t>(ordinal_)) {
      case 1: {
        ::fidl::tracking_ptr<::llcpp::fidl::test::json::Pizza> to_destroy =
            static_cast<::fidl::tracking_ptr<::llcpp::fidl::test::json::Pizza>>(
                std::move(envelope_.data));
        break;
      }
      case 2: {
        ::fidl::tracking_ptr<::llcpp::fidl::test::json::Pasta> to_destroy =
            static_cast<::fidl::tracking_ptr<::llcpp::fidl::test::json::Pasta>>(
                std::move(envelope_.data));
        break;
      }
    }

    envelope_.data = std::move(new_ptr);
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t fidl_test_json_PizzaOrPastaTable;

class PizzaOrPasta {
 public:
  PizzaOrPasta() : ordinal_(Ordinal::Invalid), envelope_{} {}

  PizzaOrPasta(PizzaOrPasta&&) = default;
  PizzaOrPasta& operator=(PizzaOrPasta&&) = default;

  ~PizzaOrPasta() { reset_ptr(nullptr); }

  enum class Tag : fidl_xunion_tag_t {
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_pizza() const { return ordinal_ == Ordinal::kPizza; }

  static PizzaOrPasta WithPizza(
      ::fidl::tracking_ptr<::llcpp::fidl::test::json::Pizza>&& val) {
    PizzaOrPasta result;
    result.set_pizza(std::move(val));
    return result;
  }

  void set_pizza(
      ::fidl::tracking_ptr<::llcpp::fidl::test::json::Pizza>&& elem) {
    ordinal_ = Ordinal::kPizza;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::llcpp::fidl::test::json::Pizza& mutable_pizza() {
    ZX_ASSERT(ordinal_ == Ordinal::kPizza);
    return *static_cast<::llcpp::fidl::test::json::Pizza*>(
        envelope_.data.get());
  }
  const ::llcpp::fidl::test::json::Pizza& pizza() const {
    ZX_ASSERT(ordinal_ == Ordinal::kPizza);
    return *static_cast<::llcpp::fidl::test::json::Pizza*>(
        envelope_.data.get());
  }

  bool is_pasta() const { return ordinal_ == Ordinal::kPasta; }

  static PizzaOrPasta WithPasta(
      ::fidl::tracking_ptr<::llcpp::fidl::test::json::Pasta>&& val) {
    PizzaOrPasta result;
    result.set_pasta(std::move(val));
    return result;
  }

  void set_pasta(
      ::fidl::tracking_ptr<::llcpp::fidl::test::json::Pasta>&& elem) {
    ordinal_ = Ordinal::kPasta;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::llcpp::fidl::test::json::Pasta& mutable_pasta() {
    ZX_ASSERT(ordinal_ == Ordinal::kPasta);
    return *static_cast<::llcpp::fidl::test::json::Pasta*>(
        envelope_.data.get());
  }
  const ::llcpp::fidl::test::json::Pasta& pasta() const {
    ZX_ASSERT(ordinal_ == Ordinal::kPasta);
    return *static_cast<::llcpp::fidl::test::json::Pasta*>(
        envelope_.data.get());
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &fidl_test_json_PizzaOrPastaTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;
  static constexpr bool IsResource = false;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  void reset_ptr(::fidl::tracking_ptr<void>&& new_ptr) {
    // To clear the existing value, std::move it and let it go out of scope.
    switch (static_cast<fidl_xunion_tag_t>(ordinal_)) {
      case 1: {
        ::fidl::tracking_ptr<::llcpp::fidl::test::json::Pizza> to_destroy =
            static_cast<::fidl::tracking_ptr<::llcpp::fidl::test::json::Pizza>>(
                std::move(envelope_.data));
        break;
      }
      case 2: {
        ::fidl::tracking_ptr<::llcpp::fidl::test::json::Pasta> to_destroy =
            static_cast<::fidl::tracking_ptr<::llcpp::fidl::test::json::Pasta>>(
                std::move(envelope_.data));
        break;
      }
    }

    envelope_.data = std::move(new_ptr);
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t fidl_test_json_FlexiblePizzaOrPastaTable;

class FlexiblePizzaOrPasta {
 public:
  FlexiblePizzaOrPasta() : ordinal_(Ordinal::Invalid), envelope_{} {}

  FlexiblePizzaOrPasta(FlexiblePizzaOrPasta&&) = default;
  FlexiblePizzaOrPasta& operator=(FlexiblePizzaOrPasta&&) = default;

  ~FlexiblePizzaOrPasta() { reset_ptr(nullptr); }

  enum class Tag : fidl_xunion_tag_t {
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_pizza() const { return ordinal_ == Ordinal::kPizza; }

  static FlexiblePizzaOrPasta WithPizza(
      ::fidl::tracking_ptr<::llcpp::fidl::test::json::Pizza>&& val) {
    FlexiblePizzaOrPasta result;
    result.set_pizza(std::move(val));
    return result;
  }

  void set_pizza(
      ::fidl::tracking_ptr<::llcpp::fidl::test::json::Pizza>&& elem) {
    ordinal_ = Ordinal::kPizza;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::llcpp::fidl::test::json::Pizza& mutable_pizza() {
    ZX_ASSERT(ordinal_ == Ordinal::kPizza);
    return *static_cast<::llcpp::fidl::test::json::Pizza*>(
        envelope_.data.get());
  }
  const ::llcpp::fidl::test::json::Pizza& pizza() const {
    ZX_ASSERT(ordinal_ == Ordinal::kPizza);
    return *static_cast<::llcpp::fidl::test::json::Pizza*>(
        envelope_.data.get());
  }

  bool is_pasta() const { return ordinal_ == Ordinal::kPasta; }

  static FlexiblePizzaOrPasta WithPasta(
      ::fidl::tracking_ptr<::llcpp::fidl::test::json::Pasta>&& val) {
    FlexiblePizzaOrPasta result;
    result.set_pasta(std::move(val));
    return result;
  }

  void set_pasta(
      ::fidl::tracking_ptr<::llcpp::fidl::test::json::Pasta>&& elem) {
    ordinal_ = Ordinal::kPasta;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::llcpp::fidl::test::json::Pasta& mutable_pasta() {
    ZX_ASSERT(ordinal_ == Ordinal::kPasta);
    return *static_cast<::llcpp::fidl::test::json::Pasta*>(
        envelope_.data.get());
  }
  const ::llcpp::fidl::test::json::Pasta& pasta() const {
    ZX_ASSERT(ordinal_ == Ordinal::kPasta);
    return *static_cast<::llcpp::fidl::test::json::Pasta*>(
        envelope_.data.get());
  }
  void* unknownData() const {
    ZX_ASSERT(which() == Tag::kUnknown);
    return envelope_.data.get();
  }
  Tag which() const;

  static constexpr const fidl_type_t* Type =
      &fidl_test_json_FlexiblePizzaOrPastaTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;
  static constexpr bool IsResource = false;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  void reset_ptr(::fidl::tracking_ptr<void>&& new_ptr) {
    // To clear the existing value, std::move it and let it go out of scope.
    switch (static_cast<fidl_xunion_tag_t>(ordinal_)) {
      case 1: {
        ::fidl::tracking_ptr<::llcpp::fidl::test::json::Pizza> to_destroy =
            static_cast<::fidl::tracking_ptr<::llcpp::fidl::test::json::Pizza>>(
                std::move(envelope_.data));
        break;
      }
      case 2: {
        ::fidl::tracking_ptr<::llcpp::fidl::test::json::Pasta> to_destroy =
            static_cast<::fidl::tracking_ptr<::llcpp::fidl::test::json::Pasta>>(
                std::move(envelope_.data));
        break;
      }
    }

    envelope_.data = std::move(new_ptr);
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t fidl_test_json_ExplicitPizzaOrPastaTable;

class ExplicitPizzaOrPasta {
 public:
  ExplicitPizzaOrPasta() : ordinal_(Ordinal::Invalid), envelope_{} {}

  ExplicitPizzaOrPasta(ExplicitPizzaOrPasta&&) = default;
  ExplicitPizzaOrPasta& operator=(ExplicitPizzaOrPasta&&) = default;

  ~ExplicitPizzaOrPasta() { reset_ptr(nullptr); }

  enum class Tag : fidl_xunion_tag_t {
    kPizza = 1,  // 0x1
    kPasta = 4,  // 0x4
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_pizza() const { return ordinal_ == Ordinal::kPizza; }

  static ExplicitPizzaOrPasta WithPizza(
      ::fidl::tracking_ptr<::llcpp::fidl::test::json::Pizza>&& val) {
    ExplicitPizzaOrPasta result;
    result.set_pizza(std::move(val));
    return result;
  }

  void set_pizza(
      ::fidl::tracking_ptr<::llcpp::fidl::test::json::Pizza>&& elem) {
    ordinal_ = Ordinal::kPizza;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::llcpp::fidl::test::json::Pizza& mutable_pizza() {
    ZX_ASSERT(ordinal_ == Ordinal::kPizza);
    return *static_cast<::llcpp::fidl::test::json::Pizza*>(
        envelope_.data.get());
  }
  const ::llcpp::fidl::test::json::Pizza& pizza() const {
    ZX_ASSERT(ordinal_ == Ordinal::kPizza);
    return *static_cast<::llcpp::fidl::test::json::Pizza*>(
        envelope_.data.get());
  }

  bool is_pasta() const { return ordinal_ == Ordinal::kPasta; }

  static ExplicitPizzaOrPasta WithPasta(
      ::fidl::tracking_ptr<::llcpp::fidl::test::json::Pasta>&& val) {
    ExplicitPizzaOrPasta result;
    result.set_pasta(std::move(val));
    return result;
  }

  void set_pasta(
      ::fidl::tracking_ptr<::llcpp::fidl::test::json::Pasta>&& elem) {
    ordinal_ = Ordinal::kPasta;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::llcpp::fidl::test::json::Pasta& mutable_pasta() {
    ZX_ASSERT(ordinal_ == Ordinal::kPasta);
    return *static_cast<::llcpp::fidl::test::json::Pasta*>(
        envelope_.data.get());
  }
  const ::llcpp::fidl::test::json::Pasta& pasta() const {
    ZX_ASSERT(ordinal_ == Ordinal::kPasta);
    return *static_cast<::llcpp::fidl::test::json::Pasta*>(
        envelope_.data.get());
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type =
      &fidl_test_json_ExplicitPizzaOrPastaTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;
  static constexpr bool IsResource = false;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPizza = 1,  // 0x1
    kPasta = 4,  // 0x4
  };

  void reset_ptr(::fidl::tracking_ptr<void>&& new_ptr) {
    // To clear the existing value, std::move it and let it go out of scope.
    switch (static_cast<fidl_xunion_tag_t>(ordinal_)) {
      case 1: {
        ::fidl::tracking_ptr<::llcpp::fidl::test::json::Pizza> to_destroy =
            static_cast<::fidl::tracking_ptr<::llcpp::fidl::test::json::Pizza>>(
                std::move(envelope_.data));
        break;
      }
      case 4: {
        ::fidl::tracking_ptr<::llcpp::fidl::test::json::Pasta> to_destroy =
            static_cast<::fidl::tracking_ptr<::llcpp::fidl::test::json::Pasta>>(
                std::move(envelope_.data));
        break;
      }
    }

    envelope_.data = std::move(new_ptr);
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t fidl_test_json_OlderSimpleUnionTable;

class OlderSimpleUnion {
 public:
  OlderSimpleUnion() : ordinal_(Ordinal::Invalid), envelope_{} {}

  OlderSimpleUnion(OlderSimpleUnion&&) = default;
  OlderSimpleUnion& operator=(OlderSimpleUnion&&) = default;

  ~OlderSimpleUnion() { reset_ptr(nullptr); }

  enum class Tag : fidl_xunion_tag_t {
    kI = 1,  // 0x1
    kF = 2,  // 0x2
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_i() const { return ordinal_ == Ordinal::kI; }

  static OlderSimpleUnion WithI(::fidl::tracking_ptr<int64_t>&& val) {
    OlderSimpleUnion result;
    result.set_i(std::move(val));
    return result;
  }

  void set_i(::fidl::tracking_ptr<int64_t>&& elem) {
    ordinal_ = Ordinal::kI;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  int64_t& mutable_i() {
    ZX_ASSERT(ordinal_ == Ordinal::kI);
    return *static_cast<int64_t*>(envelope_.data.get());
  }
  const int64_t& i() const {
    ZX_ASSERT(ordinal_ == Ordinal::kI);
    return *static_cast<int64_t*>(envelope_.data.get());
  }

  bool is_f() const { return ordinal_ == Ordinal::kF; }

  static OlderSimpleUnion WithF(::fidl::tracking_ptr<float>&& val) {
    OlderSimpleUnion result;
    result.set_f(std::move(val));
    return result;
  }

  void set_f(::fidl::tracking_ptr<float>&& elem) {
    ordinal_ = Ordinal::kF;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  float& mutable_f() {
    ZX_ASSERT(ordinal_ == Ordinal::kF);
    return *static_cast<float*>(envelope_.data.get());
  }
  const float& f() const {
    ZX_ASSERT(ordinal_ == Ordinal::kF);
    return *static_cast<float*>(envelope_.data.get());
  }
  void* unknownData() const {
    ZX_ASSERT(which() == Tag::kUnknown);
    return envelope_.data.get();
  }
  Tag which() const;

  static constexpr const fidl_type_t* Type =
      &fidl_test_json_OlderSimpleUnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasPointer = true;
  static constexpr bool IsResource = false;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kI = 1,  // 0x1
    kF = 2,  // 0x2
  };

  void reset_ptr(::fidl::tracking_ptr<void>&& new_ptr) {
    // To clear the existing value, std::move it and let it go out of scope.
    switch (static_cast<fidl_xunion_tag_t>(ordinal_)) {
      case 1: {
        ::fidl::tracking_ptr<int64_t> to_destroy =
            static_cast<::fidl::tracking_ptr<int64_t>>(
                std::move(envelope_.data));
        break;
      }
      case 2: {
        ::fidl::tracking_ptr<float> to_destroy =
            static_cast<::fidl::tracking_ptr<float>>(std::move(envelope_.data));
        break;
      }
    }

    envelope_.data = std::move(new_ptr);
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t fidl_test_json_NewerSimpleUnionTable;

class NewerSimpleUnion {
 public:
  NewerSimpleUnion() : ordinal_(Ordinal::Invalid), envelope_{} {}

  NewerSimpleUnion(NewerSimpleUnion&&) = default;
  NewerSimpleUnion& operator=(NewerSimpleUnion&&) = default;

  ~NewerSimpleUnion() { reset_ptr(nullptr); }

  enum class Tag : fidl_xunion_tag_t {
    kI = 1,  // 0x1
    kS = 2,  // 0x2
    kV = 3,  // 0x3
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_i() const { return ordinal_ == Ordinal::kI; }

  static NewerSimpleUnion WithI(::fidl::tracking_ptr<int64_t>&& val) {
    NewerSimpleUnion result;
    result.set_i(std::move(val));
    return result;
  }

  void set_i(::fidl::tracking_ptr<int64_t>&& elem) {
    ordinal_ = Ordinal::kI;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  int64_t& mutable_i() {
    ZX_ASSERT(ordinal_ == Ordinal::kI);
    return *static_cast<int64_t*>(envelope_.data.get());
  }
  const int64_t& i() const {
    ZX_ASSERT(ordinal_ == Ordinal::kI);
    return *static_cast<int64_t*>(envelope_.data.get());
  }

  bool is_s() const { return ordinal_ == Ordinal::kS; }

  static NewerSimpleUnion WithS(
      ::fidl::tracking_ptr<::fidl::StringView>&& val) {
    NewerSimpleUnion result;
    result.set_s(std::move(val));
    return result;
  }

  void set_s(::fidl::tracking_ptr<::fidl::StringView>&& elem) {
    ordinal_ = Ordinal::kS;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::fidl::StringView& mutable_s() {
    ZX_ASSERT(ordinal_ == Ordinal::kS);
    return *static_cast<::fidl::StringView*>(envelope_.data.get());
  }
  const ::fidl::StringView& s() const {
    ZX_ASSERT(ordinal_ == Ordinal::kS);
    return *static_cast<::fidl::StringView*>(envelope_.data.get());
  }

  bool is_v() const { return ordinal_ == Ordinal::kV; }

  static NewerSimpleUnion WithV(
      ::fidl::tracking_ptr<::fidl::VectorView<::fidl::StringView>>&& val) {
    NewerSimpleUnion result;
    result.set_v(std::move(val));
    return result;
  }

  void set_v(
      ::fidl::tracking_ptr<::fidl::VectorView<::fidl::StringView>>&& elem) {
    ordinal_ = Ordinal::kV;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::fidl::VectorView<::fidl::StringView>& mutable_v() {
    ZX_ASSERT(ordinal_ == Ordinal::kV);
    return *static_cast<::fidl::VectorView<::fidl::StringView>*>(
        envelope_.data.get());
  }
  const ::fidl::VectorView<::fidl::StringView>& v() const {
    ZX_ASSERT(ordinal_ == Ordinal::kV);
    return *static_cast<::fidl::VectorView<::fidl::StringView>*>(
        envelope_.data.get());
  }
  void* unknownData() const {
    ZX_ASSERT(which() == Tag::kUnknown);
    return envelope_.data.get();
  }
  Tag which() const;

  static constexpr const fidl_type_t* Type =
      &fidl_test_json_NewerSimpleUnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;
  static constexpr bool IsResource = false;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kI = 1,  // 0x1
    kS = 2,  // 0x2
    kV = 3,  // 0x3
  };

  void reset_ptr(::fidl::tracking_ptr<void>&& new_ptr) {
    // To clear the existing value, std::move it and let it go out of scope.
    switch (static_cast<fidl_xunion_tag_t>(ordinal_)) {
      case 1: {
        ::fidl::tracking_ptr<int64_t> to_destroy =
            static_cast<::fidl::tracking_ptr<int64_t>>(
                std::move(envelope_.data));
        break;
      }
      case 2: {
        ::fidl::tracking_ptr<::fidl::StringView> to_destroy =
            static_cast<::fidl::tracking_ptr<::fidl::StringView>>(
                std::move(envelope_.data));
        break;
      }
      case 3: {
        ::fidl::tracking_ptr<::fidl::VectorView<::fidl::StringView>>
            to_destroy = static_cast<
                ::fidl::tracking_ptr<::fidl::VectorView<::fidl::StringView>>>(
                std::move(envelope_.data));
        break;
      }
    }

    envelope_.data = std::move(new_ptr);
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t fidl_test_json_FlexibleUnionTable;

class FlexibleUnion {
 public:
  FlexibleUnion() : ordinal_(Ordinal::Invalid), envelope_{} {}

  FlexibleUnion(FlexibleUnion&&) = default;
  FlexibleUnion& operator=(FlexibleUnion&&) = default;

  ~FlexibleUnion() { reset_ptr(nullptr); }

  enum class Tag : fidl_xunion_tag_t {
    kPrimitive = 1,                         // 0x1
    kStringNeedsConstructor = 2,            // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_Primitive() const { return ordinal_ == Ordinal::kPrimitive; }

  static FlexibleUnion WithPrimitive(::fidl::tracking_ptr<int32_t>&& val) {
    FlexibleUnion result;
    result.set_Primitive(std::move(val));
    return result;
  }

  void set_Primitive(::fidl::tracking_ptr<int32_t>&& elem) {
    ordinal_ = Ordinal::kPrimitive;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  int32_t& mutable_Primitive() {
    ZX_ASSERT(ordinal_ == Ordinal::kPrimitive);
    return *static_cast<int32_t*>(envelope_.data.get());
  }
  const int32_t& Primitive() const {
    ZX_ASSERT(ordinal_ == Ordinal::kPrimitive);
    return *static_cast<int32_t*>(envelope_.data.get());
  }

  bool is_StringNeedsConstructor() const {
    return ordinal_ == Ordinal::kStringNeedsConstructor;
  }

  static FlexibleUnion WithStringNeedsConstructor(
      ::fidl::tracking_ptr<::fidl::StringView>&& val) {
    FlexibleUnion result;
    result.set_StringNeedsConstructor(std::move(val));
    return result;
  }

  void set_StringNeedsConstructor(
      ::fidl::tracking_ptr<::fidl::StringView>&& elem) {
    ordinal_ = Ordinal::kStringNeedsConstructor;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::fidl::StringView& mutable_StringNeedsConstructor() {
    ZX_ASSERT(ordinal_ == Ordinal::kStringNeedsConstructor);
    return *static_cast<::fidl::StringView*>(envelope_.data.get());
  }
  const ::fidl::StringView& StringNeedsConstructor() const {
    ZX_ASSERT(ordinal_ == Ordinal::kStringNeedsConstructor);
    return *static_cast<::fidl::StringView*>(envelope_.data.get());
  }

  bool is_VectorStringAlsoNeedsConstructor() const {
    return ordinal_ == Ordinal::kVectorStringAlsoNeedsConstructor;
  }

  static FlexibleUnion WithVectorStringAlsoNeedsConstructor(
      ::fidl::tracking_ptr<::fidl::VectorView<::fidl::StringView>>&& val) {
    FlexibleUnion result;
    result.set_VectorStringAlsoNeedsConstructor(std::move(val));
    return result;
  }

  void set_VectorStringAlsoNeedsConstructor(
      ::fidl::tracking_ptr<::fidl::VectorView<::fidl::StringView>>&& elem) {
    ordinal_ = Ordinal::kVectorStringAlsoNeedsConstructor;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::fidl::VectorView<::fidl::StringView>&
  mutable_VectorStringAlsoNeedsConstructor() {
    ZX_ASSERT(ordinal_ == Ordinal::kVectorStringAlsoNeedsConstructor);
    return *static_cast<::fidl::VectorView<::fidl::StringView>*>(
        envelope_.data.get());
  }
  const ::fidl::VectorView<::fidl::StringView>&
  VectorStringAlsoNeedsConstructor() const {
    ZX_ASSERT(ordinal_ == Ordinal::kVectorStringAlsoNeedsConstructor);
    return *static_cast<::fidl::VectorView<::fidl::StringView>*>(
        envelope_.data.get());
  }
  void* unknownData() const {
    ZX_ASSERT(which() == Tag::kUnknown);
    return envelope_.data.get();
  }
  Tag which() const;

  static constexpr const fidl_type_t* Type = &fidl_test_json_FlexibleUnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;
  static constexpr bool IsResource = false;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPrimitive = 1,                         // 0x1
    kStringNeedsConstructor = 2,            // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  void reset_ptr(::fidl::tracking_ptr<void>&& new_ptr) {
    // To clear the existing value, std::move it and let it go out of scope.
    switch (static_cast<fidl_xunion_tag_t>(ordinal_)) {
      case 1: {
        ::fidl::tracking_ptr<int32_t> to_destroy =
            static_cast<::fidl::tracking_ptr<int32_t>>(
                std::move(envelope_.data));
        break;
      }
      case 2: {
        ::fidl::tracking_ptr<::fidl::StringView> to_destroy =
            static_cast<::fidl::tracking_ptr<::fidl::StringView>>(
                std::move(envelope_.data));
        break;
      }
      case 3: {
        ::fidl::tracking_ptr<::fidl::VectorView<::fidl::StringView>>
            to_destroy = static_cast<
                ::fidl::tracking_ptr<::fidl::VectorView<::fidl::StringView>>>(
                std::move(envelope_.data));
        break;
      }
    }

    envelope_.data = std::move(new_ptr);
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t fidl_test_json_FlexibleFooTable;

class FlexibleFoo {
 public:
  FlexibleFoo() : ordinal_(Ordinal::Invalid), envelope_{} {}

  FlexibleFoo(FlexibleFoo&&) = default;
  FlexibleFoo& operator=(FlexibleFoo&&) = default;

  ~FlexibleFoo() { reset_ptr(nullptr); }

  enum class Tag : fidl_xunion_tag_t {
    kS = 1,  // 0x1
    kI = 2,  // 0x2
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_s() const { return ordinal_ == Ordinal::kS; }

  static FlexibleFoo WithS(::fidl::tracking_ptr<::fidl::StringView>&& val) {
    FlexibleFoo result;
    result.set_s(std::move(val));
    return result;
  }

  void set_s(::fidl::tracking_ptr<::fidl::StringView>&& elem) {
    ordinal_ = Ordinal::kS;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::fidl::StringView& mutable_s() {
    ZX_ASSERT(ordinal_ == Ordinal::kS);
    return *static_cast<::fidl::StringView*>(envelope_.data.get());
  }
  const ::fidl::StringView& s() const {
    ZX_ASSERT(ordinal_ == Ordinal::kS);
    return *static_cast<::fidl::StringView*>(envelope_.data.get());
  }

  bool is_i() const { return ordinal_ == Ordinal::kI; }

  static FlexibleFoo WithI(::fidl::tracking_ptr<int32_t>&& val) {
    FlexibleFoo result;
    result.set_i(std::move(val));
    return result;
  }

  void set_i(::fidl::tracking_ptr<int32_t>&& elem) {
    ordinal_ = Ordinal::kI;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  int32_t& mutable_i() {
    ZX_ASSERT(ordinal_ == Ordinal::kI);
    return *static_cast<int32_t*>(envelope_.data.get());
  }
  const int32_t& i() const {
    ZX_ASSERT(ordinal_ == Ordinal::kI);
    return *static_cast<int32_t*>(envelope_.data.get());
  }
  void* unknownData() const {
    ZX_ASSERT(which() == Tag::kUnknown);
    return envelope_.data.get();
  }
  Tag which() const;

  static constexpr const fidl_type_t* Type = &fidl_test_json_FlexibleFooTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;
  static constexpr bool IsResource = false;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kS = 1,  // 0x1
    kI = 2,  // 0x2
  };

  void reset_ptr(::fidl::tracking_ptr<void>&& new_ptr) {
    // To clear the existing value, std::move it and let it go out of scope.
    switch (static_cast<fidl_xunion_tag_t>(ordinal_)) {
      case 1: {
        ::fidl::tracking_ptr<::fidl::StringView> to_destroy =
            static_cast<::fidl::tracking_ptr<::fidl::StringView>>(
                std::move(envelope_.data));
        break;
      }
      case 2: {
        ::fidl::tracking_ptr<int32_t> to_destroy =
            static_cast<::fidl::tracking_ptr<int32_t>>(
                std::move(envelope_.data));
        break;
      }
    }

    envelope_.data = std::move(new_ptr);
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t fidl_test_json_FieldCollisionTable;

class FieldCollision {
 public:
  FieldCollision() : ordinal_(Ordinal::Invalid), envelope_{} {}

  FieldCollision(FieldCollision&&) = default;
  FieldCollision& operator=(FieldCollision&&) = default;

  ~FieldCollision() { reset_ptr(nullptr); }

  enum class Tag : fidl_xunion_tag_t {
    kFieldCollisionTag = 1,  // 0x1
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_field_collision_tag() const {
    return ordinal_ == Ordinal::kFieldCollisionTag;
  }

  static FieldCollision WithFieldCollisionTag(
      ::fidl::tracking_ptr<int32_t>&& val) {
    FieldCollision result;
    result.set_field_collision_tag(std::move(val));
    return result;
  }

  void set_field_collision_tag(::fidl::tracking_ptr<int32_t>&& elem) {
    ordinal_ = Ordinal::kFieldCollisionTag;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  int32_t& mutable_field_collision_tag() {
    ZX_ASSERT(ordinal_ == Ordinal::kFieldCollisionTag);
    return *static_cast<int32_t*>(envelope_.data.get());
  }
  const int32_t& field_collision_tag() const {
    ZX_ASSERT(ordinal_ == Ordinal::kFieldCollisionTag);
    return *static_cast<int32_t*>(envelope_.data.get());
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type =
      &fidl_test_json_FieldCollisionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasPointer = true;
  static constexpr bool IsResource = false;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kFieldCollisionTag = 1,  // 0x1
  };

  void reset_ptr(::fidl::tracking_ptr<void>&& new_ptr) {
    // To clear the existing value, std::move it and let it go out of scope.
    switch (static_cast<fidl_xunion_tag_t>(ordinal_)) {
      case 1: {
        ::fidl::tracking_ptr<int32_t> to_destroy =
            static_cast<::fidl::tracking_ptr<int32_t>>(
                std::move(envelope_.data));
        break;
      }
    }

    envelope_.data = std::move(new_ptr);
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t fidl_test_json_ExplicitXUnionTable;

class ExplicitXUnion {
 public:
  ExplicitXUnion() : ordinal_(Ordinal::Invalid), envelope_{} {}

  ExplicitXUnion(ExplicitXUnion&&) = default;
  ExplicitXUnion& operator=(ExplicitXUnion&&) = default;

  ~ExplicitXUnion() { reset_ptr(nullptr); }

  enum class Tag : fidl_xunion_tag_t {
    kI = 1,  // 0x1
    kF = 4,  // 0x4
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_i() const { return ordinal_ == Ordinal::kI; }

  static ExplicitXUnion WithI(::fidl::tracking_ptr<int64_t>&& val) {
    ExplicitXUnion result;
    result.set_i(std::move(val));
    return result;
  }

  void set_i(::fidl::tracking_ptr<int64_t>&& elem) {
    ordinal_ = Ordinal::kI;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  int64_t& mutable_i() {
    ZX_ASSERT(ordinal_ == Ordinal::kI);
    return *static_cast<int64_t*>(envelope_.data.get());
  }
  const int64_t& i() const {
    ZX_ASSERT(ordinal_ == Ordinal::kI);
    return *static_cast<int64_t*>(envelope_.data.get());
  }

  bool is_f() const { return ordinal_ == Ordinal::kF; }

  static ExplicitXUnion WithF(::fidl::tracking_ptr<float>&& val) {
    ExplicitXUnion result;
    result.set_f(std::move(val));
    return result;
  }

  void set_f(::fidl::tracking_ptr<float>&& elem) {
    ordinal_ = Ordinal::kF;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  float& mutable_f() {
    ZX_ASSERT(ordinal_ == Ordinal::kF);
    return *static_cast<float*>(envelope_.data.get());
  }
  const float& f() const {
    ZX_ASSERT(ordinal_ == Ordinal::kF);
    return *static_cast<float*>(envelope_.data.get());
  }
  void* unknownData() const {
    ZX_ASSERT(which() == Tag::kUnknown);
    return envelope_.data.get();
  }
  Tag which() const;

  static constexpr const fidl_type_t* Type =
      &fidl_test_json_ExplicitXUnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasPointer = true;
  static constexpr bool IsResource = false;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kI = 1,  // 0x1
    kF = 4,  // 0x4
  };

  void reset_ptr(::fidl::tracking_ptr<void>&& new_ptr) {
    // To clear the existing value, std::move it and let it go out of scope.
    switch (static_cast<fidl_xunion_tag_t>(ordinal_)) {
      case 1: {
        ::fidl::tracking_ptr<int64_t> to_destroy =
            static_cast<::fidl::tracking_ptr<int64_t>>(
                std::move(envelope_.data));
        break;
      }
      case 4: {
        ::fidl::tracking_ptr<float> to_destroy =
            static_cast<::fidl::tracking_ptr<float>>(std::move(envelope_.data));
        break;
      }
    }

    envelope_.data = std::move(new_ptr);
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t fidl_test_json_ExplicitUnionTable;

class ExplicitUnion {
 public:
  ExplicitUnion() : ordinal_(Ordinal::Invalid), envelope_{} {}

  ExplicitUnion(ExplicitUnion&&) = default;
  ExplicitUnion& operator=(ExplicitUnion&&) = default;

  ~ExplicitUnion() { reset_ptr(nullptr); }

  enum class Tag : fidl_xunion_tag_t {
    kPrimitive = 1,               // 0x1
    kStringNeedsConstructor = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_Primitive() const { return ordinal_ == Ordinal::kPrimitive; }

  static ExplicitUnion WithPrimitive(::fidl::tracking_ptr<int32_t>&& val) {
    ExplicitUnion result;
    result.set_Primitive(std::move(val));
    return result;
  }

  void set_Primitive(::fidl::tracking_ptr<int32_t>&& elem) {
    ordinal_ = Ordinal::kPrimitive;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  int32_t& mutable_Primitive() {
    ZX_ASSERT(ordinal_ == Ordinal::kPrimitive);
    return *static_cast<int32_t*>(envelope_.data.get());
  }
  const int32_t& Primitive() const {
    ZX_ASSERT(ordinal_ == Ordinal::kPrimitive);
    return *static_cast<int32_t*>(envelope_.data.get());
  }

  bool is_StringNeedsConstructor() const {
    return ordinal_ == Ordinal::kStringNeedsConstructor;
  }

  static ExplicitUnion WithStringNeedsConstructor(
      ::fidl::tracking_ptr<::fidl::StringView>&& val) {
    ExplicitUnion result;
    result.set_StringNeedsConstructor(std::move(val));
    return result;
  }

  void set_StringNeedsConstructor(
      ::fidl::tracking_ptr<::fidl::StringView>&& elem) {
    ordinal_ = Ordinal::kStringNeedsConstructor;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::fidl::StringView& mutable_StringNeedsConstructor() {
    ZX_ASSERT(ordinal_ == Ordinal::kStringNeedsConstructor);
    return *static_cast<::fidl::StringView*>(envelope_.data.get());
  }
  const ::fidl::StringView& StringNeedsConstructor() const {
    ZX_ASSERT(ordinal_ == Ordinal::kStringNeedsConstructor);
    return *static_cast<::fidl::StringView*>(envelope_.data.get());
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &fidl_test_json_ExplicitUnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;
  static constexpr bool IsResource = false;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPrimitive = 1,               // 0x1
    kStringNeedsConstructor = 3,  // 0x3
  };

  void reset_ptr(::fidl::tracking_ptr<void>&& new_ptr) {
    // To clear the existing value, std::move it and let it go out of scope.
    switch (static_cast<fidl_xunion_tag_t>(ordinal_)) {
      case 1: {
        ::fidl::tracking_ptr<int32_t> to_destroy =
            static_cast<::fidl::tracking_ptr<int32_t>>(
                std::move(envelope_.data));
        break;
      }
      case 3: {
        ::fidl::tracking_ptr<::fidl::StringView> to_destroy =
            static_cast<::fidl::tracking_ptr<::fidl::StringView>>(
                std::move(envelope_.data));
        break;
      }
    }

    envelope_.data = std::move(new_ptr);
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t fidl_test_json_ExplicitStrictFooTable;

class ExplicitStrictFoo {
 public:
  ExplicitStrictFoo() : ordinal_(Ordinal::Invalid), envelope_{} {}

  ExplicitStrictFoo(ExplicitStrictFoo&&) = default;
  ExplicitStrictFoo& operator=(ExplicitStrictFoo&&) = default;

  ~ExplicitStrictFoo() { reset_ptr(nullptr); }

  enum class Tag : fidl_xunion_tag_t {
    kS = 3,  // 0x3
    kI = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_s() const { return ordinal_ == Ordinal::kS; }

  static ExplicitStrictFoo WithS(
      ::fidl::tracking_ptr<::fidl::StringView>&& val) {
    ExplicitStrictFoo result;
    result.set_s(std::move(val));
    return result;
  }

  void set_s(::fidl::tracking_ptr<::fidl::StringView>&& elem) {
    ordinal_ = Ordinal::kS;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::fidl::StringView& mutable_s() {
    ZX_ASSERT(ordinal_ == Ordinal::kS);
    return *static_cast<::fidl::StringView*>(envelope_.data.get());
  }
  const ::fidl::StringView& s() const {
    ZX_ASSERT(ordinal_ == Ordinal::kS);
    return *static_cast<::fidl::StringView*>(envelope_.data.get());
  }

  bool is_i() const { return ordinal_ == Ordinal::kI; }

  static ExplicitStrictFoo WithI(::fidl::tracking_ptr<int32_t>&& val) {
    ExplicitStrictFoo result;
    result.set_i(std::move(val));
    return result;
  }

  void set_i(::fidl::tracking_ptr<int32_t>&& elem) {
    ordinal_ = Ordinal::kI;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  int32_t& mutable_i() {
    ZX_ASSERT(ordinal_ == Ordinal::kI);
    return *static_cast<int32_t*>(envelope_.data.get());
  }
  const int32_t& i() const {
    ZX_ASSERT(ordinal_ == Ordinal::kI);
    return *static_cast<int32_t*>(envelope_.data.get());
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type =
      &fidl_test_json_ExplicitStrictFooTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;
  static constexpr bool IsResource = false;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kS = 3,  // 0x3
    kI = 2,  // 0x2
  };

  void reset_ptr(::fidl::tracking_ptr<void>&& new_ptr) {
    // To clear the existing value, std::move it and let it go out of scope.
    switch (static_cast<fidl_xunion_tag_t>(ordinal_)) {
      case 3: {
        ::fidl::tracking_ptr<::fidl::StringView> to_destroy =
            static_cast<::fidl::tracking_ptr<::fidl::StringView>>(
                std::move(envelope_.data));
        break;
      }
      case 2: {
        ::fidl::tracking_ptr<int32_t> to_destroy =
            static_cast<::fidl::tracking_ptr<int32_t>>(
                std::move(envelope_.data));
        break;
      }
    }

    envelope_.data = std::move(new_ptr);
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t fidl_test_json_ExplicitFooTable;

class ExplicitFoo {
 public:
  ExplicitFoo() : ordinal_(Ordinal::Invalid), envelope_{} {}

  ExplicitFoo(ExplicitFoo&&) = default;
  ExplicitFoo& operator=(ExplicitFoo&&) = default;

  ~ExplicitFoo() { reset_ptr(nullptr); }

  enum class Tag : fidl_xunion_tag_t {
    kS = 2,  // 0x2
    kI = 1,  // 0x1
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_s() const { return ordinal_ == Ordinal::kS; }

  static ExplicitFoo WithS(::fidl::tracking_ptr<::fidl::StringView>&& val) {
    ExplicitFoo result;
    result.set_s(std::move(val));
    return result;
  }

  void set_s(::fidl::tracking_ptr<::fidl::StringView>&& elem) {
    ordinal_ = Ordinal::kS;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::fidl::StringView& mutable_s() {
    ZX_ASSERT(ordinal_ == Ordinal::kS);
    return *static_cast<::fidl::StringView*>(envelope_.data.get());
  }
  const ::fidl::StringView& s() const {
    ZX_ASSERT(ordinal_ == Ordinal::kS);
    return *static_cast<::fidl::StringView*>(envelope_.data.get());
  }

  bool is_i() const { return ordinal_ == Ordinal::kI; }

  static ExplicitFoo WithI(::fidl::tracking_ptr<int32_t>&& val) {
    ExplicitFoo result;
    result.set_i(std::move(val));
    return result;
  }

  void set_i(::fidl::tracking_ptr<int32_t>&& elem) {
    ordinal_ = Ordinal::kI;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  int32_t& mutable_i() {
    ZX_ASSERT(ordinal_ == Ordinal::kI);
    return *static_cast<int32_t*>(envelope_.data.get());
  }
  const int32_t& i() const {
    ZX_ASSERT(ordinal_ == Ordinal::kI);
    return *static_cast<int32_t*>(envelope_.data.get());
  }
  void* unknownData() const {
    ZX_ASSERT(which() == Tag::kUnknown);
    return envelope_.data.get();
  }
  Tag which() const;

  static constexpr const fidl_type_t* Type = &fidl_test_json_ExplicitFooTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;
  static constexpr bool IsResource = false;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kS = 2,  // 0x2
    kI = 1,  // 0x1
  };

  void reset_ptr(::fidl::tracking_ptr<void>&& new_ptr) {
    // To clear the existing value, std::move it and let it go out of scope.
    switch (static_cast<fidl_xunion_tag_t>(ordinal_)) {
      case 2: {
        ::fidl::tracking_ptr<::fidl::StringView> to_destroy =
            static_cast<::fidl::tracking_ptr<::fidl::StringView>>(
                std::move(envelope_.data));
        break;
      }
      case 1: {
        ::fidl::tracking_ptr<int32_t> to_destroy =
            static_cast<::fidl::tracking_ptr<int32_t>>(
                std::move(envelope_.data));
        break;
      }
    }

    envelope_.data = std::move(new_ptr);
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t fidl_test_json_XUnionContainingEmptyStructTable;

class XUnionContainingEmptyStruct {
 public:
  XUnionContainingEmptyStruct() : ordinal_(Ordinal::Invalid), envelope_{} {}

  XUnionContainingEmptyStruct(XUnionContainingEmptyStruct&&) = default;
  XUnionContainingEmptyStruct& operator=(XUnionContainingEmptyStruct&&) =
      default;

  ~XUnionContainingEmptyStruct() { reset_ptr(nullptr); }

  enum class Tag : fidl_xunion_tag_t {
    kEmpty = 1,  // 0x1
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_empty() const { return ordinal_ == Ordinal::kEmpty; }

  static XUnionContainingEmptyStruct WithEmpty(
      ::fidl::tracking_ptr<::llcpp::fidl::test::json::Empty>&& val) {
    XUnionContainingEmptyStruct result;
    result.set_empty(std::move(val));
    return result;
  }

  void set_empty(
      ::fidl::tracking_ptr<::llcpp::fidl::test::json::Empty>&& elem) {
    ordinal_ = Ordinal::kEmpty;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::llcpp::fidl::test::json::Empty& mutable_empty() {
    ZX_ASSERT(ordinal_ == Ordinal::kEmpty);
    return *static_cast<::llcpp::fidl::test::json::Empty*>(
        envelope_.data.get());
  }
  const ::llcpp::fidl::test::json::Empty& empty() const {
    ZX_ASSERT(ordinal_ == Ordinal::kEmpty);
    return *static_cast<::llcpp::fidl::test::json::Empty*>(
        envelope_.data.get());
  }
  void* unknownData() const {
    ZX_ASSERT(which() == Tag::kUnknown);
    return envelope_.data.get();
  }
  Tag which() const;

  static constexpr const fidl_type_t* Type =
      &fidl_test_json_XUnionContainingEmptyStructTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasPointer = true;
  static constexpr bool IsResource = false;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kEmpty = 1,  // 0x1
  };

  void reset_ptr(::fidl::tracking_ptr<void>&& new_ptr) {
    // To clear the existing value, std::move it and let it go out of scope.
    switch (static_cast<fidl_xunion_tag_t>(ordinal_)) {
      case 1: {
        ::fidl::tracking_ptr<::llcpp::fidl::test::json::Empty> to_destroy =
            static_cast<::fidl::tracking_ptr<::llcpp::fidl::test::json::Empty>>(
                std::move(envelope_.data));
        break;
      }
    }

    envelope_.data = std::move(new_ptr);
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t fidl_test_json_StructWithNullableXUnionTable;

struct StructWithNullableXUnion {
  static constexpr const fidl_type_t* Type =
      &fidl_test_json_StructWithNullableXUnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasPointer = true;
  static constexpr bool IsResource = false;

  ::llcpp::fidl::test::json::OlderSimpleUnion x1 = {};
};

extern "C" const fidl_type_t fidl_test_json_PizzaTable;

struct Pizza {
  static constexpr const fidl_type_t* Type = &fidl_test_json_PizzaTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;
  static constexpr bool IsResource = false;

  ::fidl::VectorView<::fidl::StringView> toppings = {};
};

extern "C" const fidl_type_t fidl_test_json_PastaTable;

struct Pasta {
  static constexpr const fidl_type_t* Type = &fidl_test_json_PastaTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 16;
  static constexpr bool HasPointer = true;
  static constexpr bool IsResource = false;

  ::fidl::StringView sauce = {};
};

extern "C" const fidl_type_t
    fidl_test_json_TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedRequestTable;
extern "C" const fidl_type_t
    fidl_test_json_TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedResponseTable;
extern "C" const fidl_type_t
    fidl_test_json_TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedRequestTable;
extern "C" const fidl_type_t
    fidl_test_json_TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedResponseTable;

class TestProtocol final {
  TestProtocol() = delete;

 public:
  struct StrictXUnionHenceResponseMayBeStackAllocatedResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fidl::test::json::StrictBoundedXUnion xu;

    explicit StrictXUnionHenceResponseMayBeStackAllocatedResponse(
        ::llcpp::fidl::test::json::StrictBoundedXUnion& xu)
        : xu(std::move(xu)) {
      _InitHeader();
    }

    static constexpr const fidl_type_t* Type =
        &fidl_test_json_TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 32;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool IsResource = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;

   private:
    void _InitHeader();
  };
  using StrictXUnionHenceResponseMayBeStackAllocatedRequest =
      ::fidl::AnyZeroArgMessage;

  struct FlexibleXUnionHenceResponseMustBeHeapAllocatedResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fidl::test::json::OlderSimpleUnion xu;

    explicit FlexibleXUnionHenceResponseMustBeHeapAllocatedResponse(
        ::llcpp::fidl::test::json::OlderSimpleUnion& xu)
        : xu(std::move(xu)) {
      _InitHeader();
    }

    static constexpr const fidl_type_t* Type =
        &fidl_test_json_TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool IsResource = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;

   private:
    void _InitHeader();
  };
  using FlexibleXUnionHenceResponseMustBeHeapAllocatedRequest =
      ::fidl::AnyZeroArgMessage;

  // Collection of return types of FIDL calls in this protocol.
  class ResultOf final {
    ResultOf() = delete;

   private:
    template <typename ResponseType>
    class StrictXUnionHenceResponseMayBeStackAllocated_Impl final
        : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;

     public:
      StrictXUnionHenceResponseMayBeStackAllocated_Impl(
          ::zx::unowned_channel _client_end);
      ~StrictXUnionHenceResponseMayBeStackAllocated_Impl() = default;
      StrictXUnionHenceResponseMayBeStackAllocated_Impl(
          StrictXUnionHenceResponseMayBeStackAllocated_Impl&& other) = default;
      StrictXUnionHenceResponseMayBeStackAllocated_Impl& operator=(
          StrictXUnionHenceResponseMayBeStackAllocated_Impl&& other) = default;
      StrictXUnionHenceResponseMayBeStackAllocated_Impl(
          ::fidl::internal::StatusAndError&& other)
          : Super(std::move(other)) {}
      using Super::error;
      using Super::ok;
      using Super::status;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class FlexibleXUnionHenceResponseMustBeHeapAllocated_Impl final
        : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;

     public:
      FlexibleXUnionHenceResponseMustBeHeapAllocated_Impl(
          ::zx::unowned_channel _client_end);
      ~FlexibleXUnionHenceResponseMustBeHeapAllocated_Impl() = default;
      FlexibleXUnionHenceResponseMustBeHeapAllocated_Impl(
          FlexibleXUnionHenceResponseMustBeHeapAllocated_Impl&& other) =
          default;
      FlexibleXUnionHenceResponseMustBeHeapAllocated_Impl& operator=(
          FlexibleXUnionHenceResponseMustBeHeapAllocated_Impl&& other) =
          default;
      FlexibleXUnionHenceResponseMustBeHeapAllocated_Impl(
          ::fidl::internal::StatusAndError&& other)
          : Super(std::move(other)) {}
      using Super::error;
      using Super::ok;
      using Super::status;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using StrictXUnionHenceResponseMayBeStackAllocated =
        StrictXUnionHenceResponseMayBeStackAllocated_Impl<
            StrictXUnionHenceResponseMayBeStackAllocatedResponse>;
    using FlexibleXUnionHenceResponseMustBeHeapAllocated =
        FlexibleXUnionHenceResponseMustBeHeapAllocated_Impl<
            FlexibleXUnionHenceResponseMustBeHeapAllocatedResponse>;
  };

  // Collection of return types of FIDL calls in this protocol,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;

   private:
    template <typename ResponseType>
    class StrictXUnionHenceResponseMayBeStackAllocated_Impl final
        : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;

     public:
      StrictXUnionHenceResponseMayBeStackAllocated_Impl(
          ::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~StrictXUnionHenceResponseMayBeStackAllocated_Impl() = default;
      StrictXUnionHenceResponseMayBeStackAllocated_Impl(
          StrictXUnionHenceResponseMayBeStackAllocated_Impl&& other) = default;
      StrictXUnionHenceResponseMayBeStackAllocated_Impl& operator=(
          StrictXUnionHenceResponseMayBeStackAllocated_Impl&& other) = default;
      StrictXUnionHenceResponseMayBeStackAllocated_Impl(
          ::fidl::internal::StatusAndError&& other)
          : Super(std::move(other)) {}
      using Super::error;
      using Super::ok;
      using Super::status;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class FlexibleXUnionHenceResponseMustBeHeapAllocated_Impl final
        : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;

     public:
      FlexibleXUnionHenceResponseMustBeHeapAllocated_Impl(
          ::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~FlexibleXUnionHenceResponseMustBeHeapAllocated_Impl() = default;
      FlexibleXUnionHenceResponseMustBeHeapAllocated_Impl(
          FlexibleXUnionHenceResponseMustBeHeapAllocated_Impl&& other) =
          default;
      FlexibleXUnionHenceResponseMustBeHeapAllocated_Impl& operator=(
          FlexibleXUnionHenceResponseMustBeHeapAllocated_Impl&& other) =
          default;
      FlexibleXUnionHenceResponseMustBeHeapAllocated_Impl(
          ::fidl::internal::StatusAndError&& other)
          : Super(std::move(other)) {}
      using Super::error;
      using Super::ok;
      using Super::status;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using StrictXUnionHenceResponseMayBeStackAllocated =
        StrictXUnionHenceResponseMayBeStackAllocated_Impl<
            StrictXUnionHenceResponseMayBeStackAllocatedResponse>;
    using FlexibleXUnionHenceResponseMustBeHeapAllocated =
        FlexibleXUnionHenceResponseMustBeHeapAllocated_Impl<
            FlexibleXUnionHenceResponseMustBeHeapAllocatedResponse>;
  };

  class SyncClient final {
   public:
    SyncClient() = default;
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Allocates 88 bytes of message buffer on the stack. No heap allocation
    // necessary.
    ResultOf::StrictXUnionHenceResponseMayBeStackAllocated
    StrictXUnionHenceResponseMayBeStackAllocated();

    // Caller provides the backing storage for FIDL message via request and
    // response buffers.
    UnownedResultOf::StrictXUnionHenceResponseMayBeStackAllocated
    StrictXUnionHenceResponseMayBeStackAllocated(
        ::fidl::BytePart _response_buffer);

    // Allocates 16 bytes of request buffer on the stack. Response is
    // heap-allocated.
    ResultOf::FlexibleXUnionHenceResponseMustBeHeapAllocated
    FlexibleXUnionHenceResponseMustBeHeapAllocated();

    // Caller provides the backing storage for FIDL message via request and
    // response buffers.
    UnownedResultOf::FlexibleXUnionHenceResponseMustBeHeapAllocated
    FlexibleXUnionHenceResponseMustBeHeapAllocated(
        ::fidl::BytePart _response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding
  // setting up a client.
  class Call final {
    Call() = delete;

   public:
    // Allocates 88 bytes of message buffer on the stack. No heap allocation
    // necessary.
    static ResultOf::StrictXUnionHenceResponseMayBeStackAllocated
    StrictXUnionHenceResponseMayBeStackAllocated(
        ::zx::unowned_channel _client_end);

    // Caller provides the backing storage for FIDL message via request and
    // response buffers.
    static UnownedResultOf::StrictXUnionHenceResponseMayBeStackAllocated
    StrictXUnionHenceResponseMayBeStackAllocated(
        ::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Allocates 16 bytes of request buffer on the stack. Response is
    // heap-allocated.
    static ResultOf::FlexibleXUnionHenceResponseMustBeHeapAllocated
    FlexibleXUnionHenceResponseMustBeHeapAllocated(
        ::zx::unowned_channel _client_end);

    // Caller provides the backing storage for FIDL message via request and
    // response buffers.
    static UnownedResultOf::FlexibleXUnionHenceResponseMustBeHeapAllocated
    FlexibleXUnionHenceResponseMustBeHeapAllocated(
        ::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL
  // wire-format.
  class InPlace final {
    InPlace() = delete;

   public:
    static ::fidl::DecodeResult<
        StrictXUnionHenceResponseMayBeStackAllocatedResponse>
    StrictXUnionHenceResponseMayBeStackAllocated(
        ::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<
        FlexibleXUnionHenceResponseMustBeHeapAllocatedResponse>
    FlexibleXUnionHenceResponseMustBeHeapAllocated(
        ::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);
  };

  struct AsyncEventHandlers;
  class StrictXUnionHenceResponseMayBeStackAllocatedResponseContext;
  class FlexibleXUnionHenceResponseMustBeHeapAllocatedResponseContext;
  class ClientImpl;

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = TestProtocol;
    using _Base = ::fidl::CompleterBase;

    class StrictXUnionHenceResponseMayBeStackAllocatedCompleterBase
        : public _Base {
     public:
      void Reply(::llcpp::fidl::test::json::StrictBoundedXUnion xu);
      void Reply(::fidl::BytePart _buffer,
                 ::llcpp::fidl::test::json::StrictBoundedXUnion xu);
      void Reply(::fidl::DecodedMessage<
                 StrictXUnionHenceResponseMayBeStackAllocatedResponse>
                     params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using StrictXUnionHenceResponseMayBeStackAllocatedCompleter =
        ::fidl::Completer<
            StrictXUnionHenceResponseMayBeStackAllocatedCompleterBase>;

    virtual void StrictXUnionHenceResponseMayBeStackAllocated(
        StrictXUnionHenceResponseMayBeStackAllocatedCompleter::Sync
            _completer) = 0;

    class FlexibleXUnionHenceResponseMustBeHeapAllocatedCompleterBase
        : public _Base {
     public:
      void Reply(::llcpp::fidl::test::json::OlderSimpleUnion xu);
      void Reply(::fidl::BytePart _buffer,
                 ::llcpp::fidl::test::json::OlderSimpleUnion xu);
      void Reply(::fidl::DecodedMessage<
                 FlexibleXUnionHenceResponseMustBeHeapAllocatedResponse>
                     params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using FlexibleXUnionHenceResponseMustBeHeapAllocatedCompleter =
        ::fidl::Completer<
            FlexibleXUnionHenceResponseMustBeHeapAllocatedCompleterBase>;

    virtual void FlexibleXUnionHenceResponseMustBeHeapAllocated(
        FlexibleXUnionHenceResponseMustBeHeapAllocatedCompleter::Sync
            _completer) = 0;
  };

  // Attempts to dispatch the incoming message to a handler function in the
  // server implementation. If there is no matching handler, it returns false,
  // leaving the message and transaction intact. In all other cases, it consumes
  // the message and returns true. It is possible to chain multiple TryDispatch
  // functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg,
                          ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the
  // protocol. If there is no matching handler, it closes all the handles in
  // |msg| and closes the channel with a |ZX_ERR_NOT_SUPPORTED| epitaph, before
  // returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg,
                       ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used
  // with |fidl::Bind| to reduce template expansion. Do not call this method
  // manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg,
                                 ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

  class EventSender;

  // Helper functions to fill in the transaction header in a
  // |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;

   public:
    static void StrictXUnionHenceResponseMayBeStackAllocatedRequest(
        const ::fidl::DecodedMessage<
            TestProtocol::StrictXUnionHenceResponseMayBeStackAllocatedRequest>&
            _msg,
        zx_txid_t _txid = 0);
    static void StrictXUnionHenceResponseMayBeStackAllocatedRequest(
        const ::fidl::EncodedMessage<
            TestProtocol::StrictXUnionHenceResponseMayBeStackAllocatedRequest>&
            _msg,
        zx_txid_t _txid = 0);
    static void FlexibleXUnionHenceResponseMustBeHeapAllocatedRequest(
        const ::fidl::DecodedMessage<
            TestProtocol::
                FlexibleXUnionHenceResponseMustBeHeapAllocatedRequest>& _msg,
        zx_txid_t _txid = 0);
    static void FlexibleXUnionHenceResponseMustBeHeapAllocatedRequest(
        const ::fidl::EncodedMessage<
            TestProtocol::
                FlexibleXUnionHenceResponseMustBeHeapAllocatedRequest>& _msg,
        zx_txid_t _txid = 0);
  };
};

extern "C" const fidl_type_t fidl_test_json_NullableUnionStructTable;

struct NullableUnionStruct {
  static constexpr const fidl_type_t* Type =
      &fidl_test_json_NullableUnionStructTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;
  static constexpr bool IsResource = false;

  ::llcpp::fidl::test::json::Union the_union = {};
};

extern "C" const fidl_type_t fidl_test_json_EmptyTable;

struct Empty {
  static constexpr const fidl_type_t* Type = &fidl_test_json_EmptyTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;
  static constexpr bool IsResource = false;

  uint8_t __reserved = {};
};

}  // namespace json
}  // namespace test
}  // namespace fidl
}  // namespace llcpp

namespace fidl {

template <>
struct IsFidlType<::llcpp::fidl::test::json::Union> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fidl::test::json::Union>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::StructWithNullableXUnion>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::llcpp::fidl::test::json::StructWithNullableXUnion>);
static_assert(offsetof(::llcpp::fidl::test::json::StructWithNullableXUnion,
                       x1) == 0);
static_assert(sizeof(::llcpp::fidl::test::json::StructWithNullableXUnion) ==
              ::llcpp::fidl::test::json::StructWithNullableXUnion::PrimarySize);

template <>
struct IsFidlType<::llcpp::fidl::test::json::StrictUnion>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::llcpp::fidl::test::json::StrictUnion>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::StrictSimpleXUnion>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::llcpp::fidl::test::json::StrictSimpleXUnion>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::StrictFoo>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fidl::test::json::StrictFoo>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::StrictBoundedXUnion>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::llcpp::fidl::test::json::StrictBoundedXUnion>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::ReverseOrdinalUnion>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::llcpp::fidl::test::json::ReverseOrdinalUnion>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::Pizza> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fidl::test::json::Pizza>);
static_assert(offsetof(::llcpp::fidl::test::json::Pizza, toppings) == 0);
static_assert(sizeof(::llcpp::fidl::test::json::Pizza) ==
              ::llcpp::fidl::test::json::Pizza::PrimarySize);

template <>
struct IsFidlType<::llcpp::fidl::test::json::Pasta> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fidl::test::json::Pasta>);
static_assert(offsetof(::llcpp::fidl::test::json::Pasta, sauce) == 0);
static_assert(sizeof(::llcpp::fidl::test::json::Pasta) ==
              ::llcpp::fidl::test::json::Pasta::PrimarySize);

template <>
struct IsFidlType<::llcpp::fidl::test::json::StrictPizzaOrPasta>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::llcpp::fidl::test::json::StrictPizzaOrPasta>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::PizzaOrPasta>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::llcpp::fidl::test::json::PizzaOrPasta>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::FlexiblePizzaOrPasta>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::llcpp::fidl::test::json::FlexiblePizzaOrPasta>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::ExplicitPizzaOrPasta>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::llcpp::fidl::test::json::ExplicitPizzaOrPasta>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::OlderSimpleUnion>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::llcpp::fidl::test::json::OlderSimpleUnion>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::TestProtocol::
                      StrictXUnionHenceResponseMayBeStackAllocatedResponse>
    : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fidl::test::json::TestProtocol::
                         StrictXUnionHenceResponseMayBeStackAllocatedResponse>
    : public std::true_type {};
static_assert(
    sizeof(::llcpp::fidl::test::json::TestProtocol::
               StrictXUnionHenceResponseMayBeStackAllocatedResponse) ==
    ::llcpp::fidl::test::json::TestProtocol::
        StrictXUnionHenceResponseMayBeStackAllocatedResponse::PrimarySize);
static_assert(offsetof(::llcpp::fidl::test::json::TestProtocol::
                           StrictXUnionHenceResponseMayBeStackAllocatedResponse,
                       xu) == 16);

template <>
struct IsFidlType<::llcpp::fidl::test::json::TestProtocol::
                      FlexibleXUnionHenceResponseMustBeHeapAllocatedResponse>
    : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fidl::test::json::TestProtocol::
                         FlexibleXUnionHenceResponseMustBeHeapAllocatedResponse>
    : public std::true_type {};
static_assert(
    sizeof(::llcpp::fidl::test::json::TestProtocol::
               FlexibleXUnionHenceResponseMustBeHeapAllocatedResponse) ==
    ::llcpp::fidl::test::json::TestProtocol::
        FlexibleXUnionHenceResponseMustBeHeapAllocatedResponse::PrimarySize);
static_assert(
    offsetof(::llcpp::fidl::test::json::TestProtocol::
                 FlexibleXUnionHenceResponseMustBeHeapAllocatedResponse,
             xu) == 16);

template <>
struct IsFidlType<::llcpp::fidl::test::json::NullableUnionStruct>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::llcpp::fidl::test::json::NullableUnionStruct>);
static_assert(offsetof(::llcpp::fidl::test::json::NullableUnionStruct,
                       the_union) == 0);
static_assert(sizeof(::llcpp::fidl::test::json::NullableUnionStruct) ==
              ::llcpp::fidl::test::json::NullableUnionStruct::PrimarySize);

template <>
struct IsFidlType<::llcpp::fidl::test::json::NewerSimpleUnion>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::llcpp::fidl::test::json::NewerSimpleUnion>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::FlexibleUnion>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::llcpp::fidl::test::json::FlexibleUnion>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::FlexibleFoo>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::llcpp::fidl::test::json::FlexibleFoo>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::FieldCollision>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::llcpp::fidl::test::json::FieldCollision>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::ExplicitXUnion>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::llcpp::fidl::test::json::ExplicitXUnion>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::ExplicitUnion>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::llcpp::fidl::test::json::ExplicitUnion>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::ExplicitStrictFoo>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::llcpp::fidl::test::json::ExplicitStrictFoo>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::ExplicitFoo>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::llcpp::fidl::test::json::ExplicitFoo>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::Empty> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fidl::test::json::Empty>);
static_assert(offsetof(::llcpp::fidl::test::json::Empty, __reserved) == 0);
static_assert(sizeof(::llcpp::fidl::test::json::Empty) ==
              ::llcpp::fidl::test::json::Empty::PrimarySize);

template <>
struct IsFidlType<::llcpp::fidl::test::json::XUnionContainingEmptyStruct>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::llcpp::fidl::test::json::XUnionContainingEmptyStruct>);

}  // namespace fidl

namespace llcpp {

namespace fidl {
namespace test {
namespace json {

struct TestProtocol::AsyncEventHandlers {};

class TestProtocol::StrictXUnionHenceResponseMayBeStackAllocatedResponseContext
    : public ::fidl::internal::ResponseContext {
 public:
  virtual ~StrictXUnionHenceResponseMayBeStackAllocatedResponseContext() =
      default;
  virtual void OnReply(::fidl::DecodedMessage<
                       StrictXUnionHenceResponseMayBeStackAllocatedResponse>
                           msg) = 0;

 protected:
  StrictXUnionHenceResponseMayBeStackAllocatedResponseContext() = default;
};

class TestProtocol::
    FlexibleXUnionHenceResponseMustBeHeapAllocatedResponseContext
    : public ::fidl::internal::ResponseContext {
 public:
  virtual ~FlexibleXUnionHenceResponseMustBeHeapAllocatedResponseContext() =
      default;
  virtual void OnReply(::fidl::DecodedMessage<
                       FlexibleXUnionHenceResponseMustBeHeapAllocatedResponse>
                           msg) = 0;

 protected:
  FlexibleXUnionHenceResponseMustBeHeapAllocatedResponseContext() = default;
};

class TestProtocol::ClientImpl final : private ::fidl::internal::ClientBase {
 public:
  // Asynchronous variant of
  // |TestProtocol.StrictXUnionHenceResponseMayBeStackAllocated()|. Allocates 16
  // bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::StatusAndError StrictXUnionHenceResponseMayBeStackAllocated(
      ::fit::callback<void(::llcpp::fidl::test::json::StrictBoundedXUnion xu)>
          _cb);

  // Asynchronous variant of
  // |TestProtocol.StrictXUnionHenceResponseMayBeStackAllocated()|. Caller
  // provides the backing storage for FIDL message via request and response
  // buffers. Ownership of _context is given unsafely to the binding until
  // OnError() or OnReply() are called on it.
  ::fidl::StatusAndError StrictXUnionHenceResponseMayBeStackAllocated(
      StrictXUnionHenceResponseMayBeStackAllocatedResponseContext* _context);
  // Synchronous variant of
  // |TestProtocol.StrictXUnionHenceResponseMayBeStackAllocated()|. Allocates 88
  // bytes of message buffer on the stack. No heap allocation necessary.
  ResultOf::StrictXUnionHenceResponseMayBeStackAllocated
  StrictXUnionHenceResponseMayBeStackAllocated_Sync();

  // Synchronous variant of
  // |TestProtocol.StrictXUnionHenceResponseMayBeStackAllocated()|. Caller
  // provides the backing storage for FIDL message via request and response
  // buffers.
  UnownedResultOf::StrictXUnionHenceResponseMayBeStackAllocated
  StrictXUnionHenceResponseMayBeStackAllocated_Sync(
      ::fidl::BytePart _response_buffer);

  // Asynchronous variant of
  // |TestProtocol.FlexibleXUnionHenceResponseMustBeHeapAllocated()|. Allocates
  // 16 bytes of request buffer on the stack. The callback is stored on the
  // heap.
  ::fidl::StatusAndError FlexibleXUnionHenceResponseMustBeHeapAllocated(
      ::fit::callback<void(::llcpp::fidl::test::json::OlderSimpleUnion xu)>
          _cb);

  // Asynchronous variant of
  // |TestProtocol.FlexibleXUnionHenceResponseMustBeHeapAllocated()|. Caller
  // provides the backing storage for FIDL message via request and response
  // buffers. Ownership of _context is given unsafely to the binding until
  // OnError() or OnReply() are called on it.
  ::fidl::StatusAndError FlexibleXUnionHenceResponseMustBeHeapAllocated(
      FlexibleXUnionHenceResponseMustBeHeapAllocatedResponseContext* _context);
  // Synchronous variant of
  // |TestProtocol.FlexibleXUnionHenceResponseMustBeHeapAllocated()|. Allocates
  // 16 bytes of request buffer on the stack. Response is heap-allocated.
  ResultOf::FlexibleXUnionHenceResponseMustBeHeapAllocated
  FlexibleXUnionHenceResponseMustBeHeapAllocated_Sync();

  // Synchronous variant of
  // |TestProtocol.FlexibleXUnionHenceResponseMustBeHeapAllocated()|. Caller
  // provides the backing storage for FIDL message via request and response
  // buffers.
  UnownedResultOf::FlexibleXUnionHenceResponseMustBeHeapAllocated
  FlexibleXUnionHenceResponseMustBeHeapAllocated_Sync(
      ::fidl::BytePart _response_buffer);

 private:
  friend class ::fidl::Client<TestProtocol>;

  ClientImpl(::zx::channel client_end, async_dispatcher_t* dispatcher,
             ::fidl::internal::TypeErasedOnUnboundFn on_unbound,
             AsyncEventHandlers handlers)
      : ::fidl::internal::ClientBase(std::move(client_end), dispatcher,
                                     std::move(on_unbound)),
        handlers_(std::move(handlers)) {}

  zx_status_t Dispatch(fidl_msg_t* msg,
                       ::fidl::internal::ResponseContext* context) override;

  AsyncEventHandlers handlers_;
};

class TestProtocol::EventSender {
 public:
 private:
  friend class ::fidl::ServerBinding<TestProtocol>;

  explicit EventSender(std::weak_ptr<::fidl::internal::AsyncBinding> binding)
      : binding_(std::move(binding)) {}

  std::weak_ptr<::fidl::internal::AsyncBinding> binding_;
};

}  // namespace json
}  // namespace test
}  // namespace fidl
}  // namespace llcpp

// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/txn_header.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/connect_service.h>
#include <lib/fidl/llcpp/envelope.h>
#include <lib/fidl/llcpp/service_handler_interface.h>
#include <lib/fidl/llcpp/string_view.h>
#include <lib/fidl/llcpp/sync_call.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/tracking_ptr.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/fidl/llcpp/vector_view.h>
#include <lib/fit/function.h>
#include <zircon/fidl.h>

namespace llcpp {

namespace fidl {
namespace test {
namespace json {

class Union;
class StrictUnion;
class ReverseOrdinalUnion;
struct Pizza;
struct Pasta;
class StrictPizzaOrPasta;
class PizzaOrPasta;
class FlexiblePizzaOrPasta;
class ExplicitPizzaOrPasta;
struct NullableUnionStruct;
class FlexibleUnion;
class FieldCollision;
class ExplicitUnion;

extern "C" const fidl_type_t v1_fidl_test_json_UnionTable;

class Union {
  public:
  Union() : ordinal_(Ordinal::Invalid), envelope_{} {}

  Union(Union&&) = default;
  Union& operator=(Union&&) = default;

  ~Union() {
    reset_ptr(nullptr);
  }

  enum class Tag : fidl_xunion_tag_t {
    kPrimitive = 1,  // 0x1
    kStringNeedsConstructor = 2,  // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_Primitive() const { return ordinal_ == Ordinal::kPrimitive; }

  static Union WithPrimitive(::fidl::tracking_ptr<int32_t>&& val) {
    Union result;
    result.set_Primitive(std::move(val));
    return result;
  }

  void set_Primitive(::fidl::tracking_ptr<int32_t>&& elem) {
    ordinal_ = Ordinal::kPrimitive;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  int32_t& mutable_Primitive() {
    ZX_ASSERT(ordinal_ == Ordinal::kPrimitive);
    return *static_cast<int32_t*>(envelope_.data.get());
  }
  const int32_t& Primitive() const {
    ZX_ASSERT(ordinal_ == Ordinal::kPrimitive);
    return *static_cast<int32_t*>(envelope_.data.get());
  }

  bool is_StringNeedsConstructor() const { return ordinal_ == Ordinal::kStringNeedsConstructor; }

  static Union WithStringNeedsConstructor(::fidl::tracking_ptr<::fidl::StringView>&& val) {
    Union result;
    result.set_StringNeedsConstructor(std::move(val));
    return result;
  }

  void set_StringNeedsConstructor(::fidl::tracking_ptr<::fidl::StringView>&& elem) {
    ordinal_ = Ordinal::kStringNeedsConstructor;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::fidl::StringView& mutable_StringNeedsConstructor() {
    ZX_ASSERT(ordinal_ == Ordinal::kStringNeedsConstructor);
    return *static_cast<::fidl::StringView*>(envelope_.data.get());
  }
  const ::fidl::StringView& StringNeedsConstructor() const {
    ZX_ASSERT(ordinal_ == Ordinal::kStringNeedsConstructor);
    return *static_cast<::fidl::StringView*>(envelope_.data.get());
  }

  bool is_VectorStringAlsoNeedsConstructor() const { return ordinal_ == Ordinal::kVectorStringAlsoNeedsConstructor; }

  static Union WithVectorStringAlsoNeedsConstructor(::fidl::tracking_ptr<::fidl::VectorView<::fidl::StringView>>&& val) {
    Union result;
    result.set_VectorStringAlsoNeedsConstructor(std::move(val));
    return result;
  }

  void set_VectorStringAlsoNeedsConstructor(::fidl::tracking_ptr<::fidl::VectorView<::fidl::StringView>>&& elem) {
    ordinal_ = Ordinal::kVectorStringAlsoNeedsConstructor;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::fidl::VectorView<::fidl::StringView>& mutable_VectorStringAlsoNeedsConstructor() {
    ZX_ASSERT(ordinal_ == Ordinal::kVectorStringAlsoNeedsConstructor);
    return *static_cast<::fidl::VectorView<::fidl::StringView>*>(envelope_.data.get());
  }
  const ::fidl::VectorView<::fidl::StringView>& VectorStringAlsoNeedsConstructor() const {
    ZX_ASSERT(ordinal_ == Ordinal::kVectorStringAlsoNeedsConstructor);
    return *static_cast<::fidl::VectorView<::fidl::StringView>*>(envelope_.data.get());
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &v1_fidl_test_json_UnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPrimitive = 1,  // 0x1
    kStringNeedsConstructor = 2,  // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  void reset_ptr(::fidl::tracking_ptr<void>&& new_ptr) {
    // To clear the existing value, std::move it and let it go out of scope.
    switch (static_cast<fidl_xunion_tag_t>(ordinal_)) {
    case 1: {
      ::fidl::tracking_ptr<int32_t> to_destroy =
        static_cast<::fidl::tracking_ptr<int32_t>>(std::move(envelope_.data));
      break;
    }
    case 2: {
      ::fidl::tracking_ptr<::fidl::StringView> to_destroy =
        static_cast<::fidl::tracking_ptr<::fidl::StringView>>(std::move(envelope_.data));
      break;
    }
    case 3: {
      ::fidl::tracking_ptr<::fidl::VectorView<::fidl::StringView>> to_destroy =
        static_cast<::fidl::tracking_ptr<::fidl::VectorView<::fidl::StringView>>>(std::move(envelope_.data));
      break;
    }
    }

    envelope_.data = std::move(new_ptr);
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t v1_fidl_test_json_StrictUnionTable;

class StrictUnion {
  public:
  StrictUnion() : ordinal_(Ordinal::Invalid), envelope_{} {}

  StrictUnion(StrictUnion&&) = default;
  StrictUnion& operator=(StrictUnion&&) = default;

  ~StrictUnion() {
    reset_ptr(nullptr);
  }

  enum class Tag : fidl_xunion_tag_t {
    kPrimitive = 1,  // 0x1
    kStringNeedsConstructor = 2,  // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_Primitive() const { return ordinal_ == Ordinal::kPrimitive; }

  static StrictUnion WithPrimitive(::fidl::tracking_ptr<int32_t>&& val) {
    StrictUnion result;
    result.set_Primitive(std::move(val));
    return result;
  }

  void set_Primitive(::fidl::tracking_ptr<int32_t>&& elem) {
    ordinal_ = Ordinal::kPrimitive;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  int32_t& mutable_Primitive() {
    ZX_ASSERT(ordinal_ == Ordinal::kPrimitive);
    return *static_cast<int32_t*>(envelope_.data.get());
  }
  const int32_t& Primitive() const {
    ZX_ASSERT(ordinal_ == Ordinal::kPrimitive);
    return *static_cast<int32_t*>(envelope_.data.get());
  }

  bool is_StringNeedsConstructor() const { return ordinal_ == Ordinal::kStringNeedsConstructor; }

  static StrictUnion WithStringNeedsConstructor(::fidl::tracking_ptr<::fidl::StringView>&& val) {
    StrictUnion result;
    result.set_StringNeedsConstructor(std::move(val));
    return result;
  }

  void set_StringNeedsConstructor(::fidl::tracking_ptr<::fidl::StringView>&& elem) {
    ordinal_ = Ordinal::kStringNeedsConstructor;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::fidl::StringView& mutable_StringNeedsConstructor() {
    ZX_ASSERT(ordinal_ == Ordinal::kStringNeedsConstructor);
    return *static_cast<::fidl::StringView*>(envelope_.data.get());
  }
  const ::fidl::StringView& StringNeedsConstructor() const {
    ZX_ASSERT(ordinal_ == Ordinal::kStringNeedsConstructor);
    return *static_cast<::fidl::StringView*>(envelope_.data.get());
  }

  bool is_VectorStringAlsoNeedsConstructor() const { return ordinal_ == Ordinal::kVectorStringAlsoNeedsConstructor; }

  static StrictUnion WithVectorStringAlsoNeedsConstructor(::fidl::tracking_ptr<::fidl::VectorView<::fidl::StringView>>&& val) {
    StrictUnion result;
    result.set_VectorStringAlsoNeedsConstructor(std::move(val));
    return result;
  }

  void set_VectorStringAlsoNeedsConstructor(::fidl::tracking_ptr<::fidl::VectorView<::fidl::StringView>>&& elem) {
    ordinal_ = Ordinal::kVectorStringAlsoNeedsConstructor;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::fidl::VectorView<::fidl::StringView>& mutable_VectorStringAlsoNeedsConstructor() {
    ZX_ASSERT(ordinal_ == Ordinal::kVectorStringAlsoNeedsConstructor);
    return *static_cast<::fidl::VectorView<::fidl::StringView>*>(envelope_.data.get());
  }
  const ::fidl::VectorView<::fidl::StringView>& VectorStringAlsoNeedsConstructor() const {
    ZX_ASSERT(ordinal_ == Ordinal::kVectorStringAlsoNeedsConstructor);
    return *static_cast<::fidl::VectorView<::fidl::StringView>*>(envelope_.data.get());
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &v1_fidl_test_json_StrictUnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPrimitive = 1,  // 0x1
    kStringNeedsConstructor = 2,  // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  void reset_ptr(::fidl::tracking_ptr<void>&& new_ptr) {
    // To clear the existing value, std::move it and let it go out of scope.
    switch (static_cast<fidl_xunion_tag_t>(ordinal_)) {
    case 1: {
      ::fidl::tracking_ptr<int32_t> to_destroy =
        static_cast<::fidl::tracking_ptr<int32_t>>(std::move(envelope_.data));
      break;
    }
    case 2: {
      ::fidl::tracking_ptr<::fidl::StringView> to_destroy =
        static_cast<::fidl::tracking_ptr<::fidl::StringView>>(std::move(envelope_.data));
      break;
    }
    case 3: {
      ::fidl::tracking_ptr<::fidl::VectorView<::fidl::StringView>> to_destroy =
        static_cast<::fidl::tracking_ptr<::fidl::VectorView<::fidl::StringView>>>(std::move(envelope_.data));
      break;
    }
    }

    envelope_.data = std::move(new_ptr);
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t v1_fidl_test_json_ReverseOrdinalUnionTable;

class ReverseOrdinalUnion {
  public:
  ReverseOrdinalUnion() : ordinal_(Ordinal::Invalid), envelope_{} {}

  ReverseOrdinalUnion(ReverseOrdinalUnion&&) = default;
  ReverseOrdinalUnion& operator=(ReverseOrdinalUnion&&) = default;

  ~ReverseOrdinalUnion() {
    reset_ptr(nullptr);
  }

  enum class Tag : fidl_xunion_tag_t {
    kFirst = 1,  // 0x1
    kSecond = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_first() const { return ordinal_ == Ordinal::kFirst; }

  static ReverseOrdinalUnion WithFirst(::fidl::tracking_ptr<uint32_t>&& val) {
    ReverseOrdinalUnion result;
    result.set_first(std::move(val));
    return result;
  }

  void set_first(::fidl::tracking_ptr<uint32_t>&& elem) {
    ordinal_ = Ordinal::kFirst;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  uint32_t& mutable_first() {
    ZX_ASSERT(ordinal_ == Ordinal::kFirst);
    return *static_cast<uint32_t*>(envelope_.data.get());
  }
  const uint32_t& first() const {
    ZX_ASSERT(ordinal_ == Ordinal::kFirst);
    return *static_cast<uint32_t*>(envelope_.data.get());
  }

  bool is_second() const { return ordinal_ == Ordinal::kSecond; }

  static ReverseOrdinalUnion WithSecond(::fidl::tracking_ptr<uint32_t>&& val) {
    ReverseOrdinalUnion result;
    result.set_second(std::move(val));
    return result;
  }

  void set_second(::fidl::tracking_ptr<uint32_t>&& elem) {
    ordinal_ = Ordinal::kSecond;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  uint32_t& mutable_second() {
    ZX_ASSERT(ordinal_ == Ordinal::kSecond);
    return *static_cast<uint32_t*>(envelope_.data.get());
  }
  const uint32_t& second() const {
    ZX_ASSERT(ordinal_ == Ordinal::kSecond);
    return *static_cast<uint32_t*>(envelope_.data.get());
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &v1_fidl_test_json_ReverseOrdinalUnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kFirst = 1,  // 0x1
    kSecond = 2,  // 0x2
  };

  void reset_ptr(::fidl::tracking_ptr<void>&& new_ptr) {
    // To clear the existing value, std::move it and let it go out of scope.
    switch (static_cast<fidl_xunion_tag_t>(ordinal_)) {
    case 1: {
      ::fidl::tracking_ptr<uint32_t> to_destroy =
        static_cast<::fidl::tracking_ptr<uint32_t>>(std::move(envelope_.data));
      break;
    }
    case 2: {
      ::fidl::tracking_ptr<uint32_t> to_destroy =
        static_cast<::fidl::tracking_ptr<uint32_t>>(std::move(envelope_.data));
      break;
    }
    }

    envelope_.data = std::move(new_ptr);
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t v1_fidl_test_json_StrictPizzaOrPastaTable;

class StrictPizzaOrPasta {
  public:
  StrictPizzaOrPasta() : ordinal_(Ordinal::Invalid), envelope_{} {}

  StrictPizzaOrPasta(StrictPizzaOrPasta&&) = default;
  StrictPizzaOrPasta& operator=(StrictPizzaOrPasta&&) = default;

  ~StrictPizzaOrPasta() {
    reset_ptr(nullptr);
  }

  enum class Tag : fidl_xunion_tag_t {
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_pizza() const { return ordinal_ == Ordinal::kPizza; }

  static StrictPizzaOrPasta WithPizza(::fidl::tracking_ptr<::llcpp::fidl::test::json::Pizza>&& val) {
    StrictPizzaOrPasta result;
    result.set_pizza(std::move(val));
    return result;
  }

  void set_pizza(::fidl::tracking_ptr<::llcpp::fidl::test::json::Pizza>&& elem) {
    ordinal_ = Ordinal::kPizza;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::llcpp::fidl::test::json::Pizza& mutable_pizza() {
    ZX_ASSERT(ordinal_ == Ordinal::kPizza);
    return *static_cast<::llcpp::fidl::test::json::Pizza*>(envelope_.data.get());
  }
  const ::llcpp::fidl::test::json::Pizza& pizza() const {
    ZX_ASSERT(ordinal_ == Ordinal::kPizza);
    return *static_cast<::llcpp::fidl::test::json::Pizza*>(envelope_.data.get());
  }

  bool is_pasta() const { return ordinal_ == Ordinal::kPasta; }

  static StrictPizzaOrPasta WithPasta(::fidl::tracking_ptr<::llcpp::fidl::test::json::Pasta>&& val) {
    StrictPizzaOrPasta result;
    result.set_pasta(std::move(val));
    return result;
  }

  void set_pasta(::fidl::tracking_ptr<::llcpp::fidl::test::json::Pasta>&& elem) {
    ordinal_ = Ordinal::kPasta;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::llcpp::fidl::test::json::Pasta& mutable_pasta() {
    ZX_ASSERT(ordinal_ == Ordinal::kPasta);
    return *static_cast<::llcpp::fidl::test::json::Pasta*>(envelope_.data.get());
  }
  const ::llcpp::fidl::test::json::Pasta& pasta() const {
    ZX_ASSERT(ordinal_ == Ordinal::kPasta);
    return *static_cast<::llcpp::fidl::test::json::Pasta*>(envelope_.data.get());
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &v1_fidl_test_json_StrictPizzaOrPastaTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  void reset_ptr(::fidl::tracking_ptr<void>&& new_ptr) {
    // To clear the existing value, std::move it and let it go out of scope.
    switch (static_cast<fidl_xunion_tag_t>(ordinal_)) {
    case 1: {
      ::fidl::tracking_ptr<::llcpp::fidl::test::json::Pizza> to_destroy =
        static_cast<::fidl::tracking_ptr<::llcpp::fidl::test::json::Pizza>>(std::move(envelope_.data));
      break;
    }
    case 2: {
      ::fidl::tracking_ptr<::llcpp::fidl::test::json::Pasta> to_destroy =
        static_cast<::fidl::tracking_ptr<::llcpp::fidl::test::json::Pasta>>(std::move(envelope_.data));
      break;
    }
    }

    envelope_.data = std::move(new_ptr);
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t v1_fidl_test_json_PizzaOrPastaTable;

class PizzaOrPasta {
  public:
  PizzaOrPasta() : ordinal_(Ordinal::Invalid), envelope_{} {}

  PizzaOrPasta(PizzaOrPasta&&) = default;
  PizzaOrPasta& operator=(PizzaOrPasta&&) = default;

  ~PizzaOrPasta() {
    reset_ptr(nullptr);
  }

  enum class Tag : fidl_xunion_tag_t {
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_pizza() const { return ordinal_ == Ordinal::kPizza; }

  static PizzaOrPasta WithPizza(::fidl::tracking_ptr<::llcpp::fidl::test::json::Pizza>&& val) {
    PizzaOrPasta result;
    result.set_pizza(std::move(val));
    return result;
  }

  void set_pizza(::fidl::tracking_ptr<::llcpp::fidl::test::json::Pizza>&& elem) {
    ordinal_ = Ordinal::kPizza;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::llcpp::fidl::test::json::Pizza& mutable_pizza() {
    ZX_ASSERT(ordinal_ == Ordinal::kPizza);
    return *static_cast<::llcpp::fidl::test::json::Pizza*>(envelope_.data.get());
  }
  const ::llcpp::fidl::test::json::Pizza& pizza() const {
    ZX_ASSERT(ordinal_ == Ordinal::kPizza);
    return *static_cast<::llcpp::fidl::test::json::Pizza*>(envelope_.data.get());
  }

  bool is_pasta() const { return ordinal_ == Ordinal::kPasta; }

  static PizzaOrPasta WithPasta(::fidl::tracking_ptr<::llcpp::fidl::test::json::Pasta>&& val) {
    PizzaOrPasta result;
    result.set_pasta(std::move(val));
    return result;
  }

  void set_pasta(::fidl::tracking_ptr<::llcpp::fidl::test::json::Pasta>&& elem) {
    ordinal_ = Ordinal::kPasta;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::llcpp::fidl::test::json::Pasta& mutable_pasta() {
    ZX_ASSERT(ordinal_ == Ordinal::kPasta);
    return *static_cast<::llcpp::fidl::test::json::Pasta*>(envelope_.data.get());
  }
  const ::llcpp::fidl::test::json::Pasta& pasta() const {
    ZX_ASSERT(ordinal_ == Ordinal::kPasta);
    return *static_cast<::llcpp::fidl::test::json::Pasta*>(envelope_.data.get());
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &v1_fidl_test_json_PizzaOrPastaTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  void reset_ptr(::fidl::tracking_ptr<void>&& new_ptr) {
    // To clear the existing value, std::move it and let it go out of scope.
    switch (static_cast<fidl_xunion_tag_t>(ordinal_)) {
    case 1: {
      ::fidl::tracking_ptr<::llcpp::fidl::test::json::Pizza> to_destroy =
        static_cast<::fidl::tracking_ptr<::llcpp::fidl::test::json::Pizza>>(std::move(envelope_.data));
      break;
    }
    case 2: {
      ::fidl::tracking_ptr<::llcpp::fidl::test::json::Pasta> to_destroy =
        static_cast<::fidl::tracking_ptr<::llcpp::fidl::test::json::Pasta>>(std::move(envelope_.data));
      break;
    }
    }

    envelope_.data = std::move(new_ptr);
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t v1_fidl_test_json_FlexiblePizzaOrPastaTable;

class FlexiblePizzaOrPasta {
  public:
  FlexiblePizzaOrPasta() : ordinal_(Ordinal::Invalid), envelope_{} {}

  FlexiblePizzaOrPasta(FlexiblePizzaOrPasta&&) = default;
  FlexiblePizzaOrPasta& operator=(FlexiblePizzaOrPasta&&) = default;

  ~FlexiblePizzaOrPasta() {
    reset_ptr(nullptr);
  }

  enum class Tag : fidl_xunion_tag_t {
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_pizza() const { return ordinal_ == Ordinal::kPizza; }

  static FlexiblePizzaOrPasta WithPizza(::fidl::tracking_ptr<::llcpp::fidl::test::json::Pizza>&& val) {
    FlexiblePizzaOrPasta result;
    result.set_pizza(std::move(val));
    return result;
  }

  void set_pizza(::fidl::tracking_ptr<::llcpp::fidl::test::json::Pizza>&& elem) {
    ordinal_ = Ordinal::kPizza;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::llcpp::fidl::test::json::Pizza& mutable_pizza() {
    ZX_ASSERT(ordinal_ == Ordinal::kPizza);
    return *static_cast<::llcpp::fidl::test::json::Pizza*>(envelope_.data.get());
  }
  const ::llcpp::fidl::test::json::Pizza& pizza() const {
    ZX_ASSERT(ordinal_ == Ordinal::kPizza);
    return *static_cast<::llcpp::fidl::test::json::Pizza*>(envelope_.data.get());
  }

  bool is_pasta() const { return ordinal_ == Ordinal::kPasta; }

  static FlexiblePizzaOrPasta WithPasta(::fidl::tracking_ptr<::llcpp::fidl::test::json::Pasta>&& val) {
    FlexiblePizzaOrPasta result;
    result.set_pasta(std::move(val));
    return result;
  }

  void set_pasta(::fidl::tracking_ptr<::llcpp::fidl::test::json::Pasta>&& elem) {
    ordinal_ = Ordinal::kPasta;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::llcpp::fidl::test::json::Pasta& mutable_pasta() {
    ZX_ASSERT(ordinal_ == Ordinal::kPasta);
    return *static_cast<::llcpp::fidl::test::json::Pasta*>(envelope_.data.get());
  }
  const ::llcpp::fidl::test::json::Pasta& pasta() const {
    ZX_ASSERT(ordinal_ == Ordinal::kPasta);
    return *static_cast<::llcpp::fidl::test::json::Pasta*>(envelope_.data.get());
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &v1_fidl_test_json_FlexiblePizzaOrPastaTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  void reset_ptr(::fidl::tracking_ptr<void>&& new_ptr) {
    // To clear the existing value, std::move it and let it go out of scope.
    switch (static_cast<fidl_xunion_tag_t>(ordinal_)) {
    case 1: {
      ::fidl::tracking_ptr<::llcpp::fidl::test::json::Pizza> to_destroy =
        static_cast<::fidl::tracking_ptr<::llcpp::fidl::test::json::Pizza>>(std::move(envelope_.data));
      break;
    }
    case 2: {
      ::fidl::tracking_ptr<::llcpp::fidl::test::json::Pasta> to_destroy =
        static_cast<::fidl::tracking_ptr<::llcpp::fidl::test::json::Pasta>>(std::move(envelope_.data));
      break;
    }
    }

    envelope_.data = std::move(new_ptr);
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t v1_fidl_test_json_ExplicitPizzaOrPastaTable;

class ExplicitPizzaOrPasta {
  public:
  ExplicitPizzaOrPasta() : ordinal_(Ordinal::Invalid), envelope_{} {}

  ExplicitPizzaOrPasta(ExplicitPizzaOrPasta&&) = default;
  ExplicitPizzaOrPasta& operator=(ExplicitPizzaOrPasta&&) = default;

  ~ExplicitPizzaOrPasta() {
    reset_ptr(nullptr);
  }

  enum class Tag : fidl_xunion_tag_t {
    kPizza = 1,  // 0x1
    kPasta = 4,  // 0x4
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_pizza() const { return ordinal_ == Ordinal::kPizza; }

  static ExplicitPizzaOrPasta WithPizza(::fidl::tracking_ptr<::llcpp::fidl::test::json::Pizza>&& val) {
    ExplicitPizzaOrPasta result;
    result.set_pizza(std::move(val));
    return result;
  }

  void set_pizza(::fidl::tracking_ptr<::llcpp::fidl::test::json::Pizza>&& elem) {
    ordinal_ = Ordinal::kPizza;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::llcpp::fidl::test::json::Pizza& mutable_pizza() {
    ZX_ASSERT(ordinal_ == Ordinal::kPizza);
    return *static_cast<::llcpp::fidl::test::json::Pizza*>(envelope_.data.get());
  }
  const ::llcpp::fidl::test::json::Pizza& pizza() const {
    ZX_ASSERT(ordinal_ == Ordinal::kPizza);
    return *static_cast<::llcpp::fidl::test::json::Pizza*>(envelope_.data.get());
  }

  bool is_pasta() const { return ordinal_ == Ordinal::kPasta; }

  static ExplicitPizzaOrPasta WithPasta(::fidl::tracking_ptr<::llcpp::fidl::test::json::Pasta>&& val) {
    ExplicitPizzaOrPasta result;
    result.set_pasta(std::move(val));
    return result;
  }

  void set_pasta(::fidl::tracking_ptr<::llcpp::fidl::test::json::Pasta>&& elem) {
    ordinal_ = Ordinal::kPasta;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::llcpp::fidl::test::json::Pasta& mutable_pasta() {
    ZX_ASSERT(ordinal_ == Ordinal::kPasta);
    return *static_cast<::llcpp::fidl::test::json::Pasta*>(envelope_.data.get());
  }
  const ::llcpp::fidl::test::json::Pasta& pasta() const {
    ZX_ASSERT(ordinal_ == Ordinal::kPasta);
    return *static_cast<::llcpp::fidl::test::json::Pasta*>(envelope_.data.get());
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &v1_fidl_test_json_ExplicitPizzaOrPastaTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPizza = 1,  // 0x1
    kPasta = 4,  // 0x4
  };

  void reset_ptr(::fidl::tracking_ptr<void>&& new_ptr) {
    // To clear the existing value, std::move it and let it go out of scope.
    switch (static_cast<fidl_xunion_tag_t>(ordinal_)) {
    case 1: {
      ::fidl::tracking_ptr<::llcpp::fidl::test::json::Pizza> to_destroy =
        static_cast<::fidl::tracking_ptr<::llcpp::fidl::test::json::Pizza>>(std::move(envelope_.data));
      break;
    }
    case 4: {
      ::fidl::tracking_ptr<::llcpp::fidl::test::json::Pasta> to_destroy =
        static_cast<::fidl::tracking_ptr<::llcpp::fidl::test::json::Pasta>>(std::move(envelope_.data));
      break;
    }
    }

    envelope_.data = std::move(new_ptr);
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t v1_fidl_test_json_FlexibleUnionTable;

class FlexibleUnion {
  public:
  FlexibleUnion() : ordinal_(Ordinal::Invalid), envelope_{} {}

  FlexibleUnion(FlexibleUnion&&) = default;
  FlexibleUnion& operator=(FlexibleUnion&&) = default;

  ~FlexibleUnion() {
    reset_ptr(nullptr);
  }

  enum class Tag : fidl_xunion_tag_t {
    kPrimitive = 1,  // 0x1
    kStringNeedsConstructor = 2,  // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_Primitive() const { return ordinal_ == Ordinal::kPrimitive; }

  static FlexibleUnion WithPrimitive(::fidl::tracking_ptr<int32_t>&& val) {
    FlexibleUnion result;
    result.set_Primitive(std::move(val));
    return result;
  }

  void set_Primitive(::fidl::tracking_ptr<int32_t>&& elem) {
    ordinal_ = Ordinal::kPrimitive;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  int32_t& mutable_Primitive() {
    ZX_ASSERT(ordinal_ == Ordinal::kPrimitive);
    return *static_cast<int32_t*>(envelope_.data.get());
  }
  const int32_t& Primitive() const {
    ZX_ASSERT(ordinal_ == Ordinal::kPrimitive);
    return *static_cast<int32_t*>(envelope_.data.get());
  }

  bool is_StringNeedsConstructor() const { return ordinal_ == Ordinal::kStringNeedsConstructor; }

  static FlexibleUnion WithStringNeedsConstructor(::fidl::tracking_ptr<::fidl::StringView>&& val) {
    FlexibleUnion result;
    result.set_StringNeedsConstructor(std::move(val));
    return result;
  }

  void set_StringNeedsConstructor(::fidl::tracking_ptr<::fidl::StringView>&& elem) {
    ordinal_ = Ordinal::kStringNeedsConstructor;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::fidl::StringView& mutable_StringNeedsConstructor() {
    ZX_ASSERT(ordinal_ == Ordinal::kStringNeedsConstructor);
    return *static_cast<::fidl::StringView*>(envelope_.data.get());
  }
  const ::fidl::StringView& StringNeedsConstructor() const {
    ZX_ASSERT(ordinal_ == Ordinal::kStringNeedsConstructor);
    return *static_cast<::fidl::StringView*>(envelope_.data.get());
  }

  bool is_VectorStringAlsoNeedsConstructor() const { return ordinal_ == Ordinal::kVectorStringAlsoNeedsConstructor; }

  static FlexibleUnion WithVectorStringAlsoNeedsConstructor(::fidl::tracking_ptr<::fidl::VectorView<::fidl::StringView>>&& val) {
    FlexibleUnion result;
    result.set_VectorStringAlsoNeedsConstructor(std::move(val));
    return result;
  }

  void set_VectorStringAlsoNeedsConstructor(::fidl::tracking_ptr<::fidl::VectorView<::fidl::StringView>>&& elem) {
    ordinal_ = Ordinal::kVectorStringAlsoNeedsConstructor;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::fidl::VectorView<::fidl::StringView>& mutable_VectorStringAlsoNeedsConstructor() {
    ZX_ASSERT(ordinal_ == Ordinal::kVectorStringAlsoNeedsConstructor);
    return *static_cast<::fidl::VectorView<::fidl::StringView>*>(envelope_.data.get());
  }
  const ::fidl::VectorView<::fidl::StringView>& VectorStringAlsoNeedsConstructor() const {
    ZX_ASSERT(ordinal_ == Ordinal::kVectorStringAlsoNeedsConstructor);
    return *static_cast<::fidl::VectorView<::fidl::StringView>*>(envelope_.data.get());
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &v1_fidl_test_json_FlexibleUnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPrimitive = 1,  // 0x1
    kStringNeedsConstructor = 2,  // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  void reset_ptr(::fidl::tracking_ptr<void>&& new_ptr) {
    // To clear the existing value, std::move it and let it go out of scope.
    switch (static_cast<fidl_xunion_tag_t>(ordinal_)) {
    case 1: {
      ::fidl::tracking_ptr<int32_t> to_destroy =
        static_cast<::fidl::tracking_ptr<int32_t>>(std::move(envelope_.data));
      break;
    }
    case 2: {
      ::fidl::tracking_ptr<::fidl::StringView> to_destroy =
        static_cast<::fidl::tracking_ptr<::fidl::StringView>>(std::move(envelope_.data));
      break;
    }
    case 3: {
      ::fidl::tracking_ptr<::fidl::VectorView<::fidl::StringView>> to_destroy =
        static_cast<::fidl::tracking_ptr<::fidl::VectorView<::fidl::StringView>>>(std::move(envelope_.data));
      break;
    }
    }

    envelope_.data = std::move(new_ptr);
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t v1_fidl_test_json_FieldCollisionTable;

class FieldCollision {
  public:
  FieldCollision() : ordinal_(Ordinal::Invalid), envelope_{} {}

  FieldCollision(FieldCollision&&) = default;
  FieldCollision& operator=(FieldCollision&&) = default;

  ~FieldCollision() {
    reset_ptr(nullptr);
  }

  enum class Tag : fidl_xunion_tag_t {
    kFieldCollisionTag = 1,  // 0x1
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_field_collision_tag() const { return ordinal_ == Ordinal::kFieldCollisionTag; }

  static FieldCollision WithFieldCollisionTag(::fidl::tracking_ptr<int32_t>&& val) {
    FieldCollision result;
    result.set_field_collision_tag(std::move(val));
    return result;
  }

  void set_field_collision_tag(::fidl::tracking_ptr<int32_t>&& elem) {
    ordinal_ = Ordinal::kFieldCollisionTag;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  int32_t& mutable_field_collision_tag() {
    ZX_ASSERT(ordinal_ == Ordinal::kFieldCollisionTag);
    return *static_cast<int32_t*>(envelope_.data.get());
  }
  const int32_t& field_collision_tag() const {
    ZX_ASSERT(ordinal_ == Ordinal::kFieldCollisionTag);
    return *static_cast<int32_t*>(envelope_.data.get());
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &v1_fidl_test_json_FieldCollisionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kFieldCollisionTag = 1,  // 0x1
  };

  void reset_ptr(::fidl::tracking_ptr<void>&& new_ptr) {
    // To clear the existing value, std::move it and let it go out of scope.
    switch (static_cast<fidl_xunion_tag_t>(ordinal_)) {
    case 1: {
      ::fidl::tracking_ptr<int32_t> to_destroy =
        static_cast<::fidl::tracking_ptr<int32_t>>(std::move(envelope_.data));
      break;
    }
    }

    envelope_.data = std::move(new_ptr);
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t v1_fidl_test_json_ExplicitUnionTable;

class ExplicitUnion {
  public:
  ExplicitUnion() : ordinal_(Ordinal::Invalid), envelope_{} {}

  ExplicitUnion(ExplicitUnion&&) = default;
  ExplicitUnion& operator=(ExplicitUnion&&) = default;

  ~ExplicitUnion() {
    reset_ptr(nullptr);
  }

  enum class Tag : fidl_xunion_tag_t {
    kPrimitive = 1,  // 0x1
    kStringNeedsConstructor = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_Primitive() const { return ordinal_ == Ordinal::kPrimitive; }

  static ExplicitUnion WithPrimitive(::fidl::tracking_ptr<int32_t>&& val) {
    ExplicitUnion result;
    result.set_Primitive(std::move(val));
    return result;
  }

  void set_Primitive(::fidl::tracking_ptr<int32_t>&& elem) {
    ordinal_ = Ordinal::kPrimitive;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  int32_t& mutable_Primitive() {
    ZX_ASSERT(ordinal_ == Ordinal::kPrimitive);
    return *static_cast<int32_t*>(envelope_.data.get());
  }
  const int32_t& Primitive() const {
    ZX_ASSERT(ordinal_ == Ordinal::kPrimitive);
    return *static_cast<int32_t*>(envelope_.data.get());
  }

  bool is_StringNeedsConstructor() const { return ordinal_ == Ordinal::kStringNeedsConstructor; }

  static ExplicitUnion WithStringNeedsConstructor(::fidl::tracking_ptr<::fidl::StringView>&& val) {
    ExplicitUnion result;
    result.set_StringNeedsConstructor(std::move(val));
    return result;
  }

  void set_StringNeedsConstructor(::fidl::tracking_ptr<::fidl::StringView>&& elem) {
    ordinal_ = Ordinal::kStringNeedsConstructor;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::fidl::StringView& mutable_StringNeedsConstructor() {
    ZX_ASSERT(ordinal_ == Ordinal::kStringNeedsConstructor);
    return *static_cast<::fidl::StringView*>(envelope_.data.get());
  }
  const ::fidl::StringView& StringNeedsConstructor() const {
    ZX_ASSERT(ordinal_ == Ordinal::kStringNeedsConstructor);
    return *static_cast<::fidl::StringView*>(envelope_.data.get());
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &v1_fidl_test_json_ExplicitUnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPrimitive = 1,  // 0x1
    kStringNeedsConstructor = 3,  // 0x3
  };

  void reset_ptr(::fidl::tracking_ptr<void>&& new_ptr) {
    // To clear the existing value, std::move it and let it go out of scope.
    switch (static_cast<fidl_xunion_tag_t>(ordinal_)) {
    case 1: {
      ::fidl::tracking_ptr<int32_t> to_destroy =
        static_cast<::fidl::tracking_ptr<int32_t>>(std::move(envelope_.data));
      break;
    }
    case 3: {
      ::fidl::tracking_ptr<::fidl::StringView> to_destroy =
        static_cast<::fidl::tracking_ptr<::fidl::StringView>>(std::move(envelope_.data));
      break;
    }
    }

    envelope_.data = std::move(new_ptr);
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t v1_fidl_test_json_PizzaTable;

struct Pizza {
  static constexpr const fidl_type_t* Type = &v1_fidl_test_json_PizzaTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

  ::fidl::VectorView<::fidl::StringView> toppings = {};
};

extern "C" const fidl_type_t v1_fidl_test_json_PastaTable;

struct Pasta {
  static constexpr const fidl_type_t* Type = &v1_fidl_test_json_PastaTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 16;
  static constexpr bool HasPointer = true;

  ::fidl::StringView sauce = {};
};

extern "C" const fidl_type_t v1_fidl_test_json_NullableUnionStructTable;

struct NullableUnionStruct {
  static constexpr const fidl_type_t* Type = &v1_fidl_test_json_NullableUnionStructTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

  ::llcpp::fidl::test::json::Union the_union = {};
};

}  // namespace json
}  // namespace test
}  // namespace fidl
}  // namespace llcpp

namespace fidl {

template <>
struct IsFidlType<::llcpp::fidl::test::json::Union> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fidl::test::json::Union>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::StrictUnion> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fidl::test::json::StrictUnion>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::ReverseOrdinalUnion> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fidl::test::json::ReverseOrdinalUnion>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::Pizza> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fidl::test::json::Pizza>);
static_assert(offsetof(::llcpp::fidl::test::json::Pizza, toppings) == 0);
static_assert(sizeof(::llcpp::fidl::test::json::Pizza) == ::llcpp::fidl::test::json::Pizza::PrimarySize);

template <>
struct IsFidlType<::llcpp::fidl::test::json::Pasta> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fidl::test::json::Pasta>);
static_assert(offsetof(::llcpp::fidl::test::json::Pasta, sauce) == 0);
static_assert(sizeof(::llcpp::fidl::test::json::Pasta) == ::llcpp::fidl::test::json::Pasta::PrimarySize);

template <>
struct IsFidlType<::llcpp::fidl::test::json::StrictPizzaOrPasta> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fidl::test::json::StrictPizzaOrPasta>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::PizzaOrPasta> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fidl::test::json::PizzaOrPasta>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::FlexiblePizzaOrPasta> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fidl::test::json::FlexiblePizzaOrPasta>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::ExplicitPizzaOrPasta> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fidl::test::json::ExplicitPizzaOrPasta>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::NullableUnionStruct> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fidl::test::json::NullableUnionStruct>);
static_assert(offsetof(::llcpp::fidl::test::json::NullableUnionStruct, the_union) == 0);
static_assert(sizeof(::llcpp::fidl::test::json::NullableUnionStruct) == ::llcpp::fidl::test::json::NullableUnionStruct::PrimarySize);

template <>
struct IsFidlType<::llcpp::fidl::test::json::FlexibleUnion> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fidl::test::json::FlexibleUnion>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::FieldCollision> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fidl::test::json::FieldCollision>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::ExplicitUnion> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fidl::test::json::ExplicitUnion>);

}  // namespace fidl

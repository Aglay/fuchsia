// WARNING: This file is machine generated by fidlgen.

#include <union.fidl.json.h>

#include "lib/fidl/cpp/internal/implementation.h"
namespace test {
namespace name {

Union::Union() : value_() {}

Union::~Union() {
}

Union::Union(Union&& other) : value_(std::move(other.value_)) {
}

Union& Union::operator=(Union&& other) {
  if (this != &other) {
    value_ = std::move(other.value_);
  }
  return *this;
}

void Union::Encode(::fidl::Encoder* encoder, size_t offset) {
  fidl_union_tag_t tag = static_cast<fidl_union_tag_t>(Which());
  ::fidl::Encode(encoder, &tag, offset);
  switch (tag) {
   case 0:
    ::fidl::Encode(encoder, &Primitive(), offset + 8);
    break;
   case 1:
    ::fidl::Encode(encoder, &StringNeedsConstructor(), offset + 8);
    break;
   case 2:
    ::fidl::Encode(encoder, &VectorStringAlsoNeedsConstructor(), offset + 8);
    break;
   default:
    break;
  }
}

void Union::Decode(::fidl::Decoder* decoder, Union* value, size_t offset) {
  fidl_union_tag_t tag;
  ::fidl::Decode(decoder, &tag, offset);
  switch (tag) {
   case 0:
    {
      int32_t member{};
      ::fidl::Decode(decoder, &member, offset + 8);
      value->set_Primitive(std::move(member));
      break;
    }
   case 1:
    {
      ::std::string member{};
      ::fidl::Decode(decoder, &member, offset + 8);
      value->set_StringNeedsConstructor(std::move(member));
      break;
    }
   case 2:
    {
      ::std::vector<::std::string> member{};
      ::fidl::Decode(decoder, &member, offset + 8);
      value->set_VectorStringAlsoNeedsConstructor(std::move(member));
      break;
    }
   default:
    value->value_.emplace<0>();
  }
}

zx_status_t Union::Clone(Union* result) const {
  zx_status_t status = ZX_OK;
  switch (Which()) {
    case Tag::kPrimitive:
      {
        int32_t member{};
        status = ::fidl::Clone(Primitive(), &member);
        if (status == ZX_OK) {
	  result->set_Primitive(std::move(member));
        }
      }
      break;
    case Tag::kStringNeedsConstructor:
      {
        ::std::string member{};
        status = ::fidl::Clone(StringNeedsConstructor(), &member);
        if (status == ZX_OK) {
	  result->set_StringNeedsConstructor(std::move(member));
        }
      }
      break;
    case Tag::kVectorStringAlsoNeedsConstructor:
      {
        ::std::vector<::std::string> member{};
        status = ::fidl::Clone(VectorStringAlsoNeedsConstructor(), &member);
        if (status == ZX_OK) {
	  result->set_VectorStringAlsoNeedsConstructor(std::move(member));
        }
      }
      break;
    case Tag::Invalid:
      result->value_.emplace<0>();
      break;
  }
  return status;
}

bool operator==(const Union& lhs, const Union& rhs) {
  if (lhs.Which() != rhs.Which()) {
    return false;
  }
  switch (lhs.Which()) {
    case Union::Tag::kPrimitive:
      return ::fidl::Equals(lhs.Primitive(), rhs.Primitive());
    case Union::Tag::kStringNeedsConstructor:
      return ::fidl::Equals(lhs.StringNeedsConstructor(), rhs.StringNeedsConstructor());
    case Union::Tag::kVectorStringAlsoNeedsConstructor:
      return ::fidl::Equals(lhs.VectorStringAlsoNeedsConstructor(), rhs.VectorStringAlsoNeedsConstructor());
    case Union::Tag::Invalid:
      return true;
    default:
      return false;
  }
}

void Union::set_Primitive(int32_t value) {
  value_.emplace<static_cast<size_t>(Tag::kPrimitive) + 1>(std::move(value));
}

void Union::set_StringNeedsConstructor(::std::string value) {
  value_.emplace<static_cast<size_t>(Tag::kStringNeedsConstructor) + 1>(std::move(value));
}

void Union::set_VectorStringAlsoNeedsConstructor(::std::vector<::std::string> value) {
  value_.emplace<static_cast<size_t>(Tag::kVectorStringAlsoNeedsConstructor) + 1>(std::move(value));
}
}  // namespace name
}  // namespace test

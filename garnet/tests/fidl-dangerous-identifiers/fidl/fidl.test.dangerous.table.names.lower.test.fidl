// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Generated by generate.py.
library fidl.test.dangerous.table.names.lower;
using membertype = uint32;
table abstract { 1: membertype member; };
table alignas { 1: membertype member; };
table alignof { 1: membertype member; };
table and { 1: membertype member; };
table and_eq { 1: membertype member; };
table as { 1: membertype member; };
table asm { 1: membertype member; };
table async { 1: membertype member; };
table atomic_cancel { 1: membertype member; };
table atomic_commit { 1: membertype member; };
table atomic_noexcept { 1: membertype member; };
table auto { 1: membertype member; };
table await { 1: membertype member; };
table become { 1: membertype member; };
table bitand { 1: membertype member; };
table bitor { 1: membertype member; };
table bool { 1: membertype member; };
table box { 1: membertype member; };
table break { 1: membertype member; };
table byte { 1: membertype member; };
table case { 1: membertype member; };
table catch { 1: membertype member; };
table chan { 1: membertype member; };
table char { 1: membertype member; };
table char16_t { 1: membertype member; };
table char32_t { 1: membertype member; };
table class { 1: membertype member; };
table co_await { 1: membertype member; };
table co_return { 1: membertype member; };
table co_yield { 1: membertype member; };
table coding_traits { 1: membertype member; };
table compl { 1: membertype member; };
table concept { 1: membertype member; };
table const { 1: membertype member; };
table const_cast { 1: membertype member; };
table constexpr { 1: membertype member; };
table continue { 1: membertype member; };
table controller { 1: membertype member; };
table crate { 1: membertype member; };
table decltype { 1: membertype member; };
table decoder { 1: membertype member; };
table default { 1: membertype member; };
table defer { 1: membertype member; };
table delete { 1: membertype member; };
table do { 1: membertype member; };
table double { 1: membertype member; };
table dynamic_cast { 1: membertype member; };
table else { 1: membertype member; };
table encoder { 1: membertype member; };
table enum { 1: membertype member; };
table err { 1: membertype member; };
table explicit { 1: membertype member; };
table export { 1: membertype member; };
table extern { 1: membertype member; };
table fallthrough { 1: membertype member; };
table false { 1: membertype member; };
table fidl { 1: membertype member; };
table fidl_type { 1: membertype member; };
table final { 1: membertype member; };
table float { 1: membertype member; };
table fn { 1: membertype member; };
table for { 1: membertype member; };
table friend { 1: membertype member; };
table func { 1: membertype member; };
table future { 1: membertype member; };
table futures { 1: membertype member; };
table go { 1: membertype member; };
table goto { 1: membertype member; };
table has_invalid_tag { 1: membertype member; };
table if { 1: membertype member; };
table impl { 1: membertype member; };
table import { 1: membertype member; };
table in { 1: membertype member; };
table inline { 1: membertype member; };
table int { 1: membertype member; };
table int16 { 1: membertype member; };
table int32 { 1: membertype member; };
table int64 { 1: membertype member; };
table int8 { 1: membertype member; };
table interface { 1: membertype member; };
table let { 1: membertype member; };
table lhs { 1: membertype member; };
table list { 1: membertype member; };
table long { 1: membertype member; };
table loop { 1: membertype member; };
table macro { 1: membertype member; };
table map { 1: membertype member; };
table match { 1: membertype member; };
table mod { 1: membertype member; };
table module { 1: membertype member; };
table move { 1: membertype member; };
table mut { 1: membertype member; };
table mutable { 1: membertype member; };
table namespace { 1: membertype member; };
table never { 1: membertype member; };
table new { 1: membertype member; };
table noexcept { 1: membertype member; };
table none { 1: membertype member; };
table not { 1: membertype member; };
table not_eq { 1: membertype member; };
table nullptr { 1: membertype member; };
table offset { 1: membertype member; };
table offsetof { 1: membertype member; };
table ok { 1: membertype member; };
table on_open { 1: membertype member; };
table operator { 1: membertype member; };
table option { 1: membertype member; };
table or { 1: membertype member; };
table or_eq { 1: membertype member; };
table override { 1: membertype member; };
table package { 1: membertype member; };
table priv { 1: membertype member; };
table private { 1: membertype member; };
table proc { 1: membertype member; };
table protected { 1: membertype member; };
table proxy { 1: membertype member; };
table pub { 1: membertype member; };
table public { 1: membertype member; };
table pure { 1: membertype member; };
table range { 1: membertype member; };
table ref { 1: membertype member; };
table register { 1: membertype member; };
table reinterpret_cast { 1: membertype member; };
table requires { 1: membertype member; };
table result { 1: membertype member; };
table return { 1: membertype member; };
table rhs { 1: membertype member; };
table rune { 1: membertype member; };
table select { 1: membertype member; };
table self { 1: membertype member; };
table send { 1: membertype member; };
table set_controller { 1: membertype member; };
table short { 1: membertype member; };
table signed { 1: membertype member; };
table sizeof { 1: membertype member; };
table some { 1: membertype member; };
table static { 1: membertype member; };
table static_assert { 1: membertype member; };
table static_cast { 1: membertype member; };
table stream { 1: membertype member; };
table string { 1: membertype member; };
table struct { 1: membertype member; };
table stub { 1: membertype member; };
table super { 1: membertype member; };
table switch { 1: membertype member; };
table synchronized { 1: membertype member; };
table tag { 1: membertype member; };
table template { 1: membertype member; };
table this { 1: membertype member; };
table thread_local { 1: membertype member; };
table throw { 1: membertype member; };
table to_string { 1: membertype member; };
table trait { 1: membertype member; };
table true { 1: membertype member; };
table try { 1: membertype member; };
table type { 1: membertype member; };
table typedef { 1: membertype member; };
table typeid { 1: membertype member; };
table typename { 1: membertype member; };
table typeof { 1: membertype member; };
table uint16 { 1: membertype member; };
table uint32 { 1: membertype member; };
table uint64 { 1: membertype member; };
table uint8 { 1: membertype member; };
table union { 1: membertype member; };
table unsafe { 1: membertype member; };
table unsigned { 1: membertype member; };
table unsized { 1: membertype member; };
table use { 1: membertype member; };
table using { 1: membertype member; };
table value { 1: membertype member; };
table value_of { 1: membertype member; };
table value_union { 1: membertype member; };
table values { 1: membertype member; };
table values_map { 1: membertype member; };
table var { 1: membertype member; };
table vec { 1: membertype member; };
table virtual { 1: membertype member; };
table void { 1: membertype member; };
table volatile { 1: membertype member; };
table wchar_t { 1: membertype member; };
table where { 1: membertype member; };
table which { 1: membertype member; };
table while { 1: membertype member; };
table xor { 1: membertype member; };
table xor_eq { 1: membertype member; };
table xunion { 1: membertype member; };
table yield { 1: membertype member; };
table zx { 1: membertype member; };
table DangerousMembers {
  1: abstract f0;
  2: alignas f1;
  3: alignof f2;
  4: and f3;
  5: and_eq f4;
  6: as f5;
  7: asm f6;
  8: async f7;
  9: atomic_cancel f8;
  10: atomic_commit f9;
  11: atomic_noexcept f10;
  12: auto f11;
  13: await f12;
  14: become f13;
  15: bitand f14;
  16: bitor f15;
  17: bool f16;
  18: box f17;
  19: break f18;
  20: byte f19;
  21: case f20;
  22: catch f21;
  23: chan f22;
  24: char f23;
  25: char16_t f24;
  26: char32_t f25;
  27: class f26;
  28: co_await f27;
  29: co_return f28;
  30: co_yield f29;
  31: coding_traits f30;
  32: compl f31;
  33: concept f32;
  34: const f33;
  35: const_cast f34;
  36: constexpr f35;
  37: continue f36;
  38: controller f37;
  39: crate f38;
  40: decltype f39;
  41: decoder f40;
  42: default f41;
  43: defer f42;
  44: delete f43;
  45: do f44;
  46: double f45;
  47: dynamic_cast f46;
  48: else f47;
  49: encoder f48;
  50: enum f49;
  51: err f50;
  52: explicit f51;
  53: export f52;
  54: extern f53;
  55: fallthrough f54;
  56: false f55;
  57: fidl f56;
  58: fidl_type f57;
  59: final f58;
  60: float f59;
  61: fn f60;
  62: for f61;
  63: friend f62;
  64: func f63;
  65: future f64;
  66: futures f65;
  67: go f66;
  68: goto f67;
  69: has_invalid_tag f68;
  70: if f69;
  71: impl f70;
  72: import f71;
  73: in f72;
  74: inline f73;
  75: int f74;
  76: int16 f75;
  77: int32 f76;
  78: int64 f77;
  79: int8 f78;
  80: interface f79;
  81: let f80;
  82: lhs f81;
  83: list f82;
  84: long f83;
  85: loop f84;
  86: macro f85;
  87: map f86;
  88: match f87;
  89: mod f88;
  90: module f89;
  91: move f90;
  92: mut f91;
  93: mutable f92;
  94: namespace f93;
  95: never f94;
  96: new f95;
  97: noexcept f96;
  98: none f97;
  99: not f98;
  100: not_eq f99;
  101: nullptr f100;
  102: offset f101;
  103: offsetof f102;
  104: ok f103;
  105: on_open f104;
  106: operator f105;
  107: option f106;
  108: or f107;
  109: or_eq f108;
  110: override f109;
  111: package f110;
  112: priv f111;
  113: private f112;
  114: proc f113;
  115: protected f114;
  116: proxy f115;
  117: pub f116;
  118: public f117;
  119: pure f118;
  120: range f119;
  121: ref f120;
  122: register f121;
  123: reinterpret_cast f122;
  124: requires f123;
  125: result f124;
  126: return f125;
  127: rhs f126;
  128: rune f127;
  129: select f128;
  130: self f129;
  131: send f130;
  132: set_controller f131;
  133: short f132;
  134: signed f133;
  135: sizeof f134;
  136: some f135;
  137: static f136;
  138: static_assert f137;
  139: static_cast f138;
  140: stream f139;
  141: string f140;
  142: struct f141;
  143: stub f142;
  144: super f143;
  145: switch f144;
  146: synchronized f145;
  147: tag f146;
  148: template f147;
  149: this f148;
  150: thread_local f149;
  151: throw f150;
  152: to_string f151;
  153: trait f152;
  154: true f153;
  155: try f154;
  156: type f155;
  157: typedef f156;
  158: typeid f157;
  159: typename f158;
  160: typeof f159;
  161: uint16 f160;
  162: uint32 f161;
  163: uint64 f162;
  164: uint8 f163;
  165: union f164;
  166: unsafe f165;
  167: unsigned f166;
  168: unsized f167;
  169: use f168;
  170: using f169;
  171: value f170;
  172: value_of f171;
  173: value_union f172;
  174: values f173;
  175: values_map f174;
  176: var f175;
  177: vec f176;
  178: virtual f177;
  179: void f178;
  180: volatile f179;
  181: wchar_t f180;
  182: where f181;
  183: which f182;
  184: while f183;
  185: xor f184;
  186: xor_eq f185;
  187: xunion f186;
  188: yield f187;
  189: zx f188;
};

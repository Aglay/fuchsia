// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Generated by generate.py.
library fidl.test.dangerous.struct.types.upper;
using membertype = uint32;
struct ABSTRACT { membertype member = 1; };
struct ALIGNAS { membertype member = 1; };
struct ALIGNOF { membertype member = 1; };
struct AND { membertype member = 1; };
struct AND_EQ { membertype member = 1; };
struct AS { membertype member = 1; };
struct ASM { membertype member = 1; };
struct ASYNC { membertype member = 1; };
struct ATOMIC_CANCEL { membertype member = 1; };
struct ATOMIC_COMMIT { membertype member = 1; };
struct ATOMIC_NOEXCEPT { membertype member = 1; };
struct AUTO { membertype member = 1; };
struct AWAIT { membertype member = 1; };
struct BECOME { membertype member = 1; };
struct BITAND { membertype member = 1; };
struct BITOR { membertype member = 1; };
struct BOOL { membertype member = 1; };
struct BOX { membertype member = 1; };
struct BREAK { membertype member = 1; };
struct BYTE { membertype member = 1; };
struct CASE { membertype member = 1; };
struct CATCH { membertype member = 1; };
struct CHAN { membertype member = 1; };
struct CHAR { membertype member = 1; };
struct CHAR16_T { membertype member = 1; };
struct CHAR32_T { membertype member = 1; };
struct CLASS { membertype member = 1; };
struct CO_AWAIT { membertype member = 1; };
struct CO_RETURN { membertype member = 1; };
struct CO_YIELD { membertype member = 1; };
struct CODING_TRAITS { membertype member = 1; };
struct COMPL { membertype member = 1; };
struct CONCEPT { membertype member = 1; };
struct CONST { membertype member = 1; };
struct CONST_CAST { membertype member = 1; };
struct CONSTEXPR { membertype member = 1; };
struct CONTINUE { membertype member = 1; };
struct CONTROLLER { membertype member = 1; };
struct CRATE { membertype member = 1; };
struct DECLTYPE { membertype member = 1; };
struct DECODER { membertype member = 1; };
struct DEFAULT { membertype member = 1; };
struct DEFER { membertype member = 1; };
struct DELETE { membertype member = 1; };
struct DO { membertype member = 1; };
struct DOUBLE { membertype member = 1; };
struct DYNAMIC_CAST { membertype member = 1; };
struct ELSE { membertype member = 1; };
struct ENCODER { membertype member = 1; };
struct ENUM { membertype member = 1; };
struct ERR { membertype member = 1; };
struct EXPLICIT { membertype member = 1; };
struct EXPORT { membertype member = 1; };
struct EXTERN { membertype member = 1; };
struct FALLTHROUGH { membertype member = 1; };
struct FALSE { membertype member = 1; };
struct FIDL { membertype member = 1; };
struct FIDL_TYPE { membertype member = 1; };
struct FINAL { membertype member = 1; };
struct FLOAT { membertype member = 1; };
struct FN { membertype member = 1; };
struct FOR { membertype member = 1; };
struct FRIEND { membertype member = 1; };
struct FUNC { membertype member = 1; };
struct FUTURE { membertype member = 1; };
struct FUTURES { membertype member = 1; };
struct GO { membertype member = 1; };
struct GOTO { membertype member = 1; };
struct HAS_INVALID_TAG { membertype member = 1; };
struct IF { membertype member = 1; };
struct IMPL { membertype member = 1; };
struct IMPORT { membertype member = 1; };
struct IN { membertype member = 1; };
struct INLINE { membertype member = 1; };
struct INT { membertype member = 1; };
struct INT16 { membertype member = 1; };
struct INT32 { membertype member = 1; };
struct INT64 { membertype member = 1; };
struct INT8 { membertype member = 1; };
struct INTERFACE { membertype member = 1; };
struct LET { membertype member = 1; };
struct LHS { membertype member = 1; };
struct LIST { membertype member = 1; };
struct LONG { membertype member = 1; };
struct LOOP { membertype member = 1; };
struct MACRO { membertype member = 1; };
struct MAP { membertype member = 1; };
struct MATCH { membertype member = 1; };
struct MOD { membertype member = 1; };
struct MODULE { membertype member = 1; };
struct MOVE { membertype member = 1; };
struct MUT { membertype member = 1; };
struct MUTABLE { membertype member = 1; };
struct NAMESPACE { membertype member = 1; };
struct NEVER { membertype member = 1; };
struct NEW { membertype member = 1; };
struct NOEXCEPT { membertype member = 1; };
struct NONE { membertype member = 1; };
struct NOT { membertype member = 1; };
struct NOT_EQ { membertype member = 1; };
struct NULLPTR { membertype member = 1; };
struct OFFSET { membertype member = 1; };
struct OFFSETOF { membertype member = 1; };
struct OK { membertype member = 1; };
struct ON_OPEN { membertype member = 1; };
struct OPERATOR { membertype member = 1; };
struct OPTION { membertype member = 1; };
struct OR { membertype member = 1; };
struct OR_EQ { membertype member = 1; };
struct OVERRIDE { membertype member = 1; };
struct PACKAGE { membertype member = 1; };
struct PRIV { membertype member = 1; };
struct PRIVATE { membertype member = 1; };
struct PROC { membertype member = 1; };
struct PROTECTED { membertype member = 1; };
struct PROXY { membertype member = 1; };
struct PUB { membertype member = 1; };
struct PUBLIC { membertype member = 1; };
struct PURE { membertype member = 1; };
struct RANGE { membertype member = 1; };
struct REF { membertype member = 1; };
struct REGISTER { membertype member = 1; };
struct REINTERPRET_CAST { membertype member = 1; };
struct REQUIRES { membertype member = 1; };
struct RESULT { membertype member = 1; };
struct RETURN { membertype member = 1; };
struct RHS { membertype member = 1; };
struct RUNE { membertype member = 1; };
struct SELECT { membertype member = 1; };
struct SELF { membertype member = 1; };
struct SEND { membertype member = 1; };
struct SET_CONTROLLER { membertype member = 1; };
struct SHORT { membertype member = 1; };
struct SIGNED { membertype member = 1; };
struct SIZEOF { membertype member = 1; };
struct SOME { membertype member = 1; };
struct STATIC { membertype member = 1; };
struct STATIC_ASSERT { membertype member = 1; };
struct STATIC_CAST { membertype member = 1; };
struct STREAM { membertype member = 1; };
struct STRING { membertype member = 1; };
struct STRUCT { membertype member = 1; };
struct STUB { membertype member = 1; };
struct SUPER { membertype member = 1; };
struct SWITCH { membertype member = 1; };
struct SYNCHRONIZED { membertype member = 1; };
struct TAG { membertype member = 1; };
struct TEMPLATE { membertype member = 1; };
struct THIS { membertype member = 1; };
struct THREAD_LOCAL { membertype member = 1; };
struct THROW { membertype member = 1; };
struct TO_STRING { membertype member = 1; };
struct TRAIT { membertype member = 1; };
struct TRUE { membertype member = 1; };
struct TRY { membertype member = 1; };
struct TYPE { membertype member = 1; };
struct TYPEDEF { membertype member = 1; };
struct TYPEID { membertype member = 1; };
struct TYPENAME { membertype member = 1; };
struct TYPEOF { membertype member = 1; };
struct UINT16 { membertype member = 1; };
struct UINT32 { membertype member = 1; };
struct UINT64 { membertype member = 1; };
struct UINT8 { membertype member = 1; };
struct UNION { membertype member = 1; };
struct UNSAFE { membertype member = 1; };
struct UNSIGNED { membertype member = 1; };
struct UNSIZED { membertype member = 1; };
struct USE { membertype member = 1; };
struct USING { membertype member = 1; };
struct VALUE { membertype member = 1; };
struct VALUE_OF { membertype member = 1; };
struct VALUE_UNION { membertype member = 1; };
struct VALUES { membertype member = 1; };
struct VALUES_MAP { membertype member = 1; };
struct VAR { membertype member = 1; };
struct VEC { membertype member = 1; };
struct VIRTUAL { membertype member = 1; };
struct VOID { membertype member = 1; };
struct VOLATILE { membertype member = 1; };
struct WCHAR_T { membertype member = 1; };
struct WHERE { membertype member = 1; };
struct WHICH { membertype member = 1; };
struct WHILE { membertype member = 1; };
struct XOR { membertype member = 1; };
struct XOR_EQ { membertype member = 1; };
struct XUNION { membertype member = 1; };
struct YIELD { membertype member = 1; };
struct ZX { membertype member = 1; };
struct DangerousMembers {
  ABSTRACT f0;
  ALIGNAS f1;
  ALIGNOF f2;
  AND f3;
  AND_EQ f4;
  AS f5;
  ASM f6;
  ASYNC f7;
  ATOMIC_CANCEL f8;
  ATOMIC_COMMIT f9;
  ATOMIC_NOEXCEPT f10;
  AUTO f11;
  AWAIT f12;
  BECOME f13;
  BITAND f14;
  BITOR f15;
  BOOL f16;
  BOX f17;
  BREAK f18;
  BYTE f19;
  CASE f20;
  CATCH f21;
  CHAN f22;
  CHAR f23;
  CHAR16_T f24;
  CHAR32_T f25;
  CLASS f26;
  CO_AWAIT f27;
  CO_RETURN f28;
  CO_YIELD f29;
  CODING_TRAITS f30;
  COMPL f31;
  CONCEPT f32;
  CONST f33;
  CONST_CAST f34;
  CONSTEXPR f35;
  CONTINUE f36;
  CONTROLLER f37;
  CRATE f38;
  DECLTYPE f39;
  DECODER f40;
  DEFAULT f41;
  DEFER f42;
  DELETE f43;
  DO f44;
  DOUBLE f45;
  DYNAMIC_CAST f46;
  ELSE f47;
  ENCODER f48;
  ENUM f49;
  ERR f50;
  EXPLICIT f51;
  EXPORT f52;
  EXTERN f53;
  FALLTHROUGH f54;
  FALSE f55;
  FIDL f56;
  FIDL_TYPE f57;
  FINAL f58;
  FLOAT f59;
  FN f60;
  FOR f61;
  FRIEND f62;
  FUNC f63;
  FUTURE f64;
  FUTURES f65;
  GO f66;
  GOTO f67;
  HAS_INVALID_TAG f68;
  IF f69;
  IMPL f70;
  IMPORT f71;
  IN f72;
  INLINE f73;
  INT f74;
  INT16 f75;
  INT32 f76;
  INT64 f77;
  INT8 f78;
  INTERFACE f79;
  LET f80;
  LHS f81;
  LIST f82;
  LONG f83;
  LOOP f84;
  MACRO f85;
  MAP f86;
  MATCH f87;
  MOD f88;
  MODULE f89;
  MOVE f90;
  MUT f91;
  MUTABLE f92;
  NAMESPACE f93;
  NEVER f94;
  NEW f95;
  NOEXCEPT f96;
  NONE f97;
  NOT f98;
  NOT_EQ f99;
  NULLPTR f100;
  OFFSET f101;
  OFFSETOF f102;
  OK f103;
  ON_OPEN f104;
  OPERATOR f105;
  OPTION f106;
  OR f107;
  OR_EQ f108;
  OVERRIDE f109;
  PACKAGE f110;
  PRIV f111;
  PRIVATE f112;
  PROC f113;
  PROTECTED f114;
  PROXY f115;
  PUB f116;
  PUBLIC f117;
  PURE f118;
  RANGE f119;
  REF f120;
  REGISTER f121;
  REINTERPRET_CAST f122;
  REQUIRES f123;
  RESULT f124;
  RETURN f125;
  RHS f126;
  RUNE f127;
  SELECT f128;
  SELF f129;
  SEND f130;
  SET_CONTROLLER f131;
  SHORT f132;
  SIGNED f133;
  SIZEOF f134;
  SOME f135;
  STATIC f136;
  STATIC_ASSERT f137;
  STATIC_CAST f138;
  STREAM f139;
  STRING f140;
  STRUCT f141;
  STUB f142;
  SUPER f143;
  SWITCH f144;
  SYNCHRONIZED f145;
  TAG f146;
  TEMPLATE f147;
  THIS f148;
  THREAD_LOCAL f149;
  THROW f150;
  TO_STRING f151;
  TRAIT f152;
  TRUE f153;
  TRY f154;
  TYPE f155;
  TYPEDEF f156;
  TYPEID f157;
  TYPENAME f158;
  TYPEOF f159;
  UINT16 f160;
  UINT32 f161;
  UINT64 f162;
  UINT8 f163;
  UNION f164;
  UNSAFE f165;
  UNSIGNED f166;
  UNSIZED f167;
  USE f168;
  USING f169;
  VALUE f170;
  VALUE_OF f171;
  VALUE_UNION f172;
  VALUES f173;
  VALUES_MAP f174;
  VAR f175;
  VEC f176;
  VIRTUAL f177;
  VOID f178;
  VOLATILE f179;
  WCHAR_T f180;
  WHERE f181;
  WHICH f182;
  WHILE f183;
  XOR f184;
  XOR_EQ f185;
  XUNION f186;
  YIELD f187;
  ZX f188;
};

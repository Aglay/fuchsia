// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Generated by generate.py.
library fidl.test.dangerous.enums.camel;
enum Abstract { MEMBER = 1; };
enum Alignas { MEMBER = 1; };
enum Alignof { MEMBER = 1; };
enum And { MEMBER = 1; };
enum AndEq { MEMBER = 1; };
enum As { MEMBER = 1; };
enum Asm { MEMBER = 1; };
enum Async { MEMBER = 1; };
enum AtomicCancel { MEMBER = 1; };
enum AtomicCommit { MEMBER = 1; };
enum AtomicNoexcept { MEMBER = 1; };
enum Auto { MEMBER = 1; };
enum Await { MEMBER = 1; };
enum Become { MEMBER = 1; };
enum Bitand { MEMBER = 1; };
enum Bitor { MEMBER = 1; };
enum Bool { MEMBER = 1; };
enum Box { MEMBER = 1; };
enum Break { MEMBER = 1; };
enum Byte { MEMBER = 1; };
enum Case { MEMBER = 1; };
enum Catch { MEMBER = 1; };
enum Chan { MEMBER = 1; };
enum Char { MEMBER = 1; };
enum Char16T { MEMBER = 1; };
enum Char32T { MEMBER = 1; };
enum Class { MEMBER = 1; };
enum CoAwait { MEMBER = 1; };
enum CoReturn { MEMBER = 1; };
enum CoYield { MEMBER = 1; };
enum CodingTraits { MEMBER = 1; };
enum Compl { MEMBER = 1; };
enum Concept { MEMBER = 1; };
enum Const { MEMBER = 1; };
enum ConstCast { MEMBER = 1; };
enum Constexpr { MEMBER = 1; };
enum Continue { MEMBER = 1; };
enum Crate { MEMBER = 1; };
enum Decltype { MEMBER = 1; };
enum Decoder { MEMBER = 1; };
enum Default { MEMBER = 1; };
enum Defer { MEMBER = 1; };
enum Delete { MEMBER = 1; };
enum Do { MEMBER = 1; };
enum Double { MEMBER = 1; };
enum DynamicCast { MEMBER = 1; };
enum Else { MEMBER = 1; };
enum Encoder { MEMBER = 1; };
enum Enum { MEMBER = 1; };
enum Err { MEMBER = 1; };
enum Explicit { MEMBER = 1; };
enum Export { MEMBER = 1; };
enum Extern { MEMBER = 1; };
enum Fallthrough { MEMBER = 1; };
enum False { MEMBER = 1; };
enum Fidl { MEMBER = 1; };
enum FidlType { MEMBER = 1; };
enum Final { MEMBER = 1; };
enum Float { MEMBER = 1; };
enum Fn { MEMBER = 1; };
enum For { MEMBER = 1; };
enum Friend { MEMBER = 1; };
enum Func { MEMBER = 1; };
enum Future { MEMBER = 1; };
enum Futures { MEMBER = 1; };
enum Go { MEMBER = 1; };
enum Goto { MEMBER = 1; };
enum HasInvalidTag { MEMBER = 1; };
enum If { MEMBER = 1; };
enum Impl { MEMBER = 1; };
enum Import { MEMBER = 1; };
enum In { MEMBER = 1; };
enum Inline { MEMBER = 1; };
enum Int { MEMBER = 1; };
enum Int16 { MEMBER = 1; };
enum Int32 { MEMBER = 1; };
enum Int64 { MEMBER = 1; };
enum Int8 { MEMBER = 1; };
enum Interface { MEMBER = 1; };
enum Let { MEMBER = 1; };
enum Lhs { MEMBER = 1; };
enum Long { MEMBER = 1; };
enum Loop { MEMBER = 1; };
enum Macro { MEMBER = 1; };
enum Map { MEMBER = 1; };
enum Match { MEMBER = 1; };
enum Mod { MEMBER = 1; };
enum Module { MEMBER = 1; };
enum Move { MEMBER = 1; };
enum Mut { MEMBER = 1; };
enum Mutable { MEMBER = 1; };
enum Namespace { MEMBER = 1; };
enum Never { MEMBER = 1; };
enum New { MEMBER = 1; };
enum Noexcept { MEMBER = 1; };
enum None { MEMBER = 1; };
enum Not { MEMBER = 1; };
enum NotEq { MEMBER = 1; };
enum Nullptr { MEMBER = 1; };
enum Offset { MEMBER = 1; };
enum Offsetof { MEMBER = 1; };
enum Ok { MEMBER = 1; };
enum OnOpen { MEMBER = 1; };
enum Operator { MEMBER = 1; };
enum Option { MEMBER = 1; };
enum Or { MEMBER = 1; };
enum OrEq { MEMBER = 1; };
enum Override { MEMBER = 1; };
enum Package { MEMBER = 1; };
enum Priv { MEMBER = 1; };
enum Private { MEMBER = 1; };
enum Proc { MEMBER = 1; };
enum Protected { MEMBER = 1; };
enum Pub { MEMBER = 1; };
enum Public { MEMBER = 1; };
enum Pure { MEMBER = 1; };
enum Range { MEMBER = 1; };
enum Ref { MEMBER = 1; };
enum Register { MEMBER = 1; };
enum ReinterpretCast { MEMBER = 1; };
enum Requires { MEMBER = 1; };
enum Result { MEMBER = 1; };
enum Return { MEMBER = 1; };
enum Rhs { MEMBER = 1; };
enum Rune { MEMBER = 1; };
enum Select { MEMBER = 1; };
enum Self { MEMBER = 1; };
enum Send { MEMBER = 1; };
enum Short { MEMBER = 1; };
enum Signed { MEMBER = 1; };
enum Sizeof { MEMBER = 1; };
enum Some { MEMBER = 1; };
enum Static { MEMBER = 1; };
enum StaticAssert { MEMBER = 1; };
enum StaticCast { MEMBER = 1; };
enum Stream { MEMBER = 1; };
enum String { MEMBER = 1; };
enum Struct { MEMBER = 1; };
enum Super { MEMBER = 1; };
enum Switch { MEMBER = 1; };
enum Synchronized { MEMBER = 1; };
enum Tag { MEMBER = 1; };
enum Template { MEMBER = 1; };
enum This { MEMBER = 1; };
enum ThreadLocal { MEMBER = 1; };
enum Throw { MEMBER = 1; };
enum Trait { MEMBER = 1; };
enum True { MEMBER = 1; };
enum Try { MEMBER = 1; };
enum Type { MEMBER = 1; };
enum Typedef { MEMBER = 1; };
enum Typeid { MEMBER = 1; };
enum Typename { MEMBER = 1; };
enum Typeof { MEMBER = 1; };
enum Uint16 { MEMBER = 1; };
enum Uint32 { MEMBER = 1; };
enum Uint64 { MEMBER = 1; };
enum Uint8 { MEMBER = 1; };
enum Union { MEMBER = 1; };
enum Unsafe { MEMBER = 1; };
enum Unsigned { MEMBER = 1; };
enum Unsized { MEMBER = 1; };
enum Use { MEMBER = 1; };
enum Using { MEMBER = 1; };
enum Value { MEMBER = 1; };
enum ValueUnion { MEMBER = 1; };
enum Var { MEMBER = 1; };
enum Vec { MEMBER = 1; };
enum Virtual { MEMBER = 1; };
enum Void { MEMBER = 1; };
enum Volatile { MEMBER = 1; };
enum WcharT { MEMBER = 1; };
enum Where { MEMBER = 1; };
enum Which { MEMBER = 1; };
enum While { MEMBER = 1; };
enum Xor { MEMBER = 1; };
enum XorEq { MEMBER = 1; };
enum Xunion { MEMBER = 1; };
enum Yield { MEMBER = 1; };
enum Zx { MEMBER = 1; };
enum DangerousMembers {
  Abstract = 0;
  Alignas = 1;
  Alignof = 2;
  And = 3;
  AndEq = 4;
  As = 5;
  Asm = 6;
  Async = 7;
  AtomicCancel = 8;
  AtomicCommit = 9;
  AtomicNoexcept = 10;
  Auto = 11;
  Await = 12;
  Become = 13;
  Bitand = 14;
  Bitor = 15;
  Bool = 16;
  Box = 17;
  Break = 18;
  Byte = 19;
  Case = 20;
  Catch = 21;
  Chan = 22;
  Char = 23;
  Char16T = 24;
  Char32T = 25;
  Class = 26;
  CoAwait = 27;
  CoReturn = 28;
  CoYield = 29;
  CodingTraits = 30;
  Compl = 31;
  Concept = 32;
  Const = 33;
  ConstCast = 34;
  Constexpr = 35;
  Continue = 36;
  Crate = 37;
  Decltype = 38;
  Decoder = 39;
  Default = 40;
  Defer = 41;
  Delete = 42;
  Do = 43;
  Double = 44;
  DynamicCast = 45;
  Else = 46;
  Encoder = 47;
  Enum = 48;
  Err = 49;
  Explicit = 50;
  Export = 51;
  Extern = 52;
  Fallthrough = 53;
  False = 54;
  Fidl = 55;
  FidlType = 56;
  Final = 57;
  Float = 58;
  Fn = 59;
  For = 60;
  Friend = 61;
  Func = 62;
  Future = 63;
  Futures = 64;
  Go = 65;
  Goto = 66;
  HasInvalidTag = 67;
  If = 68;
  Impl = 69;
  Import = 70;
  In = 71;
  Inline = 72;
  Int = 73;
  Int16 = 74;
  Int32 = 75;
  Int64 = 76;
  Int8 = 77;
  Interface = 78;
  Let = 79;
  Lhs = 80;
  Long = 81;
  Loop = 82;
  Macro = 83;
  Map = 84;
  Match = 85;
  Mod = 86;
  Module = 87;
  Move = 88;
  Mut = 89;
  Mutable = 90;
  Namespace = 91;
  Never = 92;
  New = 93;
  Noexcept = 94;
  None = 95;
  Not = 96;
  NotEq = 97;
  Nullptr = 98;
  Offset = 99;
  Offsetof = 100;
  Ok = 101;
  OnOpen = 102;
  Operator = 103;
  Option = 104;
  Or = 105;
  OrEq = 106;
  Override = 107;
  Package = 108;
  Priv = 109;
  Private = 110;
  Proc = 111;
  Protected = 112;
  Pub = 113;
  Public = 114;
  Pure = 115;
  Range = 116;
  Ref = 117;
  Register = 118;
  ReinterpretCast = 119;
  Requires = 120;
  Result = 121;
  Return = 122;
  Rhs = 123;
  Rune = 124;
  Select = 125;
  Self = 126;
  Send = 127;
  Short = 128;
  Signed = 129;
  Sizeof = 130;
  Some = 131;
  Static = 132;
  StaticAssert = 133;
  StaticCast = 134;
  Stream = 135;
  String = 136;
  Struct = 137;
  Super = 138;
  Switch = 139;
  Synchronized = 140;
  Tag = 141;
  Template = 142;
  This = 143;
  ThreadLocal = 144;
  Throw = 145;
  Trait = 146;
  True = 147;
  Try = 148;
  Type = 149;
  Typedef = 150;
  Typeid = 151;
  Typename = 152;
  Typeof = 153;
  Uint16 = 154;
  Uint32 = 155;
  Uint64 = 156;
  Uint8 = 157;
  Union = 158;
  Unsafe = 159;
  Unsigned = 160;
  Unsized = 161;
  Use = 162;
  Using = 163;
  Value = 164;
  ValueUnion = 165;
  Var = 166;
  Vec = 167;
  Virtual = 168;
  Void = 169;
  Volatile = 170;
  WcharT = 171;
  Where = 172;
  Which = 173;
  While = 174;
  Xor = 175;
  XorEq = 176;
  Xunion = 177;
  Yield = 178;
  Zx = 179;
};

// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Generated by generate.py.
library fidl.test.dangerous.enums.camel;
enum Abstract { MEMBER = 1; };
enum Alignas { MEMBER = 1; };
enum Alignof { MEMBER = 1; };
enum And { MEMBER = 1; };
enum AndEq { MEMBER = 1; };
enum As { MEMBER = 1; };
enum Asm { MEMBER = 1; };
enum Async { MEMBER = 1; };
enum AtomicCancel { MEMBER = 1; };
enum AtomicCommit { MEMBER = 1; };
enum AtomicNoexcept { MEMBER = 1; };
enum Auto { MEMBER = 1; };
enum Await { MEMBER = 1; };
enum Become { MEMBER = 1; };
enum Bitand { MEMBER = 1; };
enum Bitor { MEMBER = 1; };
enum Bool { MEMBER = 1; };
enum Box { MEMBER = 1; };
enum Break { MEMBER = 1; };
enum Byte { MEMBER = 1; };
enum Case { MEMBER = 1; };
enum Catch { MEMBER = 1; };
enum Chan { MEMBER = 1; };
enum Char { MEMBER = 1; };
enum Char16T { MEMBER = 1; };
enum Char32T { MEMBER = 1; };
enum Class { MEMBER = 1; };
enum CoAwait { MEMBER = 1; };
enum CoReturn { MEMBER = 1; };
enum CoYield { MEMBER = 1; };
enum CodingTraits { MEMBER = 1; };
enum Compl { MEMBER = 1; };
enum Concept { MEMBER = 1; };
enum Const { MEMBER = 1; };
enum ConstCast { MEMBER = 1; };
enum Constexpr { MEMBER = 1; };
enum Continue { MEMBER = 1; };
enum Controller { MEMBER = 1; };
enum Crate { MEMBER = 1; };
enum Decltype { MEMBER = 1; };
enum Decoder { MEMBER = 1; };
enum Default { MEMBER = 1; };
enum Defer { MEMBER = 1; };
enum Delete { MEMBER = 1; };
enum Do { MEMBER = 1; };
enum Double { MEMBER = 1; };
enum DynamicCast { MEMBER = 1; };
enum Else { MEMBER = 1; };
enum Encoder { MEMBER = 1; };
enum Enum { MEMBER = 1; };
enum Err { MEMBER = 1; };
enum Explicit { MEMBER = 1; };
enum Export { MEMBER = 1; };
enum Extern { MEMBER = 1; };
enum Fallthrough { MEMBER = 1; };
enum False { MEMBER = 1; };
enum Fidl { MEMBER = 1; };
enum FidlType { MEMBER = 1; };
enum Final { MEMBER = 1; };
enum Float { MEMBER = 1; };
enum Fn { MEMBER = 1; };
enum For { MEMBER = 1; };
enum Friend { MEMBER = 1; };
enum Func { MEMBER = 1; };
enum Future { MEMBER = 1; };
enum Futures { MEMBER = 1; };
enum Go { MEMBER = 1; };
enum Goto { MEMBER = 1; };
enum HasInvalidTag { MEMBER = 1; };
enum If { MEMBER = 1; };
enum Impl { MEMBER = 1; };
enum Import { MEMBER = 1; };
enum In { MEMBER = 1; };
enum Inline { MEMBER = 1; };
enum Int { MEMBER = 1; };
enum Int16 { MEMBER = 1; };
enum Int32 { MEMBER = 1; };
enum Int64 { MEMBER = 1; };
enum Int8 { MEMBER = 1; };
enum Interface { MEMBER = 1; };
enum Let { MEMBER = 1; };
enum Lhs { MEMBER = 1; };
enum List { MEMBER = 1; };
enum Long { MEMBER = 1; };
enum Loop { MEMBER = 1; };
enum Macro { MEMBER = 1; };
enum Map { MEMBER = 1; };
enum Match { MEMBER = 1; };
enum Mod { MEMBER = 1; };
enum Module { MEMBER = 1; };
enum Move { MEMBER = 1; };
enum Mut { MEMBER = 1; };
enum Mutable { MEMBER = 1; };
enum Namespace { MEMBER = 1; };
enum Never { MEMBER = 1; };
enum New { MEMBER = 1; };
enum Noexcept { MEMBER = 1; };
enum None { MEMBER = 1; };
enum Not { MEMBER = 1; };
enum NotEq { MEMBER = 1; };
enum Nullptr { MEMBER = 1; };
enum Offset { MEMBER = 1; };
enum Offsetof { MEMBER = 1; };
enum Ok { MEMBER = 1; };
enum OnOpen { MEMBER = 1; };
enum Operator { MEMBER = 1; };
enum Option { MEMBER = 1; };
enum Or { MEMBER = 1; };
enum OrEq { MEMBER = 1; };
enum Override { MEMBER = 1; };
enum Package { MEMBER = 1; };
enum Priv { MEMBER = 1; };
enum Private { MEMBER = 1; };
enum Proc { MEMBER = 1; };
enum Protected { MEMBER = 1; };
enum Proxy { MEMBER = 1; };
enum Pub { MEMBER = 1; };
enum Public { MEMBER = 1; };
enum Pure { MEMBER = 1; };
enum Range { MEMBER = 1; };
enum Ref { MEMBER = 1; };
enum Register { MEMBER = 1; };
enum ReinterpretCast { MEMBER = 1; };
enum Requires { MEMBER = 1; };
enum Result { MEMBER = 1; };
enum Return { MEMBER = 1; };
enum Rhs { MEMBER = 1; };
enum Rune { MEMBER = 1; };
enum Select { MEMBER = 1; };
enum Self { MEMBER = 1; };
enum Send { MEMBER = 1; };
enum SetController { MEMBER = 1; };
enum Short { MEMBER = 1; };
enum Signed { MEMBER = 1; };
enum Sizeof { MEMBER = 1; };
enum Some { MEMBER = 1; };
enum Static { MEMBER = 1; };
enum StaticAssert { MEMBER = 1; };
enum StaticCast { MEMBER = 1; };
enum Stream { MEMBER = 1; };
enum String { MEMBER = 1; };
enum Struct { MEMBER = 1; };
enum Stub { MEMBER = 1; };
enum Super { MEMBER = 1; };
enum Switch { MEMBER = 1; };
enum Synchronized { MEMBER = 1; };
enum Tag { MEMBER = 1; };
enum Template { MEMBER = 1; };
enum This { MEMBER = 1; };
enum ThreadLocal { MEMBER = 1; };
enum Throw { MEMBER = 1; };
enum ToString { MEMBER = 1; };
enum Trait { MEMBER = 1; };
enum True { MEMBER = 1; };
enum Try { MEMBER = 1; };
enum Type { MEMBER = 1; };
enum Typedef { MEMBER = 1; };
enum Typeid { MEMBER = 1; };
enum Typename { MEMBER = 1; };
enum Typeof { MEMBER = 1; };
enum Uint16 { MEMBER = 1; };
enum Uint32 { MEMBER = 1; };
enum Uint64 { MEMBER = 1; };
enum Uint8 { MEMBER = 1; };
enum Union { MEMBER = 1; };
enum Unsafe { MEMBER = 1; };
enum Unsigned { MEMBER = 1; };
enum Unsized { MEMBER = 1; };
enum Use { MEMBER = 1; };
enum Using { MEMBER = 1; };
enum Value { MEMBER = 1; };
enum ValueOf { MEMBER = 1; };
enum ValueUnion { MEMBER = 1; };
enum Values { MEMBER = 1; };
enum ValuesMap { MEMBER = 1; };
enum Var { MEMBER = 1; };
enum Vec { MEMBER = 1; };
enum Virtual { MEMBER = 1; };
enum Void { MEMBER = 1; };
enum Volatile { MEMBER = 1; };
enum WcharT { MEMBER = 1; };
enum Where { MEMBER = 1; };
enum Which { MEMBER = 1; };
enum While { MEMBER = 1; };
enum Xor { MEMBER = 1; };
enum XorEq { MEMBER = 1; };
enum Xunion { MEMBER = 1; };
enum Yield { MEMBER = 1; };
enum Zx { MEMBER = 1; };
enum DangerousMembers {
  Abstract = 0;
  Alignas = 1;
  Alignof = 2;
  And = 3;
  AndEq = 4;
  As = 5;
  Asm = 6;
  Async = 7;
  AtomicCancel = 8;
  AtomicCommit = 9;
  AtomicNoexcept = 10;
  Auto = 11;
  Await = 12;
  Become = 13;
  Bitand = 14;
  Bitor = 15;
  Bool = 16;
  Box = 17;
  Break = 18;
  Byte = 19;
  Case = 20;
  Catch = 21;
  Chan = 22;
  Char = 23;
  Char16T = 24;
  Char32T = 25;
  Class = 26;
  CoAwait = 27;
  CoReturn = 28;
  CoYield = 29;
  CodingTraits = 30;
  Compl = 31;
  Concept = 32;
  Const = 33;
  ConstCast = 34;
  Constexpr = 35;
  Continue = 36;
  Controller = 37;
  Crate = 38;
  Decltype = 39;
  Decoder = 40;
  Default = 41;
  Defer = 42;
  Delete = 43;
  Do = 44;
  Double = 45;
  DynamicCast = 46;
  Else = 47;
  Encoder = 48;
  Enum = 49;
  Err = 50;
  Explicit = 51;
  Export = 52;
  Extern = 53;
  Fallthrough = 54;
  False = 55;
  Fidl = 56;
  FidlType = 57;
  Final = 58;
  Float = 59;
  Fn = 60;
  For = 61;
  Friend = 62;
  Func = 63;
  Future = 64;
  Futures = 65;
  Go = 66;
  Goto = 67;
  HasInvalidTag = 68;
  If = 69;
  Impl = 70;
  Import = 71;
  In = 72;
  Inline = 73;
  Int = 74;
  Int16 = 75;
  Int32 = 76;
  Int64 = 77;
  Int8 = 78;
  Interface = 79;
  Let = 80;
  Lhs = 81;
  List = 82;
  Long = 83;
  Loop = 84;
  Macro = 85;
  Map = 86;
  Match = 87;
  Mod = 88;
  Module = 89;
  Move = 90;
  Mut = 91;
  Mutable = 92;
  Namespace = 93;
  Never = 94;
  New = 95;
  Noexcept = 96;
  None = 97;
  Not = 98;
  NotEq = 99;
  Nullptr = 100;
  Offset = 101;
  Offsetof = 102;
  Ok = 103;
  OnOpen = 104;
  Operator = 105;
  Option = 106;
  Or = 107;
  OrEq = 108;
  Override = 109;
  Package = 110;
  Priv = 111;
  Private = 112;
  Proc = 113;
  Protected = 114;
  Proxy = 115;
  Pub = 116;
  Public = 117;
  Pure = 118;
  Range = 119;
  Ref = 120;
  Register = 121;
  ReinterpretCast = 122;
  Requires = 123;
  Result = 124;
  Return = 125;
  Rhs = 126;
  Rune = 127;
  Select = 128;
  Self = 129;
  Send = 130;
  SetController = 131;
  Short = 132;
  Signed = 133;
  Sizeof = 134;
  Some = 135;
  Static = 136;
  StaticAssert = 137;
  StaticCast = 138;
  Stream = 139;
  String = 140;
  Struct = 141;
  Stub = 142;
  Super = 143;
  Switch = 144;
  Synchronized = 145;
  Tag = 146;
  Template = 147;
  This = 148;
  ThreadLocal = 149;
  Throw = 150;
  ToString = 151;
  Trait = 152;
  True = 153;
  Try = 154;
  Type = 155;
  Typedef = 156;
  Typeid = 157;
  Typename = 158;
  Typeof = 159;
  Uint16 = 160;
  Uint32 = 161;
  Uint64 = 162;
  Uint8 = 163;
  Union = 164;
  Unsafe = 165;
  Unsigned = 166;
  Unsized = 167;
  Use = 168;
  Using = 169;
  Value = 170;
  ValueOf = 171;
  ValueUnion = 172;
  Values = 173;
  ValuesMap = 174;
  Var = 175;
  Vec = 176;
  Virtual = 177;
  Void = 178;
  Volatile = 179;
  WcharT = 180;
  Where = 181;
  Which = 182;
  While = 183;
  Xor = 184;
  XorEq = 185;
  Xunion = 186;
  Yield = 187;
  Zx = 188;
};

// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Generated by generate.py.
library fidl.test.dangerous.enums.lower;
enum abstract { MEMBER = 1; };
enum alignas { MEMBER = 1; };
enum alignof { MEMBER = 1; };
enum and { MEMBER = 1; };
enum and_eq { MEMBER = 1; };
enum as { MEMBER = 1; };
enum asm { MEMBER = 1; };
enum async { MEMBER = 1; };
enum atomic_cancel { MEMBER = 1; };
enum atomic_commit { MEMBER = 1; };
enum atomic_noexcept { MEMBER = 1; };
enum auto { MEMBER = 1; };
enum await { MEMBER = 1; };
enum become { MEMBER = 1; };
enum bitand { MEMBER = 1; };
enum bitor { MEMBER = 1; };
enum bool { MEMBER = 1; };
enum box { MEMBER = 1; };
enum break { MEMBER = 1; };
enum byte { MEMBER = 1; };
enum case { MEMBER = 1; };
enum catch { MEMBER = 1; };
enum chan { MEMBER = 1; };
enum char { MEMBER = 1; };
enum char16_t { MEMBER = 1; };
enum char32_t { MEMBER = 1; };
enum class { MEMBER = 1; };
enum co_await { MEMBER = 1; };
enum co_return { MEMBER = 1; };
enum co_yield { MEMBER = 1; };
enum coding_traits { MEMBER = 1; };
enum compl { MEMBER = 1; };
enum concept { MEMBER = 1; };
enum const { MEMBER = 1; };
enum const_cast { MEMBER = 1; };
enum constexpr { MEMBER = 1; };
enum continue { MEMBER = 1; };
enum controller { MEMBER = 1; };
enum crate { MEMBER = 1; };
enum decltype { MEMBER = 1; };
enum decoder { MEMBER = 1; };
enum default { MEMBER = 1; };
enum defer { MEMBER = 1; };
enum delete { MEMBER = 1; };
enum do { MEMBER = 1; };
enum double { MEMBER = 1; };
enum dynamic_cast { MEMBER = 1; };
enum else { MEMBER = 1; };
enum encoder { MEMBER = 1; };
enum enum { MEMBER = 1; };
enum err { MEMBER = 1; };
enum explicit { MEMBER = 1; };
enum export { MEMBER = 1; };
enum extern { MEMBER = 1; };
enum fallthrough { MEMBER = 1; };
enum false { MEMBER = 1; };
enum fidl { MEMBER = 1; };
enum fidl_type { MEMBER = 1; };
enum final { MEMBER = 1; };
enum float { MEMBER = 1; };
enum fn { MEMBER = 1; };
enum for { MEMBER = 1; };
enum friend { MEMBER = 1; };
enum func { MEMBER = 1; };
enum future { MEMBER = 1; };
enum futures { MEMBER = 1; };
enum go { MEMBER = 1; };
enum goto { MEMBER = 1; };
enum has_invalid_tag { MEMBER = 1; };
enum if { MEMBER = 1; };
enum impl { MEMBER = 1; };
enum import { MEMBER = 1; };
enum in { MEMBER = 1; };
enum inline { MEMBER = 1; };
enum int { MEMBER = 1; };
enum int16 { MEMBER = 1; };
enum int32 { MEMBER = 1; };
enum int64 { MEMBER = 1; };
enum int8 { MEMBER = 1; };
enum interface { MEMBER = 1; };
enum let { MEMBER = 1; };
enum lhs { MEMBER = 1; };
enum list { MEMBER = 1; };
enum long { MEMBER = 1; };
enum loop { MEMBER = 1; };
enum macro { MEMBER = 1; };
enum map { MEMBER = 1; };
enum match { MEMBER = 1; };
enum mod { MEMBER = 1; };
enum module { MEMBER = 1; };
enum move { MEMBER = 1; };
enum mut { MEMBER = 1; };
enum mutable { MEMBER = 1; };
enum namespace { MEMBER = 1; };
enum never { MEMBER = 1; };
enum new { MEMBER = 1; };
enum noexcept { MEMBER = 1; };
enum none { MEMBER = 1; };
enum not { MEMBER = 1; };
enum not_eq { MEMBER = 1; };
enum nullptr { MEMBER = 1; };
enum offset { MEMBER = 1; };
enum offsetof { MEMBER = 1; };
enum ok { MEMBER = 1; };
enum on_open { MEMBER = 1; };
enum operator { MEMBER = 1; };
enum option { MEMBER = 1; };
enum or { MEMBER = 1; };
enum or_eq { MEMBER = 1; };
enum override { MEMBER = 1; };
enum package { MEMBER = 1; };
enum priv { MEMBER = 1; };
enum private { MEMBER = 1; };
enum proc { MEMBER = 1; };
enum protected { MEMBER = 1; };
enum proxy { MEMBER = 1; };
enum pub { MEMBER = 1; };
enum public { MEMBER = 1; };
enum pure { MEMBER = 1; };
enum range { MEMBER = 1; };
enum ref { MEMBER = 1; };
enum register { MEMBER = 1; };
enum reinterpret_cast { MEMBER = 1; };
enum requires { MEMBER = 1; };
enum result { MEMBER = 1; };
enum return { MEMBER = 1; };
enum rhs { MEMBER = 1; };
enum rune { MEMBER = 1; };
enum select { MEMBER = 1; };
enum self { MEMBER = 1; };
enum send { MEMBER = 1; };
enum set_controller { MEMBER = 1; };
enum short { MEMBER = 1; };
enum signed { MEMBER = 1; };
enum sizeof { MEMBER = 1; };
enum some { MEMBER = 1; };
enum static { MEMBER = 1; };
enum static_assert { MEMBER = 1; };
enum static_cast { MEMBER = 1; };
enum stream { MEMBER = 1; };
enum string { MEMBER = 1; };
enum struct { MEMBER = 1; };
enum stub { MEMBER = 1; };
enum super { MEMBER = 1; };
enum switch { MEMBER = 1; };
enum synchronized { MEMBER = 1; };
enum tag { MEMBER = 1; };
enum template { MEMBER = 1; };
enum this { MEMBER = 1; };
enum thread_local { MEMBER = 1; };
enum throw { MEMBER = 1; };
enum to_string { MEMBER = 1; };
enum trait { MEMBER = 1; };
enum true { MEMBER = 1; };
enum try { MEMBER = 1; };
enum type { MEMBER = 1; };
enum typedef { MEMBER = 1; };
enum typeid { MEMBER = 1; };
enum typename { MEMBER = 1; };
enum typeof { MEMBER = 1; };
enum uint16 { MEMBER = 1; };
enum uint32 { MEMBER = 1; };
enum uint64 { MEMBER = 1; };
enum uint8 { MEMBER = 1; };
enum union { MEMBER = 1; };
enum unsafe { MEMBER = 1; };
enum unsigned { MEMBER = 1; };
enum unsized { MEMBER = 1; };
enum use { MEMBER = 1; };
enum using { MEMBER = 1; };
enum value { MEMBER = 1; };
enum value_of { MEMBER = 1; };
enum value_union { MEMBER = 1; };
enum values { MEMBER = 1; };
enum values_map { MEMBER = 1; };
enum var { MEMBER = 1; };
enum vec { MEMBER = 1; };
enum virtual { MEMBER = 1; };
enum void { MEMBER = 1; };
enum volatile { MEMBER = 1; };
enum wchar_t { MEMBER = 1; };
enum where { MEMBER = 1; };
enum which { MEMBER = 1; };
enum while { MEMBER = 1; };
enum xor { MEMBER = 1; };
enum xor_eq { MEMBER = 1; };
enum xunion { MEMBER = 1; };
enum yield { MEMBER = 1; };
enum zx { MEMBER = 1; };
enum DangerousMembers {
  abstract = 0;
  alignas = 1;
  alignof = 2;
  and = 3;
  and_eq = 4;
  as = 5;
  asm = 6;
  async = 7;
  atomic_cancel = 8;
  atomic_commit = 9;
  atomic_noexcept = 10;
  auto = 11;
  await = 12;
  become = 13;
  bitand = 14;
  bitor = 15;
  bool = 16;
  box = 17;
  break = 18;
  byte = 19;
  case = 20;
  catch = 21;
  chan = 22;
  char = 23;
  char16_t = 24;
  char32_t = 25;
  class = 26;
  co_await = 27;
  co_return = 28;
  co_yield = 29;
  coding_traits = 30;
  compl = 31;
  concept = 32;
  const = 33;
  const_cast = 34;
  constexpr = 35;
  continue = 36;
  controller = 37;
  crate = 38;
  decltype = 39;
  decoder = 40;
  default = 41;
  defer = 42;
  delete = 43;
  do = 44;
  double = 45;
  dynamic_cast = 46;
  else = 47;
  encoder = 48;
  enum = 49;
  err = 50;
  explicit = 51;
  export = 52;
  extern = 53;
  fallthrough = 54;
  false = 55;
  fidl = 56;
  fidl_type = 57;
  final = 58;
  float = 59;
  fn = 60;
  for = 61;
  friend = 62;
  func = 63;
  future = 64;
  futures = 65;
  go = 66;
  goto = 67;
  has_invalid_tag = 68;
  if = 69;
  impl = 70;
  import = 71;
  in = 72;
  inline = 73;
  int = 74;
  int16 = 75;
  int32 = 76;
  int64 = 77;
  int8 = 78;
  interface = 79;
  let = 80;
  lhs = 81;
  list = 82;
  long = 83;
  loop = 84;
  macro = 85;
  map = 86;
  match = 87;
  mod = 88;
  module = 89;
  move = 90;
  mut = 91;
  mutable = 92;
  namespace = 93;
  never = 94;
  new = 95;
  noexcept = 96;
  none = 97;
  not = 98;
  not_eq = 99;
  nullptr = 100;
  offset = 101;
  offsetof = 102;
  ok = 103;
  on_open = 104;
  operator = 105;
  option = 106;
  or = 107;
  or_eq = 108;
  override = 109;
  package = 110;
  priv = 111;
  private = 112;
  proc = 113;
  protected = 114;
  proxy = 115;
  pub = 116;
  public = 117;
  pure = 118;
  range = 119;
  ref = 120;
  register = 121;
  reinterpret_cast = 122;
  requires = 123;
  result = 124;
  return = 125;
  rhs = 126;
  rune = 127;
  select = 128;
  self = 129;
  send = 130;
  set_controller = 131;
  short = 132;
  signed = 133;
  sizeof = 134;
  some = 135;
  static = 136;
  static_assert = 137;
  static_cast = 138;
  stream = 139;
  string = 140;
  struct = 141;
  stub = 142;
  super = 143;
  switch = 144;
  synchronized = 145;
  tag = 146;
  template = 147;
  this = 148;
  thread_local = 149;
  throw = 150;
  to_string = 151;
  trait = 152;
  true = 153;
  try = 154;
  type = 155;
  typedef = 156;
  typeid = 157;
  typename = 158;
  typeof = 159;
  uint16 = 160;
  uint32 = 161;
  uint64 = 162;
  uint8 = 163;
  union = 164;
  unsafe = 165;
  unsigned = 166;
  unsized = 167;
  use = 168;
  using = 169;
  value = 170;
  value_of = 171;
  value_union = 172;
  values = 173;
  values_map = 174;
  var = 175;
  vec = 176;
  virtual = 177;
  void = 178;
  volatile = 179;
  wchar_t = 180;
  where = 181;
  which = 182;
  while = 183;
  xor = 184;
  xor_eq = 185;
  xunion = 186;
  yield = 187;
  zx = 188;
};

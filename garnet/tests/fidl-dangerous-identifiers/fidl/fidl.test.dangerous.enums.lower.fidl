// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Generated by generate.py.
library fidl.test.dangerous.enums.lower;
enum abstract { MEMBER = 1; };
enum alignas { MEMBER = 1; };
enum alignof { MEMBER = 1; };
enum and { MEMBER = 1; };
enum and_eq { MEMBER = 1; };
enum as { MEMBER = 1; };
enum asm { MEMBER = 1; };
enum async { MEMBER = 1; };
enum atomic_cancel { MEMBER = 1; };
enum atomic_commit { MEMBER = 1; };
enum atomic_noexcept { MEMBER = 1; };
enum auto { MEMBER = 1; };
enum await { MEMBER = 1; };
enum become { MEMBER = 1; };
enum bitand { MEMBER = 1; };
enum bitor { MEMBER = 1; };
enum bool { MEMBER = 1; };
enum box { MEMBER = 1; };
enum break { MEMBER = 1; };
enum byte { MEMBER = 1; };
enum case { MEMBER = 1; };
enum catch { MEMBER = 1; };
enum chan { MEMBER = 1; };
enum char { MEMBER = 1; };
enum char16_t { MEMBER = 1; };
enum char32_t { MEMBER = 1; };
enum class { MEMBER = 1; };
enum co_await { MEMBER = 1; };
enum co_return { MEMBER = 1; };
enum co_yield { MEMBER = 1; };
enum coding_traits { MEMBER = 1; };
enum compl { MEMBER = 1; };
enum concept { MEMBER = 1; };
enum const { MEMBER = 1; };
enum const_cast { MEMBER = 1; };
enum constexpr { MEMBER = 1; };
enum continue { MEMBER = 1; };
enum crate { MEMBER = 1; };
enum decltype { MEMBER = 1; };
enum decoder { MEMBER = 1; };
enum default { MEMBER = 1; };
enum defer { MEMBER = 1; };
enum delete { MEMBER = 1; };
enum do { MEMBER = 1; };
enum double { MEMBER = 1; };
enum dynamic_cast { MEMBER = 1; };
enum else { MEMBER = 1; };
enum encoder { MEMBER = 1; };
enum enum { MEMBER = 1; };
enum err { MEMBER = 1; };
enum explicit { MEMBER = 1; };
enum export { MEMBER = 1; };
enum extern { MEMBER = 1; };
enum fallthrough { MEMBER = 1; };
enum false { MEMBER = 1; };
enum fidl { MEMBER = 1; };
enum fidl_type { MEMBER = 1; };
enum final { MEMBER = 1; };
enum float { MEMBER = 1; };
enum fn { MEMBER = 1; };
enum for { MEMBER = 1; };
enum friend { MEMBER = 1; };
enum func { MEMBER = 1; };
enum future { MEMBER = 1; };
enum futures { MEMBER = 1; };
enum go { MEMBER = 1; };
enum goto { MEMBER = 1; };
enum has_invalid_tag { MEMBER = 1; };
enum if { MEMBER = 1; };
enum impl { MEMBER = 1; };
enum import { MEMBER = 1; };
enum in { MEMBER = 1; };
enum inline { MEMBER = 1; };
enum int { MEMBER = 1; };
enum int16 { MEMBER = 1; };
enum int32 { MEMBER = 1; };
enum int64 { MEMBER = 1; };
enum int8 { MEMBER = 1; };
enum interface { MEMBER = 1; };
enum let { MEMBER = 1; };
enum lhs { MEMBER = 1; };
enum long { MEMBER = 1; };
enum loop { MEMBER = 1; };
enum macro { MEMBER = 1; };
enum map { MEMBER = 1; };
enum match { MEMBER = 1; };
enum mod { MEMBER = 1; };
enum module { MEMBER = 1; };
enum move { MEMBER = 1; };
enum mut { MEMBER = 1; };
enum mutable { MEMBER = 1; };
enum namespace { MEMBER = 1; };
enum never { MEMBER = 1; };
enum new { MEMBER = 1; };
enum noexcept { MEMBER = 1; };
enum none { MEMBER = 1; };
enum not { MEMBER = 1; };
enum not_eq { MEMBER = 1; };
enum nullptr { MEMBER = 1; };
enum offset { MEMBER = 1; };
enum offsetof { MEMBER = 1; };
enum ok { MEMBER = 1; };
enum on_open { MEMBER = 1; };
enum operator { MEMBER = 1; };
enum option { MEMBER = 1; };
enum or { MEMBER = 1; };
enum or_eq { MEMBER = 1; };
enum override { MEMBER = 1; };
enum package { MEMBER = 1; };
enum priv { MEMBER = 1; };
enum private { MEMBER = 1; };
enum proc { MEMBER = 1; };
enum protected { MEMBER = 1; };
enum pub { MEMBER = 1; };
enum public { MEMBER = 1; };
enum pure { MEMBER = 1; };
enum range { MEMBER = 1; };
enum ref { MEMBER = 1; };
enum register { MEMBER = 1; };
enum reinterpret_cast { MEMBER = 1; };
enum requires { MEMBER = 1; };
enum result { MEMBER = 1; };
enum return { MEMBER = 1; };
enum rhs { MEMBER = 1; };
enum rune { MEMBER = 1; };
enum select { MEMBER = 1; };
enum self { MEMBER = 1; };
enum send { MEMBER = 1; };
enum short { MEMBER = 1; };
enum signed { MEMBER = 1; };
enum sizeof { MEMBER = 1; };
enum some { MEMBER = 1; };
enum static { MEMBER = 1; };
enum static_assert { MEMBER = 1; };
enum static_cast { MEMBER = 1; };
enum stream { MEMBER = 1; };
enum string { MEMBER = 1; };
enum struct { MEMBER = 1; };
enum super { MEMBER = 1; };
enum switch { MEMBER = 1; };
enum synchronized { MEMBER = 1; };
enum tag { MEMBER = 1; };
enum template { MEMBER = 1; };
enum this { MEMBER = 1; };
enum thread_local { MEMBER = 1; };
enum throw { MEMBER = 1; };
enum trait { MEMBER = 1; };
enum true { MEMBER = 1; };
enum try { MEMBER = 1; };
enum type { MEMBER = 1; };
enum typedef { MEMBER = 1; };
enum typeid { MEMBER = 1; };
enum typename { MEMBER = 1; };
enum typeof { MEMBER = 1; };
enum uint16 { MEMBER = 1; };
enum uint32 { MEMBER = 1; };
enum uint64 { MEMBER = 1; };
enum uint8 { MEMBER = 1; };
enum union { MEMBER = 1; };
enum unsafe { MEMBER = 1; };
enum unsigned { MEMBER = 1; };
enum unsized { MEMBER = 1; };
enum use { MEMBER = 1; };
enum using { MEMBER = 1; };
enum value { MEMBER = 1; };
enum value_union { MEMBER = 1; };
enum var { MEMBER = 1; };
enum vec { MEMBER = 1; };
enum virtual { MEMBER = 1; };
enum void { MEMBER = 1; };
enum volatile { MEMBER = 1; };
enum wchar_t { MEMBER = 1; };
enum where { MEMBER = 1; };
enum which { MEMBER = 1; };
enum while { MEMBER = 1; };
enum xor { MEMBER = 1; };
enum xor_eq { MEMBER = 1; };
enum xunion { MEMBER = 1; };
enum yield { MEMBER = 1; };
enum zx { MEMBER = 1; };
enum DangerousMembers {
  abstract = 0;
  alignas = 1;
  alignof = 2;
  and = 3;
  and_eq = 4;
  as = 5;
  asm = 6;
  async = 7;
  atomic_cancel = 8;
  atomic_commit = 9;
  atomic_noexcept = 10;
  auto = 11;
  await = 12;
  become = 13;
  bitand = 14;
  bitor = 15;
  bool = 16;
  box = 17;
  break = 18;
  byte = 19;
  case = 20;
  catch = 21;
  chan = 22;
  char = 23;
  char16_t = 24;
  char32_t = 25;
  class = 26;
  co_await = 27;
  co_return = 28;
  co_yield = 29;
  coding_traits = 30;
  compl = 31;
  concept = 32;
  const = 33;
  const_cast = 34;
  constexpr = 35;
  continue = 36;
  crate = 37;
  decltype = 38;
  decoder = 39;
  default = 40;
  defer = 41;
  delete = 42;
  do = 43;
  double = 44;
  dynamic_cast = 45;
  else = 46;
  encoder = 47;
  enum = 48;
  err = 49;
  explicit = 50;
  export = 51;
  extern = 52;
  fallthrough = 53;
  false = 54;
  fidl = 55;
  fidl_type = 56;
  final = 57;
  float = 58;
  fn = 59;
  for = 60;
  friend = 61;
  func = 62;
  future = 63;
  futures = 64;
  go = 65;
  goto = 66;
  has_invalid_tag = 67;
  if = 68;
  impl = 69;
  import = 70;
  in = 71;
  inline = 72;
  int = 73;
  int16 = 74;
  int32 = 75;
  int64 = 76;
  int8 = 77;
  interface = 78;
  let = 79;
  lhs = 80;
  long = 81;
  loop = 82;
  macro = 83;
  map = 84;
  match = 85;
  mod = 86;
  module = 87;
  move = 88;
  mut = 89;
  mutable = 90;
  namespace = 91;
  never = 92;
  new = 93;
  noexcept = 94;
  none = 95;
  not = 96;
  not_eq = 97;
  nullptr = 98;
  offset = 99;
  offsetof = 100;
  ok = 101;
  on_open = 102;
  operator = 103;
  option = 104;
  or = 105;
  or_eq = 106;
  override = 107;
  package = 108;
  priv = 109;
  private = 110;
  proc = 111;
  protected = 112;
  pub = 113;
  public = 114;
  pure = 115;
  range = 116;
  ref = 117;
  register = 118;
  reinterpret_cast = 119;
  requires = 120;
  result = 121;
  return = 122;
  rhs = 123;
  rune = 124;
  select = 125;
  self = 126;
  send = 127;
  short = 128;
  signed = 129;
  sizeof = 130;
  some = 131;
  static = 132;
  static_assert = 133;
  static_cast = 134;
  stream = 135;
  string = 136;
  struct = 137;
  super = 138;
  switch = 139;
  synchronized = 140;
  tag = 141;
  template = 142;
  this = 143;
  thread_local = 144;
  throw = 145;
  trait = 146;
  true = 147;
  try = 148;
  type = 149;
  typedef = 150;
  typeid = 151;
  typename = 152;
  typeof = 153;
  uint16 = 154;
  uint32 = 155;
  uint64 = 156;
  uint8 = 157;
  union = 158;
  unsafe = 159;
  unsigned = 160;
  unsized = 161;
  use = 162;
  using = 163;
  value = 164;
  value_union = 165;
  var = 166;
  vec = 167;
  virtual = 168;
  void = 169;
  volatile = 170;
  wchar_t = 171;
  where = 172;
  which = 173;
  while = 174;
  xor = 175;
  xor_eq = 176;
  xunion = 177;
  yield = 178;
  zx = 179;
};

// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Generated by generate.py.
library fidl.test.dangerous.table.names.lower;
using membertype = uint32;
table abstract { 1: membertype member; };
table alignas { 1: membertype member; };
table alignof { 1: membertype member; };
table and { 1: membertype member; };
table and_eq { 1: membertype member; };
table as { 1: membertype member; };
table asm { 1: membertype member; };
table async { 1: membertype member; };
table atomic_cancel { 1: membertype member; };
table atomic_commit { 1: membertype member; };
table atomic_noexcept { 1: membertype member; };
table auto { 1: membertype member; };
table await { 1: membertype member; };
table become { 1: membertype member; };
table bitand { 1: membertype member; };
table bitor { 1: membertype member; };
table bool { 1: membertype member; };
table box { 1: membertype member; };
table break { 1: membertype member; };
table byte { 1: membertype member; };
table case { 1: membertype member; };
table catch { 1: membertype member; };
table chan { 1: membertype member; };
table char { 1: membertype member; };
table char16_t { 1: membertype member; };
table char32_t { 1: membertype member; };
table class { 1: membertype member; };
table co_await { 1: membertype member; };
table co_return { 1: membertype member; };
table co_yield { 1: membertype member; };
table coding_traits { 1: membertype member; };
table compl { 1: membertype member; };
table concept { 1: membertype member; };
table const { 1: membertype member; };
table const_cast { 1: membertype member; };
table constexpr { 1: membertype member; };
table continue { 1: membertype member; };
table controller { 1: membertype member; };
table crate { 1: membertype member; };
table decltype { 1: membertype member; };
table decoder { 1: membertype member; };
table default { 1: membertype member; };
table defer { 1: membertype member; };
table delete { 1: membertype member; };
table do { 1: membertype member; };
table double { 1: membertype member; };
table dynamic_cast { 1: membertype member; };
table else { 1: membertype member; };
table encoder { 1: membertype member; };
table enum { 1: membertype member; };
table err { 1: membertype member; };
table explicit { 1: membertype member; };
table export { 1: membertype member; };
table extern { 1: membertype member; };
table fallthrough { 1: membertype member; };
table false { 1: membertype member; };
table fidl { 1: membertype member; };
table fidl_type { 1: membertype member; };
table final { 1: membertype member; };
table float { 1: membertype member; };
table fn { 1: membertype member; };
table for { 1: membertype member; };
table friend { 1: membertype member; };
table func { 1: membertype member; };
table future { 1: membertype member; };
table futures { 1: membertype member; };
table go { 1: membertype member; };
table goto { 1: membertype member; };
table has_invalid_tag { 1: membertype member; };
table if { 1: membertype member; };
table impl { 1: membertype member; };
table import { 1: membertype member; };
table in { 1: membertype member; };
table inline { 1: membertype member; };
table int { 1: membertype member; };
table int16 { 1: membertype member; };
table int32 { 1: membertype member; };
table int64 { 1: membertype member; };
table int8 { 1: membertype member; };
table interface { 1: membertype member; };
table let { 1: membertype member; };
table lhs { 1: membertype member; };
table long { 1: membertype member; };
table loop { 1: membertype member; };
table macro { 1: membertype member; };
table map { 1: membertype member; };
table match { 1: membertype member; };
table mod { 1: membertype member; };
table module { 1: membertype member; };
table move { 1: membertype member; };
table mut { 1: membertype member; };
table mutable { 1: membertype member; };
table namespace { 1: membertype member; };
table never { 1: membertype member; };
table new { 1: membertype member; };
table noexcept { 1: membertype member; };
table none { 1: membertype member; };
table not { 1: membertype member; };
table not_eq { 1: membertype member; };
table nullptr { 1: membertype member; };
table offset { 1: membertype member; };
table offsetof { 1: membertype member; };
table ok { 1: membertype member; };
table on_open { 1: membertype member; };
table operator { 1: membertype member; };
table option { 1: membertype member; };
table or { 1: membertype member; };
table or_eq { 1: membertype member; };
table override { 1: membertype member; };
table package { 1: membertype member; };
table priv { 1: membertype member; };
table private { 1: membertype member; };
table proc { 1: membertype member; };
table protected { 1: membertype member; };
table proxy { 1: membertype member; };
table pub { 1: membertype member; };
table public { 1: membertype member; };
table pure { 1: membertype member; };
table range { 1: membertype member; };
table ref { 1: membertype member; };
table register { 1: membertype member; };
table reinterpret_cast { 1: membertype member; };
table requires { 1: membertype member; };
table result { 1: membertype member; };
table return { 1: membertype member; };
table rhs { 1: membertype member; };
table rune { 1: membertype member; };
table select { 1: membertype member; };
table self { 1: membertype member; };
table send { 1: membertype member; };
table set_controller { 1: membertype member; };
table short { 1: membertype member; };
table signed { 1: membertype member; };
table sizeof { 1: membertype member; };
table some { 1: membertype member; };
table static { 1: membertype member; };
table static_assert { 1: membertype member; };
table static_cast { 1: membertype member; };
table stream { 1: membertype member; };
table string { 1: membertype member; };
table struct { 1: membertype member; };
table stub { 1: membertype member; };
table super { 1: membertype member; };
table switch { 1: membertype member; };
table synchronized { 1: membertype member; };
table tag { 1: membertype member; };
table template { 1: membertype member; };
table this { 1: membertype member; };
table thread_local { 1: membertype member; };
table throw { 1: membertype member; };
table trait { 1: membertype member; };
table true { 1: membertype member; };
table try { 1: membertype member; };
table type { 1: membertype member; };
table typedef { 1: membertype member; };
table typeid { 1: membertype member; };
table typename { 1: membertype member; };
table typeof { 1: membertype member; };
table uint16 { 1: membertype member; };
table uint32 { 1: membertype member; };
table uint64 { 1: membertype member; };
table uint8 { 1: membertype member; };
table union { 1: membertype member; };
table unsafe { 1: membertype member; };
table unsigned { 1: membertype member; };
table unsized { 1: membertype member; };
table use { 1: membertype member; };
table using { 1: membertype member; };
table value { 1: membertype member; };
table value_union { 1: membertype member; };
table var { 1: membertype member; };
table vec { 1: membertype member; };
table virtual { 1: membertype member; };
table void { 1: membertype member; };
table volatile { 1: membertype member; };
table wchar_t { 1: membertype member; };
table where { 1: membertype member; };
table which { 1: membertype member; };
table while { 1: membertype member; };
table xor { 1: membertype member; };
table xor_eq { 1: membertype member; };
table xunion { 1: membertype member; };
table yield { 1: membertype member; };
table zx { 1: membertype member; };
table DangerousMembers {
  1: abstract f0;
  2: alignas f1;
  3: alignof f2;
  4: and f3;
  5: and_eq f4;
  6: as f5;
  7: asm f6;
  8: async f7;
  9: atomic_cancel f8;
  10: atomic_commit f9;
  11: atomic_noexcept f10;
  12: auto f11;
  13: await f12;
  14: become f13;
  15: bitand f14;
  16: bitor f15;
  17: bool f16;
  18: box f17;
  19: break f18;
  20: byte f19;
  21: case f20;
  22: catch f21;
  23: chan f22;
  24: char f23;
  25: char16_t f24;
  26: char32_t f25;
  27: class f26;
  28: co_await f27;
  29: co_return f28;
  30: co_yield f29;
  31: coding_traits f30;
  32: compl f31;
  33: concept f32;
  34: const f33;
  35: const_cast f34;
  36: constexpr f35;
  37: continue f36;
  38: controller f37;
  39: crate f38;
  40: decltype f39;
  41: decoder f40;
  42: default f41;
  43: defer f42;
  44: delete f43;
  45: do f44;
  46: double f45;
  47: dynamic_cast f46;
  48: else f47;
  49: encoder f48;
  50: enum f49;
  51: err f50;
  52: explicit f51;
  53: export f52;
  54: extern f53;
  55: fallthrough f54;
  56: false f55;
  57: fidl f56;
  58: fidl_type f57;
  59: final f58;
  60: float f59;
  61: fn f60;
  62: for f61;
  63: friend f62;
  64: func f63;
  65: future f64;
  66: futures f65;
  67: go f66;
  68: goto f67;
  69: has_invalid_tag f68;
  70: if f69;
  71: impl f70;
  72: import f71;
  73: in f72;
  74: inline f73;
  75: int f74;
  76: int16 f75;
  77: int32 f76;
  78: int64 f77;
  79: int8 f78;
  80: interface f79;
  81: let f80;
  82: lhs f81;
  83: long f82;
  84: loop f83;
  85: macro f84;
  86: map f85;
  87: match f86;
  88: mod f87;
  89: module f88;
  90: move f89;
  91: mut f90;
  92: mutable f91;
  93: namespace f92;
  94: never f93;
  95: new f94;
  96: noexcept f95;
  97: none f96;
  98: not f97;
  99: not_eq f98;
  100: nullptr f99;
  101: offset f100;
  102: offsetof f101;
  103: ok f102;
  104: on_open f103;
  105: operator f104;
  106: option f105;
  107: or f106;
  108: or_eq f107;
  109: override f108;
  110: package f109;
  111: priv f110;
  112: private f111;
  113: proc f112;
  114: protected f113;
  115: proxy f114;
  116: pub f115;
  117: public f116;
  118: pure f117;
  119: range f118;
  120: ref f119;
  121: register f120;
  122: reinterpret_cast f121;
  123: requires f122;
  124: result f123;
  125: return f124;
  126: rhs f125;
  127: rune f126;
  128: select f127;
  129: self f128;
  130: send f129;
  131: set_controller f130;
  132: short f131;
  133: signed f132;
  134: sizeof f133;
  135: some f134;
  136: static f135;
  137: static_assert f136;
  138: static_cast f137;
  139: stream f138;
  140: string f139;
  141: struct f140;
  142: stub f141;
  143: super f142;
  144: switch f143;
  145: synchronized f144;
  146: tag f145;
  147: template f146;
  148: this f147;
  149: thread_local f148;
  150: throw f149;
  151: trait f150;
  152: true f151;
  153: try f152;
  154: type f153;
  155: typedef f154;
  156: typeid f155;
  157: typename f156;
  158: typeof f157;
  159: uint16 f158;
  160: uint32 f159;
  161: uint64 f160;
  162: uint8 f161;
  163: union f162;
  164: unsafe f163;
  165: unsigned f164;
  166: unsized f165;
  167: use f166;
  168: using f167;
  169: value f168;
  170: value_union f169;
  171: var f170;
  172: vec f171;
  173: virtual f172;
  174: void f173;
  175: volatile f174;
  176: wchar_t f175;
  177: where f176;
  178: which f177;
  179: while f178;
  180: xor f179;
  181: xor_eq f180;
  182: xunion f181;
  183: yield f182;
  184: zx f183;
};

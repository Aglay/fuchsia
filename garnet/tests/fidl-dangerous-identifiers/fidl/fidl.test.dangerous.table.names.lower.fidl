// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Generated by generate.py.
library fidl.test.dangerous.table.names.lower;
using membertype = uint32;
table abstract { 1: membertype member; };
table alignas { 1: membertype member; };
table alignof { 1: membertype member; };
table and { 1: membertype member; };
table and_eq { 1: membertype member; };
table as { 1: membertype member; };
table asm { 1: membertype member; };
table async { 1: membertype member; };
table atomic_cancel { 1: membertype member; };
table atomic_commit { 1: membertype member; };
table atomic_noexcept { 1: membertype member; };
table auto { 1: membertype member; };
table await { 1: membertype member; };
table become { 1: membertype member; };
table bitand { 1: membertype member; };
table bitor { 1: membertype member; };
table bool { 1: membertype member; };
table box { 1: membertype member; };
table break { 1: membertype member; };
table byte { 1: membertype member; };
table case { 1: membertype member; };
table catch { 1: membertype member; };
table chan { 1: membertype member; };
table char { 1: membertype member; };
table char16_t { 1: membertype member; };
table char32_t { 1: membertype member; };
table class { 1: membertype member; };
table co_await { 1: membertype member; };
table co_return { 1: membertype member; };
table co_yield { 1: membertype member; };
table coding_traits { 1: membertype member; };
table compl { 1: membertype member; };
table concept { 1: membertype member; };
table const { 1: membertype member; };
table const_cast { 1: membertype member; };
table constexpr { 1: membertype member; };
table continue { 1: membertype member; };
table crate { 1: membertype member; };
table decltype { 1: membertype member; };
table decoder { 1: membertype member; };
table default { 1: membertype member; };
table defer { 1: membertype member; };
table delete { 1: membertype member; };
table do { 1: membertype member; };
table double { 1: membertype member; };
table dynamic_cast { 1: membertype member; };
table else { 1: membertype member; };
table encoder { 1: membertype member; };
table enum { 1: membertype member; };
table err { 1: membertype member; };
table explicit { 1: membertype member; };
table export { 1: membertype member; };
table extern { 1: membertype member; };
table fallthrough { 1: membertype member; };
table false { 1: membertype member; };
table fidl { 1: membertype member; };
table fidl_type { 1: membertype member; };
table final { 1: membertype member; };
table float { 1: membertype member; };
table fn { 1: membertype member; };
table for { 1: membertype member; };
table friend { 1: membertype member; };
table func { 1: membertype member; };
table future { 1: membertype member; };
table futures { 1: membertype member; };
table go { 1: membertype member; };
table goto { 1: membertype member; };
table has_invalid_tag { 1: membertype member; };
table if { 1: membertype member; };
table impl { 1: membertype member; };
table import { 1: membertype member; };
table in { 1: membertype member; };
table inline { 1: membertype member; };
table int { 1: membertype member; };
table int16 { 1: membertype member; };
table int32 { 1: membertype member; };
table int64 { 1: membertype member; };
table int8 { 1: membertype member; };
table interface { 1: membertype member; };
table let { 1: membertype member; };
table lhs { 1: membertype member; };
table long { 1: membertype member; };
table loop { 1: membertype member; };
table macro { 1: membertype member; };
table map { 1: membertype member; };
table match { 1: membertype member; };
table mod { 1: membertype member; };
table module { 1: membertype member; };
table move { 1: membertype member; };
table mut { 1: membertype member; };
table mutable { 1: membertype member; };
table namespace { 1: membertype member; };
table never { 1: membertype member; };
table new { 1: membertype member; };
table noexcept { 1: membertype member; };
table none { 1: membertype member; };
table not { 1: membertype member; };
table not_eq { 1: membertype member; };
table nullptr { 1: membertype member; };
table offset { 1: membertype member; };
table offsetof { 1: membertype member; };
table ok { 1: membertype member; };
table on_open { 1: membertype member; };
table operator { 1: membertype member; };
table option { 1: membertype member; };
table or { 1: membertype member; };
table or_eq { 1: membertype member; };
table override { 1: membertype member; };
table package { 1: membertype member; };
table priv { 1: membertype member; };
table private { 1: membertype member; };
table proc { 1: membertype member; };
table protected { 1: membertype member; };
table pub { 1: membertype member; };
table public { 1: membertype member; };
table pure { 1: membertype member; };
table range { 1: membertype member; };
table ref { 1: membertype member; };
table register { 1: membertype member; };
table reinterpret_cast { 1: membertype member; };
table requires { 1: membertype member; };
table result { 1: membertype member; };
table return { 1: membertype member; };
table rhs { 1: membertype member; };
table rune { 1: membertype member; };
table select { 1: membertype member; };
table self { 1: membertype member; };
table send { 1: membertype member; };
table short { 1: membertype member; };
table signed { 1: membertype member; };
table sizeof { 1: membertype member; };
table some { 1: membertype member; };
table static { 1: membertype member; };
table static_assert { 1: membertype member; };
table static_cast { 1: membertype member; };
table stream { 1: membertype member; };
table string { 1: membertype member; };
table struct { 1: membertype member; };
table super { 1: membertype member; };
table switch { 1: membertype member; };
table synchronized { 1: membertype member; };
table tag { 1: membertype member; };
table template { 1: membertype member; };
table this { 1: membertype member; };
table thread_local { 1: membertype member; };
table throw { 1: membertype member; };
table trait { 1: membertype member; };
table true { 1: membertype member; };
table try { 1: membertype member; };
table type { 1: membertype member; };
table typedef { 1: membertype member; };
table typeid { 1: membertype member; };
table typename { 1: membertype member; };
table typeof { 1: membertype member; };
table uint16 { 1: membertype member; };
table uint32 { 1: membertype member; };
table uint64 { 1: membertype member; };
table uint8 { 1: membertype member; };
table union { 1: membertype member; };
table unsafe { 1: membertype member; };
table unsigned { 1: membertype member; };
table unsized { 1: membertype member; };
table use { 1: membertype member; };
table using { 1: membertype member; };
table value { 1: membertype member; };
table value_union { 1: membertype member; };
table var { 1: membertype member; };
table vec { 1: membertype member; };
table virtual { 1: membertype member; };
table void { 1: membertype member; };
table volatile { 1: membertype member; };
table wchar_t { 1: membertype member; };
table where { 1: membertype member; };
table which { 1: membertype member; };
table while { 1: membertype member; };
table xor { 1: membertype member; };
table xor_eq { 1: membertype member; };
table xunion { 1: membertype member; };
table yield { 1: membertype member; };
table zx { 1: membertype member; };
table DangerousMembers {
  1: abstract f0;
  2: alignas f1;
  3: alignof f2;
  4: and f3;
  5: and_eq f4;
  6: as f5;
  7: asm f6;
  8: async f7;
  9: atomic_cancel f8;
  10: atomic_commit f9;
  11: atomic_noexcept f10;
  12: auto f11;
  13: await f12;
  14: become f13;
  15: bitand f14;
  16: bitor f15;
  17: bool f16;
  18: box f17;
  19: break f18;
  20: byte f19;
  21: case f20;
  22: catch f21;
  23: chan f22;
  24: char f23;
  25: char16_t f24;
  26: char32_t f25;
  27: class f26;
  28: co_await f27;
  29: co_return f28;
  30: co_yield f29;
  31: coding_traits f30;
  32: compl f31;
  33: concept f32;
  34: const f33;
  35: const_cast f34;
  36: constexpr f35;
  37: continue f36;
  38: crate f37;
  39: decltype f38;
  40: decoder f39;
  41: default f40;
  42: defer f41;
  43: delete f42;
  44: do f43;
  45: double f44;
  46: dynamic_cast f45;
  47: else f46;
  48: encoder f47;
  49: enum f48;
  50: err f49;
  51: explicit f50;
  52: export f51;
  53: extern f52;
  54: fallthrough f53;
  55: false f54;
  56: fidl f55;
  57: fidl_type f56;
  58: final f57;
  59: float f58;
  60: fn f59;
  61: for f60;
  62: friend f61;
  63: func f62;
  64: future f63;
  65: futures f64;
  66: go f65;
  67: goto f66;
  68: has_invalid_tag f67;
  69: if f68;
  70: impl f69;
  71: import f70;
  72: in f71;
  73: inline f72;
  74: int f73;
  75: int16 f74;
  76: int32 f75;
  77: int64 f76;
  78: int8 f77;
  79: interface f78;
  80: let f79;
  81: lhs f80;
  82: long f81;
  83: loop f82;
  84: macro f83;
  85: map f84;
  86: match f85;
  87: mod f86;
  88: module f87;
  89: move f88;
  90: mut f89;
  91: mutable f90;
  92: namespace f91;
  93: never f92;
  94: new f93;
  95: noexcept f94;
  96: none f95;
  97: not f96;
  98: not_eq f97;
  99: nullptr f98;
  100: offset f99;
  101: offsetof f100;
  102: ok f101;
  103: on_open f102;
  104: operator f103;
  105: option f104;
  106: or f105;
  107: or_eq f106;
  108: override f107;
  109: package f108;
  110: priv f109;
  111: private f110;
  112: proc f111;
  113: protected f112;
  114: pub f113;
  115: public f114;
  116: pure f115;
  117: range f116;
  118: ref f117;
  119: register f118;
  120: reinterpret_cast f119;
  121: requires f120;
  122: result f121;
  123: return f122;
  124: rhs f123;
  125: rune f124;
  126: select f125;
  127: self f126;
  128: send f127;
  129: short f128;
  130: signed f129;
  131: sizeof f130;
  132: some f131;
  133: static f132;
  134: static_assert f133;
  135: static_cast f134;
  136: stream f135;
  137: string f136;
  138: struct f137;
  139: super f138;
  140: switch f139;
  141: synchronized f140;
  142: tag f141;
  143: template f142;
  144: this f143;
  145: thread_local f144;
  146: throw f145;
  147: trait f146;
  148: true f147;
  149: try f148;
  150: type f149;
  151: typedef f150;
  152: typeid f151;
  153: typename f152;
  154: typeof f153;
  155: uint16 f154;
  156: uint32 f155;
  157: uint64 f156;
  158: uint8 f157;
  159: union f158;
  160: unsafe f159;
  161: unsigned f160;
  162: unsized f161;
  163: use f162;
  164: using f163;
  165: value f164;
  166: value_union f165;
  167: var f166;
  168: vec f167;
  169: virtual f168;
  170: void f169;
  171: volatile f170;
  172: wchar_t f171;
  173: where f172;
  174: which f173;
  175: while f174;
  176: xor f175;
  177: xor_eq f176;
  178: xunion f177;
  179: yield f178;
  180: zx f179;
};

// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Generated by generate.py.
library fidl.test.dangerous.struct.types.upper;
using membertype = uint32;
struct ABSTRACT { membertype member = 1; };
struct ALIGNAS { membertype member = 1; };
struct ALIGNOF { membertype member = 1; };
struct AND { membertype member = 1; };
struct AND_EQ { membertype member = 1; };
struct AS { membertype member = 1; };
struct ASM { membertype member = 1; };
struct ASYNC { membertype member = 1; };
struct ATOMIC_CANCEL { membertype member = 1; };
struct ATOMIC_COMMIT { membertype member = 1; };
struct ATOMIC_NOEXCEPT { membertype member = 1; };
struct AUTO { membertype member = 1; };
struct AWAIT { membertype member = 1; };
struct BECOME { membertype member = 1; };
struct BITAND { membertype member = 1; };
struct BITOR { membertype member = 1; };
struct BOOL { membertype member = 1; };
struct BOX { membertype member = 1; };
struct BREAK { membertype member = 1; };
struct BYTE { membertype member = 1; };
struct CASE { membertype member = 1; };
struct CATCH { membertype member = 1; };
struct CHAN { membertype member = 1; };
struct CHAR { membertype member = 1; };
struct CHAR16_T { membertype member = 1; };
struct CHAR32_T { membertype member = 1; };
struct CLASS { membertype member = 1; };
struct CO_AWAIT { membertype member = 1; };
struct CO_RETURN { membertype member = 1; };
struct CO_YIELD { membertype member = 1; };
struct CODING_TRAITS { membertype member = 1; };
struct COMPL { membertype member = 1; };
struct CONCEPT { membertype member = 1; };
struct CONST { membertype member = 1; };
struct CONST_CAST { membertype member = 1; };
struct CONSTEXPR { membertype member = 1; };
struct CONTINUE { membertype member = 1; };
struct CRATE { membertype member = 1; };
struct DECLTYPE { membertype member = 1; };
struct DECODER { membertype member = 1; };
struct DEFAULT { membertype member = 1; };
struct DEFER { membertype member = 1; };
struct DELETE { membertype member = 1; };
struct DO { membertype member = 1; };
struct DOUBLE { membertype member = 1; };
struct DYNAMIC_CAST { membertype member = 1; };
struct ELSE { membertype member = 1; };
struct ENCODER { membertype member = 1; };
struct ENUM { membertype member = 1; };
struct ERR { membertype member = 1; };
struct EXPLICIT { membertype member = 1; };
struct EXPORT { membertype member = 1; };
struct EXTERN { membertype member = 1; };
struct FALLTHROUGH { membertype member = 1; };
struct FALSE { membertype member = 1; };
struct FIDL { membertype member = 1; };
struct FIDL_TYPE { membertype member = 1; };
struct FINAL { membertype member = 1; };
struct FLOAT { membertype member = 1; };
struct FN { membertype member = 1; };
struct FOR { membertype member = 1; };
struct FRIEND { membertype member = 1; };
struct FUNC { membertype member = 1; };
struct FUTURE { membertype member = 1; };
struct FUTURES { membertype member = 1; };
struct GO { membertype member = 1; };
struct GOTO { membertype member = 1; };
struct HAS_INVALID_TAG { membertype member = 1; };
struct IF { membertype member = 1; };
struct IMPL { membertype member = 1; };
struct IMPORT { membertype member = 1; };
struct IN { membertype member = 1; };
struct INLINE { membertype member = 1; };
struct INT { membertype member = 1; };
struct INT16 { membertype member = 1; };
struct INT32 { membertype member = 1; };
struct INT64 { membertype member = 1; };
struct INT8 { membertype member = 1; };
struct INTERFACE { membertype member = 1; };
struct LET { membertype member = 1; };
struct LHS { membertype member = 1; };
struct LONG { membertype member = 1; };
struct LOOP { membertype member = 1; };
struct MACRO { membertype member = 1; };
struct MAP { membertype member = 1; };
struct MATCH { membertype member = 1; };
struct MOD { membertype member = 1; };
struct MODULE { membertype member = 1; };
struct MOVE { membertype member = 1; };
struct MUT { membertype member = 1; };
struct MUTABLE { membertype member = 1; };
struct NAMESPACE { membertype member = 1; };
struct NEVER { membertype member = 1; };
struct NEW { membertype member = 1; };
struct NOEXCEPT { membertype member = 1; };
struct NONE { membertype member = 1; };
struct NOT { membertype member = 1; };
struct NOT_EQ { membertype member = 1; };
struct NULLPTR { membertype member = 1; };
struct OFFSET { membertype member = 1; };
struct OFFSETOF { membertype member = 1; };
struct OK { membertype member = 1; };
struct ON_OPEN { membertype member = 1; };
struct OPERATOR { membertype member = 1; };
struct OPTION { membertype member = 1; };
struct OR { membertype member = 1; };
struct OR_EQ { membertype member = 1; };
struct OVERRIDE { membertype member = 1; };
struct PACKAGE { membertype member = 1; };
struct PRIV { membertype member = 1; };
struct PRIVATE { membertype member = 1; };
struct PROC { membertype member = 1; };
struct PROTECTED { membertype member = 1; };
struct PUB { membertype member = 1; };
struct PUBLIC { membertype member = 1; };
struct PURE { membertype member = 1; };
struct RANGE { membertype member = 1; };
struct REF { membertype member = 1; };
struct REGISTER { membertype member = 1; };
struct REINTERPRET_CAST { membertype member = 1; };
struct REQUIRES { membertype member = 1; };
struct RESULT { membertype member = 1; };
struct RETURN { membertype member = 1; };
struct RHS { membertype member = 1; };
struct RUNE { membertype member = 1; };
struct SELECT { membertype member = 1; };
struct SELF { membertype member = 1; };
struct SEND { membertype member = 1; };
struct SHORT { membertype member = 1; };
struct SIGNED { membertype member = 1; };
struct SIZEOF { membertype member = 1; };
struct SOME { membertype member = 1; };
struct STATIC { membertype member = 1; };
struct STATIC_ASSERT { membertype member = 1; };
struct STATIC_CAST { membertype member = 1; };
struct STREAM { membertype member = 1; };
struct STRING { membertype member = 1; };
struct STRUCT { membertype member = 1; };
struct SUPER { membertype member = 1; };
struct SWITCH { membertype member = 1; };
struct SYNCHRONIZED { membertype member = 1; };
struct TAG { membertype member = 1; };
struct TEMPLATE { membertype member = 1; };
struct THIS { membertype member = 1; };
struct THREAD_LOCAL { membertype member = 1; };
struct THROW { membertype member = 1; };
struct TRAIT { membertype member = 1; };
struct TRUE { membertype member = 1; };
struct TRY { membertype member = 1; };
struct TYPE { membertype member = 1; };
struct TYPEDEF { membertype member = 1; };
struct TYPEID { membertype member = 1; };
struct TYPENAME { membertype member = 1; };
struct TYPEOF { membertype member = 1; };
struct UINT16 { membertype member = 1; };
struct UINT32 { membertype member = 1; };
struct UINT64 { membertype member = 1; };
struct UINT8 { membertype member = 1; };
struct UNION { membertype member = 1; };
struct UNSAFE { membertype member = 1; };
struct UNSIGNED { membertype member = 1; };
struct UNSIZED { membertype member = 1; };
struct USE { membertype member = 1; };
struct USING { membertype member = 1; };
struct VALUE { membertype member = 1; };
struct VALUE_UNION { membertype member = 1; };
struct VAR { membertype member = 1; };
struct VEC { membertype member = 1; };
struct VIRTUAL { membertype member = 1; };
struct VOID { membertype member = 1; };
struct VOLATILE { membertype member = 1; };
struct WCHAR_T { membertype member = 1; };
struct WHERE { membertype member = 1; };
struct WHICH { membertype member = 1; };
struct WHILE { membertype member = 1; };
struct XOR { membertype member = 1; };
struct XOR_EQ { membertype member = 1; };
struct XUNION { membertype member = 1; };
struct YIELD { membertype member = 1; };
struct ZX { membertype member = 1; };
struct DangerousMembers {
  ABSTRACT f0;
  ALIGNAS f1;
  ALIGNOF f2;
  AND f3;
  AND_EQ f4;
  AS f5;
  ASM f6;
  ASYNC f7;
  ATOMIC_CANCEL f8;
  ATOMIC_COMMIT f9;
  ATOMIC_NOEXCEPT f10;
  AUTO f11;
  AWAIT f12;
  BECOME f13;
  BITAND f14;
  BITOR f15;
  BOOL f16;
  BOX f17;
  BREAK f18;
  BYTE f19;
  CASE f20;
  CATCH f21;
  CHAN f22;
  CHAR f23;
  CHAR16_T f24;
  CHAR32_T f25;
  CLASS f26;
  CO_AWAIT f27;
  CO_RETURN f28;
  CO_YIELD f29;
  CODING_TRAITS f30;
  COMPL f31;
  CONCEPT f32;
  CONST f33;
  CONST_CAST f34;
  CONSTEXPR f35;
  CONTINUE f36;
  CRATE f37;
  DECLTYPE f38;
  DECODER f39;
  DEFAULT f40;
  DEFER f41;
  DELETE f42;
  DO f43;
  DOUBLE f44;
  DYNAMIC_CAST f45;
  ELSE f46;
  ENCODER f47;
  ENUM f48;
  ERR f49;
  EXPLICIT f50;
  EXPORT f51;
  EXTERN f52;
  FALLTHROUGH f53;
  FALSE f54;
  FIDL f55;
  FIDL_TYPE f56;
  FINAL f57;
  FLOAT f58;
  FN f59;
  FOR f60;
  FRIEND f61;
  FUNC f62;
  FUTURE f63;
  FUTURES f64;
  GO f65;
  GOTO f66;
  HAS_INVALID_TAG f67;
  IF f68;
  IMPL f69;
  IMPORT f70;
  IN f71;
  INLINE f72;
  INT f73;
  INT16 f74;
  INT32 f75;
  INT64 f76;
  INT8 f77;
  INTERFACE f78;
  LET f79;
  LHS f80;
  LONG f81;
  LOOP f82;
  MACRO f83;
  MAP f84;
  MATCH f85;
  MOD f86;
  MODULE f87;
  MOVE f88;
  MUT f89;
  MUTABLE f90;
  NAMESPACE f91;
  NEVER f92;
  NEW f93;
  NOEXCEPT f94;
  NONE f95;
  NOT f96;
  NOT_EQ f97;
  NULLPTR f98;
  OFFSET f99;
  OFFSETOF f100;
  OK f101;
  ON_OPEN f102;
  OPERATOR f103;
  OPTION f104;
  OR f105;
  OR_EQ f106;
  OVERRIDE f107;
  PACKAGE f108;
  PRIV f109;
  PRIVATE f110;
  PROC f111;
  PROTECTED f112;
  PUB f113;
  PUBLIC f114;
  PURE f115;
  RANGE f116;
  REF f117;
  REGISTER f118;
  REINTERPRET_CAST f119;
  REQUIRES f120;
  RESULT f121;
  RETURN f122;
  RHS f123;
  RUNE f124;
  SELECT f125;
  SELF f126;
  SEND f127;
  SHORT f128;
  SIGNED f129;
  SIZEOF f130;
  SOME f131;
  STATIC f132;
  STATIC_ASSERT f133;
  STATIC_CAST f134;
  STREAM f135;
  STRING f136;
  STRUCT f137;
  SUPER f138;
  SWITCH f139;
  SYNCHRONIZED f140;
  TAG f141;
  TEMPLATE f142;
  THIS f143;
  THREAD_LOCAL f144;
  THROW f145;
  TRAIT f146;
  TRUE f147;
  TRY f148;
  TYPE f149;
  TYPEDEF f150;
  TYPEID f151;
  TYPENAME f152;
  TYPEOF f153;
  UINT16 f154;
  UINT32 f155;
  UINT64 f156;
  UINT8 f157;
  UNION f158;
  UNSAFE f159;
  UNSIGNED f160;
  UNSIZED f161;
  USE f162;
  USING f163;
  VALUE f164;
  VALUE_UNION f165;
  VAR f166;
  VEC f167;
  VIRTUAL f168;
  VOID f169;
  VOLATILE f170;
  WCHAR_T f171;
  WHERE f172;
  WHICH f173;
  WHILE f174;
  XOR f175;
  XOR_EQ f176;
  XUNION f177;
  YIELD f178;
  ZX f179;
};

// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Generated by generate.py.
library fidl.test.dangerous.struct.types.upper;
using membertype = uint32;
struct ABSTRACT { membertype member = 1; };
struct ALIGNAS { membertype member = 1; };
struct ALIGNOF { membertype member = 1; };
struct AND { membertype member = 1; };
struct AND_EQ { membertype member = 1; };
struct AS { membertype member = 1; };
struct ASM { membertype member = 1; };
struct ASYNC { membertype member = 1; };
struct ATOMIC_CANCEL { membertype member = 1; };
struct ATOMIC_COMMIT { membertype member = 1; };
struct ATOMIC_NOEXCEPT { membertype member = 1; };
struct AUTO { membertype member = 1; };
struct AWAIT { membertype member = 1; };
struct BECOME { membertype member = 1; };
struct BITAND { membertype member = 1; };
struct BITOR { membertype member = 1; };
struct BOOL { membertype member = 1; };
struct BOX { membertype member = 1; };
struct BREAK { membertype member = 1; };
struct BYTE { membertype member = 1; };
struct CASE { membertype member = 1; };
struct CATCH { membertype member = 1; };
struct CHAN { membertype member = 1; };
struct CHAR { membertype member = 1; };
struct CHAR16_T { membertype member = 1; };
struct CHAR32_T { membertype member = 1; };
struct CLASS { membertype member = 1; };
struct CO_AWAIT { membertype member = 1; };
struct CO_RETURN { membertype member = 1; };
struct CO_YIELD { membertype member = 1; };
struct CODING_TRAITS { membertype member = 1; };
struct COMPL { membertype member = 1; };
struct CONCEPT { membertype member = 1; };
struct CONST { membertype member = 1; };
struct CONST_CAST { membertype member = 1; };
struct CONSTEXPR { membertype member = 1; };
struct CONTINUE { membertype member = 1; };
struct CONTROLLER { membertype member = 1; };
struct CRATE { membertype member = 1; };
struct DECLTYPE { membertype member = 1; };
struct DECODER { membertype member = 1; };
struct DEFAULT { membertype member = 1; };
struct DEFER { membertype member = 1; };
struct DELETE { membertype member = 1; };
struct DO { membertype member = 1; };
struct DOUBLE { membertype member = 1; };
struct DYNAMIC_CAST { membertype member = 1; };
struct ELSE { membertype member = 1; };
struct ENCODER { membertype member = 1; };
struct ENUM { membertype member = 1; };
struct ERR { membertype member = 1; };
struct EXPLICIT { membertype member = 1; };
struct EXPORT { membertype member = 1; };
struct EXTERN { membertype member = 1; };
struct FALLTHROUGH { membertype member = 1; };
struct FALSE { membertype member = 1; };
struct FIDL { membertype member = 1; };
struct FIDL_TYPE { membertype member = 1; };
struct FINAL { membertype member = 1; };
struct FLOAT { membertype member = 1; };
struct FN { membertype member = 1; };
struct FOR { membertype member = 1; };
struct FRIEND { membertype member = 1; };
struct FUNC { membertype member = 1; };
struct FUTURE { membertype member = 1; };
struct FUTURES { membertype member = 1; };
struct GO { membertype member = 1; };
struct GOTO { membertype member = 1; };
struct HAS_INVALID_TAG { membertype member = 1; };
struct IF { membertype member = 1; };
struct IMPL { membertype member = 1; };
struct IMPORT { membertype member = 1; };
struct IN { membertype member = 1; };
struct INLINE { membertype member = 1; };
struct INT { membertype member = 1; };
struct INT16 { membertype member = 1; };
struct INT32 { membertype member = 1; };
struct INT64 { membertype member = 1; };
struct INT8 { membertype member = 1; };
struct INTERFACE { membertype member = 1; };
struct LET { membertype member = 1; };
struct LHS { membertype member = 1; };
struct LONG { membertype member = 1; };
struct LOOP { membertype member = 1; };
struct MACRO { membertype member = 1; };
struct MAP { membertype member = 1; };
struct MATCH { membertype member = 1; };
struct MOD { membertype member = 1; };
struct MODULE { membertype member = 1; };
struct MOVE { membertype member = 1; };
struct MUT { membertype member = 1; };
struct MUTABLE { membertype member = 1; };
struct NAMESPACE { membertype member = 1; };
struct NEVER { membertype member = 1; };
struct NEW { membertype member = 1; };
struct NOEXCEPT { membertype member = 1; };
struct NONE { membertype member = 1; };
struct NOT { membertype member = 1; };
struct NOT_EQ { membertype member = 1; };
struct NULLPTR { membertype member = 1; };
struct OFFSET { membertype member = 1; };
struct OFFSETOF { membertype member = 1; };
struct OK { membertype member = 1; };
struct ON_OPEN { membertype member = 1; };
struct OPERATOR { membertype member = 1; };
struct OPTION { membertype member = 1; };
struct OR { membertype member = 1; };
struct OR_EQ { membertype member = 1; };
struct OVERRIDE { membertype member = 1; };
struct PACKAGE { membertype member = 1; };
struct PRIV { membertype member = 1; };
struct PRIVATE { membertype member = 1; };
struct PROC { membertype member = 1; };
struct PROTECTED { membertype member = 1; };
struct PROXY { membertype member = 1; };
struct PUB { membertype member = 1; };
struct PUBLIC { membertype member = 1; };
struct PURE { membertype member = 1; };
struct RANGE { membertype member = 1; };
struct REF { membertype member = 1; };
struct REGISTER { membertype member = 1; };
struct REINTERPRET_CAST { membertype member = 1; };
struct REQUIRES { membertype member = 1; };
struct RESULT { membertype member = 1; };
struct RETURN { membertype member = 1; };
struct RHS { membertype member = 1; };
struct RUNE { membertype member = 1; };
struct SELECT { membertype member = 1; };
struct SELF { membertype member = 1; };
struct SEND { membertype member = 1; };
struct SET_CONTROLLER { membertype member = 1; };
struct SHORT { membertype member = 1; };
struct SIGNED { membertype member = 1; };
struct SIZEOF { membertype member = 1; };
struct SOME { membertype member = 1; };
struct STATIC { membertype member = 1; };
struct STATIC_ASSERT { membertype member = 1; };
struct STATIC_CAST { membertype member = 1; };
struct STREAM { membertype member = 1; };
struct STRING { membertype member = 1; };
struct STRUCT { membertype member = 1; };
struct STUB { membertype member = 1; };
struct SUPER { membertype member = 1; };
struct SWITCH { membertype member = 1; };
struct SYNCHRONIZED { membertype member = 1; };
struct TAG { membertype member = 1; };
struct TEMPLATE { membertype member = 1; };
struct THIS { membertype member = 1; };
struct THREAD_LOCAL { membertype member = 1; };
struct THROW { membertype member = 1; };
struct TRAIT { membertype member = 1; };
struct TRUE { membertype member = 1; };
struct TRY { membertype member = 1; };
struct TYPE { membertype member = 1; };
struct TYPEDEF { membertype member = 1; };
struct TYPEID { membertype member = 1; };
struct TYPENAME { membertype member = 1; };
struct TYPEOF { membertype member = 1; };
struct UINT16 { membertype member = 1; };
struct UINT32 { membertype member = 1; };
struct UINT64 { membertype member = 1; };
struct UINT8 { membertype member = 1; };
struct UNION { membertype member = 1; };
struct UNSAFE { membertype member = 1; };
struct UNSIGNED { membertype member = 1; };
struct UNSIZED { membertype member = 1; };
struct USE { membertype member = 1; };
struct USING { membertype member = 1; };
struct VALUE { membertype member = 1; };
struct VALUE_UNION { membertype member = 1; };
struct VAR { membertype member = 1; };
struct VEC { membertype member = 1; };
struct VIRTUAL { membertype member = 1; };
struct VOID { membertype member = 1; };
struct VOLATILE { membertype member = 1; };
struct WCHAR_T { membertype member = 1; };
struct WHERE { membertype member = 1; };
struct WHICH { membertype member = 1; };
struct WHILE { membertype member = 1; };
struct XOR { membertype member = 1; };
struct XOR_EQ { membertype member = 1; };
struct XUNION { membertype member = 1; };
struct YIELD { membertype member = 1; };
struct ZX { membertype member = 1; };
struct DangerousMembers {
  ABSTRACT f0;
  ALIGNAS f1;
  ALIGNOF f2;
  AND f3;
  AND_EQ f4;
  AS f5;
  ASM f6;
  ASYNC f7;
  ATOMIC_CANCEL f8;
  ATOMIC_COMMIT f9;
  ATOMIC_NOEXCEPT f10;
  AUTO f11;
  AWAIT f12;
  BECOME f13;
  BITAND f14;
  BITOR f15;
  BOOL f16;
  BOX f17;
  BREAK f18;
  BYTE f19;
  CASE f20;
  CATCH f21;
  CHAN f22;
  CHAR f23;
  CHAR16_T f24;
  CHAR32_T f25;
  CLASS f26;
  CO_AWAIT f27;
  CO_RETURN f28;
  CO_YIELD f29;
  CODING_TRAITS f30;
  COMPL f31;
  CONCEPT f32;
  CONST f33;
  CONST_CAST f34;
  CONSTEXPR f35;
  CONTINUE f36;
  CONTROLLER f37;
  CRATE f38;
  DECLTYPE f39;
  DECODER f40;
  DEFAULT f41;
  DEFER f42;
  DELETE f43;
  DO f44;
  DOUBLE f45;
  DYNAMIC_CAST f46;
  ELSE f47;
  ENCODER f48;
  ENUM f49;
  ERR f50;
  EXPLICIT f51;
  EXPORT f52;
  EXTERN f53;
  FALLTHROUGH f54;
  FALSE f55;
  FIDL f56;
  FIDL_TYPE f57;
  FINAL f58;
  FLOAT f59;
  FN f60;
  FOR f61;
  FRIEND f62;
  FUNC f63;
  FUTURE f64;
  FUTURES f65;
  GO f66;
  GOTO f67;
  HAS_INVALID_TAG f68;
  IF f69;
  IMPL f70;
  IMPORT f71;
  IN f72;
  INLINE f73;
  INT f74;
  INT16 f75;
  INT32 f76;
  INT64 f77;
  INT8 f78;
  INTERFACE f79;
  LET f80;
  LHS f81;
  LONG f82;
  LOOP f83;
  MACRO f84;
  MAP f85;
  MATCH f86;
  MOD f87;
  MODULE f88;
  MOVE f89;
  MUT f90;
  MUTABLE f91;
  NAMESPACE f92;
  NEVER f93;
  NEW f94;
  NOEXCEPT f95;
  NONE f96;
  NOT f97;
  NOT_EQ f98;
  NULLPTR f99;
  OFFSET f100;
  OFFSETOF f101;
  OK f102;
  ON_OPEN f103;
  OPERATOR f104;
  OPTION f105;
  OR f106;
  OR_EQ f107;
  OVERRIDE f108;
  PACKAGE f109;
  PRIV f110;
  PRIVATE f111;
  PROC f112;
  PROTECTED f113;
  PROXY f114;
  PUB f115;
  PUBLIC f116;
  PURE f117;
  RANGE f118;
  REF f119;
  REGISTER f120;
  REINTERPRET_CAST f121;
  REQUIRES f122;
  RESULT f123;
  RETURN f124;
  RHS f125;
  RUNE f126;
  SELECT f127;
  SELF f128;
  SEND f129;
  SET_CONTROLLER f130;
  SHORT f131;
  SIGNED f132;
  SIZEOF f133;
  SOME f134;
  STATIC f135;
  STATIC_ASSERT f136;
  STATIC_CAST f137;
  STREAM f138;
  STRING f139;
  STRUCT f140;
  STUB f141;
  SUPER f142;
  SWITCH f143;
  SYNCHRONIZED f144;
  TAG f145;
  TEMPLATE f146;
  THIS f147;
  THREAD_LOCAL f148;
  THROW f149;
  TRAIT f150;
  TRUE f151;
  TRY f152;
  TYPE f153;
  TYPEDEF f154;
  TYPEID f155;
  TYPENAME f156;
  TYPEOF f157;
  UINT16 f158;
  UINT32 f159;
  UINT64 f160;
  UINT8 f161;
  UNION f162;
  UNSAFE f163;
  UNSIGNED f164;
  UNSIZED f165;
  USE f166;
  USING f167;
  VALUE f168;
  VALUE_UNION f169;
  VAR f170;
  VEC f171;
  VIRTUAL f172;
  VOID f173;
  VOLATILE f174;
  WCHAR_T f175;
  WHERE f176;
  WHICH f177;
  WHILE f178;
  XOR f179;
  XOR_EQ f180;
  XUNION f181;
  YIELD f182;
  ZX f183;
};

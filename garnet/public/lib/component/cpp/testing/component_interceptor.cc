// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// The intercepting mechanism works by creating an Environment containing a
// custom |fuchsia.sys.Loader| and |fuchsia.sys.Runner|. This custom environment
// loader, which answers to all components launches under this environment,
// responds with an autogenerated package directory with a .cmx pointing to a
// custom runner component. The runner component, which will also under the
// environment, forwards its requests back up to environment's injected
// |fuchsia.sys.Runner| implemented here.

#include <lib/component/cpp/testing/component_interceptor.h>

#include <fs/pseudo-file.h>
#include <fs/service.h>
#include <lib/fxl/logging.h>
#include <lib/fxl/strings/substitute.h>
#include <rapidjson/document.h>
#include <rapidjson/stringbuffer.h>
#include <rapidjson/writer.h>

namespace component {
namespace testing {

namespace {
// The runner we inject in autogenerated .cmx files.
constexpr char kEnvironmentDelegatingRunner[] =
    "fuchsia-pkg://fuchsia.com/environment_delegating_runner#meta/"
    "environment_delegating_runner.cmx";

// Relative path within the autogenerated package directory to the manifest.
constexpr char kAutogenPkgDirManifestPath[] = "autogenerated_manifest.cmx";
// Path to the autogenerated cmx file of the intercepted component. $0 is
// substituted for `kAutogenPkgDirManifestPath` at runtime.
constexpr char kAutogenCmxPathSubstitutePattern[] =
    "fuchsia-pkg://example.com/fake_pkg#$0";
}  // namespace

ComponentInterceptor::ComponentInterceptor(
    fuchsia::sys::LoaderPtr fallback_loader, async_dispatcher_t* dispatcher)
    : fallback_loader_(std::move(fallback_loader)),
      dispatcher_(dispatcher),
      vfs_(dispatcher == nullptr ? async_get_default_dispatcher()
                                 : dispatcher_) {
  loader_svc_ = fbl::AdoptRef(new fs::Service([this](zx::channel h) mutable {
    loader_bindings_.AddBinding(
        this, fidl::InterfaceRequest<fuchsia::sys::Loader>(std::move(h)),
        dispatcher_);
    return ZX_OK;
  }));
}

ComponentInterceptor::~ComponentInterceptor() = default;

// static
ComponentInterceptor ComponentInterceptor::CreateWithEnvironmentLoader(
    const fuchsia::sys::EnvironmentPtr& env, async_dispatcher_t* dispatcher) {
  // The fallback loader comes from |parent_env|.
  fuchsia::sys::LoaderPtr fallback_loader;
  fuchsia::sys::ServiceProviderPtr sp;
  env->GetServices(sp.NewRequest());
  sp->ConnectToService(fuchsia::sys::Loader::Name_,
                       fallback_loader.NewRequest().TakeChannel());

  return ComponentInterceptor(std::move(fallback_loader), dispatcher);
}

std::unique_ptr<EnvironmentServices>
ComponentInterceptor::MakeEnvironmentServices(
    const fuchsia::sys::EnvironmentPtr& parent_env) {
  auto env_services = EnvironmentServices::CreateWithCustomLoader(
      parent_env, loader_svc_, dispatcher_);

  FXL_CHECK(env_services->AddService(
                runner_bindings_.GetHandler(this, dispatcher_)) == ZX_OK)
      << "Could not initialize EnvironmentServices with custom runner.";

  return env_services;
}

// Modifies the supplied |cmx| such that:
// * required fields in .cmx are set if not present:
//    - program.binary
// * the runner is the environment delegating runner.
void SetDefaultsForCmx(rapidjson::Document* cmx) {
  // 1. Enforce that it has delegating runner.
  cmx->RemoveMember("runner");
  cmx->AddMember("runner", kEnvironmentDelegatingRunner, cmx->GetAllocator());

  // 2. If "program" is not set, give it a default one with an empty binary.
  if (!cmx->HasMember("program")) {
    rapidjson::Value program;
    program.SetObject();
    program.AddMember("binary", "", cmx->GetAllocator());
    cmx->AddMember("program", program, cmx->GetAllocator());
  }
}

bool ComponentInterceptor::InterceptURL(std::string component_url,
                                        std::string extra_cmx_contents,
                                        ComponentLaunchHandler handler) {
  FXL_DCHECK(handler) << "Must be a valid handler.";

  // 1. Parse the extra_cmx_contents. Enforce that our delgating runner is
  //    specified, and give it defaults for required fields.
  rapidjson::Document cmx;
  cmx.Parse(extra_cmx_contents);
  if (!cmx.IsObject() && !cmx.IsNull()) {
    return false;
  }
  if (cmx.IsNull()) {
    cmx.SetObject();
  }
  SetDefaultsForCmx(&cmx);

  // 2. Construct a package directory and put the |cmx| manifest in it
  // for this particular component URL.
  rapidjson::StringBuffer buf;
  rapidjson::Writer<rapidjson::StringBuffer> writer(buf);
  cmx.Accept(writer);
  std::string cmx_str = buf.GetString();

  ComponentLoadInfo info;
  info.pkg_dir = fbl::AdoptRef(new fs::PseudoDir());
  info.pkg_dir->AddEntry(kAutogenPkgDirManifestPath,
                         fbl::AdoptRef(new fs::BufferedPseudoFile(
                             [cmx_str = std::move(cmx_str)](fbl::String* out) {
                               *out = cmx_str;
                               return ZX_OK;
                             })));
  info.handler = std::move(handler);

  std::lock_guard<std::mutex> lock(intercept_urls_mu_);
  intercepted_component_load_info_[component_url] = std::move(info);

  return true;
}

void ComponentInterceptor::LoadUrl(std::string url, LoadUrlCallback response) {
  std::lock_guard<std::mutex> lock(intercept_urls_mu_);

  auto it = intercepted_component_load_info_.find(url);
  if (it == intercepted_component_load_info_.end()) {
    fallback_loader_->LoadUrl(url, std::move(response));
    return;
  }

  auto pkg = std::make_unique<fuchsia::sys::Package>();
  zx::channel server, client;
  FXL_CHECK(zx::channel::create(0, &server, &client) == ZX_OK);
  FXL_CHECK(vfs_.ServeDirectory(it->second.pkg_dir, std::move(server)) ==
            ZX_OK);
  pkg->directory = std::move(client);
  pkg->resolved_url = fxl::Substitute(kAutogenCmxPathSubstitutePattern,
                                      kAutogenPkgDirManifestPath);
  response(std::move(pkg));
  // After this point, the runner specified in the autogenerated manifest should
  // forward its requests back to us over our Runner fidl binding.
}

void ComponentInterceptor::StartComponent(
    fuchsia::sys::Package package, fuchsia::sys::StartupInfo startup_info,
    fidl::InterfaceRequest<fuchsia::sys::ComponentController> controller) {
  ComponentLaunchHandler handler;
  {
    std::lock_guard<std::mutex> lock(intercept_urls_mu_);
    auto it =
        intercepted_component_load_info_.find(startup_info.launch_info.url);
    FXL_DCHECK(it != intercepted_component_load_info_.end());

    // We maintain a reference to |handler| and unlock the mutex before calling
    // it. This allows that handler to call InterceptURL() without deadlocking
    // this on |intercept_urls_mu_|
    handler = it->second.handler;
  }

  handler(std::move(startup_info), std::move(controller));
}

}  // namespace testing
}  // namespace component

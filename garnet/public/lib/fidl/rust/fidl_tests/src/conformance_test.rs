// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// Code generated by tools/fidl/gidl-conformance-suite/regen.sh; DO NOT EDIT.

use fidl::{
    encoding::{Context, Decodable, Decoder, Encoder},
    Error,
};
use fidl_conformance as conformance;

const OLD_CONTEXT: &Context = &Context { unions_use_xunion_format: false };
const V1_CONTEXT: &Context = &Context { unions_use_xunion_format: true };

#[test]
fn test_3_byte_object_alignment_in_struct_encode() {
    let value = &mut conformance::ThreeByteInStruct {
        elem1: conformance::ThreeByte { elem1: 1u8, elem2: 2u8, elem3: 3u8 },
        elem2: conformance::ThreeByte { elem1: 4u8, elem2: 5u8, elem3: 6u8 },
        elem3: conformance::ThreeByte { elem1: 7u8, elem2: 8u8, elem3: 9u8 },
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_5_byte_object_alignment_in_struct_encode() {
    let value = &mut conformance::FiveByteInStruct {
        elem1: conformance::FiveByte { elem1: 16909060u32, elem2: 5u8 },
        elem2: conformance::FiveByte { elem1: 101124105u32, elem2: 10u8 },
        elem3: conformance::FiveByte { elem1: 185339150u32, elem2: 15u8 },
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x04, 0x03, 0x02, 0x01, 0x05, 0x00, 0x00, 0x00, 0x09, 0x08, 0x07, 0x06, 0x0a, 0x00,
            0x00, 0x00, 0x0e, 0x0d, 0x0c, 0x0b, 0x0f, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_3_byte_object_alignment_in_vector_encode() {
    let value = &mut conformance::ThreeByteInVector {
        elems: vec![
            conformance::ThreeByte { elem1: 1u8, elem2: 2u8, elem3: 3u8 },
            conformance::ThreeByte { elem1: 4u8, elem2: 5u8, elem3: 6u8 },
            conformance::ThreeByte { elem1: 7u8, elem2: 8u8, elem3: 9u8 },
        ],
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_5_byte_object_alignment_in_vector_encode() {
    let value = &mut conformance::FiveByteInVector {
        elems: vec![
            conformance::FiveByte { elem1: 16909060u32, elem2: 5u8 },
            conformance::FiveByte { elem1: 101124105u32, elem2: 10u8 },
            conformance::FiveByte { elem1: 185339150u32, elem2: 15u8 },
        ],
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x04, 0x03, 0x02, 0x01, 0x05, 0x00, 0x00, 0x00, 0x09, 0x08, 0x07, 0x06,
            0x0a, 0x00, 0x00, 0x00, 0x0e, 0x0d, 0x0c, 0x0b, 0x0f, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_3_byte_object_alignment_in_array_encode() {
    let value = &mut conformance::ThreeByteInArray {
        elems: [
            conformance::ThreeByte { elem1: 1u8, elem2: 2u8, elem3: 3u8 },
            conformance::ThreeByte { elem1: 4u8, elem2: 5u8, elem3: 6u8 },
            conformance::ThreeByte { elem1: 7u8, elem2: 8u8, elem3: 9u8 },
        ],
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_5_byte_object_alignment_in_array_encode() {
    let value = &mut conformance::FiveByteInArray {
        elems: [
            conformance::FiveByte { elem1: 16909060u32, elem2: 5u8 },
            conformance::FiveByte { elem1: 101124105u32, elem2: 10u8 },
            conformance::FiveByte { elem1: 185339150u32, elem2: 15u8 },
        ],
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x04, 0x03, 0x02, 0x01, 0x05, 0x00, 0x00, 0x00, 0x09, 0x08, 0x07, 0x06, 0x0a, 0x00,
            0x00, 0x00, 0x0e, 0x0d, 0x0c, 0x0b, 0x0f, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_empty_struct_encode() {
    let value = &mut conformance::EmptyStruct {};
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_empty_struct_sandwich_encode() {
    let value = &mut conformance::EmptyStructSandwich {
        before: String::from("before"),
        es: conformance::EmptyStruct {},
        after: String::from("after"),
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x65,
            0x66, 0x6f, 0x72, 0x65, 0x00, 0x00, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_uint8_uint16_uint32_uint64_encode() {
    let value = &mut conformance::Uint8Uint16Uint32Uint64 {
        f1: 1u8,
        f2: 515u16,
        f3: 67438087u32,
        f4: 579005069656919567u64,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x00, 0x03, 0x02, 0x07, 0x06, 0x05, 0x04, 0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a,
            0x09, 0x08,
        ][..]
    );
}

#[test]
fn test_uint64_uint32_uint16_uint8_encode() {
    let value = &mut conformance::Uint64Uint32Uint16Uint8 {
        f1: 579005069656919567u64,
        f2: 67438087u32,
        f3: 515u16,
        f4: 1u8,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a, 0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02,
            0x01, 0x00,
        ][..]
    );
}

#[test]
fn test_simple_table_empty_encode() {
    let value = &mut conformance::StructOfSimpleTable {
        table: conformance::SimpleTable { x: None, y: None },
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff,
        ][..]
    );
}

#[test]
fn test_simple_table_x_and_y_encode() {
    let value = &mut conformance::StructOfSimpleTable {
        table: conformance::SimpleTable { x: Some(42i64), y: Some(67i64) },
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2a, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_simple_table_just_y_encode() {
    let value = &mut conformance::StructOfSimpleTable {
        table: conformance::SimpleTable { y: Some(67i64), x: None },
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x43, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_table_with_string_and_vector_no_vector_content_encode() {
    let value = &mut conformance::StructOfTableWithStringAndVector {
        table: conformance::TableWithStringAndVector {
            foo: Some(String::from("hello")),
            bar: Some(27i32),
            baz: None,
        },
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x00,
            0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_simple_table_then_uint64_encode() {
    let value = &mut conformance::SimpleTableThenUint64 {
        table: conformance::SimpleTable { x: Some(42i64), y: Some(67i64) },
        number: 16045690984833335023u64,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xef, 0xbe, 0xad, 0xde, 0xef, 0xbe, 0xad, 0xde, 0x08, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_inline_x_union_in_struct_encode() {
    let value = &mut conformance::TestInlineXUnionInStruct {
        before: String::from("before"),
        xu: conformance::SampleXUnion::U(3735928559u32),
        after: String::from("after"),
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xb2, 0x56, 0x9c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x00, 0x00, 0xef, 0xbe, 0xad, 0xde, 0x00, 0x00,
            0x00, 0x00, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_optional_x_union_in_struct_absent_encode() {
    let value = &mut conformance::TestOptionalXUnionInStruct {
        before: String::from("before"),
        after: String::from("after"),
        xu: None,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x00, 0x00, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00,
            0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_optional_x_union_in_struct_present_encode() {
    let value = &mut conformance::TestOptionalXUnionInStruct {
        before: String::from("before"),
        xu: Some(Box::new(conformance::SampleXUnion::U(3735928559u32))),
        after: String::from("after"),
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xb2, 0x56, 0x9c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x00, 0x00, 0xef, 0xbe, 0xad, 0xde, 0x00, 0x00,
            0x00, 0x00, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_x_union_in_table_x_union_absent_encode() {
    let value = &mut conformance::TestXUnionInTable {
        value: conformance::XUnionInTable {
            before: Some(String::from("before")),
            after: Some(String::from("after")),
            xu: None,
        },
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x65, 0x66, 0x6f,
            0x72, 0x65, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_x_union_in_table_x_union_present_encode() {
    let value = &mut conformance::TestXUnionInTable {
        value: conformance::XUnionInTable {
            before: Some(String::from("before")),
            xu: Some(conformance::SampleXUnion::U(3735928559u32)),
            after: Some(String::from("after")),
        },
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x65, 0x66, 0x6f,
            0x72, 0x65, 0x00, 0x00, 0xb2, 0x56, 0x9c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xef, 0xbe, 0xad, 0xde, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x61, 0x66, 0x74, 0x65,
            0x72, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_strict_x_union_encode() {
    let value = &mut conformance::TestStrictXUnionInStruct {
        xu: conformance::SampleStrictXUnion::U(3735928559u32),
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x72, 0xea, 0xe2, 0x08, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xbe, 0xad, 0xde,
            0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_add_ethernet_device_request_encode() {
    let value = &mut conformance::TestAddEthernetDeviceRequest {
        topological_path: String::from("@/dev/sys/pci/00:03.0/e1000/ethernet"),
        config: conformance::InterfaceConfig {
            name: String::from("ethp0003"),
            ip_address_config: conformance::IpAddressConfig::Dhcp(true),
        },
        this_should_be_a_handle: 4294967295u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
            0x00, 0x00, 0x40, 0x2f, 0x64, 0x65, 0x76, 0x2f, 0x73, 0x79, 0x73, 0x2f, 0x70, 0x63,
            0x69, 0x2f, 0x30, 0x30, 0x3a, 0x30, 0x33, 0x2e, 0x30, 0x2f, 0x65, 0x31, 0x30, 0x30,
            0x30, 0x2f, 0x65, 0x74, 0x68, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x00, 0x00, 0x00, 0x00,
            0x65, 0x74, 0x68, 0x70, 0x30, 0x30, 0x30, 0x33,
        ][..]
    );
}

#[test]
fn test_file_get_attr_response_encode() {
    let value = &mut conformance::FileGetAttrResponse {
        s: 2125315759i32,
        attributes: conformance::NodeAttributes {
            mode: 2518909348u32,
            id: 1u64,
            content_size: 231u64,
            storage_size: 231u64,
            link_count: 1u64,
            creation_time: 9833440827789222417u64,
            modification_time: 72038755451251353u64,
        },
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0xaf, 0xbe, 0xad, 0x7e, 0x00, 0x00, 0x00, 0x00, 0xa4, 0x81, 0x23, 0x96, 0x00, 0x00,
            0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe7, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xe7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
            0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00,
        ][..]
    );
}

#[test]
fn test_optionals_encode() {
    let value = &mut conformance::StructWithOptionals {
        s: conformance::EmptyStruct {},
        s2: Some(Box::new(conformance::EmptyStruct {})),
        t: conformance::TableWithEmptyStruct { s: Some(conformance::EmptyStruct {}) },
        xu: conformance::XUnionWithEmptyStruct::S(conformance::EmptyStruct {}),
        xu2: Some(Box::new(conformance::XUnionWithEmptyStruct::S(conformance::EmptyStruct {}))),
        u: conformance::UnionWithEmptyStruct::S(conformance::EmptyStruct {}),
        u2: Some(Box::new(conformance::UnionWithEmptyStruct::S(conformance::EmptyStruct {}))),
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xfe, 0xe0, 0x99, 0x74, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xfe, 0xe0, 0x99, 0x74, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_arrays_encode() {
    let value = &mut conformance::StructWithArrays {
        arr_int: [1i32, 2i32],
        arr_string: [String::from("a"), String::from("b")],
        arr_nullable_string: [Some(String::from("c")), None],
        arr_struct: [
            conformance::StructWithInt { x: 1i32 },
            conformance::StructWithInt { x: 2i32 },
        ],
        arr_nullable_struct: [None, Some(Box::new(conformance::StructWithInt { x: 16909060i32 }))],
        arr_arr_int: [[1i32, 2i32, 3i32], [4i32, 5i32, 6i32]],
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00,
            0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
            0x05, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x04, 0x03, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_vectors_encode() {
    let value = &mut conformance::StructWithVectors {
        vec_empty: vec![],
        vec_int: vec![1i32, 2i32],
        vec_string: vec![String::from("a"), String::from("b")],
        vec_nullable_string: vec![None, Some(String::from("c")), None],
        vec_struct: vec![conformance::StructWithInt { x: 1i32 }],
        vec_nullable_struct: vec![
            None,
            None,
            Some(Box::new(conformance::StructWithInt { x: 2i32 })),
        ],
        vec_vec_int: vec![vec![1i32, 2i32], vec![3i32]],
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x02, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x61, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_bool_true_encode() {
    let value = &mut conformance::MyBool { value: true };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_bool_false_encode() {
    let value = &mut conformance::MyBool { value: false };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_byte_zero_encode() {
    let value = &mut conformance::MyByte { value: 0u8 };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_byte255_encode() {
    let value = &mut conformance::MyByte { value: 255u8 };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_int8_min_encode() {
    let value = &mut conformance::MyInt8 { value: -128i8 };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_int8_zero_encode() {
    let value = &mut conformance::MyInt8 { value: 0i8 };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_int8_max_encode() {
    let value = &mut conformance::MyInt8 { value: 127i8 };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_int16_min_encode() {
    let value = &mut conformance::MyInt16 { value: -32768i16 };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_int16_zero_encode() {
    let value = &mut conformance::MyInt16 { value: 0i16 };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_int16_max_encode() {
    let value = &mut conformance::MyInt16 { value: 32767i16 };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_int32_min_encode() {
    let value = &mut conformance::MyInt32 { value: -2147483648i32 };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_int32_zero_encode() {
    let value = &mut conformance::MyInt32 { value: 0i32 };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_int32_max_encode() {
    let value = &mut conformance::MyInt32 { value: 2147483647i32 };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0xff, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_int64_min_encode() {
    let value = &mut conformance::MyInt64 { value: -9223372036854775808i64 };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,][..]);
}

#[test]
fn test_int64_zero_encode() {
    let value = &mut conformance::MyInt64 { value: 0i64 };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_int64_max_encode() {
    let value = &mut conformance::MyInt64 { value: 9223372036854775807i64 };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f,][..]);
}

#[test]
fn test_uint8_zero_encode() {
    let value = &mut conformance::MyUint8 { value: 0u8 };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_uint8_max_encode() {
    let value = &mut conformance::MyUint8 { value: 255u8 };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_uint16_zero_encode() {
    let value = &mut conformance::MyUint16 { value: 0u16 };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_uint16_max_encode() {
    let value = &mut conformance::MyUint16 { value: 65535u16 };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_uint32_zero_encode() {
    let value = &mut conformance::MyUint32 { value: 0u32 };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_uint32_max_encode() {
    let value = &mut conformance::MyUint32 { value: 4294967295u32 };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_uint64_zero_encode() {
    let value = &mut conformance::MyUint64 { value: 0u64 };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_uint64_max_encode() {
    let value = &mut conformance::MyUint64 { value: 18446744073709551615u64 };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,][..]);
}

#[test]
fn test_float32_zero_encode() {
    let value = &mut conformance::MyFloat32 { value: 0f32 };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_float32_one_encode() {
    let value = &mut conformance::MyFloat32 { value: 1f32 };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_float32_minus_one_encode() {
    let value = &mut conformance::MyFloat32 { value: -1f32 };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x80, 0xbf, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_float32_max_encode() {
    let value = &mut conformance::MyFloat32 { value: 3.4028234663852886e+38f32 };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0xff, 0xff, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_float64_zero_encode() {
    let value = &mut conformance::MyFloat64 { value: 0f64 };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_float64_one_encode() {
    let value = &mut conformance::MyFloat64 { value: 1f64 };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,][..]);
}

#[test]
fn test_float64_minus_one_encode() {
    let value = &mut conformance::MyFloat64 { value: -1f64 };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xbf,][..]);
}

#[test]
fn test_float64_max_encode() {
    let value = &mut conformance::MyFloat64 { value: 1.7976931348623157e+308f64 };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0x7f,][..]);
}

#[test]
fn test_sandwich1_case1_encode() {
    let value = &mut conformance::Sandwich1 {
        before: 67305985u32,
        the_union: conformance::UnionSize8Align4::Variant(202050057u32),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x02, 0x00, 0x00, 0x00, 0x09, 0x0a, 0x0b, 0x0c, 0x05, 0x06,
            0x07, 0x08,
        ][..]
    );
}

#[test]
fn test_sandwich1_case1_v1_encode() {
    let value = &mut conformance::Sandwich1 {
        before: 67305985u32,
        the_union: conformance::UnionSize8Align4::Variant(202050057u32),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x09, 0x0a,
            0x0b, 0x0c, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich2_case1_encode() {
    let value = &mut conformance::Sandwich2 {
        before: 67305985u32,
        the_union: conformance::UnionSize12Align4::Variant([
            160u8, 161u8, 162u8, 163u8, 164u8, 165u8,
        ]),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x03, 0x00, 0x00, 0x00, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5,
            0x00, 0x00, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich2_case1_v1_encode() {
    let value = &mut conformance::Sandwich2 {
        before: 67305985u32,
        the_union: conformance::UnionSize12Align4::Variant([
            160u8, 161u8, 162u8, 163u8, 164u8, 165u8,
        ]),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0xa0, 0xa1,
            0xa2, 0xa3, 0xa4, 0xa5, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich3_case1_encode() {
    let value = &mut conformance::Sandwich3 {
        before: 67305985u32,
        the_union: conformance::UnionSize24Align8::Variant(conformance::StructSize16Align8 {
            f1: 12080525177006498208u64,
            f2: 12659246559711111592u64,
        }),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab,
            0xac, 0xad, 0xae, 0xaf, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich3_case1_v1_encode() {
    let value = &mut conformance::Sandwich3 {
        before: 67305985u32,
        the_union: conformance::UnionSize24Align8::Variant(conformance::StructSize16Align8 {
            f1: 12080525177006498208u64,
            f2: 12659246559711111592u64,
        }),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0xa0, 0xa1,
            0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
        ][..]
    );
}

#[test]
fn test_sandwich4_case1_encode() {
    let value = &mut conformance::Sandwich4 {
        before: 67305985u32,
        the_union: conformance::UnionSize36Align4::Variant([
            160u8, 161u8, 162u8, 163u8, 164u8, 165u8, 166u8, 167u8, 168u8, 169u8, 170u8, 171u8,
            172u8, 173u8, 174u8, 175u8, 176u8, 177u8, 178u8, 179u8, 180u8, 181u8, 182u8, 183u8,
            184u8, 185u8, 186u8, 187u8, 188u8, 189u8, 190u8, 191u8,
        ]),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x03, 0x00, 0x00, 0x00, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5,
            0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3,
            0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0x05, 0x06,
            0x07, 0x08, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich4_case1_v1_encode() {
    let value = &mut conformance::Sandwich4 {
        before: 67305985u32,
        the_union: conformance::UnionSize36Align4::Variant([
            160u8, 161u8, 162u8, 163u8, 164u8, 165u8, 166u8, 167u8, 168u8, 169u8, 170u8, 171u8,
            172u8, 173u8, 174u8, 175u8, 176u8, 177u8, 178u8, 179u8, 180u8, 181u8, 182u8, 183u8,
            184u8, 185u8, 186u8, 187u8, 188u8, 189u8, 190u8, 191u8,
        ]),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0xa0, 0xa1,
            0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
            0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd,
            0xbe, 0xbf,
        ][..]
    );
}

#[test]
fn test_sandwich5_case1_encode() {
    let value = &mut conformance::Sandwich5 {
        before: 67305985u32,
        union_of_union: conformance::UnionOfUnion::Size8align4(
            conformance::UnionSize8Align4::Variant(202050057u32),
        ),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x09, 0x0a, 0x0b, 0x0c, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x06,
            0x07, 0x08, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich5_case1_v1_encode() {
    let value = &mut conformance::Sandwich5 {
        before: 67305985u32,
        union_of_union: conformance::UnionOfUnion::Size8align4(
            conformance::UnionSize8Align4::Variant(202050057u32),
        ),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x09, 0x0a, 0x0b, 0x0c, 0x00, 0x00,
            0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich5_case2_encode() {
    let value = &mut conformance::Sandwich5 {
        before: 67305985u32,
        union_of_union: conformance::UnionOfUnion::Size24align8(
            conformance::UnionSize24Align8::Variant(conformance::StructSize16Align8 {
                f1: 12080525177006498208u64,
                f2: 12659246559711111592u64,
            }),
        ),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0xa1, 0xa2, 0xa3,
            0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0x05, 0x06,
            0x07, 0x08, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich5_case2_v1_encode() {
    let value = &mut conformance::Sandwich5 {
        before: 67305985u32,
        union_of_union: conformance::UnionOfUnion::Size24align8(
            conformance::UnionSize24Align8::Variant(conformance::StructSize16Align8 {
                f1: 12080525177006498208u64,
                f2: 12659246559711111592u64,
            }),
        ),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5,
            0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
        ][..]
    );
}

#[test]
fn test_sandwich6_case1_encode() {
    let value = &mut conformance::Sandwich6 {
        before: 67305985u32,
        the_union: conformance::UnionWithVector::VectorOfUint8(vec![
            160u8, 161u8, 162u8, 163u8, 164u8, 165u8,
        ]),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0xa0, 0xa1,
            0xa2, 0xa3, 0xa4, 0xa5, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich6_case1_v1_encode() {
    let value = &mut conformance::Sandwich6 {
        before: 67305985u32,
        the_union: conformance::UnionWithVector::VectorOfUint8(vec![
            160u8, 161u8, 162u8, 163u8, 164u8, 165u8,
        ]),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich6_case1_absent_vector_encode() {
    let value = &mut conformance::Sandwich6 {
        before: 67305985u32,
        the_union: conformance::UnionWithVector::VectorOfUint8(vec![]),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich6_case1_absent_vector_v1_encode() {
    let value = &mut conformance::Sandwich6 {
        before: 67305985u32,
        the_union: conformance::UnionWithVector::VectorOfUint8(vec![]),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        ][..]
    );
}

#[test]
fn test_sandwich6_case2_encode() {
    let value = &mut conformance::Sandwich6 {
        before: 67305985u32,
        the_union: conformance::UnionWithVector::S(String::from("soft migrations rock!")),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x73, 0x6f,
            0x66, 0x74, 0x20, 0x6d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20,
            0x72, 0x6f, 0x63, 0x6b, 0x21, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich6_case2_v1_encode() {
    let value = &mut conformance::Sandwich6 {
        before: 67305985u32,
        the_union: conformance::UnionWithVector::S(String::from("soft migrations rock!")),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x73, 0x6f, 0x66, 0x74, 0x20, 0x6d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
            0x73, 0x20, 0x72, 0x6f, 0x63, 0x6b, 0x21, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich6_case3_encode() {
    let value = &mut conformance::Sandwich6 {
        before: 67305985u32,
        the_union: conformance::UnionWithVector::VectorS3A1(vec![
            conformance::StructSize3Align1 { three_bytes: [115u8, 111u8, 102u8] },
            conformance::StructSize3Align1 { three_bytes: [32u8, 109u8, 105u8] },
            conformance::StructSize3Align1 { three_bytes: [114u8, 97u8, 116u8] },
        ]),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x73, 0x6f,
            0x66, 0x20, 0x6d, 0x69, 0x72, 0x61, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich6_case3_v1_encode() {
    let value = &mut conformance::Sandwich6 {
        before: 67305985u32,
        the_union: conformance::UnionWithVector::VectorS3A1(vec![
            conformance::StructSize3Align1 { three_bytes: [115u8, 111u8, 102u8] },
            conformance::StructSize3Align1 { three_bytes: [32u8, 109u8, 105u8] },
            conformance::StructSize3Align1 { three_bytes: [114u8, 97u8, 116u8] },
        ]),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x73, 0x6f, 0x66, 0x20, 0x6d, 0x69, 0x72, 0x61, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich6_case4_encode() {
    let value = &mut conformance::Sandwich6 {
        before: 67305985u32,
        the_union: conformance::UnionWithVector::VectorS3A2(vec![
            conformance::StructSize3Align2 { f1: 28531u16, f2: 102u8 },
            conformance::StructSize3Align2 { f1: 27936u16, f2: 105u8 },
            conformance::StructSize3Align2 { f1: 24946u16, f2: 116u8 },
        ]),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x73, 0x6f,
            0x66, 0x00, 0x20, 0x6d, 0x69, 0x00, 0x72, 0x61, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich6_case4_v1_encode() {
    let value = &mut conformance::Sandwich6 {
        before: 67305985u32,
        the_union: conformance::UnionWithVector::VectorS3A2(vec![
            conformance::StructSize3Align2 { f1: 28531u16, f2: 102u8 },
            conformance::StructSize3Align2 { f1: 27936u16, f2: 105u8 },
            conformance::StructSize3Align2 { f1: 24946u16, f2: 116u8 },
        ]),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x73, 0x6f, 0x66, 0x00, 0x20, 0x6d, 0x69, 0x00, 0x72, 0x61, 0x74, 0x00, 0x00, 0x00,
            0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich6_case5_encode() {
    let value = &mut conformance::Sandwich6 {
        before: 67305985u32,
        the_union: conformance::UnionWithVector::Handles(vec![
            4294967295u32,
            4294967295u32,
            4294967295u32,
        ]),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich6_case5_v1_encode() {
    let value = &mut conformance::Sandwich6 {
        before: 67305985u32,
        the_union: conformance::UnionWithVector::Handles(vec![
            4294967295u32,
            4294967295u32,
            4294967295u32,
        ]),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
            0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich6_case6_encode() {
    let value = &mut conformance::Sandwich6 {
        before: 67305985u32,
        the_union: conformance::UnionWithVector::ArrayS3A1([
            conformance::StructSize3Align1 { three_bytes: [161u8, 162u8, 163u8] },
            conformance::StructSize3Align1 { three_bytes: [164u8, 165u8, 166u8] },
        ]),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich6_case6_v1_encode() {
    let value = &mut conformance::Sandwich6 {
        before: 67305985u32,
        the_union: conformance::UnionWithVector::ArrayS3A1([
            conformance::StructSize3Align1 { three_bytes: [161u8, 162u8, 163u8] },
            conformance::StructSize3Align1 { three_bytes: [164u8, 165u8, 166u8] },
        ]),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0xa1, 0xa2,
            0xa3, 0xa4, 0xa5, 0xa6, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich6_case7_encode() {
    let value = &mut conformance::Sandwich6 {
        before: 67305985u32,
        the_union: conformance::UnionWithVector::ArrayS3A2([
            conformance::StructSize3Align2 { f1: 41633u16, f2: 163u8 },
            conformance::StructSize3Align2 { f1: 42404u16, f2: 166u8 },
        ]),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xa1, 0xa2, 0xa3, 0x00, 0xa4, 0xa5, 0xa6, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich6_case7_v1_encode() {
    let value = &mut conformance::Sandwich6 {
        before: 67305985u32,
        the_union: conformance::UnionWithVector::ArrayS3A2([
            conformance::StructSize3Align2 { f1: 41633u16, f2: 163u8 },
            conformance::StructSize3Align2 { f1: 42404u16, f2: 166u8 },
        ]),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0xa1, 0xa2,
            0xa3, 0x00, 0xa4, 0xa5, 0xa6, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich6_case8_encode() {
    let value = &mut conformance::Sandwich6 {
        before: 67305985u32,
        the_union: conformance::UnionWithVector::VectorUnion(vec![
            conformance::UnionSize8Align4::Variant(202050057u32),
        ]),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
            0x00, 0x00, 0x09, 0x0a, 0x0b, 0x0c,
        ][..]
    );
}

#[test]
fn test_sandwich6_case8_v1_encode() {
    let value = &mut conformance::Sandwich6 {
        before: 67305985u32,
        the_union: conformance::UnionWithVector::VectorUnion(vec![
            conformance::UnionSize8Align4::Variant(202050057u32),
        ]),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x09, 0x0a, 0x0b, 0x0c,
            0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_table_struct_with_reserved_sandwich_encode() {
    let value = &mut conformance::TableStructWithReservedSandwichStruct {
        table: conformance::TableStructWithReservedSandwich {
            s1: Some(conformance::StructSize3Align1 { three_bytes: [9u8, 10u8, 11u8] }),
            s2: Some(conformance::StructSize3Align1 { three_bytes: [25u8, 26u8, 27u8] }),
        },
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x09, 0x0a, 0x0b, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x19, 0x1a, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_table_struct_with_reserved_sandwich_v1_encode() {
    let value = &mut conformance::TableStructWithReservedSandwichStruct {
        table: conformance::TableStructWithReservedSandwich {
            s1: Some(conformance::StructSize3Align1 { three_bytes: [9u8, 10u8, 11u8] }),
            s2: Some(conformance::StructSize3Align1 { three_bytes: [25u8, 26u8, 27u8] }),
        },
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x09, 0x0a, 0x0b, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x19, 0x1a, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_table_struct_with_uint32_sandwich_encode() {
    let value = &mut conformance::TableStructWithUint32SandwichStruct {
        table: conformance::TableStructWithUint32Sandwich {
            i: Some(67305985u32),
            s1: Some(conformance::StructSize3Align1 { three_bytes: [9u8, 10u8, 11u8] }),
            s2: Some(conformance::StructSize3Align1 { three_bytes: [25u8, 26u8, 27u8] }),
            i2: Some(218893066u32),
        },
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x02, 0x03, 0x04,
            0x00, 0x00, 0x00, 0x00, 0x09, 0x0a, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x1a,
            0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_table_struct_with_uint32_sandwich_v1_encode() {
    let value = &mut conformance::TableStructWithUint32SandwichStruct {
        table: conformance::TableStructWithUint32Sandwich {
            i: Some(67305985u32),
            s1: Some(conformance::StructSize3Align1 { three_bytes: [9u8, 10u8, 11u8] }),
            s2: Some(conformance::StructSize3Align1 { three_bytes: [25u8, 26u8, 27u8] }),
            i2: Some(218893066u32),
        },
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x02, 0x03, 0x04,
            0x00, 0x00, 0x00, 0x00, 0x09, 0x0a, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x1a,
            0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_table_union_with_vector_reserved_sandwich_encode() {
    let value = &mut conformance::TableUnionWithVectorReservedSandwichStruct {
        table: conformance::TableUnionWithVectorReservedSandwich {
            uv: Some(conformance::UnionWithVector::S(String::from("hello"))),
        },
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_table_union_with_vector_reserved_sandwich_v1_encode() {
    let value = &mut conformance::TableUnionWithVectorReservedSandwichStruct {
        table: conformance::TableUnionWithVectorReservedSandwich {
            uv: Some(conformance::UnionWithVector::S(String::from("hello"))),
        },
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_table_union_with_vector_struct_sandwich_encode() {
    let value = &mut conformance::TableUnionWithVectorStructSandwichStruct {
        table: conformance::TableUnionWithVectorStructSandwich {
            s1: Some(conformance::StructSize3Align1 { three_bytes: [1u8, 2u8, 3u8] }),
            uv: Some(conformance::UnionWithVector::S(String::from("hello"))),
            s2: Some(conformance::StructSize3Align1 { three_bytes: [4u8, 5u8, 6u8] }),
        },
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x02, 0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x68, 0x65,
            0x6c, 0x6c, 0x6f, 0x00, 0x00, 0x00, 0x04, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_table_union_with_vector_struct_sandwich_v1_encode() {
    let value = &mut conformance::TableUnionWithVectorStructSandwichStruct {
        table: conformance::TableUnionWithVectorStructSandwich {
            s1: Some(conformance::StructSize3Align1 { three_bytes: [1u8, 2u8, 3u8] }),
            uv: Some(conformance::UnionWithVector::S(String::from("hello"))),
            s2: Some(conformance::StructSize3Align1 { three_bytes: [4u8, 5u8, 6u8] }),
        },
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x02, 0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x00, 0x00, 0x00, 0x04, 0x05, 0x06, 0x00, 0x00, 0x00,
            0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_x_union_with_struct_encode() {
    let value = &mut conformance::XUnionWithStructStruct {
        xu: conformance::XUnionWithStruct::S(conformance::StructSize3Align1 {
            three_bytes: [1u8, 2u8, 3u8],
        }),
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x14, 0x5c, 0x3e, 0x19, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x02, 0x03, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_x_union_with_struct_v1_encode() {
    let value = &mut conformance::XUnionWithStructStruct {
        xu: conformance::XUnionWithStruct::S(conformance::StructSize3Align1 {
            three_bytes: [1u8, 2u8, 3u8],
        }),
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x14, 0x5c, 0x3e, 0x19, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x02, 0x03, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_array_struct_encode() {
    let value = &mut conformance::ArrayStruct {
        unions: [
            conformance::StringUnion::S(String::from("one")),
            conformance::StringUnion::S(String::from("two")),
            conformance::StringUnion::S(String::from("three")),
        ],
        optional_unions: [
            Some(Box::new(conformance::StringUnion::S(String::from("four")))),
            Some(Box::new(conformance::StringUnion::S(String::from("five")))),
            Some(Box::new(conformance::StringUnion::S(String::from("six")))),
        ],
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x6f, 0x6e,
            0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0x77, 0x6f, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x74, 0x68, 0x72, 0x65, 0x65, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x66, 0x6f, 0x75, 0x72, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x66, 0x69, 0x76, 0x65, 0x00, 0x00,
            0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x73, 0x69,
            0x78, 0x00, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_array_struct_v1_encode() {
    let value = &mut conformance::ArrayStruct {
        unions: [
            conformance::StringUnion::S(String::from("one")),
            conformance::StringUnion::S(String::from("two")),
            conformance::StringUnion::S(String::from("three")),
        ],
        optional_unions: [
            Some(Box::new(conformance::StringUnion::S(String::from("four")))),
            Some(Box::new(conformance::StringUnion::S(String::from("five")))),
            Some(Box::new(conformance::StringUnion::S(String::from("six")))),
        ],
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x02, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x6f, 0x6e, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x74, 0x77, 0x6f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x74, 0x68,
            0x72, 0x65, 0x65, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x66, 0x6f, 0x75, 0x72, 0x00, 0x00,
            0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x66, 0x69, 0x76, 0x65, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x73, 0x69, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_regression1_encode() {
    let value =
        &mut conformance::Regression1 { f1: 1u8, f2: 2u32, f3: 3u8, f4: 4u16, f5: 5u64, f6: 6u8 };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x04, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_regression1_v1_encode() {
    let value =
        &mut conformance::Regression1 { f1: 1u8, f2: 2u32, f3: 3u8, f4: 4u16, f5: 5u64, f6: 6u8 };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x04, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_regression2_encode() {
    let value = &mut conformance::Regression2 {
        head: conformance::Regression1 { f1: 1u8, f2: 2u32, f3: 3u8, f4: 4u16, f5: 5u64, f6: 6u8 },
        f7: 7u8,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x04, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_regression2_v1_encode() {
    let value = &mut conformance::Regression2 {
        head: conformance::Regression1 { f1: 1u8, f2: 2u32, f3: 3u8, f4: 4u16, f5: 5u64, f6: 6u8 },
        f7: 7u8,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x04, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_regression3_absent_encode() {
    let value = &mut conformance::Regression3 { opt_value: None };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_regression3_absent_v1_encode() {
    let value = &mut conformance::Regression3 { opt_value: None };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_regression3_present_encode() {
    let value = &mut conformance::Regression3 {
        opt_value: Some(Box::new(conformance::Regression2 {
            head: conformance::Regression1 {
                f1: 1u8,
                f2: 2u32,
                f3: 3u8,
                f4: 4u16,
                f5: 5u64,
                f6: 6u8,
            },
            f7: 7u8,
        })),
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00,
            0x00, 0x00, 0x03, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_regression3_present_v1_encode() {
    let value = &mut conformance::Regression3 {
        opt_value: Some(Box::new(conformance::Regression2 {
            head: conformance::Regression1 {
                f1: 1u8,
                f2: 2u32,
                f3: 3u8,
                f4: 4u16,
                f5: 5u64,
                f6: 6u8,
            },
            f7: 7u8,
        })),
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00,
            0x00, 0x00, 0x03, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_union_with_bound_string_encode() {
    let value = &mut conformance::UnionWithBoundStringStruct {
        v: conformance::UnionWithBoundString::BoundFiveStr(String::from("abcd")),
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x61, 0x62, 0x63, 0x64,
            0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_union_migration_single_variant_encode() {
    let value =
        &mut conformance::SingleVariantUnionStruct { u: conformance::SingleVariantUnion::X(42u32) };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_union_migration_single_variant_v1_encode() {
    let value =
        &mut conformance::SingleVariantUnionStruct { u: conformance::SingleVariantUnion::X(42u32) };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2a, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_union_size8_alignment4_encode() {
    let value = &mut conformance::SandwichUnionSize8Alignment4 {
        before: 10u32,
        value: conformance::UnionSize8Alignment4::Variant(4u32),
        after: 20u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x0a, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x14, 0x00,
            0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_union_size8_alignment4_v1_encode() {
    let value = &mut conformance::SandwichUnionSize8Alignment4 {
        before: 10u32,
        value: conformance::UnionSize8Alignment4::Variant(4u32),
        after: 20u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_union_size12_alignment4_encode() {
    let value = &mut conformance::SandwichUnionSize12Alignment4 {
        before: 10u32,
        value: conformance::UnionSize12Alignment4::Variant([1u8, 2u8, 3u8, 4u8, 5u8, 6u8]),
        after: 20u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x0a, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
            0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_union_size12_alignment4_v1_encode() {
    let value = &mut conformance::SandwichUnionSize12Alignment4 {
        before: 10u32,
        value: conformance::UnionSize12Alignment4::Variant([1u8, 2u8, 3u8, 4u8, 5u8, 6u8]),
        after: 20u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02,
            0x03, 0x04, 0x05, 0x06, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_union_size24_alignment8_encode() {
    let value = &mut conformance::SandwichUnionSize24Alignment8 {
        before: 10u32,
        value: conformance::UnionSize24Alignment8::Variant(conformance::StructSize16Alignment8 {
            f1: 1u64,
            f2: 2u64,
        }),
        after: 20u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_union_size24_alignment8_v1_encode() {
    let value = &mut conformance::SandwichUnionSize24Alignment8 {
        before: 10u32,
        value: conformance::UnionSize24Alignment8::Variant(conformance::StructSize16Alignment8 {
            f1: 1u64,
            f2: 2u64,
        }),
        after: 20u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_union_size36_alignment4_encode() {
    let value = &mut conformance::SandwichUnionSize36Alignment4 {
        before: 10u32,
        value: conformance::UnionSize36Alignment4::Variant([
            1u8, 2u8, 3u8, 4u8, 5u8, 6u8, 7u8, 8u8, 9u8, 10u8, 11u8, 12u8, 13u8, 14u8, 15u8, 16u8,
            17u8, 18u8, 19u8, 20u8, 21u8, 22u8, 23u8, 24u8, 25u8, 26u8, 27u8, 28u8, 29u8, 30u8,
            31u8, 32u8,
        ]),
        after: 20u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(OLD_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x0a, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
            0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14,
            0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x14, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_union_size36_alignment4_v1_encode() {
    let value = &mut conformance::SandwichUnionSize36Alignment4 {
        before: 10u32,
        value: conformance::UnionSize36Alignment4::Variant([
            1u8, 2u8, 3u8, 4u8, 5u8, 6u8, 7u8, 8u8, 9u8, 10u8, 11u8, 12u8, 13u8, 14u8, 15u8, 16u8,
            17u8, 18u8, 19u8, 20u8, 21u8, 22u8, 23u8, 24u8, 25u8, 26u8, 27u8, 28u8, 29u8, 30u8,
            31u8, 32u8,
        ]),
        after: 20u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02,
            0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
            0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e,
            0x1f, 0x20,
        ][..]
    );
}

#[test]
fn test_3_byte_object_alignment_in_struct_decode() {
    let value = &mut conformance::ThreeByteInStruct::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::ThreeByteInStruct {
            elem1: conformance::ThreeByte { elem1: 1u8, elem2: 2u8, elem3: 3u8 },
            elem2: conformance::ThreeByte { elem1: 4u8, elem2: 5u8, elem3: 6u8 },
            elem3: conformance::ThreeByte { elem1: 7u8, elem2: 8u8, elem3: 9u8 }
        }
    );
}

#[test]
fn test_5_byte_object_alignment_in_struct_decode() {
    let value = &mut conformance::FiveByteInStruct::new_empty();
    let bytes = &mut [
        0x04, 0x03, 0x02, 0x01, 0x05, 0x00, 0x00, 0x00, 0x09, 0x08, 0x07, 0x06, 0x0a, 0x00, 0x00,
        0x00, 0x0e, 0x0d, 0x0c, 0x0b, 0x0f, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::FiveByteInStruct {
            elem1: conformance::FiveByte { elem1: 16909060u32, elem2: 5u8 },
            elem2: conformance::FiveByte { elem1: 101124105u32, elem2: 10u8 },
            elem3: conformance::FiveByte { elem1: 185339150u32, elem2: 15u8 }
        }
    );
}

#[test]
fn test_3_byte_object_alignment_in_vector_decode() {
    let value = &mut conformance::ThreeByteInVector::new_empty();
    let bytes = &mut [
        0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::ThreeByteInVector {
            elems: vec![
                conformance::ThreeByte { elem1: 1u8, elem2: 2u8, elem3: 3u8 },
                conformance::ThreeByte { elem1: 4u8, elem2: 5u8, elem3: 6u8 },
                conformance::ThreeByte { elem1: 7u8, elem2: 8u8, elem3: 9u8 }
            ]
        }
    );
}

#[test]
fn test_5_byte_object_alignment_in_vector_decode() {
    let value = &mut conformance::FiveByteInVector::new_empty();
    let bytes = &mut [
        0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x04, 0x03, 0x02, 0x01, 0x05, 0x00, 0x00, 0x00, 0x09, 0x08, 0x07, 0x06, 0x0a, 0x00,
        0x00, 0x00, 0x0e, 0x0d, 0x0c, 0x0b, 0x0f, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::FiveByteInVector {
            elems: vec![
                conformance::FiveByte { elem1: 16909060u32, elem2: 5u8 },
                conformance::FiveByte { elem1: 101124105u32, elem2: 10u8 },
                conformance::FiveByte { elem1: 185339150u32, elem2: 15u8 }
            ]
        }
    );
}

#[test]
fn test_3_byte_object_alignment_in_array_decode() {
    let value = &mut conformance::ThreeByteInArray::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::ThreeByteInArray {
            elems: [
                conformance::ThreeByte { elem1: 1u8, elem2: 2u8, elem3: 3u8 },
                conformance::ThreeByte { elem1: 4u8, elem2: 5u8, elem3: 6u8 },
                conformance::ThreeByte { elem1: 7u8, elem2: 8u8, elem3: 9u8 }
            ]
        }
    );
}

#[test]
fn test_5_byte_object_alignment_in_array_decode() {
    let value = &mut conformance::FiveByteInArray::new_empty();
    let bytes = &mut [
        0x04, 0x03, 0x02, 0x01, 0x05, 0x00, 0x00, 0x00, 0x09, 0x08, 0x07, 0x06, 0x0a, 0x00, 0x00,
        0x00, 0x0e, 0x0d, 0x0c, 0x0b, 0x0f, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::FiveByteInArray {
            elems: [
                conformance::FiveByte { elem1: 16909060u32, elem2: 5u8 },
                conformance::FiveByte { elem1: 101124105u32, elem2: 10u8 },
                conformance::FiveByte { elem1: 185339150u32, elem2: 15u8 }
            ]
        }
    );
}

#[test]
fn test_empty_struct_decode() {
    let value = &mut conformance::EmptyStruct::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::EmptyStruct {});
}

#[test]
fn test_empty_struct_sandwich_decode() {
    let value = &mut conformance::EmptyStructSandwich::new_empty();
    let bytes = &mut [
        0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x65, 0x66, 0x6f, 0x72,
        0x65, 0x00, 0x00, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::EmptyStructSandwich {
            before: String::from("before"),
            es: conformance::EmptyStruct {},
            after: String::from("after")
        }
    );
}

#[test]
fn test_uint8_uint16_uint32_uint64_decode() {
    let value = &mut conformance::Uint8Uint16Uint32Uint64::new_empty();
    let bytes = &mut [
        0x01, 0x00, 0x03, 0x02, 0x07, 0x06, 0x05, 0x04, 0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a, 0x09,
        0x08,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Uint8Uint16Uint32Uint64 {
            f1: 1u8,
            f2: 515u16,
            f3: 67438087u32,
            f4: 579005069656919567u64
        }
    );
}

#[test]
fn test_uint64_uint32_uint16_uint8_decode() {
    let value = &mut conformance::Uint64Uint32Uint16Uint8::new_empty();
    let bytes = &mut [
        0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a, 0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01,
        0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Uint64Uint32Uint16Uint8 {
            f1: 579005069656919567u64,
            f2: 67438087u32,
            f3: 515u16,
            f4: 1u8
        }
    );
}

#[test]
fn test_simple_table_empty_decode() {
    let value = &mut conformance::StructOfSimpleTable::new_empty();
    let bytes = &mut [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::StructOfSimpleTable { table: conformance::SimpleTable { x: None, y: None } }
    );
}

#[test]
fn test_simple_table_x_and_y_decode() {
    let value = &mut conformance::StructOfSimpleTable::new_empty();
    let bytes = &mut [
        0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::StructOfSimpleTable {
            table: conformance::SimpleTable { x: Some(42i64), y: Some(67i64) }
        }
    );
}

#[test]
fn test_simple_table_just_y_decode() {
    let value = &mut conformance::StructOfSimpleTable::new_empty();
    let bytes = &mut [
        0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::StructOfSimpleTable {
            table: conformance::SimpleTable { y: Some(67i64), x: None }
        }
    );
}

#[test]
fn test_table_with_string_and_vector_no_vector_content_decode() {
    let value = &mut conformance::StructOfTableWithStringAndVector::new_empty();
    let bytes = &mut [
        0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::StructOfTableWithStringAndVector {
            table: conformance::TableWithStringAndVector {
                foo: Some(String::from("hello")),
                bar: Some(27i32),
                baz: None
            }
        }
    );
}

#[test]
fn test_simple_table_then_uint64_decode() {
    let value = &mut conformance::SimpleTableThenUint64::new_empty();
    let bytes = &mut [
        0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xef, 0xbe, 0xad, 0xde, 0xef, 0xbe, 0xad, 0xde, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2a,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::SimpleTableThenUint64 {
            table: conformance::SimpleTable { x: Some(42i64), y: Some(67i64) },
            number: 16045690984833335023u64
        }
    );
}

#[test]
fn test_inline_x_union_in_struct_decode() {
    let value = &mut conformance::TestInlineXUnionInStruct::new_empty();
    let bytes = &mut [
        0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xb2, 0x56, 0x9c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x65, 0x66, 0x6f,
        0x72, 0x65, 0x00, 0x00, 0xef, 0xbe, 0xad, 0xde, 0x00, 0x00, 0x00, 0x00, 0x61, 0x66, 0x74,
        0x65, 0x72, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::TestInlineXUnionInStruct {
            before: String::from("before"),
            xu: conformance::SampleXUnion::U(3735928559u32),
            after: String::from("after")
        }
    );
}

#[test]
fn test_optional_x_union_in_struct_absent_decode() {
    let value = &mut conformance::TestOptionalXUnionInStruct::new_empty();
    let bytes = &mut [
        0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x65, 0x66, 0x6f,
        0x72, 0x65, 0x00, 0x00, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::TestOptionalXUnionInStruct {
            before: String::from("before"),
            after: String::from("after"),
            xu: None
        }
    );
}

#[test]
fn test_optional_x_union_in_struct_present_decode() {
    let value = &mut conformance::TestOptionalXUnionInStruct::new_empty();
    let bytes = &mut [
        0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xb2, 0x56, 0x9c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x65, 0x66, 0x6f,
        0x72, 0x65, 0x00, 0x00, 0xef, 0xbe, 0xad, 0xde, 0x00, 0x00, 0x00, 0x00, 0x61, 0x66, 0x74,
        0x65, 0x72, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::TestOptionalXUnionInStruct {
            before: String::from("before"),
            xu: Some(Box::new(conformance::SampleXUnion::U(3735928559u32))),
            after: String::from("after")
        }
    );
}

#[test]
fn test_x_union_in_table_x_union_absent_decode() {
    let value = &mut conformance::TestXUnionInTable::new_empty();
    let bytes = &mut [
        0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x00, 0x00, 0x05, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x61,
        0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::TestXUnionInTable {
            value: conformance::XUnionInTable {
                before: Some(String::from("before")),
                after: Some(String::from("after")),
                xu: None
            }
        }
    );
}

#[test]
fn test_x_union_in_table_x_union_present_decode() {
    let value = &mut conformance::TestXUnionInTable::new_empty();
    let bytes = &mut [
        0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x00, 0x00, 0xb2, 0x56,
        0x9c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xbe, 0xad, 0xde, 0x00, 0x00, 0x00, 0x00,
        0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::TestXUnionInTable {
            value: conformance::XUnionInTable {
                before: Some(String::from("before")),
                xu: Some(conformance::SampleXUnion::U(3735928559u32)),
                after: Some(String::from("after"))
            }
        }
    );
}

#[test]
fn test_strict_x_union_decode() {
    let value = &mut conformance::TestStrictXUnionInStruct::new_empty();
    let bytes = &mut [
        0x72, 0xea, 0xe2, 0x08, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xbe, 0xad, 0xde, 0x00, 0x00,
        0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::TestStrictXUnionInStruct {
            xu: conformance::SampleStrictXUnion::U(3735928559u32)
        }
    );
}

#[test]
fn test_add_ethernet_device_request_decode() {
    let value = &mut conformance::TestAddEthernetDeviceRequest::new_empty();
    let bytes = &mut [
        0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x40, 0x2f, 0x64,
        0x65, 0x76, 0x2f, 0x73, 0x79, 0x73, 0x2f, 0x70, 0x63, 0x69, 0x2f, 0x30, 0x30, 0x3a, 0x30,
        0x33, 0x2e, 0x30, 0x2f, 0x65, 0x31, 0x30, 0x30, 0x30, 0x2f, 0x65, 0x74, 0x68, 0x65, 0x72,
        0x6e, 0x65, 0x74, 0x00, 0x00, 0x00, 0x00, 0x65, 0x74, 0x68, 0x70, 0x30, 0x30, 0x30, 0x33,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::TestAddEthernetDeviceRequest {
            topological_path: String::from("@/dev/sys/pci/00:03.0/e1000/ethernet"),
            config: conformance::InterfaceConfig {
                name: String::from("ethp0003"),
                ip_address_config: conformance::IpAddressConfig::Dhcp(true)
            },
            this_should_be_a_handle: 4294967295u32
        }
    );
}

#[test]
fn test_file_get_attr_response_decode() {
    let value = &mut conformance::FileGetAttrResponse::new_empty();
    let bytes = &mut [
        0xaf, 0xbe, 0xad, 0x7e, 0x00, 0x00, 0x00, 0x00, 0xa4, 0x81, 0x23, 0x96, 0x00, 0x00, 0x00,
        0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe7, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xe7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc,
        0xdd, 0xee, 0xff, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::FileGetAttrResponse {
            s: 2125315759i32,
            attributes: conformance::NodeAttributes {
                mode: 2518909348u32,
                id: 1u64,
                content_size: 231u64,
                storage_size: 231u64,
                link_count: 1u64,
                creation_time: 9833440827789222417u64,
                modification_time: 72038755451251353u64
            }
        }
    );
}

#[test]
fn test_optionals_decode() {
    let value = &mut conformance::StructWithOptionals::new_empty();
    let bytes = &mut [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xfe, 0xe0, 0x99, 0x74, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xe0, 0x99, 0x74,
        0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::StructWithOptionals {
            s: conformance::EmptyStruct {},
            s2: Some(Box::new(conformance::EmptyStruct {})),
            t: conformance::TableWithEmptyStruct { s: Some(conformance::EmptyStruct {}) },
            xu: conformance::XUnionWithEmptyStruct::S(conformance::EmptyStruct {}),
            xu2: Some(Box::new(conformance::XUnionWithEmptyStruct::S(conformance::EmptyStruct {}))),
            u: conformance::UnionWithEmptyStruct::S(conformance::EmptyStruct {}),
            u2: Some(Box::new(conformance::UnionWithEmptyStruct::S(conformance::EmptyStruct {})))
        }
    );
}

#[test]
fn test_arrays_decode() {
    let value = &mut conformance::StructWithArrays::new_empty();
    let bytes = &mut [
        0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
        0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
        0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x03, 0x02, 0x01, 0x00, 0x00,
        0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::StructWithArrays {
            arr_int: [1i32, 2i32],
            arr_string: [String::from("a"), String::from("b")],
            arr_nullable_string: [Some(String::from("c")), None],
            arr_struct: [
                conformance::StructWithInt { x: 1i32 },
                conformance::StructWithInt { x: 2i32 }
            ],
            arr_nullable_struct: [
                None,
                Some(Box::new(conformance::StructWithInt { x: 16909060i32 }))
            ],
            arr_arr_int: [[1i32, 2i32, 3i32], [4i32, 5i32, 6i32]]
        }
    );
}

#[test]
fn test_vectors_decode() {
    let value = &mut conformance::StructWithVectors::new_empty();
    let bytes = &mut [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::StructWithVectors {
            vec_empty: vec![],
            vec_int: vec![1i32, 2i32],
            vec_string: vec![String::from("a"), String::from("b")],
            vec_nullable_string: vec![None, Some(String::from("c")), None],
            vec_struct: vec![conformance::StructWithInt { x: 1i32 }],
            vec_nullable_struct: vec![
                None,
                None,
                Some(Box::new(conformance::StructWithInt { x: 2i32 }))
            ],
            vec_vec_int: vec![vec![1i32, 2i32], vec![3i32]]
        }
    );
}

#[test]
fn test_bool_true_decode() {
    let value = &mut conformance::MyBool::new_empty();
    let bytes = &mut [0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyBool { value: true });
}

#[test]
fn test_bool_false_decode() {
    let value = &mut conformance::MyBool::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyBool { value: false });
}

#[test]
fn test_byte_zero_decode() {
    let value = &mut conformance::MyByte::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyByte { value: 0u8 });
}

#[test]
fn test_byte255_decode() {
    let value = &mut conformance::MyByte::new_empty();
    let bytes = &mut [0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyByte { value: 255u8 });
}

#[test]
fn test_int8_min_decode() {
    let value = &mut conformance::MyInt8::new_empty();
    let bytes = &mut [0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyInt8 { value: -128i8 });
}

#[test]
fn test_int8_zero_decode() {
    let value = &mut conformance::MyInt8::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyInt8 { value: 0i8 });
}

#[test]
fn test_int8_max_decode() {
    let value = &mut conformance::MyInt8::new_empty();
    let bytes = &mut [0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyInt8 { value: 127i8 });
}

#[test]
fn test_int16_min_decode() {
    let value = &mut conformance::MyInt16::new_empty();
    let bytes = &mut [0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyInt16 { value: -32768i16 });
}

#[test]
fn test_int16_zero_decode() {
    let value = &mut conformance::MyInt16::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyInt16 { value: 0i16 });
}

#[test]
fn test_int16_max_decode() {
    let value = &mut conformance::MyInt16::new_empty();
    let bytes = &mut [0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyInt16 { value: 32767i16 });
}

#[test]
fn test_int32_min_decode() {
    let value = &mut conformance::MyInt32::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyInt32 { value: -2147483648i32 });
}

#[test]
fn test_int32_zero_decode() {
    let value = &mut conformance::MyInt32::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyInt32 { value: 0i32 });
}

#[test]
fn test_int32_max_decode() {
    let value = &mut conformance::MyInt32::new_empty();
    let bytes = &mut [0xff, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyInt32 { value: 2147483647i32 });
}

#[test]
fn test_int64_min_decode() {
    let value = &mut conformance::MyInt64::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyInt64 { value: -9223372036854775808i64 });
}

#[test]
fn test_int64_zero_decode() {
    let value = &mut conformance::MyInt64::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyInt64 { value: 0i64 });
}

#[test]
fn test_int64_max_decode() {
    let value = &mut conformance::MyInt64::new_empty();
    let bytes = &mut [0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyInt64 { value: 9223372036854775807i64 });
}

#[test]
fn test_uint8_zero_decode() {
    let value = &mut conformance::MyUint8::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyUint8 { value: 0u8 });
}

#[test]
fn test_uint8_max_decode() {
    let value = &mut conformance::MyUint8::new_empty();
    let bytes = &mut [0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyUint8 { value: 255u8 });
}

#[test]
fn test_uint16_zero_decode() {
    let value = &mut conformance::MyUint16::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyUint16 { value: 0u16 });
}

#[test]
fn test_uint16_max_decode() {
    let value = &mut conformance::MyUint16::new_empty();
    let bytes = &mut [0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyUint16 { value: 65535u16 });
}

#[test]
fn test_uint32_zero_decode() {
    let value = &mut conformance::MyUint32::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyUint32 { value: 0u32 });
}

#[test]
fn test_uint32_max_decode() {
    let value = &mut conformance::MyUint32::new_empty();
    let bytes = &mut [0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyUint32 { value: 4294967295u32 });
}

#[test]
fn test_uint64_zero_decode() {
    let value = &mut conformance::MyUint64::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyUint64 { value: 0u64 });
}

#[test]
fn test_uint64_max_decode() {
    let value = &mut conformance::MyUint64::new_empty();
    let bytes = &mut [0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyUint64 { value: 18446744073709551615u64 });
}

#[test]
fn test_float32_zero_decode() {
    let value = &mut conformance::MyFloat32::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyFloat32 { value: 0f32 });
}

#[test]
fn test_float32_one_decode() {
    let value = &mut conformance::MyFloat32::new_empty();
    let bytes = &mut [0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyFloat32 { value: 1f32 });
}

#[test]
fn test_float32_minus_one_decode() {
    let value = &mut conformance::MyFloat32::new_empty();
    let bytes = &mut [0x00, 0x00, 0x80, 0xbf, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyFloat32 { value: -1f32 });
}

#[test]
fn test_float32_max_decode() {
    let value = &mut conformance::MyFloat32::new_empty();
    let bytes = &mut [0xff, 0xff, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyFloat32 { value: 3.4028234663852886e+38f32 });
}

#[test]
fn test_float64_zero_decode() {
    let value = &mut conformance::MyFloat64::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyFloat64 { value: 0f64 });
}

#[test]
fn test_float64_one_decode() {
    let value = &mut conformance::MyFloat64::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyFloat64 { value: 1f64 });
}

#[test]
fn test_float64_minus_one_decode() {
    let value = &mut conformance::MyFloat64::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xbf];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyFloat64 { value: -1f64 });
}

#[test]
fn test_float64_max_decode() {
    let value = &mut conformance::MyFloat64::new_empty();
    let bytes = &mut [0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0x7f];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyFloat64 { value: 1.7976931348623157e+308f64 });
}

#[test]
fn test_sandwich1_case1_decode() {
    let value = &mut conformance::Sandwich1::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x02, 0x00, 0x00, 0x00, 0x09, 0x0a, 0x0b, 0x0c, 0x05, 0x06, 0x07,
        0x08,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich1 {
            before: 67305985u32,
            the_union: conformance::UnionSize8Align4::Variant(202050057u32),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich1_case1_v1_decode() {
    let value = &mut conformance::Sandwich1::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x09, 0x0a, 0x0b, 0x0c, 0x00,
        0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich1 {
            before: 67305985u32,
            the_union: conformance::UnionSize8Align4::Variant(202050057u32),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich2_case1_decode() {
    let value = &mut conformance::Sandwich2::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x03, 0x00, 0x00, 0x00, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0x00,
        0x00, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich2 {
            before: 67305985u32,
            the_union: conformance::UnionSize12Align4::Variant([
                160u8, 161u8, 162u8, 163u8, 164u8, 165u8
            ]),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich2_case1_v1_decode() {
    let value = &mut conformance::Sandwich2::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4,
        0xa5, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich2 {
            before: 67305985u32,
            the_union: conformance::UnionSize12Align4::Variant([
                160u8, 161u8, 162u8, 163u8, 164u8, 165u8
            ]),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich3_case1_decode() {
    let value = &mut conformance::Sandwich3::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad,
        0xae, 0xaf, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich3 {
            before: 67305985u32,
            the_union: conformance::UnionSize24Align8::Variant(conformance::StructSize16Align8 {
                f1: 12080525177006498208u64,
                f2: 12659246559711111592u64
            }),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich3_case1_v1_decode() {
    let value = &mut conformance::Sandwich3::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4,
        0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich3 {
            before: 67305985u32,
            the_union: conformance::UnionSize24Align8::Variant(conformance::StructSize16Align8 {
                f1: 12080525177006498208u64,
                f2: 12659246559711111592u64
            }),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich4_case1_decode() {
    let value = &mut conformance::Sandwich4::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x03, 0x00, 0x00, 0x00, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6,
        0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5,
        0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0x05, 0x06, 0x07, 0x08, 0x00,
        0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich4 {
            before: 67305985u32,
            the_union: conformance::UnionSize36Align4::Variant([
                160u8, 161u8, 162u8, 163u8, 164u8, 165u8, 166u8, 167u8, 168u8, 169u8, 170u8, 171u8,
                172u8, 173u8, 174u8, 175u8, 176u8, 177u8, 178u8, 179u8, 180u8, 181u8, 182u8, 183u8,
                184u8, 185u8, 186u8, 187u8, 188u8, 189u8, 190u8, 191u8
            ]),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich4_case1_v1_decode() {
    let value = &mut conformance::Sandwich4::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4,
        0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3,
        0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich4 {
            before: 67305985u32,
            the_union: conformance::UnionSize36Align4::Variant([
                160u8, 161u8, 162u8, 163u8, 164u8, 165u8, 166u8, 167u8, 168u8, 169u8, 170u8, 171u8,
                172u8, 173u8, 174u8, 175u8, 176u8, 177u8, 178u8, 179u8, 180u8, 181u8, 182u8, 183u8,
                184u8, 185u8, 186u8, 187u8, 188u8, 189u8, 190u8, 191u8
            ]),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich5_case1_decode() {
    let value = &mut conformance::Sandwich5::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x02, 0x00, 0x00, 0x00, 0x09, 0x0a, 0x0b, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x06, 0x07, 0x08, 0x00,
        0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich5 {
            before: 67305985u32,
            union_of_union: conformance::UnionOfUnion::Size8align4(
                conformance::UnionSize8Align4::Variant(202050057u32)
            ),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich5_case1_v1_decode() {
    let value = &mut conformance::Sandwich5::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0x09, 0x0a, 0x0b, 0x0c, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich5 {
            before: 67305985u32,
            union_of_union: conformance::UnionOfUnion::Size8align4(
                conformance::UnionSize8Align4::Variant(202050057u32)
            ),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich5_case2_decode() {
    let value = &mut conformance::Sandwich5::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5,
        0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0x05, 0x06, 0x07, 0x08, 0x00,
        0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich5 {
            before: 67305985u32,
            union_of_union: conformance::UnionOfUnion::Size24align8(
                conformance::UnionSize24Align8::Variant(conformance::StructSize16Align8 {
                    f1: 12080525177006498208u64,
                    f2: 12659246559711111592u64
                })
            ),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich5_case2_v1_decode() {
    let value = &mut conformance::Sandwich5::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa,
        0xab, 0xac, 0xad, 0xae, 0xaf,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich5 {
            before: 67305985u32,
            union_of_union: conformance::UnionOfUnion::Size24align8(
                conformance::UnionSize24Align8::Variant(conformance::StructSize16Align8 {
                    f1: 12080525177006498208u64,
                    f2: 12659246559711111592u64
                })
            ),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich6_case1_decode() {
    let value = &mut conformance::Sandwich6::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4,
        0xa5, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich6 {
            before: 67305985u32,
            the_union: conformance::UnionWithVector::VectorOfUint8(vec![
                160u8, 161u8, 162u8, 163u8, 164u8, 165u8
            ]),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich6_case1_v1_decode() {
    let value = &mut conformance::Sandwich6::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa0, 0xa1, 0xa2, 0xa3,
        0xa4, 0xa5, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich6 {
            before: 67305985u32,
            the_union: conformance::UnionWithVector::VectorOfUint8(vec![
                160u8, 161u8, 162u8, 163u8, 164u8, 165u8
            ]),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich6_case1_absent_vector_decode() {
    let value = &mut conformance::Sandwich6::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich6 {
            before: 67305985u32,
            the_union: conformance::UnionWithVector::VectorOfUint8(vec![]),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich6_case1_absent_vector_v1_decode() {
    let value = &mut conformance::Sandwich6::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich6 {
            before: 67305985u32,
            the_union: conformance::UnionWithVector::VectorOfUint8(vec![]),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich6_case2_decode() {
    let value = &mut conformance::Sandwich6::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x73, 0x6f, 0x66, 0x74, 0x20,
        0x6d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x72, 0x6f, 0x63, 0x6b,
        0x21, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich6 {
            before: 67305985u32,
            the_union: conformance::UnionWithVector::S(String::from("soft migrations rock!")),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich6_case2_v1_decode() {
    let value = &mut conformance::Sandwich6::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x73, 0x6f, 0x66, 0x74,
        0x20, 0x6d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x72, 0x6f, 0x63,
        0x6b, 0x21, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich6 {
            before: 67305985u32,
            the_union: conformance::UnionWithVector::S(String::from("soft migrations rock!")),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich6_case3_decode() {
    let value = &mut conformance::Sandwich6::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x73, 0x6f, 0x66, 0x20, 0x6d,
        0x69, 0x72, 0x61, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich6 {
            before: 67305985u32,
            the_union: conformance::UnionWithVector::VectorS3A1(vec![
                conformance::StructSize3Align1 { three_bytes: [115u8, 111u8, 102u8] },
                conformance::StructSize3Align1 { three_bytes: [32u8, 109u8, 105u8] },
                conformance::StructSize3Align1 { three_bytes: [114u8, 97u8, 116u8] }
            ]),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich6_case3_v1_decode() {
    let value = &mut conformance::Sandwich6::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x73, 0x6f, 0x66, 0x20,
        0x6d, 0x69, 0x72, 0x61, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich6 {
            before: 67305985u32,
            the_union: conformance::UnionWithVector::VectorS3A1(vec![
                conformance::StructSize3Align1 { three_bytes: [115u8, 111u8, 102u8] },
                conformance::StructSize3Align1 { three_bytes: [32u8, 109u8, 105u8] },
                conformance::StructSize3Align1 { three_bytes: [114u8, 97u8, 116u8] }
            ]),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich6_case4_decode() {
    let value = &mut conformance::Sandwich6::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x73, 0x6f, 0x66, 0x00, 0x20,
        0x6d, 0x69, 0x00, 0x72, 0x61, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich6 {
            before: 67305985u32,
            the_union: conformance::UnionWithVector::VectorS3A2(vec![
                conformance::StructSize3Align2 { f1: 28531u16, f2: 102u8 },
                conformance::StructSize3Align2 { f1: 27936u16, f2: 105u8 },
                conformance::StructSize3Align2 { f1: 24946u16, f2: 116u8 }
            ]),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich6_case4_v1_decode() {
    let value = &mut conformance::Sandwich6::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x73, 0x6f, 0x66, 0x00,
        0x20, 0x6d, 0x69, 0x00, 0x72, 0x61, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich6 {
            before: 67305985u32,
            the_union: conformance::UnionWithVector::VectorS3A2(vec![
                conformance::StructSize3Align2 { f1: 28531u16, f2: 102u8 },
                conformance::StructSize3Align2 { f1: 27936u16, f2: 105u8 },
                conformance::StructSize3Align2 { f1: 24946u16, f2: 116u8 }
            ]),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich6_case5_decode() {
    let value = &mut conformance::Sandwich6::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich6 {
            before: 67305985u32,
            the_union: conformance::UnionWithVector::Handles(vec![
                4294967295u32,
                4294967295u32,
                4294967295u32
            ]),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich6_case5_v1_decode() {
    let value = &mut conformance::Sandwich6::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich6 {
            before: 67305985u32,
            the_union: conformance::UnionWithVector::Handles(vec![
                4294967295u32,
                4294967295u32,
                4294967295u32
            ]),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich6_case6_decode() {
    let value = &mut conformance::Sandwich6::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich6 {
            before: 67305985u32,
            the_union: conformance::UnionWithVector::ArrayS3A1([
                conformance::StructSize3Align1 { three_bytes: [161u8, 162u8, 163u8] },
                conformance::StructSize3Align1 { three_bytes: [164u8, 165u8, 166u8] }
            ]),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich6_case6_v1_decode() {
    let value = &mut conformance::Sandwich6::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5,
        0xa6, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich6 {
            before: 67305985u32,
            the_union: conformance::UnionWithVector::ArrayS3A1([
                conformance::StructSize3Align1 { three_bytes: [161u8, 162u8, 163u8] },
                conformance::StructSize3Align1 { three_bytes: [164u8, 165u8, 166u8] }
            ]),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich6_case7_decode() {
    let value = &mut conformance::Sandwich6::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xa1, 0xa2, 0xa3, 0x00, 0xa4, 0xa5, 0xa6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich6 {
            before: 67305985u32,
            the_union: conformance::UnionWithVector::ArrayS3A2([
                conformance::StructSize3Align2 { f1: 41633u16, f2: 163u8 },
                conformance::StructSize3Align2 { f1: 42404u16, f2: 166u8 }
            ]),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich6_case7_v1_decode() {
    let value = &mut conformance::Sandwich6::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0xa1, 0xa2, 0xa3, 0x00, 0xa4,
        0xa5, 0xa6, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich6 {
            before: 67305985u32,
            the_union: conformance::UnionWithVector::ArrayS3A2([
                conformance::StructSize3Align2 { f1: 41633u16, f2: 163u8 },
                conformance::StructSize3Align2 { f1: 42404u16, f2: 166u8 }
            ]),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich6_case8_decode() {
    let value = &mut conformance::Sandwich6::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x09,
        0x0a, 0x0b, 0x0c,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich6 {
            before: 67305985u32,
            the_union: conformance::UnionWithVector::VectorUnion(vec![
                conformance::UnionSize8Align4::Variant(202050057u32)
            ]),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich6_case8_v1_decode() {
    let value = &mut conformance::Sandwich6::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0x09, 0x0a, 0x0b, 0x0c, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich6 {
            before: 67305985u32,
            the_union: conformance::UnionWithVector::VectorUnion(vec![
                conformance::UnionSize8Align4::Variant(202050057u32)
            ]),
            after: 134678021u32
        }
    );
}

#[test]
fn test_table_struct_with_reserved_sandwich_decode() {
    let value = &mut conformance::TableStructWithReservedSandwichStruct::new_empty();
    let bytes = &mut [
        0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0x09, 0x0a, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x1a, 0x1b,
        0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::TableStructWithReservedSandwichStruct {
            table: conformance::TableStructWithReservedSandwich {
                s1: Some(conformance::StructSize3Align1 { three_bytes: [9u8, 10u8, 11u8] }),
                s2: Some(conformance::StructSize3Align1 { three_bytes: [25u8, 26u8, 27u8] })
            }
        }
    );
}

#[test]
fn test_table_struct_with_reserved_sandwich_v1_decode() {
    let value = &mut conformance::TableStructWithReservedSandwichStruct::new_empty();
    let bytes = &mut [
        0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0x09, 0x0a, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x1a, 0x1b,
        0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::TableStructWithReservedSandwichStruct {
            table: conformance::TableStructWithReservedSandwich {
                s1: Some(conformance::StructSize3Align1 { three_bytes: [9u8, 10u8, 11u8] }),
                s2: Some(conformance::StructSize3Align1 { three_bytes: [25u8, 26u8, 27u8] })
            }
        }
    );
}

#[test]
fn test_table_struct_with_uint32_sandwich_decode() {
    let value = &mut conformance::TableStructWithUint32SandwichStruct::new_empty();
    let bytes = &mut [
        0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x09, 0x0a,
        0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x1a, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
        0x0b, 0x0c, 0x0d, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::TableStructWithUint32SandwichStruct {
            table: conformance::TableStructWithUint32Sandwich {
                i: Some(67305985u32),
                s1: Some(conformance::StructSize3Align1 { three_bytes: [9u8, 10u8, 11u8] }),
                s2: Some(conformance::StructSize3Align1 { three_bytes: [25u8, 26u8, 27u8] }),
                i2: Some(218893066u32)
            }
        }
    );
}

#[test]
fn test_table_struct_with_uint32_sandwich_v1_decode() {
    let value = &mut conformance::TableStructWithUint32SandwichStruct::new_empty();
    let bytes = &mut [
        0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x09, 0x0a,
        0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x1a, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
        0x0b, 0x0c, 0x0d, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::TableStructWithUint32SandwichStruct {
            table: conformance::TableStructWithUint32Sandwich {
                i: Some(67305985u32),
                s1: Some(conformance::StructSize3Align1 { three_bytes: [9u8, 10u8, 11u8] }),
                s2: Some(conformance::StructSize3Align1 { three_bytes: [25u8, 26u8, 27u8] }),
                i2: Some(218893066u32)
            }
        }
    );
}

#[test]
fn test_table_union_with_vector_reserved_sandwich_decode() {
    let value = &mut conformance::TableUnionWithVectorReservedSandwichStruct::new_empty();
    let bytes = &mut [
        0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x68, 0x65, 0x6c,
        0x6c, 0x6f, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::TableUnionWithVectorReservedSandwichStruct {
            table: conformance::TableUnionWithVectorReservedSandwich {
                uv: Some(conformance::UnionWithVector::S(String::from("hello")))
            }
        }
    );
}

#[test]
fn test_table_union_with_vector_reserved_sandwich_v1_decode() {
    let value = &mut conformance::TableUnionWithVectorReservedSandwichStruct::new_empty();
    let bytes = &mut [
        0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x68, 0x65,
        0x6c, 0x6c, 0x6f, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::TableUnionWithVectorReservedSandwichStruct {
            table: conformance::TableUnionWithVectorReservedSandwich {
                uv: Some(conformance::UnionWithVector::S(String::from("hello")))
            }
        }
    );
}

#[test]
fn test_table_union_with_vector_struct_sandwich_decode() {
    let value = &mut conformance::TableUnionWithVectorStructSandwichStruct::new_empty();
    let bytes = &mut [
        0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0x01, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x00, 0x00, 0x00, 0x04,
        0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::TableUnionWithVectorStructSandwichStruct {
            table: conformance::TableUnionWithVectorStructSandwich {
                s1: Some(conformance::StructSize3Align1 { three_bytes: [1u8, 2u8, 3u8] }),
                uv: Some(conformance::UnionWithVector::S(String::from("hello"))),
                s2: Some(conformance::StructSize3Align1 { three_bytes: [4u8, 5u8, 6u8] })
            }
        }
    );
}

#[test]
fn test_table_union_with_vector_struct_sandwich_v1_decode() {
    let value = &mut conformance::TableUnionWithVectorStructSandwichStruct::new_empty();
    let bytes = &mut [
        0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0x01, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x00, 0x00, 0x00,
        0x04, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::TableUnionWithVectorStructSandwichStruct {
            table: conformance::TableUnionWithVectorStructSandwich {
                s1: Some(conformance::StructSize3Align1 { three_bytes: [1u8, 2u8, 3u8] }),
                uv: Some(conformance::UnionWithVector::S(String::from("hello"))),
                s2: Some(conformance::StructSize3Align1 { three_bytes: [4u8, 5u8, 6u8] })
            }
        }
    );
}

#[test]
fn test_x_union_with_struct_decode() {
    let value = &mut conformance::XUnionWithStructStruct::new_empty();
    let bytes = &mut [
        0x14, 0x5c, 0x3e, 0x19, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x02, 0x03, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::XUnionWithStructStruct {
            xu: conformance::XUnionWithStruct::S(conformance::StructSize3Align1 {
                three_bytes: [1u8, 2u8, 3u8]
            })
        }
    );
}

#[test]
fn test_x_union_with_struct_v1_decode() {
    let value = &mut conformance::XUnionWithStructStruct::new_empty();
    let bytes = &mut [
        0x14, 0x5c, 0x3e, 0x19, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x02, 0x03, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::XUnionWithStructStruct {
            xu: conformance::XUnionWithStruct::S(conformance::StructSize3Align1 {
                three_bytes: [1u8, 2u8, 3u8]
            })
        }
    );
}

#[test]
fn test_array_struct_decode() {
    let value = &mut conformance::ArrayStruct::new_empty();
    let bytes = &mut [
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x6f, 0x6e, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74,
        0x77, 0x6f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0x68, 0x72, 0x65, 0x65, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x66, 0x6f, 0x75, 0x72, 0x00, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x66, 0x69, 0x76, 0x65,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x73, 0x69,
        0x78, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::ArrayStruct {
            unions: [
                conformance::StringUnion::S(String::from("one")),
                conformance::StringUnion::S(String::from("two")),
                conformance::StringUnion::S(String::from("three"))
            ],
            optional_unions: [
                Some(Box::new(conformance::StringUnion::S(String::from("four")))),
                Some(Box::new(conformance::StringUnion::S(String::from("five")))),
                Some(Box::new(conformance::StringUnion::S(String::from("six"))))
            ]
        }
    );
}

#[test]
fn test_array_struct_v1_decode() {
    let value = &mut conformance::ArrayStruct::new_empty();
    let bytes = &mut [
        0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x6f, 0x6e, 0x65, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0x74, 0x77, 0x6f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x74, 0x68,
        0x72, 0x65, 0x65, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x66, 0x6f, 0x75, 0x72, 0x00, 0x00, 0x00, 0x00,
        0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x66, 0x69, 0x76, 0x65, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x73, 0x69, 0x78, 0x00, 0x00,
        0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::ArrayStruct {
            unions: [
                conformance::StringUnion::S(String::from("one")),
                conformance::StringUnion::S(String::from("two")),
                conformance::StringUnion::S(String::from("three"))
            ],
            optional_unions: [
                Some(Box::new(conformance::StringUnion::S(String::from("four")))),
                Some(Box::new(conformance::StringUnion::S(String::from("five")))),
                Some(Box::new(conformance::StringUnion::S(String::from("six"))))
            ]
        }
    );
}

#[test]
fn test_regression1_decode() {
    let value = &mut conformance::Regression1::new_empty();
    let bytes = &mut [
        0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Regression1 { f1: 1u8, f2: 2u32, f3: 3u8, f4: 4u16, f5: 5u64, f6: 6u8 }
    );
}

#[test]
fn test_regression1_v1_decode() {
    let value = &mut conformance::Regression1::new_empty();
    let bytes = &mut [
        0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Regression1 { f1: 1u8, f2: 2u32, f3: 3u8, f4: 4u16, f5: 5u64, f6: 6u8 }
    );
}

#[test]
fn test_regression2_decode() {
    let value = &mut conformance::Regression2::new_empty();
    let bytes = &mut [
        0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Regression2 {
            head: conformance::Regression1 {
                f1: 1u8,
                f2: 2u32,
                f3: 3u8,
                f4: 4u16,
                f5: 5u64,
                f6: 6u8
            },
            f7: 7u8
        }
    );
}

#[test]
fn test_regression2_v1_decode() {
    let value = &mut conformance::Regression2::new_empty();
    let bytes = &mut [
        0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Regression2 {
            head: conformance::Regression1 {
                f1: 1u8,
                f2: 2u32,
                f3: 3u8,
                f4: 4u16,
                f5: 5u64,
                f6: 6u8
            },
            f7: 7u8
        }
    );
}

#[test]
fn test_regression3_absent_decode() {
    let value = &mut conformance::Regression3::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::Regression3 { opt_value: None });
}

#[test]
fn test_regression3_absent_v1_decode() {
    let value = &mut conformance::Regression3::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::Regression3 { opt_value: None });
}

#[test]
fn test_regression3_present_decode() {
    let value = &mut conformance::Regression3::new_empty();
    let bytes = &mut [
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
        0x00, 0x03, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Regression3 {
            opt_value: Some(Box::new(conformance::Regression2 {
                head: conformance::Regression1 {
                    f1: 1u8,
                    f2: 2u32,
                    f3: 3u8,
                    f4: 4u16,
                    f5: 5u64,
                    f6: 6u8
                },
                f7: 7u8
            }))
        }
    );
}

#[test]
fn test_regression3_present_v1_decode() {
    let value = &mut conformance::Regression3::new_empty();
    let bytes = &mut [
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
        0x00, 0x03, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Regression3 {
            opt_value: Some(Box::new(conformance::Regression2 {
                head: conformance::Regression1 {
                    f1: 1u8,
                    f2: 2u32,
                    f3: 3u8,
                    f4: 4u16,
                    f5: 5u64,
                    f6: 6u8
                },
                f7: 7u8
            }))
        }
    );
}

#[test]
fn test_union_with_bound_string_decode() {
    let value = &mut conformance::UnionWithBoundStringStruct::new_empty();
    let bytes = &mut [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x61, 0x62, 0x63, 0x64, 0x00, 0x00,
        0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::UnionWithBoundStringStruct {
            v: conformance::UnionWithBoundString::BoundFiveStr(String::from("abcd"))
        }
    );
}

#[test]
fn test_union_migration_single_variant_decode() {
    let value = &mut conformance::SingleVariantUnionStruct::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x00, 0x00];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::SingleVariantUnionStruct { u: conformance::SingleVariantUnion::X(42u32) }
    );
}

#[test]
fn test_union_migration_single_variant_v1_decode() {
    let value = &mut conformance::SingleVariantUnionStruct::new_empty();
    let bytes = &mut [
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::SingleVariantUnionStruct { u: conformance::SingleVariantUnion::X(42u32) }
    );
}

#[test]
fn test_union_size8_alignment4_decode() {
    let value = &mut conformance::SandwichUnionSize8Alignment4::new_empty();
    let bytes = &mut [
        0x0a, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00,
        0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::SandwichUnionSize8Alignment4 {
            before: 10u32,
            value: conformance::UnionSize8Alignment4::Variant(4u32),
            after: 20u32
        }
    );
}

#[test]
fn test_union_size8_alignment4_v1_decode() {
    let value = &mut conformance::SandwichUnionSize8Alignment4::new_empty();
    let bytes = &mut [
        0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::SandwichUnionSize8Alignment4 {
            before: 10u32,
            value: conformance::UnionSize8Alignment4::Variant(4u32),
            after: 20u32
        }
    );
}

#[test]
fn test_union_size12_alignment4_decode() {
    let value = &mut conformance::SandwichUnionSize12Alignment4::new_empty();
    let bytes = &mut [
        0x0a, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x00,
        0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::SandwichUnionSize12Alignment4 {
            before: 10u32,
            value: conformance::UnionSize12Alignment4::Variant([1u8, 2u8, 3u8, 4u8, 5u8, 6u8]),
            after: 20u32
        }
    );
}

#[test]
fn test_union_size12_alignment4_v1_decode() {
    let value = &mut conformance::SandwichUnionSize12Alignment4::new_empty();
    let bytes = &mut [
        0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
        0x06, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::SandwichUnionSize12Alignment4 {
            before: 10u32,
            value: conformance::UnionSize12Alignment4::Variant([1u8, 2u8, 3u8, 4u8, 5u8, 6u8]),
            after: 20u32
        }
    );
}

#[test]
fn test_union_size24_alignment8_decode() {
    let value = &mut conformance::SandwichUnionSize24Alignment8::new_empty();
    let bytes = &mut [
        0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::SandwichUnionSize24Alignment8 {
            before: 10u32,
            value: conformance::UnionSize24Alignment8::Variant(
                conformance::StructSize16Alignment8 { f1: 1u64, f2: 2u64 }
            ),
            after: 20u32
        }
    );
}

#[test]
fn test_union_size24_alignment8_v1_decode() {
    let value = &mut conformance::SandwichUnionSize24Alignment8::new_empty();
    let bytes = &mut [
        0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::SandwichUnionSize24Alignment8 {
            before: 10u32,
            value: conformance::UnionSize24Alignment8::Variant(
                conformance::StructSize16Alignment8 { f1: 1u64, f2: 2u64 }
            ),
            after: 20u32
        }
    );
}

#[test]
fn test_union_size36_alignment4_decode() {
    let value = &mut conformance::SandwichUnionSize36Alignment4::new_empty();
    let bytes = &mut [
        0x0a, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,
        0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x14, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::SandwichUnionSize36Alignment4 {
            before: 10u32,
            value: conformance::UnionSize36Alignment4::Variant([
                1u8, 2u8, 3u8, 4u8, 5u8, 6u8, 7u8, 8u8, 9u8, 10u8, 11u8, 12u8, 13u8, 14u8, 15u8,
                16u8, 17u8, 18u8, 19u8, 20u8, 21u8, 22u8, 23u8, 24u8, 25u8, 26u8, 27u8, 28u8, 29u8,
                30u8, 31u8, 32u8
            ]),
            after: 20u32
        }
    );
}

#[test]
fn test_union_size36_alignment4_v1_decode() {
    let value = &mut conformance::SandwichUnionSize36Alignment4::new_empty();
    let bytes = &mut [
        0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
        0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14,
        0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::SandwichUnionSize36Alignment4 {
            before: 10u32,
            value: conformance::UnionSize36Alignment4::Variant([
                1u8, 2u8, 3u8, 4u8, 5u8, 6u8, 7u8, 8u8, 9u8, 10u8, 11u8, 12u8, 13u8, 14u8, 15u8,
                16u8, 17u8, 18u8, 19u8, 20u8, 21u8, 22u8, 23u8, 24u8, 25u8, 26u8, 27u8, 28u8, 29u8,
                30u8, 31u8, 32u8
            ]),
            after: 20u32
        }
    );
}

#[test]
fn test_non_empty_string_with_null_ptr_body_decode_failure() {
    let value = &mut conformance::StringWrapper::new_empty();
    let bytes = &mut [
        0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];
    match Decoder::decode_with_context(OLD_CONTEXT, bytes, &mut [], value) {
        Err(Error::UnexpectedNullRef { .. }) => (),
        Err(err) => panic!("unexpected error: {}", err),
        Ok(_) => panic!("unexpected successful decoding"),
    }
}

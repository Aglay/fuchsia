// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// Code generated by tools/fidl/gidl-conformance-suite/regen.sh; DO NOT EDIT.

use fidl::encoding::{Context, Decodable, Decoder, Encoder};
use fidl_conformance as conformance;

const V1_CONTEXT: &Context = &Context { unions_use_xunion_format: true };

#[test]
fn test_add_ethernet_device_request_v1_encode() {
    let value = &mut conformance::TestAddEthernetDeviceRequest {
        topological_path: String::from("@/dev/sys/pci/00:03.0/e1000/ethernet"),
        config: conformance::InterfaceConfig {
            name: String::from("ethp0003"),
            ip_address_config: conformance::IpAddressConfig::Dhcp(true),
        },
        this_should_be_a_handle: 4294967295u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x40, 0x2f, 0x64, 0x65, 0x76, 0x2f,
            0x73, 0x79, 0x73, 0x2f, 0x70, 0x63, 0x69, 0x2f, 0x30, 0x30, 0x3a, 0x30, 0x33, 0x2e,
            0x30, 0x2f, 0x65, 0x31, 0x30, 0x30, 0x30, 0x2f, 0x65, 0x74, 0x68, 0x65, 0x72, 0x6e,
            0x65, 0x74, 0x00, 0x00, 0x00, 0x00, 0x65, 0x74, 0x68, 0x70, 0x30, 0x30, 0x30, 0x33,
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_optionals_v1_encode() {
    let value = &mut conformance::StructWithOptionals {
        s: conformance::EmptyStruct {},
        s2: Some(Box::new(conformance::EmptyStruct {})),
        t: conformance::TableWithEmptyStruct { s: Some(conformance::EmptyStruct {}) },
        xu: conformance::XUnionWithEmptyStruct::S(conformance::EmptyStruct {}),
        xu2: Some(Box::new(conformance::XUnionWithEmptyStruct::S(conformance::EmptyStruct {}))),
        u: conformance::UnionWithEmptyStruct::S(conformance::EmptyStruct {}),
        u2: Some(Box::new(conformance::UnionWithEmptyStruct::S(conformance::EmptyStruct {}))),
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xfe, 0xe0, 0x99, 0x74, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xfe, 0xe0, 0x99, 0x74, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich1_case1_v1_encode() {
    let value = &mut conformance::Sandwich1 {
        before: 67305985u32,
        the_union: conformance::UnionSize8Align4::Variant(202050057u32),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x09, 0x0a,
            0x0b, 0x0c, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich1_with_opt_union_present_v1_encode() {
    let value = &mut conformance::Sandwich1WithOptUnion {
        before: 67305985u32,
        opt_union: Some(Box::new(conformance::UnionSize8Align4::Variant(202050057u32))),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x09, 0x0a,
            0x0b, 0x0c, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich1_with_opt_union_absent_v1_encode() {
    let value = &mut conformance::Sandwich1WithOptUnion {
        before: 67305985u32,
        after: 134678021u32,
        opt_union: None,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich2_case1_v1_encode() {
    let value = &mut conformance::Sandwich2 {
        before: 67305985u32,
        the_union: conformance::UnionSize12Align4::Variant([
            160u8, 161u8, 162u8, 163u8, 164u8, 165u8,
        ]),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0xa0, 0xa1,
            0xa2, 0xa3, 0xa4, 0xa5, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich3_case1_v1_encode() {
    let value = &mut conformance::Sandwich3 {
        before: 67305985u32,
        the_union: conformance::UnionSize24Align8::Variant(conformance::StructSize16Align8 {
            f1: 12080525177006498208u64,
            f2: 12659246559711111592u64,
        }),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0xa0, 0xa1,
            0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
        ][..]
    );
}

#[test]
fn test_sandwich4_case1_v1_encode() {
    let value = &mut conformance::Sandwich4 {
        before: 67305985u32,
        the_union: conformance::UnionSize36Align4::Variant([
            160u8, 161u8, 162u8, 163u8, 164u8, 165u8, 166u8, 167u8, 168u8, 169u8, 170u8, 171u8,
            172u8, 173u8, 174u8, 175u8, 176u8, 177u8, 178u8, 179u8, 180u8, 181u8, 182u8, 183u8,
            184u8, 185u8, 186u8, 187u8, 188u8, 189u8, 190u8, 191u8,
        ]),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0xa0, 0xa1,
            0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
            0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd,
            0xbe, 0xbf,
        ][..]
    );
}

#[test]
fn test_sandwich5_case1_v1_encode() {
    let value = &mut conformance::Sandwich5 {
        before: 67305985u32,
        union_of_union: conformance::UnionOfUnion::Size8align4(
            conformance::UnionSize8Align4::Variant(202050057u32),
        ),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x09, 0x0a, 0x0b, 0x0c, 0x00, 0x00,
            0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich5_case2_v1_encode() {
    let value = &mut conformance::Sandwich5 {
        before: 67305985u32,
        union_of_union: conformance::UnionOfUnion::Size24align8(
            conformance::UnionSize24Align8::Variant(conformance::StructSize16Align8 {
                f1: 12080525177006498208u64,
                f2: 12659246559711111592u64,
            }),
        ),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5,
            0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
        ][..]
    );
}

#[test]
fn test_sandwich6_case1_v1_encode() {
    let value = &mut conformance::Sandwich6 {
        before: 67305985u32,
        the_union: conformance::UnionWithVector::VectorOfUint8(vec![
            160u8, 161u8, 162u8, 163u8, 164u8, 165u8,
        ]),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich6_case1_absent_vector_v1_encode() {
    let value = &mut conformance::Sandwich6 {
        before: 67305985u32,
        the_union: conformance::UnionWithVector::VectorOfUint8(vec![]),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        ][..]
    );
}

#[test]
fn test_sandwich6_case2_v1_encode() {
    let value = &mut conformance::Sandwich6 {
        before: 67305985u32,
        the_union: conformance::UnionWithVector::S(String::from("soft migrations rock!")),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x73, 0x6f, 0x66, 0x74, 0x20, 0x6d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
            0x73, 0x20, 0x72, 0x6f, 0x63, 0x6b, 0x21, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich6_case3_v1_encode() {
    let value = &mut conformance::Sandwich6 {
        before: 67305985u32,
        the_union: conformance::UnionWithVector::VectorS3A1(vec![
            conformance::StructSize3Align1 { three_bytes: [115u8, 111u8, 102u8] },
            conformance::StructSize3Align1 { three_bytes: [32u8, 109u8, 105u8] },
            conformance::StructSize3Align1 { three_bytes: [114u8, 97u8, 116u8] },
        ]),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x73, 0x6f, 0x66, 0x20, 0x6d, 0x69, 0x72, 0x61, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich6_case4_v1_encode() {
    let value = &mut conformance::Sandwich6 {
        before: 67305985u32,
        the_union: conformance::UnionWithVector::VectorS3A2(vec![
            conformance::StructSize3Align2 { f1: 28531u16, f2: 102u8 },
            conformance::StructSize3Align2 { f1: 27936u16, f2: 105u8 },
            conformance::StructSize3Align2 { f1: 24946u16, f2: 116u8 },
        ]),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x73, 0x6f, 0x66, 0x00, 0x20, 0x6d, 0x69, 0x00, 0x72, 0x61, 0x74, 0x00, 0x00, 0x00,
            0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich6_case5_v1_encode() {
    let value = &mut conformance::Sandwich6 {
        before: 67305985u32,
        the_union: conformance::UnionWithVector::Handles(vec![
            4294967295u32,
            4294967295u32,
            4294967295u32,
        ]),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
            0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich6_case6_v1_encode() {
    let value = &mut conformance::Sandwich6 {
        before: 67305985u32,
        the_union: conformance::UnionWithVector::ArrayS3A1([
            conformance::StructSize3Align1 { three_bytes: [161u8, 162u8, 163u8] },
            conformance::StructSize3Align1 { three_bytes: [164u8, 165u8, 166u8] },
        ]),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0xa1, 0xa2,
            0xa3, 0xa4, 0xa5, 0xa6, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich6_case7_v1_encode() {
    let value = &mut conformance::Sandwich6 {
        before: 67305985u32,
        the_union: conformance::UnionWithVector::ArrayS3A2([
            conformance::StructSize3Align2 { f1: 41633u16, f2: 163u8 },
            conformance::StructSize3Align2 { f1: 42404u16, f2: 166u8 },
        ]),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0xa1, 0xa2,
            0xa3, 0x00, 0xa4, 0xa5, 0xa6, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich6_case8_v1_encode() {
    let value = &mut conformance::Sandwich6 {
        before: 67305985u32,
        the_union: conformance::UnionWithVector::VectorUnion(vec![
            conformance::UnionSize8Align4::Variant(202050057u32),
        ]),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x09, 0x0a, 0x0b, 0x0c,
            0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich7_case1_v1_encode() {
    let value = &mut conformance::Sandwich7 {
        before: 336794129u32,
        opt_sandwich1: Some(Box::new(conformance::Sandwich1 {
            before: 67305985u32,
            the_union: conformance::UnionSize8Align4::Variant(202050057u32),
            after: 134678021u32,
        })),
        after: 606282273u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x11, 0x12, 0x13, 0x14, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x21, 0x22, 0x23, 0x24, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04,
            0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x09, 0x0a, 0x0b, 0x0c, 0x00, 0x00,
            0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich7_case2_v1_encode() {
    let value = &mut conformance::Sandwich7 {
        before: 336794129u32,
        after: 606282273u32,
        opt_sandwich1: None,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x11, 0x12, 0x13, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x21, 0x22, 0x23, 0x24, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_regression1_v1_encode() {
    let value =
        &mut conformance::Regression1 { f1: 1u8, f2: 2u32, f3: 3u8, f4: 4u16, f5: 5u64, f6: 6u8 };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x04, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_regression2_v1_encode() {
    let value = &mut conformance::Regression2 {
        head: conformance::Regression1 { f1: 1u8, f2: 2u32, f3: 3u8, f4: 4u16, f5: 5u64, f6: 6u8 },
        f7: 7u8,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x04, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_regression3_absent_v1_encode() {
    let value = &mut conformance::Regression3 { opt_value: None };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_regression3_present_v1_encode() {
    let value = &mut conformance::Regression3 {
        opt_value: Some(Box::new(conformance::Regression2 {
            head: conformance::Regression1 {
                f1: 1u8,
                f2: 2u32,
                f3: 3u8,
                f4: 4u16,
                f5: 5u64,
                f6: 6u8,
            },
            f7: 7u8,
        })),
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00,
            0x00, 0x00, 0x03, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_size5_alignment1_array_v1_encode() {
    let value = &mut conformance::Size5Alignment1Array {
        a: [
            conformance::Size5Alignment1 { data: [1u8, 2u8, 3u8, 4u8, 5u8] },
            conformance::Size5Alignment1 { data: [6u8, 7u8, 8u8, 9u8, 10u8] },
            conformance::Size5Alignment1 { data: [11u8, 12u8, 13u8, 14u8, 15u8] },
        ],
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
            0x0f, 0x00,
        ][..]
    );
}

#[test]
fn test_size5_alignment4_array_v1_encode() {
    let value = &mut conformance::Size5Alignment4Array {
        a: [
            conformance::Size5Alignment4 { four: 67305985u32, one: 5u8 },
            conformance::Size5Alignment4 { four: 151521030u32, one: 10u8 },
            conformance::Size5Alignment4 { four: 235736075u32, one: 15u8 },
        ],
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0x00, 0x00, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x00,
            0x00, 0x00, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_size5_alignment1_vector_v1_encode() {
    let value = &mut conformance::Size5Alignment1Vector {
        v: vec![
            conformance::Size5Alignment1 { data: [1u8, 2u8, 3u8, 4u8, 5u8] },
            conformance::Size5Alignment1 { data: [6u8, 7u8, 8u8, 9u8, 10u8] },
        ],
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_size5_alignment4_vector_v1_encode() {
    let value = &mut conformance::Size5Alignment4Vector {
        v: vec![
            conformance::Size5Alignment4 { four: 67305985u32, one: 5u8 },
            conformance::Size5Alignment4 { four: 151521030u32, one: 10u8 },
        ],
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0x00, 0x00, 0x06, 0x07, 0x08, 0x09,
            0x0a, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_table_struct_with_reserved_sandwich_v1_encode() {
    let value = &mut conformance::TableStructWithReservedSandwichStruct {
        table: conformance::TableStructWithReservedSandwich {
            s1: Some(conformance::StructSize3Align1 { three_bytes: [9u8, 10u8, 11u8] }),
            s2: Some(conformance::StructSize3Align1 { three_bytes: [25u8, 26u8, 27u8] }),
        },
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x09, 0x0a, 0x0b, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x19, 0x1a, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_table_struct_with_uint32_sandwich_v1_encode() {
    let value = &mut conformance::TableStructWithUint32SandwichStruct {
        table: conformance::TableStructWithUint32Sandwich {
            i: Some(67305985u32),
            s1: Some(conformance::StructSize3Align1 { three_bytes: [9u8, 10u8, 11u8] }),
            s2: Some(conformance::StructSize3Align1 { three_bytes: [25u8, 26u8, 27u8] }),
            i2: Some(218893066u32),
        },
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x02, 0x03, 0x04,
            0x00, 0x00, 0x00, 0x00, 0x09, 0x0a, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x1a,
            0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_table_union_with_vector_reserved_sandwich_v1_encode() {
    let value = &mut conformance::TableUnionWithVectorReservedSandwichStruct {
        table: conformance::TableUnionWithVectorReservedSandwich {
            uv: Some(conformance::UnionWithVector::S(String::from("hello"))),
        },
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_table_union_with_vector_struct_sandwich_v1_encode() {
    let value = &mut conformance::TableUnionWithVectorStructSandwichStruct {
        table: conformance::TableUnionWithVectorStructSandwich {
            s1: Some(conformance::StructSize3Align1 { three_bytes: [1u8, 2u8, 3u8] }),
            uv: Some(conformance::UnionWithVector::S(String::from("hello"))),
            s2: Some(conformance::StructSize3Align1 { three_bytes: [4u8, 5u8, 6u8] }),
        },
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x02, 0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x00, 0x00, 0x00, 0x04, 0x05, 0x06, 0x00, 0x00, 0x00,
            0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_x_union_with_struct_v1_encode() {
    let value = &mut conformance::XUnionWithStructStruct {
        xu: conformance::XUnionWithStruct::S(conformance::StructSize3Align1 {
            three_bytes: [1u8, 2u8, 3u8],
        }),
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x14, 0x5c, 0x3e, 0x19, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x02, 0x03, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_array_struct_v1_encode() {
    let value = &mut conformance::ArrayStruct {
        unions: [
            conformance::StringUnion::S(String::from("one")),
            conformance::StringUnion::S(String::from("two")),
            conformance::StringUnion::S(String::from("three")),
        ],
        optional_unions: [
            Some(Box::new(conformance::StringUnion::S(String::from("four")))),
            Some(Box::new(conformance::StringUnion::S(String::from("five")))),
            Some(Box::new(conformance::StringUnion::S(String::from("six")))),
        ],
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x02, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x6f, 0x6e, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x74, 0x77, 0x6f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x74, 0x68,
            0x72, 0x65, 0x65, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x66, 0x6f, 0x75, 0x72, 0x00, 0x00,
            0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x66, 0x69, 0x76, 0x65, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x73, 0x69, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_transformer_empty_struct_v1_encode() {
    let value = &mut conformance::TransformerEmptyStruct {};
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_empty_struct_union_v1_encode() {
    let value = &mut conformance::EmptyStructUnionStruct {
        u: conformance::EmptyStructUnion::Es(conformance::TransformerEmptyStruct {}),
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_no_coding_tables_stressor_v1_encode() {
    let value = &mut conformance::NoCodingTablesStressor {
        f1: 1229782938247303441u64,
        f2: 2459565876494606882u64,
        u1: conformance::UnionSize36Align4::Variant([
            51u8, 51u8, 51u8, 51u8, 51u8, 51u8, 51u8, 51u8, 51u8, 51u8, 51u8, 51u8, 51u8, 51u8,
            51u8, 51u8, 51u8, 51u8, 51u8, 51u8, 51u8, 51u8, 51u8, 51u8, 51u8, 51u8, 51u8, 51u8,
            51u8, 51u8, 51u8, 51u8,
        ]),
        f3: 4919131752989213764u64,
        f4: 6148914691236517205u64,
        u2: conformance::UnionSize36Align4::Variant([
            102u8, 102u8, 102u8, 102u8, 102u8, 102u8, 102u8, 102u8, 102u8, 102u8, 102u8, 102u8,
            102u8, 102u8, 102u8, 102u8, 102u8, 102u8, 102u8, 102u8, 102u8, 102u8, 102u8, 102u8,
            102u8, 102u8, 102u8, 102u8, 102u8, 102u8, 102u8, 102u8,
        ]),
        f5: 8608480567731124087u64,
        f6: 9838263505978427528u64,
        u3: conformance::UnionSize36Align4::Variant([
            153u8, 153u8, 153u8, 153u8, 153u8, 153u8, 153u8, 153u8, 153u8, 153u8, 153u8, 153u8,
            153u8, 153u8, 153u8, 153u8, 153u8, 153u8, 153u8, 153u8, 153u8, 153u8, 153u8, 153u8,
            153u8, 153u8, 153u8, 153u8, 153u8, 153u8, 153u8, 153u8,
        ]),
        f7: 12297829382473034410u64,
        p1: Some(Box::new(conformance::Size8Align8 { data: 17216961135462248174u64 })),
        f8: 13527612320720337851u64,
        p2: Some(Box::new(conformance::Size8Align8 { data: 17216961135462248174u64 })),
        f9: 15987178197214944733u64,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
            0x22, 0x22, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x44, 0x44,
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
            0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x77, 0x77, 0x77, 0x77,
            0x77, 0x77, 0x77, 0x77, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x04, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
            0xaa, 0xaa, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbb, 0xbb, 0xbb, 0xbb,
            0xbb, 0xbb, 0xbb, 0xbb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdd, 0xdd,
            0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
            0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
            0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x66, 0x66, 0x66, 0x66,
            0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
            0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
            0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
            0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
            0x99, 0x99, 0x99, 0x99, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee,
            0xee, 0xee, 0xee, 0xee, 0xee, 0xee,
        ][..]
    );
}

#[test]
fn test_out_of_line_sandwich1_case1_v1_encode() {
    let value = &mut conformance::OutOfLineSandwich1 {
        before: String::from("soft migrations rock!"),
        v: vec![conformance::Sandwich1 {
            before: 67305985u32,
            the_union: conformance::UnionSize8Align4::Variant(202050057u32),
            after: 134678021u32,
        }],
        after: String::from("hard transitions suck!"),
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x6d, 0x69, 0x67,
            0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x72, 0x6f, 0x63, 0x6b, 0x21, 0x00,
            0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00,
            0x09, 0x0a, 0x0b, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x68, 0x61, 0x72, 0x64, 0x20, 0x74,
            0x72, 0x61, 0x6e, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x73, 0x75, 0x63,
            0x6b, 0x21, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_out_of_line_sandwich1_with_opt_union_present_v1_encode() {
    let value = &mut conformance::OutOfLineSandwich1WithOptUnion {
        before: String::from("soft migrations rock!"),
        v: vec![conformance::Sandwich1WithOptUnion {
            before: 67305985u32,
            opt_union: Some(Box::new(conformance::UnionSize8Align4::Variant(202050057u32))),
            after: 134678021u32,
        }],
        after: String::from("hard transitions suck!"),
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x6d, 0x69, 0x67,
            0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x72, 0x6f, 0x63, 0x6b, 0x21, 0x00,
            0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00,
            0x09, 0x0a, 0x0b, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x68, 0x61, 0x72, 0x64, 0x20, 0x74,
            0x72, 0x61, 0x6e, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x73, 0x75, 0x63,
            0x6b, 0x21, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_out_of_line_sandwich1_with_opt_union_absent_v1_encode() {
    let value = &mut conformance::OutOfLineSandwich1WithOptUnion {
        before: String::from("soft migrations rock!"),
        v: vec![conformance::Sandwich1WithOptUnion {
            before: 67305985u32,
            after: 134678021u32,
            opt_union: None,
        }],
        after: String::from("hard transitions suck!"),
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x6d, 0x69, 0x67,
            0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x72, 0x6f, 0x63, 0x6b, 0x21, 0x00,
            0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00,
            0x68, 0x61, 0x72, 0x64, 0x20, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x69, 0x74, 0x69, 0x6f,
            0x6e, 0x73, 0x20, 0x73, 0x75, 0x63, 0x6b, 0x21, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_regression4_v1_encode() {
    let value = &mut conformance::Regression4 {
        f1: 1u8,
        f2: 2u32,
        s1: conformance::StructSize3Align1 { three_bytes: [9u8, 10u8, 11u8] },
        f3: 3u8,
        f4: 4u16,
        f5: 5u64,
        f6: 6u8,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x09, 0x0a, 0x0b, 0x03, 0x04, 0x00,
            0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich4_align8_v1_encode() {
    let value = &mut conformance::Sandwich4Align8 {
        sandwich4: conformance::Sandwich4 {
            before: 67305985u32,
            the_union: conformance::UnionSize36Align4::Variant([
                160u8, 161u8, 162u8, 163u8, 164u8, 165u8, 166u8, 167u8, 168u8, 169u8, 170u8, 171u8,
                172u8, 173u8, 174u8, 175u8, 176u8, 177u8, 178u8, 179u8, 180u8, 181u8, 182u8, 183u8,
                184u8, 185u8, 186u8, 187u8, 188u8, 189u8, 190u8, 191u8,
            ]),
            after: 134678021u32,
        },
        alignment8_enforcement: 1157159078456920585u64,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x09, 0x0a,
            0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
            0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5,
            0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
        ][..]
    );
}

#[test]
fn test_sandwich4_align8_with_pointer_v1_encode() {
    let value = &mut conformance::Sandwich4Align8WithPointer {
        sandwich4: conformance::Sandwich4 {
            before: 67305985u32,
            the_union: conformance::UnionSize36Align4::Variant([
                160u8, 161u8, 162u8, 163u8, 164u8, 165u8, 166u8, 167u8, 168u8, 169u8, 170u8, 171u8,
                172u8, 173u8, 174u8, 175u8, 176u8, 177u8, 178u8, 179u8, 180u8, 181u8, 182u8, 183u8,
                184u8, 185u8, 186u8, 187u8, 188u8, 189u8, 190u8, 191u8,
            ]),
            after: 134678021u32,
        },
        alignment8_enforcement: Some(Box::new(conformance::Size8Align8 {
            data: 1157159078456920585u64,
        })),
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
            0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5,
            0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0x09, 0x0a, 0x0b, 0x0c,
            0x0d, 0x0e, 0x0f, 0x10,
        ][..]
    );
}

#[test]
fn test_sandwich8_case1_v1_encode() {
    let value = &mut conformance::Sandwich8 {
        before: 67305985u64,
        union_of_union: conformance::UnionOfUnion::Size8align4(
            conformance::UnionSize8Align4::Variant(202050057u32),
        ),
        after: 134678021u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x09, 0x0a, 0x0b, 0x0c, 0x00, 0x00,
            0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_sandwich9_case1_v1_encode() {
    let value = &mut conformance::Sandwich9 {
        before: 513u16,
        the_union: conformance::UnionWithVectorOfVectors::V(vec![vec![
            Some(Box::new(conformance::StructSize3Align1 { three_bytes: [16u8, 17u8, 18u8] })),
            Some(Box::new(conformance::StructSize3Align1 { three_bytes: [19u8, 20u8, 21u8] })),
        ]]),
        after: 4625u16,
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x11, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x10, 0x11, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x14,
            0x15, 0x00, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_simple_table_array_struct_v1_encode() {
    let value = &mut conformance::SimpleTableArrayStruct {
        the_array: [
            conformance::TransformerSimpleTable { value: Some(2745344416u32) },
            conformance::TransformerSimpleTable { value: Some(3014832560u32) },
        ],
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa0, 0xa1, 0xa2, 0xa3, 0x00, 0x00, 0x00, 0x00,
            0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xb0, 0xb1, 0xb2, 0xb3, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_string_union_vector_v1_encode() {
    let value = &mut conformance::StringUnionVector {
        the_vector: vec![
            Some(Box::new(conformance::StringUnion::S(String::from("hello")))),
            Some(Box::new(conformance::StringUnion::U8(170u8))),
            Some(Box::new(conformance::StringUnion::U8(187u8))),
        ],
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x00, 0x00, 0x00,
            0xaa, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbb, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_create_component_request_v1_encode() {
    let value = &mut conformance::CreateComponentRequest { launch_info: conformance::LaunchInfo { url: String::from("fuchsia-pkg://fuchsia.com/fidl_compatibility_test_server_rust_write_xunion#meta/fidl_compatibility_test_server_rust_write_xunion.cmx"), directory_request: 4294967295u32, arguments: None, out: None, err: None, flat_namespace: None, additional_services: None }, controller: 4294967295u32 };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x66, 0x75, 0x63, 0x68,
            0x73, 0x69, 0x61, 0x2d, 0x70, 0x6b, 0x67, 0x3a, 0x2f, 0x2f, 0x66, 0x75, 0x63, 0x68,
            0x73, 0x69, 0x61, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x66, 0x69, 0x64, 0x6c, 0x5f, 0x63,
            0x6f, 0x6d, 0x70, 0x61, 0x74, 0x69, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x5f, 0x74,
            0x65, 0x73, 0x74, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5f, 0x72, 0x75, 0x73,
            0x74, 0x5f, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x78, 0x75, 0x6e, 0x69, 0x6f, 0x6e,
            0x23, 0x6d, 0x65, 0x74, 0x61, 0x2f, 0x66, 0x69, 0x64, 0x6c, 0x5f, 0x63, 0x6f, 0x6d,
            0x70, 0x61, 0x74, 0x69, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x5f, 0x74, 0x65, 0x73,
            0x74, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5f, 0x72, 0x75, 0x73, 0x74, 0x5f,
            0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x78, 0x75, 0x6e, 0x69, 0x6f, 0x6e, 0x2e, 0x63,
            0x6d, 0x78, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_union_with_bound_string_v1_encode() {
    let value = &mut conformance::UnionWithBoundStringStruct {
        v: conformance::UnionWithBoundString::BoundFiveStr(String::from("abcd")),
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x04, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x61, 0x62,
            0x63, 0x64, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_union_migration_single_variant_v1_encode() {
    let value =
        &mut conformance::SingleVariantUnionStruct { u: conformance::SingleVariantUnion::X(42u32) };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2a, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_reverse_ordinal_union_v1_encode() {
    let value = &mut conformance::ReverseOrdinalUnionStruct {
        u: conformance::ReverseOrdinalUnion::X(42i64),
    };
    let bytes = &mut Vec::new();
    Encoder::encode_with_context(V1_CONTEXT, bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2a, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_add_ethernet_device_request_v1_decode() {
    let value = &mut conformance::TestAddEthernetDeviceRequest::new_empty();
    let bytes = &mut [
        0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x40, 0x2f, 0x64, 0x65, 0x76, 0x2f, 0x73, 0x79, 0x73, 0x2f, 0x70,
        0x63, 0x69, 0x2f, 0x30, 0x30, 0x3a, 0x30, 0x33, 0x2e, 0x30, 0x2f, 0x65, 0x31, 0x30, 0x30,
        0x30, 0x2f, 0x65, 0x74, 0x68, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x00, 0x00, 0x00, 0x00, 0x65,
        0x74, 0x68, 0x70, 0x30, 0x30, 0x30, 0x33, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::TestAddEthernetDeviceRequest {
            topological_path: String::from("@/dev/sys/pci/00:03.0/e1000/ethernet"),
            config: conformance::InterfaceConfig {
                name: String::from("ethp0003"),
                ip_address_config: conformance::IpAddressConfig::Dhcp(true)
            },
            this_should_be_a_handle: 4294967295u32
        }
    );
}

#[test]
fn test_optionals_v1_decode() {
    let value = &mut conformance::StructWithOptionals::new_empty();
    let bytes = &mut [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xfe, 0xe0, 0x99, 0x74, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xe0, 0x99, 0x74,
        0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::StructWithOptionals {
            s: conformance::EmptyStruct {},
            s2: Some(Box::new(conformance::EmptyStruct {})),
            t: conformance::TableWithEmptyStruct { s: Some(conformance::EmptyStruct {}) },
            xu: conformance::XUnionWithEmptyStruct::S(conformance::EmptyStruct {}),
            xu2: Some(Box::new(conformance::XUnionWithEmptyStruct::S(conformance::EmptyStruct {}))),
            u: conformance::UnionWithEmptyStruct::S(conformance::EmptyStruct {}),
            u2: Some(Box::new(conformance::UnionWithEmptyStruct::S(conformance::EmptyStruct {})))
        }
    );
}

#[test]
fn test_sandwich1_case1_v1_decode() {
    let value = &mut conformance::Sandwich1::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x09, 0x0a, 0x0b, 0x0c, 0x00,
        0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich1 {
            before: 67305985u32,
            the_union: conformance::UnionSize8Align4::Variant(202050057u32),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich1_with_opt_union_present_v1_decode() {
    let value = &mut conformance::Sandwich1WithOptUnion::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x09, 0x0a, 0x0b, 0x0c, 0x00,
        0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich1WithOptUnion {
            before: 67305985u32,
            opt_union: Some(Box::new(conformance::UnionSize8Align4::Variant(202050057u32))),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich1_with_opt_union_absent_v1_decode() {
    let value = &mut conformance::Sandwich1WithOptUnion::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich1WithOptUnion {
            before: 67305985u32,
            after: 134678021u32,
            opt_union: None
        }
    );
}

#[test]
fn test_sandwich2_case1_v1_decode() {
    let value = &mut conformance::Sandwich2::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4,
        0xa5, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich2 {
            before: 67305985u32,
            the_union: conformance::UnionSize12Align4::Variant([
                160u8, 161u8, 162u8, 163u8, 164u8, 165u8
            ]),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich3_case1_v1_decode() {
    let value = &mut conformance::Sandwich3::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4,
        0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich3 {
            before: 67305985u32,
            the_union: conformance::UnionSize24Align8::Variant(conformance::StructSize16Align8 {
                f1: 12080525177006498208u64,
                f2: 12659246559711111592u64
            }),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich4_case1_v1_decode() {
    let value = &mut conformance::Sandwich4::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4,
        0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3,
        0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich4 {
            before: 67305985u32,
            the_union: conformance::UnionSize36Align4::Variant([
                160u8, 161u8, 162u8, 163u8, 164u8, 165u8, 166u8, 167u8, 168u8, 169u8, 170u8, 171u8,
                172u8, 173u8, 174u8, 175u8, 176u8, 177u8, 178u8, 179u8, 180u8, 181u8, 182u8, 183u8,
                184u8, 185u8, 186u8, 187u8, 188u8, 189u8, 190u8, 191u8
            ]),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich5_case1_v1_decode() {
    let value = &mut conformance::Sandwich5::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0x09, 0x0a, 0x0b, 0x0c, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich5 {
            before: 67305985u32,
            union_of_union: conformance::UnionOfUnion::Size8align4(
                conformance::UnionSize8Align4::Variant(202050057u32)
            ),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich5_case2_v1_decode() {
    let value = &mut conformance::Sandwich5::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa,
        0xab, 0xac, 0xad, 0xae, 0xaf,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich5 {
            before: 67305985u32,
            union_of_union: conformance::UnionOfUnion::Size24align8(
                conformance::UnionSize24Align8::Variant(conformance::StructSize16Align8 {
                    f1: 12080525177006498208u64,
                    f2: 12659246559711111592u64
                })
            ),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich6_case1_v1_decode() {
    let value = &mut conformance::Sandwich6::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa0, 0xa1, 0xa2, 0xa3,
        0xa4, 0xa5, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich6 {
            before: 67305985u32,
            the_union: conformance::UnionWithVector::VectorOfUint8(vec![
                160u8, 161u8, 162u8, 163u8, 164u8, 165u8
            ]),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich6_case1_absent_vector_v1_decode() {
    let value = &mut conformance::Sandwich6::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich6 {
            before: 67305985u32,
            the_union: conformance::UnionWithVector::VectorOfUint8(vec![]),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich6_case2_v1_decode() {
    let value = &mut conformance::Sandwich6::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x73, 0x6f, 0x66, 0x74,
        0x20, 0x6d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x72, 0x6f, 0x63,
        0x6b, 0x21, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich6 {
            before: 67305985u32,
            the_union: conformance::UnionWithVector::S(String::from("soft migrations rock!")),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich6_case3_v1_decode() {
    let value = &mut conformance::Sandwich6::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x73, 0x6f, 0x66, 0x20,
        0x6d, 0x69, 0x72, 0x61, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich6 {
            before: 67305985u32,
            the_union: conformance::UnionWithVector::VectorS3A1(vec![
                conformance::StructSize3Align1 { three_bytes: [115u8, 111u8, 102u8] },
                conformance::StructSize3Align1 { three_bytes: [32u8, 109u8, 105u8] },
                conformance::StructSize3Align1 { three_bytes: [114u8, 97u8, 116u8] }
            ]),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich6_case4_v1_decode() {
    let value = &mut conformance::Sandwich6::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x73, 0x6f, 0x66, 0x00,
        0x20, 0x6d, 0x69, 0x00, 0x72, 0x61, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich6 {
            before: 67305985u32,
            the_union: conformance::UnionWithVector::VectorS3A2(vec![
                conformance::StructSize3Align2 { f1: 28531u16, f2: 102u8 },
                conformance::StructSize3Align2 { f1: 27936u16, f2: 105u8 },
                conformance::StructSize3Align2 { f1: 24946u16, f2: 116u8 }
            ]),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich6_case5_v1_decode() {
    let value = &mut conformance::Sandwich6::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich6 {
            before: 67305985u32,
            the_union: conformance::UnionWithVector::Handles(vec![
                4294967295u32,
                4294967295u32,
                4294967295u32
            ]),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich6_case6_v1_decode() {
    let value = &mut conformance::Sandwich6::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5,
        0xa6, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich6 {
            before: 67305985u32,
            the_union: conformance::UnionWithVector::ArrayS3A1([
                conformance::StructSize3Align1 { three_bytes: [161u8, 162u8, 163u8] },
                conformance::StructSize3Align1 { three_bytes: [164u8, 165u8, 166u8] }
            ]),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich6_case7_v1_decode() {
    let value = &mut conformance::Sandwich6::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0xa1, 0xa2, 0xa3, 0x00, 0xa4,
        0xa5, 0xa6, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich6 {
            before: 67305985u32,
            the_union: conformance::UnionWithVector::ArrayS3A2([
                conformance::StructSize3Align2 { f1: 41633u16, f2: 163u8 },
                conformance::StructSize3Align2 { f1: 42404u16, f2: 166u8 }
            ]),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich6_case8_v1_decode() {
    let value = &mut conformance::Sandwich6::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0x09, 0x0a, 0x0b, 0x0c, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich6 {
            before: 67305985u32,
            the_union: conformance::UnionWithVector::VectorUnion(vec![
                conformance::UnionSize8Align4::Variant(202050057u32)
            ]),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich7_case1_v1_decode() {
    let value = &mut conformance::Sandwich7::new_empty();
    let bytes = &mut [
        0x11, 0x12, 0x13, 0x14, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x21, 0x22, 0x23, 0x24, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x00, 0x00,
        0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07, 0x08,
        0x00, 0x00, 0x00, 0x00, 0x09, 0x0a, 0x0b, 0x0c, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich7 {
            before: 336794129u32,
            opt_sandwich1: Some(Box::new(conformance::Sandwich1 {
                before: 67305985u32,
                the_union: conformance::UnionSize8Align4::Variant(202050057u32),
                after: 134678021u32
            })),
            after: 606282273u32
        }
    );
}

#[test]
fn test_sandwich7_case2_v1_decode() {
    let value = &mut conformance::Sandwich7::new_empty();
    let bytes = &mut [
        0x11, 0x12, 0x13, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x21, 0x22, 0x23, 0x24, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich7 { before: 336794129u32, after: 606282273u32, opt_sandwich1: None }
    );
}

#[test]
fn test_regression1_v1_decode() {
    let value = &mut conformance::Regression1::new_empty();
    let bytes = &mut [
        0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Regression1 { f1: 1u8, f2: 2u32, f3: 3u8, f4: 4u16, f5: 5u64, f6: 6u8 }
    );
}

#[test]
fn test_regression2_v1_decode() {
    let value = &mut conformance::Regression2::new_empty();
    let bytes = &mut [
        0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Regression2 {
            head: conformance::Regression1 {
                f1: 1u8,
                f2: 2u32,
                f3: 3u8,
                f4: 4u16,
                f5: 5u64,
                f6: 6u8
            },
            f7: 7u8
        }
    );
}

#[test]
fn test_regression3_absent_v1_decode() {
    let value = &mut conformance::Regression3::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::Regression3 { opt_value: None });
}

#[test]
fn test_regression3_present_v1_decode() {
    let value = &mut conformance::Regression3::new_empty();
    let bytes = &mut [
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
        0x00, 0x03, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Regression3 {
            opt_value: Some(Box::new(conformance::Regression2 {
                head: conformance::Regression1 {
                    f1: 1u8,
                    f2: 2u32,
                    f3: 3u8,
                    f4: 4u16,
                    f5: 5u64,
                    f6: 6u8
                },
                f7: 7u8
            }))
        }
    );
}

#[test]
fn test_size5_alignment1_array_v1_decode() {
    let value = &mut conformance::Size5Alignment1Array::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
        0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Size5Alignment1Array {
            a: [
                conformance::Size5Alignment1 { data: [1u8, 2u8, 3u8, 4u8, 5u8] },
                conformance::Size5Alignment1 { data: [6u8, 7u8, 8u8, 9u8, 10u8] },
                conformance::Size5Alignment1 { data: [11u8, 12u8, 13u8, 14u8, 15u8] }
            ]
        }
    );
}

#[test]
fn test_size5_alignment4_array_v1_decode() {
    let value = &mut conformance::Size5Alignment4Array::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0x00, 0x00, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x00, 0x00,
        0x00, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Size5Alignment4Array {
            a: [
                conformance::Size5Alignment4 { four: 67305985u32, one: 5u8 },
                conformance::Size5Alignment4 { four: 151521030u32, one: 10u8 },
                conformance::Size5Alignment4 { four: 235736075u32, one: 15u8 }
            ]
        }
    );
}

#[test]
fn test_size5_alignment1_vector_v1_decode() {
    let value = &mut conformance::Size5Alignment1Vector::new_empty();
    let bytes = &mut [
        0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Size5Alignment1Vector {
            v: vec![
                conformance::Size5Alignment1 { data: [1u8, 2u8, 3u8, 4u8, 5u8] },
                conformance::Size5Alignment1 { data: [6u8, 7u8, 8u8, 9u8, 10u8] }
            ]
        }
    );
}

#[test]
fn test_size5_alignment4_vector_v1_decode() {
    let value = &mut conformance::Size5Alignment4Vector::new_empty();
    let bytes = &mut [
        0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0x00, 0x00, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x00,
        0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Size5Alignment4Vector {
            v: vec![
                conformance::Size5Alignment4 { four: 67305985u32, one: 5u8 },
                conformance::Size5Alignment4 { four: 151521030u32, one: 10u8 }
            ]
        }
    );
}

#[test]
fn test_table_struct_with_reserved_sandwich_v1_decode() {
    let value = &mut conformance::TableStructWithReservedSandwichStruct::new_empty();
    let bytes = &mut [
        0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0x09, 0x0a, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x1a, 0x1b,
        0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::TableStructWithReservedSandwichStruct {
            table: conformance::TableStructWithReservedSandwich {
                s1: Some(conformance::StructSize3Align1 { three_bytes: [9u8, 10u8, 11u8] }),
                s2: Some(conformance::StructSize3Align1 { three_bytes: [25u8, 26u8, 27u8] })
            }
        }
    );
}

#[test]
fn test_table_struct_with_uint32_sandwich_v1_decode() {
    let value = &mut conformance::TableStructWithUint32SandwichStruct::new_empty();
    let bytes = &mut [
        0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x09, 0x0a,
        0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x1a, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
        0x0b, 0x0c, 0x0d, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::TableStructWithUint32SandwichStruct {
            table: conformance::TableStructWithUint32Sandwich {
                i: Some(67305985u32),
                s1: Some(conformance::StructSize3Align1 { three_bytes: [9u8, 10u8, 11u8] }),
                s2: Some(conformance::StructSize3Align1 { three_bytes: [25u8, 26u8, 27u8] }),
                i2: Some(218893066u32)
            }
        }
    );
}

#[test]
fn test_table_union_with_vector_reserved_sandwich_v1_decode() {
    let value = &mut conformance::TableUnionWithVectorReservedSandwichStruct::new_empty();
    let bytes = &mut [
        0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x68, 0x65,
        0x6c, 0x6c, 0x6f, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::TableUnionWithVectorReservedSandwichStruct {
            table: conformance::TableUnionWithVectorReservedSandwich {
                uv: Some(conformance::UnionWithVector::S(String::from("hello")))
            }
        }
    );
}

#[test]
fn test_table_union_with_vector_struct_sandwich_v1_decode() {
    let value = &mut conformance::TableUnionWithVectorStructSandwichStruct::new_empty();
    let bytes = &mut [
        0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0x01, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x00, 0x00, 0x00,
        0x04, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::TableUnionWithVectorStructSandwichStruct {
            table: conformance::TableUnionWithVectorStructSandwich {
                s1: Some(conformance::StructSize3Align1 { three_bytes: [1u8, 2u8, 3u8] }),
                uv: Some(conformance::UnionWithVector::S(String::from("hello"))),
                s2: Some(conformance::StructSize3Align1 { three_bytes: [4u8, 5u8, 6u8] })
            }
        }
    );
}

#[test]
fn test_x_union_with_struct_v1_decode() {
    let value = &mut conformance::XUnionWithStructStruct::new_empty();
    let bytes = &mut [
        0x14, 0x5c, 0x3e, 0x19, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x02, 0x03, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::XUnionWithStructStruct {
            xu: conformance::XUnionWithStruct::S(conformance::StructSize3Align1 {
                three_bytes: [1u8, 2u8, 3u8]
            })
        }
    );
}

#[test]
fn test_array_struct_v1_decode() {
    let value = &mut conformance::ArrayStruct::new_empty();
    let bytes = &mut [
        0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x6f, 0x6e, 0x65, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0x74, 0x77, 0x6f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x74, 0x68,
        0x72, 0x65, 0x65, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x66, 0x6f, 0x75, 0x72, 0x00, 0x00, 0x00, 0x00,
        0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x66, 0x69, 0x76, 0x65, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x73, 0x69, 0x78, 0x00, 0x00,
        0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::ArrayStruct {
            unions: [
                conformance::StringUnion::S(String::from("one")),
                conformance::StringUnion::S(String::from("two")),
                conformance::StringUnion::S(String::from("three"))
            ],
            optional_unions: [
                Some(Box::new(conformance::StringUnion::S(String::from("four")))),
                Some(Box::new(conformance::StringUnion::S(String::from("five")))),
                Some(Box::new(conformance::StringUnion::S(String::from("six"))))
            ]
        }
    );
}

#[test]
fn test_transformer_empty_struct_v1_decode() {
    let value = &mut conformance::TransformerEmptyStruct::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::TransformerEmptyStruct {});
}

#[test]
fn test_empty_struct_union_v1_decode() {
    let value = &mut conformance::EmptyStructUnionStruct::new_empty();
    let bytes = &mut [
        0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::EmptyStructUnionStruct {
            u: conformance::EmptyStructUnion::Es(conformance::TransformerEmptyStruct {})
        }
    );
}

#[test]
fn test_no_coding_tables_stressor_v1_decode() {
    let value = &mut conformance::NoCodingTablesStressor::new_empty();
    let bytes = &mut [
        0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
        0x22, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x44, 0x44, 0x44, 0x44, 0x44,
        0x44, 0x44, 0x44, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x04, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x88, 0x88,
        0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0x33, 0x33, 0x33, 0x33, 0x33,
        0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
        0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x66, 0x66, 0x66,
        0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
        0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x99,
        0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
        0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
        0x99, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee,
        0xee, 0xee,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::NoCodingTablesStressor {
            f1: 1229782938247303441u64,
            f2: 2459565876494606882u64,
            u1: conformance::UnionSize36Align4::Variant([
                51u8, 51u8, 51u8, 51u8, 51u8, 51u8, 51u8, 51u8, 51u8, 51u8, 51u8, 51u8, 51u8, 51u8,
                51u8, 51u8, 51u8, 51u8, 51u8, 51u8, 51u8, 51u8, 51u8, 51u8, 51u8, 51u8, 51u8, 51u8,
                51u8, 51u8, 51u8, 51u8
            ]),
            f3: 4919131752989213764u64,
            f4: 6148914691236517205u64,
            u2: conformance::UnionSize36Align4::Variant([
                102u8, 102u8, 102u8, 102u8, 102u8, 102u8, 102u8, 102u8, 102u8, 102u8, 102u8, 102u8,
                102u8, 102u8, 102u8, 102u8, 102u8, 102u8, 102u8, 102u8, 102u8, 102u8, 102u8, 102u8,
                102u8, 102u8, 102u8, 102u8, 102u8, 102u8, 102u8, 102u8
            ]),
            f5: 8608480567731124087u64,
            f6: 9838263505978427528u64,
            u3: conformance::UnionSize36Align4::Variant([
                153u8, 153u8, 153u8, 153u8, 153u8, 153u8, 153u8, 153u8, 153u8, 153u8, 153u8, 153u8,
                153u8, 153u8, 153u8, 153u8, 153u8, 153u8, 153u8, 153u8, 153u8, 153u8, 153u8, 153u8,
                153u8, 153u8, 153u8, 153u8, 153u8, 153u8, 153u8, 153u8
            ]),
            f7: 12297829382473034410u64,
            p1: Some(Box::new(conformance::Size8Align8 { data: 17216961135462248174u64 })),
            f8: 13527612320720337851u64,
            p2: Some(Box::new(conformance::Size8Align8 { data: 17216961135462248174u64 })),
            f9: 15987178197214944733u64
        }
    );
}

#[test]
fn test_out_of_line_sandwich1_case1_v1_decode() {
    let value = &mut conformance::OutOfLineSandwich1::new_empty();
    let bytes = &mut [
        0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x6d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x20, 0x72, 0x6f, 0x63, 0x6b, 0x21, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03,
        0x04, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05,
        0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x09, 0x0a, 0x0b, 0x0c, 0x00, 0x00, 0x00, 0x00,
        0x68, 0x61, 0x72, 0x64, 0x20, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e,
        0x73, 0x20, 0x73, 0x75, 0x63, 0x6b, 0x21, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::OutOfLineSandwich1 {
            before: String::from("soft migrations rock!"),
            v: vec![conformance::Sandwich1 {
                before: 67305985u32,
                the_union: conformance::UnionSize8Align4::Variant(202050057u32),
                after: 134678021u32
            }],
            after: String::from("hard transitions suck!")
        }
    );
}

#[test]
fn test_out_of_line_sandwich1_with_opt_union_present_v1_decode() {
    let value = &mut conformance::OutOfLineSandwich1WithOptUnion::new_empty();
    let bytes = &mut [
        0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x6d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x20, 0x72, 0x6f, 0x63, 0x6b, 0x21, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03,
        0x04, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05,
        0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x09, 0x0a, 0x0b, 0x0c, 0x00, 0x00, 0x00, 0x00,
        0x68, 0x61, 0x72, 0x64, 0x20, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e,
        0x73, 0x20, 0x73, 0x75, 0x63, 0x6b, 0x21, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::OutOfLineSandwich1WithOptUnion {
            before: String::from("soft migrations rock!"),
            v: vec![conformance::Sandwich1WithOptUnion {
                before: 67305985u32,
                opt_union: Some(Box::new(conformance::UnionSize8Align4::Variant(202050057u32))),
                after: 134678021u32
            }],
            after: String::from("hard transitions suck!")
        }
    );
}

#[test]
fn test_out_of_line_sandwich1_with_opt_union_absent_v1_decode() {
    let value = &mut conformance::OutOfLineSandwich1WithOptUnion::new_empty();
    let bytes = &mut [
        0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x6d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x20, 0x72, 0x6f, 0x63, 0x6b, 0x21, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03,
        0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
        0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x68, 0x61, 0x72, 0x64, 0x20, 0x74, 0x72, 0x61,
        0x6e, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x73, 0x75, 0x63, 0x6b, 0x21, 0x00,
        0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::OutOfLineSandwich1WithOptUnion {
            before: String::from("soft migrations rock!"),
            v: vec![conformance::Sandwich1WithOptUnion {
                before: 67305985u32,
                after: 134678021u32,
                opt_union: None
            }],
            after: String::from("hard transitions suck!")
        }
    );
}

#[test]
fn test_regression4_v1_decode() {
    let value = &mut conformance::Regression4::new_empty();
    let bytes = &mut [
        0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x09, 0x0a, 0x0b, 0x03, 0x04, 0x00, 0x00,
        0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Regression4 {
            f1: 1u8,
            f2: 2u32,
            s1: conformance::StructSize3Align1 { three_bytes: [9u8, 10u8, 11u8] },
            f3: 3u8,
            f4: 4u16,
            f5: 5u64,
            f6: 6u8
        }
    );
}

#[test]
fn test_sandwich4_align8_v1_decode() {
    let value = &mut conformance::Sandwich4Align8::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
        0x0e, 0x0f, 0x10, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab,
        0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba,
        0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich4Align8 {
            sandwich4: conformance::Sandwich4 {
                before: 67305985u32,
                the_union: conformance::UnionSize36Align4::Variant([
                    160u8, 161u8, 162u8, 163u8, 164u8, 165u8, 166u8, 167u8, 168u8, 169u8, 170u8,
                    171u8, 172u8, 173u8, 174u8, 175u8, 176u8, 177u8, 178u8, 179u8, 180u8, 181u8,
                    182u8, 183u8, 184u8, 185u8, 186u8, 187u8, 188u8, 189u8, 190u8, 191u8
                ]),
                after: 134678021u32
            },
            alignment8_enforcement: 1157159078456920585u64
        }
    );
}

#[test]
fn test_sandwich4_align8_with_pointer_v1_decode() {
    let value = &mut conformance::Sandwich4Align8WithPointer::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab,
        0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba,
        0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich4Align8WithPointer {
            sandwich4: conformance::Sandwich4 {
                before: 67305985u32,
                the_union: conformance::UnionSize36Align4::Variant([
                    160u8, 161u8, 162u8, 163u8, 164u8, 165u8, 166u8, 167u8, 168u8, 169u8, 170u8,
                    171u8, 172u8, 173u8, 174u8, 175u8, 176u8, 177u8, 178u8, 179u8, 180u8, 181u8,
                    182u8, 183u8, 184u8, 185u8, 186u8, 187u8, 188u8, 189u8, 190u8, 191u8
                ]),
                after: 134678021u32
            },
            alignment8_enforcement: Some(Box::new(conformance::Size8Align8 {
                data: 1157159078456920585u64
            }))
        }
    );
}

#[test]
fn test_sandwich8_case1_v1_decode() {
    let value = &mut conformance::Sandwich8::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0x09, 0x0a, 0x0b, 0x0c, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich8 {
            before: 67305985u64,
            union_of_union: conformance::UnionOfUnion::Size8align4(
                conformance::UnionSize8Align4::Variant(202050057u32)
            ),
            after: 134678021u32
        }
    );
}

#[test]
fn test_sandwich9_case1_v1_decode() {
    let value = &mut conformance::Sandwich9::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x11, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x10, 0x11,
        0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x14, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Sandwich9 {
            before: 513u16,
            the_union: conformance::UnionWithVectorOfVectors::V(vec![vec![
                Some(Box::new(conformance::StructSize3Align1 { three_bytes: [16u8, 17u8, 18u8] })),
                Some(Box::new(conformance::StructSize3Align1 { three_bytes: [19u8, 20u8, 21u8] }))
            ]]),
            after: 4625u16
        }
    );
}

#[test]
fn test_simple_table_array_struct_v1_decode() {
    let value = &mut conformance::SimpleTableArrayStruct::new_empty();
    let bytes = &mut [
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xa0, 0xa1, 0xa2, 0xa3, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb0, 0xb1, 0xb2,
        0xb3, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::SimpleTableArrayStruct {
            the_array: [
                conformance::TransformerSimpleTable { value: Some(2745344416u32) },
                conformance::TransformerSimpleTable { value: Some(3014832560u32) }
            ]
        }
    );
}

#[test]
fn test_string_union_vector_v1_decode() {
    let value = &mut conformance::StringUnionVector::new_empty();
    let bytes = &mut [
        0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x68,
        0x65, 0x6c, 0x6c, 0x6f, 0x00, 0x00, 0x00, 0xaa, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xbb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::StringUnionVector {
            the_vector: vec![
                Some(Box::new(conformance::StringUnion::S(String::from("hello")))),
                Some(Box::new(conformance::StringUnion::U8(170u8))),
                Some(Box::new(conformance::StringUnion::U8(187u8)))
            ]
        }
    );
}

#[test]
fn test_create_component_request_v1_decode() {
    let value = &mut conformance::CreateComponentRequest::new_empty();
    let bytes = &mut [
        0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x66, 0x75, 0x63, 0x68, 0x73, 0x69, 0x61, 0x2d, 0x70, 0x6b,
        0x67, 0x3a, 0x2f, 0x2f, 0x66, 0x75, 0x63, 0x68, 0x73, 0x69, 0x61, 0x2e, 0x63, 0x6f, 0x6d,
        0x2f, 0x66, 0x69, 0x64, 0x6c, 0x5f, 0x63, 0x6f, 0x6d, 0x70, 0x61, 0x74, 0x69, 0x62, 0x69,
        0x6c, 0x69, 0x74, 0x79, 0x5f, 0x74, 0x65, 0x73, 0x74, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x65,
        0x72, 0x5f, 0x72, 0x75, 0x73, 0x74, 0x5f, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x78, 0x75,
        0x6e, 0x69, 0x6f, 0x6e, 0x23, 0x6d, 0x65, 0x74, 0x61, 0x2f, 0x66, 0x69, 0x64, 0x6c, 0x5f,
        0x63, 0x6f, 0x6d, 0x70, 0x61, 0x74, 0x69, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x5f, 0x74,
        0x65, 0x73, 0x74, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5f, 0x72, 0x75, 0x73, 0x74,
        0x5f, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x78, 0x75, 0x6e, 0x69, 0x6f, 0x6e, 0x2e, 0x63,
        0x6d, 0x78, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::CreateComponentRequest { launch_info: conformance::LaunchInfo { url: String::from("fuchsia-pkg://fuchsia.com/fidl_compatibility_test_server_rust_write_xunion#meta/fidl_compatibility_test_server_rust_write_xunion.cmx"), directory_request: 4294967295u32, arguments: None, out: None, err: None, flat_namespace: None, additional_services: None }, controller: 4294967295u32 });
}

#[test]
fn test_union_with_bound_string_v1_decode() {
    let value = &mut conformance::UnionWithBoundStringStruct::new_empty();
    let bytes = &mut [
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x61, 0x62, 0x63, 0x64, 0x00,
        0x00, 0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::UnionWithBoundStringStruct {
            v: conformance::UnionWithBoundString::BoundFiveStr(String::from("abcd"))
        }
    );
}

#[test]
fn test_union_migration_single_variant_v1_decode() {
    let value = &mut conformance::SingleVariantUnionStruct::new_empty();
    let bytes = &mut [
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::SingleVariantUnionStruct { u: conformance::SingleVariantUnion::X(42u32) }
    );
}

#[test]
fn test_reverse_ordinal_union_v1_decode() {
    let value = &mut conformance::ReverseOrdinalUnionStruct::new_empty();
    let bytes = &mut [
        0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];
    Decoder::decode_with_context(V1_CONTEXT, bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::ReverseOrdinalUnionStruct { u: conformance::ReverseOrdinalUnion::X(42i64) }
    );
}

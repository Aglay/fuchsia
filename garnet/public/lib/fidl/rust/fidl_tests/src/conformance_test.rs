// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// Code generated by tools/fidl/gidl-conformance-suite/regen.sh; DO NOT EDIT.

use fidl::{
    encoding::{Decodable, Decoder, Encoder},
    Error,
};
use fidl_conformance as conformance;

#[test]
fn test_3_byte_object_alignment_in_struct_encode() {
    let value = &mut conformance::ThreeByteInStruct {
        elem1: conformance::ThreeByte { elem1: 1u8, elem2: 2u8, elem3: 3u8 },
        elem2: conformance::ThreeByte { elem1: 4u8, elem2: 5u8, elem3: 6u8 },
        elem3: conformance::ThreeByte { elem1: 7u8, elem2: 8u8, elem3: 9u8 },
    };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_5_byte_object_alignment_in_struct_encode() {
    let value = &mut conformance::FiveByteInStruct {
        elem1: conformance::FiveByte { elem1: 16909060u32, elem2: 5u8 },
        elem2: conformance::FiveByte { elem1: 101124105u32, elem2: 10u8 },
        elem3: conformance::FiveByte { elem1: 185339150u32, elem2: 15u8 },
    };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x04, 0x03, 0x02, 0x01, 0x05, 0x00, 0x00, 0x00, 0x09, 0x08, 0x07, 0x06, 0x0a, 0x00,
            0x00, 0x00, 0x0e, 0x0d, 0x0c, 0x0b, 0x0f, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_3_byte_object_alignment_in_vector_encode() {
    let value = &mut conformance::ThreeByteInVector {
        elems: vec![
            conformance::ThreeByte { elem1: 1u8, elem2: 2u8, elem3: 3u8 },
            conformance::ThreeByte { elem1: 4u8, elem2: 5u8, elem3: 6u8 },
            conformance::ThreeByte { elem1: 7u8, elem2: 8u8, elem3: 9u8 },
        ],
    };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_5_byte_object_alignment_in_vector_encode() {
    let value = &mut conformance::FiveByteInVector {
        elems: vec![
            conformance::FiveByte { elem1: 16909060u32, elem2: 5u8 },
            conformance::FiveByte { elem1: 101124105u32, elem2: 10u8 },
            conformance::FiveByte { elem1: 185339150u32, elem2: 15u8 },
        ],
    };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x04, 0x03, 0x02, 0x01, 0x05, 0x00, 0x00, 0x00, 0x09, 0x08, 0x07, 0x06,
            0x0a, 0x00, 0x00, 0x00, 0x0e, 0x0d, 0x0c, 0x0b, 0x0f, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_3_byte_object_alignment_in_array_encode() {
    let value = &mut conformance::ThreeByteInArray {
        elems: [
            conformance::ThreeByte { elem1: 1u8, elem2: 2u8, elem3: 3u8 },
            conformance::ThreeByte { elem1: 4u8, elem2: 5u8, elem3: 6u8 },
            conformance::ThreeByte { elem1: 7u8, elem2: 8u8, elem3: 9u8 },
        ],
    };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_5_byte_object_alignment_in_array_encode() {
    let value = &mut conformance::FiveByteInArray {
        elems: [
            conformance::FiveByte { elem1: 16909060u32, elem2: 5u8 },
            conformance::FiveByte { elem1: 101124105u32, elem2: 10u8 },
            conformance::FiveByte { elem1: 185339150u32, elem2: 15u8 },
        ],
    };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x04, 0x03, 0x02, 0x01, 0x05, 0x00, 0x00, 0x00, 0x09, 0x08, 0x07, 0x06, 0x0a, 0x00,
            0x00, 0x00, 0x0e, 0x0d, 0x0c, 0x0b, 0x0f, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_empty_struct_encode() {
    let value = &mut conformance::EmptyStruct {};
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_empty_struct_sandwich_encode() {
    let value = &mut conformance::EmptyStructSandwich {
        before: String::from("before"),
        es: conformance::EmptyStruct {},
        after: String::from("after"),
    };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x65,
            0x66, 0x6f, 0x72, 0x65, 0x00, 0x00, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_uint8_uint16_uint32_uint64_encode() {
    let value = &mut conformance::Uint8Uint16Uint32Uint64 {
        f1: 1u8,
        f2: 515u16,
        f3: 67438087u32,
        f4: 579005069656919567u64,
    };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x00, 0x03, 0x02, 0x07, 0x06, 0x05, 0x04, 0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a,
            0x09, 0x08,
        ][..]
    );
}

#[test]
fn test_uint64_uint32_uint16_uint8_encode() {
    let value = &mut conformance::Uint64Uint32Uint16Uint8 {
        f1: 579005069656919567u64,
        f2: 67438087u32,
        f3: 515u16,
        f4: 1u8,
    };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a, 0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02,
            0x01, 0x00,
        ][..]
    );
}

#[test]
fn test_simple_table_empty_encode() {
    let value = &mut conformance::StructOfSimpleTable {
        table: conformance::SimpleTable { x: None, y: None },
    };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff,
        ][..]
    );
}

#[test]
fn test_table_with_string_and_vector_no_vector_content_encode() {
    let value = &mut conformance::StructOfTableWithStringAndVector {
        table: conformance::TableWithStringAndVector {
            foo: Some(String::from("hello")),
            bar: Some(27i32),
            baz: None,
        },
    };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x00,
            0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_inline_x_union_in_struct_encode() {
    let value = &mut conformance::TestInlineXUnionInStruct {
        before: String::from("before"),
        xu: conformance::SampleXUnion::U(3735928559u32),
        after: String::from("after"),
    };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xb2, 0x56, 0x9c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x00, 0x00, 0xef, 0xbe, 0xad, 0xde, 0x00, 0x00,
            0x00, 0x00, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_optional_x_union_in_struct_absent_encode() {
    let value = &mut conformance::TestOptionalXUnionInStruct {
        before: String::from("before"),
        after: String::from("after"),
        xu: None,
    };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x00, 0x00, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00,
            0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_optional_x_union_in_struct_present_encode() {
    let value = &mut conformance::TestOptionalXUnionInStruct {
        before: String::from("before"),
        xu: Some(Box::new(conformance::SampleXUnion::U(3735928559u32))),
        after: String::from("after"),
    };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xb2, 0x56, 0x9c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x00, 0x00, 0xef, 0xbe, 0xad, 0xde, 0x00, 0x00,
            0x00, 0x00, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_x_union_in_table_x_union_absent_encode() {
    let value = &mut conformance::TestXUnionInTable {
        value: conformance::XUnionInTable {
            before: Some(String::from("before")),
            after: Some(String::from("after")),
            xu: None,
        },
    };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x65, 0x66, 0x6f,
            0x72, 0x65, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_x_union_in_table_x_union_present_encode() {
    let value = &mut conformance::TestXUnionInTable {
        value: conformance::XUnionInTable {
            before: Some(String::from("before")),
            xu: Some(conformance::SampleXUnion::U(3735928559u32)),
            after: Some(String::from("after")),
        },
    };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x65, 0x66, 0x6f,
            0x72, 0x65, 0x00, 0x00, 0xb2, 0x56, 0x9c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xef, 0xbe, 0xad, 0xde, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x61, 0x66, 0x74, 0x65,
            0x72, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_strict_x_union_encode() {
    let value = &mut conformance::TestStrictXUnionInStruct {
        xu: conformance::SampleStrictXUnion::U(3735928559u32),
    };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x72, 0xea, 0xe2, 0x08, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xbe, 0xad, 0xde,
            0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_add_ethernet_device_request_encode() {
    let value = &mut conformance::TestAddEthernetDeviceRequest {
        topological_path: String::from("@/dev/sys/pci/00:03.0/e1000/ethernet"),
        config: conformance::InterfaceConfig {
            name: String::from("ethp0003"),
            ip_address_config: conformance::IpAddressConfig::Dhcp(true),
        },
        this_should_be_a_handle: 4294967295u32,
    };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
            0x00, 0x00, 0x40, 0x2f, 0x64, 0x65, 0x76, 0x2f, 0x73, 0x79, 0x73, 0x2f, 0x70, 0x63,
            0x69, 0x2f, 0x30, 0x30, 0x3a, 0x30, 0x33, 0x2e, 0x30, 0x2f, 0x65, 0x31, 0x30, 0x30,
            0x30, 0x2f, 0x65, 0x74, 0x68, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x00, 0x00, 0x00, 0x00,
            0x65, 0x74, 0x68, 0x70, 0x30, 0x30, 0x30, 0x33,
        ][..]
    );
}

#[test]
fn test_file_get_attr_response_encode() {
    let value = &mut conformance::FileGetAttrResponse {
        s: 2125315759i32,
        attributes: conformance::NodeAttributes {
            mode: 2518909348u32,
            id: 1u64,
            content_size: 231u64,
            storage_size: 231u64,
            link_count: 1u64,
            creation_time: 9833440827789222417u64,
            modification_time: 72038755451251353u64,
        },
    };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0xaf, 0xbe, 0xad, 0x7e, 0x00, 0x00, 0x00, 0x00, 0xa4, 0x81, 0x23, 0x96, 0x00, 0x00,
            0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe7, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xe7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
            0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00,
        ][..]
    );
}

#[test]
fn test_optionals_encode() {
    let value = &mut conformance::StructWithOptionals {
        s: conformance::EmptyStruct {},
        s2: Some(Box::new(conformance::EmptyStruct {})),
        t: conformance::TableWithEmptyStruct { s: Some(conformance::EmptyStruct {}) },
        xu: conformance::XUnionWithEmptyStruct::S(conformance::EmptyStruct {}),
        xu2: Some(Box::new(conformance::XUnionWithEmptyStruct::S(conformance::EmptyStruct {}))),
        u: conformance::UnionWithEmptyStruct::S(conformance::EmptyStruct {}),
        u2: Some(Box::new(conformance::UnionWithEmptyStruct::S(conformance::EmptyStruct {}))),
    };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xfe, 0xe0, 0x99, 0x74, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xfe, 0xe0, 0x99, 0x74, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_arrays_encode() {
    let value = &mut conformance::StructWithArrays {
        arr_int: [1i32, 2i32],
        arr_string: [String::from("a"), String::from("b")],
        arr_nullable_string: [Some(String::from("c")), None],
        arr_struct: [
            conformance::StructWithInt { x: 1i32 },
            conformance::StructWithInt { x: 2i32 },
        ],
        arr_nullable_struct: [None, Some(Box::new(conformance::StructWithInt { x: 16909060i32 }))],
        arr_arr_int: [[1i32, 2i32, 3i32], [4i32, 5i32, 6i32]],
    };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00,
            0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
            0x05, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x04, 0x03, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_vectors_encode() {
    let value = &mut conformance::StructWithVectors {
        vec_empty: vec![],
        vec_int: vec![1i32, 2i32],
        vec_string: vec![String::from("a"), String::from("b")],
        vec_nullable_string: vec![None, Some(String::from("c")), None],
        vec_struct: vec![conformance::StructWithInt { x: 1i32 }],
        vec_nullable_struct: vec![
            None,
            None,
            Some(Box::new(conformance::StructWithInt { x: 2i32 })),
        ],
        vec_vec_int: vec![vec![1i32, 2i32], vec![3i32]],
    };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x02, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x61, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_bool_true_encode() {
    let value = &mut conformance::MyBool { value: true };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_bool_false_encode() {
    let value = &mut conformance::MyBool { value: false };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_byte_zero_encode() {
    let value = &mut conformance::MyByte { value: 0u8 };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_byte255_encode() {
    let value = &mut conformance::MyByte { value: 255u8 };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_int8_min_encode() {
    let value = &mut conformance::MyInt8 { value: -128i8 };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_int8_zero_encode() {
    let value = &mut conformance::MyInt8 { value: 0i8 };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_int8_max_encode() {
    let value = &mut conformance::MyInt8 { value: 127i8 };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_int16_min_encode() {
    let value = &mut conformance::MyInt16 { value: -32768i16 };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_int16_zero_encode() {
    let value = &mut conformance::MyInt16 { value: 0i16 };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_int16_max_encode() {
    let value = &mut conformance::MyInt16 { value: 32767i16 };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_int32_min_encode() {
    let value = &mut conformance::MyInt32 { value: -2147483648i32 };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_int32_zero_encode() {
    let value = &mut conformance::MyInt32 { value: 0i32 };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_int32_max_encode() {
    let value = &mut conformance::MyInt32 { value: 2147483647i32 };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0xff, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_int64_min_encode() {
    let value = &mut conformance::MyInt64 { value: -9223372036854775808i64 };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,][..]);
}

#[test]
fn test_int64_zero_encode() {
    let value = &mut conformance::MyInt64 { value: 0i64 };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_int64_max_encode() {
    let value = &mut conformance::MyInt64 { value: 9223372036854775807i64 };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f,][..]);
}

#[test]
fn test_uint8_zero_encode() {
    let value = &mut conformance::MyUint8 { value: 0u8 };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_uint8_max_encode() {
    let value = &mut conformance::MyUint8 { value: 255u8 };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_uint16_zero_encode() {
    let value = &mut conformance::MyUint16 { value: 0u16 };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_uint16_max_encode() {
    let value = &mut conformance::MyUint16 { value: 65535u16 };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_uint32_zero_encode() {
    let value = &mut conformance::MyUint32 { value: 0u32 };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_uint32_max_encode() {
    let value = &mut conformance::MyUint32 { value: 4294967295u32 };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_uint64_zero_encode() {
    let value = &mut conformance::MyUint64 { value: 0u64 };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_uint64_max_encode() {
    let value = &mut conformance::MyUint64 { value: 18446744073709551615u64 };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,][..]);
}

#[test]
fn test_float32_zero_encode() {
    let value = &mut conformance::MyFloat32 { value: 0f32 };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_float32_one_encode() {
    let value = &mut conformance::MyFloat32 { value: 1f32 };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_float32_minus_one_encode() {
    let value = &mut conformance::MyFloat32 { value: -1f32 };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x80, 0xbf, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_float32_max_encode() {
    let value = &mut conformance::MyFloat32 { value: 3.4028234663852886e+38f32 };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0xff, 0xff, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_float64_zero_encode() {
    let value = &mut conformance::MyFloat64 { value: 0f64 };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,][..]);
}

#[test]
fn test_float64_one_encode() {
    let value = &mut conformance::MyFloat64 { value: 1f64 };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,][..]);
}

#[test]
fn test_float64_minus_one_encode() {
    let value = &mut conformance::MyFloat64 { value: -1f64 };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xbf,][..]);
}

#[test]
fn test_float64_max_encode() {
    let value = &mut conformance::MyFloat64 { value: 1.7976931348623157e+308f64 };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(*bytes, &[0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0x7f,][..]);
}

#[test]
fn test_union_with_bound_string_encode() {
    let value = &mut conformance::UnionWithBoundStringStruct {
        v: conformance::UnionWithBoundString::BoundFiveStr(String::from("abcd")),
    };
    let bytes = &mut Vec::new();
    Encoder::encode(bytes, &mut Vec::new(), value).unwrap();
    assert_eq!(
        *bytes,
        &[
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x61, 0x62, 0x63, 0x64,
            0x00, 0x00, 0x00, 0x00,
        ][..]
    );
}

#[test]
fn test_3_byte_object_alignment_in_struct_decode() {
    let value = &mut conformance::ThreeByteInStruct::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::ThreeByteInStruct {
            elem1: conformance::ThreeByte { elem1: 1u8, elem2: 2u8, elem3: 3u8 },
            elem2: conformance::ThreeByte { elem1: 4u8, elem2: 5u8, elem3: 6u8 },
            elem3: conformance::ThreeByte { elem1: 7u8, elem2: 8u8, elem3: 9u8 }
        }
    );
}

#[test]
fn test_5_byte_object_alignment_in_struct_decode() {
    let value = &mut conformance::FiveByteInStruct::new_empty();
    let bytes = &mut [
        0x04, 0x03, 0x02, 0x01, 0x05, 0x00, 0x00, 0x00, 0x09, 0x08, 0x07, 0x06, 0x0a, 0x00, 0x00,
        0x00, 0x0e, 0x0d, 0x0c, 0x0b, 0x0f, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::FiveByteInStruct {
            elem1: conformance::FiveByte { elem1: 16909060u32, elem2: 5u8 },
            elem2: conformance::FiveByte { elem1: 101124105u32, elem2: 10u8 },
            elem3: conformance::FiveByte { elem1: 185339150u32, elem2: 15u8 }
        }
    );
}

#[test]
fn test_3_byte_object_alignment_in_vector_decode() {
    let value = &mut conformance::ThreeByteInVector::new_empty();
    let bytes = &mut [
        0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::ThreeByteInVector {
            elems: vec![
                conformance::ThreeByte { elem1: 1u8, elem2: 2u8, elem3: 3u8 },
                conformance::ThreeByte { elem1: 4u8, elem2: 5u8, elem3: 6u8 },
                conformance::ThreeByte { elem1: 7u8, elem2: 8u8, elem3: 9u8 }
            ]
        }
    );
}

#[test]
fn test_5_byte_object_alignment_in_vector_decode() {
    let value = &mut conformance::FiveByteInVector::new_empty();
    let bytes = &mut [
        0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x04, 0x03, 0x02, 0x01, 0x05, 0x00, 0x00, 0x00, 0x09, 0x08, 0x07, 0x06, 0x0a, 0x00,
        0x00, 0x00, 0x0e, 0x0d, 0x0c, 0x0b, 0x0f, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::FiveByteInVector {
            elems: vec![
                conformance::FiveByte { elem1: 16909060u32, elem2: 5u8 },
                conformance::FiveByte { elem1: 101124105u32, elem2: 10u8 },
                conformance::FiveByte { elem1: 185339150u32, elem2: 15u8 }
            ]
        }
    );
}

#[test]
fn test_3_byte_object_alignment_in_array_decode() {
    let value = &mut conformance::ThreeByteInArray::new_empty();
    let bytes = &mut [
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::ThreeByteInArray {
            elems: [
                conformance::ThreeByte { elem1: 1u8, elem2: 2u8, elem3: 3u8 },
                conformance::ThreeByte { elem1: 4u8, elem2: 5u8, elem3: 6u8 },
                conformance::ThreeByte { elem1: 7u8, elem2: 8u8, elem3: 9u8 }
            ]
        }
    );
}

#[test]
fn test_5_byte_object_alignment_in_array_decode() {
    let value = &mut conformance::FiveByteInArray::new_empty();
    let bytes = &mut [
        0x04, 0x03, 0x02, 0x01, 0x05, 0x00, 0x00, 0x00, 0x09, 0x08, 0x07, 0x06, 0x0a, 0x00, 0x00,
        0x00, 0x0e, 0x0d, 0x0c, 0x0b, 0x0f, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::FiveByteInArray {
            elems: [
                conformance::FiveByte { elem1: 16909060u32, elem2: 5u8 },
                conformance::FiveByte { elem1: 101124105u32, elem2: 10u8 },
                conformance::FiveByte { elem1: 185339150u32, elem2: 15u8 }
            ]
        }
    );
}

#[test]
fn test_empty_struct_decode() {
    let value = &mut conformance::EmptyStruct::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::EmptyStruct {});
}

#[test]
fn test_empty_struct_sandwich_decode() {
    let value = &mut conformance::EmptyStructSandwich::new_empty();
    let bytes = &mut [
        0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x65, 0x66, 0x6f, 0x72,
        0x65, 0x00, 0x00, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::EmptyStructSandwich {
            before: String::from("before"),
            es: conformance::EmptyStruct {},
            after: String::from("after")
        }
    );
}

#[test]
fn test_uint8_uint16_uint32_uint64_decode() {
    let value = &mut conformance::Uint8Uint16Uint32Uint64::new_empty();
    let bytes = &mut [
        0x01, 0x00, 0x03, 0x02, 0x07, 0x06, 0x05, 0x04, 0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a, 0x09,
        0x08,
    ];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Uint8Uint16Uint32Uint64 {
            f1: 1u8,
            f2: 515u16,
            f3: 67438087u32,
            f4: 579005069656919567u64
        }
    );
}

#[test]
fn test_uint64_uint32_uint16_uint8_decode() {
    let value = &mut conformance::Uint64Uint32Uint16Uint8::new_empty();
    let bytes = &mut [
        0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a, 0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01,
        0x00,
    ];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::Uint64Uint32Uint16Uint8 {
            f1: 579005069656919567u64,
            f2: 67438087u32,
            f3: 515u16,
            f4: 1u8
        }
    );
}

#[test]
fn test_simple_table_empty_decode() {
    let value = &mut conformance::StructOfSimpleTable::new_empty();
    let bytes = &mut [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff,
    ];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::StructOfSimpleTable { table: conformance::SimpleTable { x: None, y: None } }
    );
}

#[test]
fn test_table_with_string_and_vector_no_vector_content_decode() {
    let value = &mut conformance::StructOfTableWithStringAndVector::new_empty();
    let bytes = &mut [
        0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::StructOfTableWithStringAndVector {
            table: conformance::TableWithStringAndVector {
                foo: Some(String::from("hello")),
                bar: Some(27i32),
                baz: None
            }
        }
    );
}

#[test]
fn test_inline_x_union_in_struct_decode() {
    let value = &mut conformance::TestInlineXUnionInStruct::new_empty();
    let bytes = &mut [
        0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xb2, 0x56, 0x9c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x65, 0x66, 0x6f,
        0x72, 0x65, 0x00, 0x00, 0xef, 0xbe, 0xad, 0xde, 0x00, 0x00, 0x00, 0x00, 0x61, 0x66, 0x74,
        0x65, 0x72, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::TestInlineXUnionInStruct {
            before: String::from("before"),
            xu: conformance::SampleXUnion::U(3735928559u32),
            after: String::from("after")
        }
    );
}

#[test]
fn test_optional_x_union_in_struct_absent_decode() {
    let value = &mut conformance::TestOptionalXUnionInStruct::new_empty();
    let bytes = &mut [
        0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x65, 0x66, 0x6f,
        0x72, 0x65, 0x00, 0x00, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::TestOptionalXUnionInStruct {
            before: String::from("before"),
            after: String::from("after"),
            xu: None
        }
    );
}

#[test]
fn test_optional_x_union_in_struct_present_decode() {
    let value = &mut conformance::TestOptionalXUnionInStruct::new_empty();
    let bytes = &mut [
        0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xb2, 0x56, 0x9c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x65, 0x66, 0x6f,
        0x72, 0x65, 0x00, 0x00, 0xef, 0xbe, 0xad, 0xde, 0x00, 0x00, 0x00, 0x00, 0x61, 0x66, 0x74,
        0x65, 0x72, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::TestOptionalXUnionInStruct {
            before: String::from("before"),
            xu: Some(Box::new(conformance::SampleXUnion::U(3735928559u32))),
            after: String::from("after")
        }
    );
}

#[test]
fn test_x_union_in_table_x_union_absent_decode() {
    let value = &mut conformance::TestXUnionInTable::new_empty();
    let bytes = &mut [
        0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x00, 0x00, 0x05, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x61,
        0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::TestXUnionInTable {
            value: conformance::XUnionInTable {
                before: Some(String::from("before")),
                after: Some(String::from("after")),
                xu: None
            }
        }
    );
}

#[test]
fn test_x_union_in_table_x_union_present_decode() {
    let value = &mut conformance::TestXUnionInTable::new_empty();
    let bytes = &mut [
        0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x00, 0x00, 0xb2, 0x56,
        0x9c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xbe, 0xad, 0xde, 0x00, 0x00, 0x00, 0x00,
        0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::TestXUnionInTable {
            value: conformance::XUnionInTable {
                before: Some(String::from("before")),
                xu: Some(conformance::SampleXUnion::U(3735928559u32)),
                after: Some(String::from("after"))
            }
        }
    );
}

#[test]
fn test_strict_x_union_decode() {
    let value = &mut conformance::TestStrictXUnionInStruct::new_empty();
    let bytes = &mut [
        0x72, 0xea, 0xe2, 0x08, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xbe, 0xad, 0xde, 0x00, 0x00,
        0x00, 0x00,
    ];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::TestStrictXUnionInStruct {
            xu: conformance::SampleStrictXUnion::U(3735928559u32)
        }
    );
}

#[test]
fn test_add_ethernet_device_request_decode() {
    let value = &mut conformance::TestAddEthernetDeviceRequest::new_empty();
    let bytes = &mut [
        0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x40, 0x2f, 0x64,
        0x65, 0x76, 0x2f, 0x73, 0x79, 0x73, 0x2f, 0x70, 0x63, 0x69, 0x2f, 0x30, 0x30, 0x3a, 0x30,
        0x33, 0x2e, 0x30, 0x2f, 0x65, 0x31, 0x30, 0x30, 0x30, 0x2f, 0x65, 0x74, 0x68, 0x65, 0x72,
        0x6e, 0x65, 0x74, 0x00, 0x00, 0x00, 0x00, 0x65, 0x74, 0x68, 0x70, 0x30, 0x30, 0x30, 0x33,
    ];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::TestAddEthernetDeviceRequest {
            topological_path: String::from("@/dev/sys/pci/00:03.0/e1000/ethernet"),
            config: conformance::InterfaceConfig {
                name: String::from("ethp0003"),
                ip_address_config: conformance::IpAddressConfig::Dhcp(true)
            },
            this_should_be_a_handle: 4294967295u32
        }
    );
}

#[test]
fn test_file_get_attr_response_decode() {
    let value = &mut conformance::FileGetAttrResponse::new_empty();
    let bytes = &mut [
        0xaf, 0xbe, 0xad, 0x7e, 0x00, 0x00, 0x00, 0x00, 0xa4, 0x81, 0x23, 0x96, 0x00, 0x00, 0x00,
        0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe7, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xe7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc,
        0xdd, 0xee, 0xff, 0x00,
    ];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::FileGetAttrResponse {
            s: 2125315759i32,
            attributes: conformance::NodeAttributes {
                mode: 2518909348u32,
                id: 1u64,
                content_size: 231u64,
                storage_size: 231u64,
                link_count: 1u64,
                creation_time: 9833440827789222417u64,
                modification_time: 72038755451251353u64
            }
        }
    );
}

#[test]
fn test_optionals_decode() {
    let value = &mut conformance::StructWithOptionals::new_empty();
    let bytes = &mut [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xfe, 0xe0, 0x99, 0x74, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xe0, 0x99, 0x74,
        0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00,
    ];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::StructWithOptionals {
            s: conformance::EmptyStruct {},
            s2: Some(Box::new(conformance::EmptyStruct {})),
            t: conformance::TableWithEmptyStruct { s: Some(conformance::EmptyStruct {}) },
            xu: conformance::XUnionWithEmptyStruct::S(conformance::EmptyStruct {}),
            xu2: Some(Box::new(conformance::XUnionWithEmptyStruct::S(conformance::EmptyStruct {}))),
            u: conformance::UnionWithEmptyStruct::S(conformance::EmptyStruct {}),
            u2: Some(Box::new(conformance::UnionWithEmptyStruct::S(conformance::EmptyStruct {})))
        }
    );
}

#[test]
fn test_arrays_decode() {
    let value = &mut conformance::StructWithArrays::new_empty();
    let bytes = &mut [
        0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
        0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
        0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x03, 0x02, 0x01, 0x00, 0x00,
        0x00, 0x00,
    ];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::StructWithArrays {
            arr_int: [1i32, 2i32],
            arr_string: [String::from("a"), String::from("b")],
            arr_nullable_string: [Some(String::from("c")), None],
            arr_struct: [
                conformance::StructWithInt { x: 1i32 },
                conformance::StructWithInt { x: 2i32 }
            ],
            arr_nullable_struct: [
                None,
                Some(Box::new(conformance::StructWithInt { x: 16909060i32 }))
            ],
            arr_arr_int: [[1i32, 2i32, 3i32], [4i32, 5i32, 6i32]]
        }
    );
}

#[test]
fn test_vectors_decode() {
    let value = &mut conformance::StructWithVectors::new_empty();
    let bytes = &mut [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::StructWithVectors {
            vec_empty: vec![],
            vec_int: vec![1i32, 2i32],
            vec_string: vec![String::from("a"), String::from("b")],
            vec_nullable_string: vec![None, Some(String::from("c")), None],
            vec_struct: vec![conformance::StructWithInt { x: 1i32 }],
            vec_nullable_struct: vec![
                None,
                None,
                Some(Box::new(conformance::StructWithInt { x: 2i32 }))
            ],
            vec_vec_int: vec![vec![1i32, 2i32], vec![3i32]]
        }
    );
}

#[test]
fn test_bool_true_decode() {
    let value = &mut conformance::MyBool::new_empty();
    let bytes = &mut [0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyBool { value: true });
}

#[test]
fn test_bool_false_decode() {
    let value = &mut conformance::MyBool::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyBool { value: false });
}

#[test]
fn test_byte_zero_decode() {
    let value = &mut conformance::MyByte::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyByte { value: 0u8 });
}

#[test]
fn test_byte255_decode() {
    let value = &mut conformance::MyByte::new_empty();
    let bytes = &mut [0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyByte { value: 255u8 });
}

#[test]
fn test_int8_min_decode() {
    let value = &mut conformance::MyInt8::new_empty();
    let bytes = &mut [0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyInt8 { value: -128i8 });
}

#[test]
fn test_int8_zero_decode() {
    let value = &mut conformance::MyInt8::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyInt8 { value: 0i8 });
}

#[test]
fn test_int8_max_decode() {
    let value = &mut conformance::MyInt8::new_empty();
    let bytes = &mut [0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyInt8 { value: 127i8 });
}

#[test]
fn test_int16_min_decode() {
    let value = &mut conformance::MyInt16::new_empty();
    let bytes = &mut [0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyInt16 { value: -32768i16 });
}

#[test]
fn test_int16_zero_decode() {
    let value = &mut conformance::MyInt16::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyInt16 { value: 0i16 });
}

#[test]
fn test_int16_max_decode() {
    let value = &mut conformance::MyInt16::new_empty();
    let bytes = &mut [0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyInt16 { value: 32767i16 });
}

#[test]
fn test_int32_min_decode() {
    let value = &mut conformance::MyInt32::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyInt32 { value: -2147483648i32 });
}

#[test]
fn test_int32_zero_decode() {
    let value = &mut conformance::MyInt32::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyInt32 { value: 0i32 });
}

#[test]
fn test_int32_max_decode() {
    let value = &mut conformance::MyInt32::new_empty();
    let bytes = &mut [0xff, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyInt32 { value: 2147483647i32 });
}

#[test]
fn test_int64_min_decode() {
    let value = &mut conformance::MyInt64::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyInt64 { value: -9223372036854775808i64 });
}

#[test]
fn test_int64_zero_decode() {
    let value = &mut conformance::MyInt64::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyInt64 { value: 0i64 });
}

#[test]
fn test_int64_max_decode() {
    let value = &mut conformance::MyInt64::new_empty();
    let bytes = &mut [0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyInt64 { value: 9223372036854775807i64 });
}

#[test]
fn test_uint8_zero_decode() {
    let value = &mut conformance::MyUint8::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyUint8 { value: 0u8 });
}

#[test]
fn test_uint8_max_decode() {
    let value = &mut conformance::MyUint8::new_empty();
    let bytes = &mut [0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyUint8 { value: 255u8 });
}

#[test]
fn test_uint16_zero_decode() {
    let value = &mut conformance::MyUint16::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyUint16 { value: 0u16 });
}

#[test]
fn test_uint16_max_decode() {
    let value = &mut conformance::MyUint16::new_empty();
    let bytes = &mut [0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyUint16 { value: 65535u16 });
}

#[test]
fn test_uint32_zero_decode() {
    let value = &mut conformance::MyUint32::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyUint32 { value: 0u32 });
}

#[test]
fn test_uint32_max_decode() {
    let value = &mut conformance::MyUint32::new_empty();
    let bytes = &mut [0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyUint32 { value: 4294967295u32 });
}

#[test]
fn test_uint64_zero_decode() {
    let value = &mut conformance::MyUint64::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyUint64 { value: 0u64 });
}

#[test]
fn test_uint64_max_decode() {
    let value = &mut conformance::MyUint64::new_empty();
    let bytes = &mut [0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyUint64 { value: 18446744073709551615u64 });
}

#[test]
fn test_float32_zero_decode() {
    let value = &mut conformance::MyFloat32::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyFloat32 { value: 0f32 });
}

#[test]
fn test_float32_one_decode() {
    let value = &mut conformance::MyFloat32::new_empty();
    let bytes = &mut [0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyFloat32 { value: 1f32 });
}

#[test]
fn test_float32_minus_one_decode() {
    let value = &mut conformance::MyFloat32::new_empty();
    let bytes = &mut [0x00, 0x00, 0x80, 0xbf, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyFloat32 { value: -1f32 });
}

#[test]
fn test_float32_max_decode() {
    let value = &mut conformance::MyFloat32::new_empty();
    let bytes = &mut [0xff, 0xff, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyFloat32 { value: 3.4028234663852886e+38f32 });
}

#[test]
fn test_float64_zero_decode() {
    let value = &mut conformance::MyFloat64::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyFloat64 { value: 0f64 });
}

#[test]
fn test_float64_one_decode() {
    let value = &mut conformance::MyFloat64::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyFloat64 { value: 1f64 });
}

#[test]
fn test_float64_minus_one_decode() {
    let value = &mut conformance::MyFloat64::new_empty();
    let bytes = &mut [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xbf];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyFloat64 { value: -1f64 });
}

#[test]
fn test_float64_max_decode() {
    let value = &mut conformance::MyFloat64::new_empty();
    let bytes = &mut [0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0x7f];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(*value, conformance::MyFloat64 { value: 1.7976931348623157e+308f64 });
}

#[test]
fn test_union_with_bound_string_decode() {
    let value = &mut conformance::UnionWithBoundStringStruct::new_empty();
    let bytes = &mut [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x61, 0x62, 0x63, 0x64, 0x00, 0x00,
        0x00, 0x00,
    ];
    Decoder::decode_into(bytes, &mut [], value).unwrap();
    assert_eq!(
        *value,
        conformance::UnionWithBoundStringStruct {
            v: conformance::UnionWithBoundString::BoundFiveStr(String::from("abcd"))
        }
    );
}

#[test]
fn test_non_empty_string_with_null_ptr_body_decode_failure() {
    let value = &mut conformance::StringWrapper::new_empty();
    let bytes = &mut [
        0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];
    match Decoder::decode_into(bytes, &mut [], value) {
        Err(Error::UnexpectedNullRef { .. }) => (),
        Err(err) => panic!("unexpected error: {}", err),
        Ok(_) => panic!("unexpected successful decoding"),
    }
}

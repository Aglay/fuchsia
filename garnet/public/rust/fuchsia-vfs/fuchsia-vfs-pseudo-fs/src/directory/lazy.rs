// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

//! Implementation of a "lazy" pseudo directory.  See [`Lazy`] for details.

use {
    crate::common::send_on_open_with_error,
    crate::directory::{
        common::{encode_dirent, validate_and_split_path},
        connection::DirectoryConnection,
        entry::{DirectoryEntry, EntryInfo},
        DEFAULT_DIRECTORY_PROTECTION_ATTRIBUTES,
    },
    failure::Fail,
    fidl::endpoints::ServerEnd,
    fidl_fuchsia_io::{
        DirectoryObject, DirectoryRequest, NodeAttributes, NodeInfo, NodeMarker,
        DIRENT_TYPE_DIRECTORY, INO_UNKNOWN, MAX_FILENAME, MODE_TYPE_DIRECTORY,
    },
    fuchsia_zircon::{
        sys::{ZX_ERR_INVALID_ARGS, ZX_ERR_NOT_SUPPORTED, ZX_OK},
        Status,
    },
    futures::{
        future::{FusedFuture, FutureExt},
        stream::{FuturesUnordered, StreamExt, StreamFuture},
        task::Waker,
        Future, Poll,
    },
    std::{
        default::Default,
        iter::{self, ExactSizeIterator},
        marker::Unpin,
        mem::replace,
        pin::Pin,
    },
    void::{unreachable, Void},
};

/// Type of the errors that might be generated by sink callback provided to the `get_entry_names`
/// handler.  See [`lazy`] and [`lazy_attr`].
#[derive(Debug, Fail)]
pub enum GetEntryNameSinkError {
    /// Provided name of an entry was longer than MAX_FILENAME bytes.
    #[fail(display = "Provided entry name exceeds MAX_FILENAME bytes")]
    NameTooLong,
}

// TODO When trait aliases are stabilized and we can use them (rust-lang/rust#41517).
// pub trait GetEntryNamesHandler<TraversalPosition> =
//     FnMut(
//             TraversalPosition,
//             &mut FnMut(&EntryInfo, &str) -> Result<bool, GetEntryNameSinkError>,
//         ) -> (TraversalPosition, Result<(), Status>)
//         + Send;

// TODO When trait aliases are stabilized and we can use them (rust-lang/rust#41517).
// pub trait GetEntryHandler<'entries> =
//     FnMut(&str) -> Result<Box<DirectoryEntry + 'entries>, Status> + Send;

/// Creates a lazy directory.
///
/// See [`Lazy`] for details.
///
/// POSIX access attributes are set to [`DEFAULT_DIRECTORY_PROTECTION_ATTRIBUTES`].
pub fn lazy<'entries, TraversalPosition, GetEntryNames, GetEntry>(
    get_entry_names: GetEntryNames,
    get_entry: GetEntry,
) -> Lazy<'entries, TraversalPosition, GetEntryNames, GetEntry>
where
    TraversalPosition: Default + Send,
    GetEntryNames: FnMut(
            TraversalPosition,
            &mut FnMut(&EntryInfo, &str) -> Result<bool, GetEntryNameSinkError>,
        ) -> (TraversalPosition, Result<(), Status>)
        + Send,
    GetEntry: FnMut(&str) -> Result<Box<DirectoryEntry + 'entries>, Status> + Send,
{
    lazy_attr(DEFAULT_DIRECTORY_PROTECTION_ATTRIBUTES, get_entry_names, get_entry)
}

/// Creates a lazy directory with the specified POSIX access attributes.
///
/// See [`Lazy`] for details.
///
pub fn lazy_attr<'entries, TraversalPosition, GetEntryNames, GetEntry>(
    protection_attributes: u32,
    get_entry_names: GetEntryNames,
    get_entry: GetEntry,
) -> Lazy<'entries, TraversalPosition, GetEntryNames, GetEntry>
where
    TraversalPosition: Default + Send,
    GetEntryNames: FnMut(
            TraversalPosition,
            &mut FnMut(&EntryInfo, &str) -> Result<bool, GetEntryNameSinkError>,
        ) -> (TraversalPosition, Result<(), Status>)
        + Send,
    GetEntry: FnMut(&str) -> Result<Box<DirectoryEntry + 'entries>, Status> + Send,
{
    Lazy {
        protection_attributes,
        get_entry_names,
        get_entry,
        live_entries: Vec::new(),
        connections: FuturesUnordered::new(),
    }
}

/// An implementation of a pseudo directory that generates nested entries only when they are
/// requested.  This could be useful when the number of entries is big and the expected use case is
/// that only a small fraction of all the entries will be interacted with at an given time.
///
/// [`lazy`] and [`lazy_attr`] are used to construct lazy directories.
///
/// A lazy directory contains one callback, called `get_entry_names`, which is used when a
/// directory listing is requested.  Another callback, called `get_entry`, is used to construct and
/// actual entry when it is accessed.
///
/// `get_entry_names` is provided with a position and a sink (in form of another callback).  The
/// position allows the caller to retrieve entry names starting at a point other then the very
/// first entry.  The sink is use to consume entry names and it may not be able to consume the
/// whole directory content at once as it is backed by a limited size buffer.  `get_entry_names` is
/// expected to return a new position that would allow the caller to continue the traversal from
/// the next entry.  See [`traversal_position::AlphabeticalTraversal`] for an example of a type
/// designed to be used as a traversal position.  `sink` will return Ok(true) if it can consume
/// more entries, and Ok(false) if it can not.  An Err() value is returned if the sink failed to
/// consume the entry specified.  When the traversal has reached the end of the listing, sink
/// should not be called at all - this is an indicator that we have reached the end.
///
/// `get_entry` is expected to construct an [`DirectoryEntry`] instance to back an individual entry
/// and return it.  This new entry is then owned by the lazy directory, which would run it as part
/// of it's own execution cycle.  When the last connection to this entry is closed, the entry
/// object will be destroyed.
///
/// Notice that currently there is no caching or sharing of entry objects.  Every new `open()`
/// request will cause new entry object to be allocated and used.  See #ZX-3631 for the caching
/// policy discussion.
///
/// NOTE I have considered using an iterator as the interface for `get_entry_names`.  So that
/// `get_entry_names` would return an iterator that would encapsulate the iteration position.  The
/// problem with the iterators is that they do not allow the value to be "put back".  There is an
/// [`iter::Peekable`], but it is not a trait - I would need to introduce a custom trait to support
/// this functionality which would partially remove the advantage of using a standard trait.
///
/// The other problem with iterators, is that they do not control the lifetime of the value they
/// return.  With the "sink", `get_entry_names` is providing a reference that need to be alive only
/// for the duration of the call of the "sink".  An iterator, if it is returning a reference, has
/// no control over the reference lifetime.  And if it is not returning a reference, then a copy
/// will happen, if the data could have been referenced, in cases when it relatively static.
///
/// The later may be partially addressed by generalizing the iterator over its return type, as done
/// in the [`watchers::Watchers::add`] in the next commit.  But this generalization will introduce
/// additional complexity.
pub struct Lazy<'entries, TraversalPosition, GetEntryNames, GetEntry>
where
    TraversalPosition: Default + Send,
    GetEntryNames: FnMut(
            TraversalPosition,
            &mut FnMut(&EntryInfo, &str) -> Result<bool, GetEntryNameSinkError>,
        ) -> (TraversalPosition, Result<(), Status>)
        + Send,
    GetEntry: FnMut(&str) -> Result<Box<DirectoryEntry + 'entries>, Status> + Send,
{
    /// MODE_PROTECTION_MASK attributes returned by this directory through io.fidl:Node::GetAttr.
    /// They have no meaning for the directory operation itself, but may have consequences to the
    /// POSIX emulation layer.  This field should only have set bits in the MODE_PROTECTION_MASK
    /// part.
    protection_attributes: u32,

    /// This callback is invoked to get names of the entries inside the directory.  The first
    /// argument specifies the starting point.  The second argument is a "sink" that is supposed to
    /// be called with all entries that come after the first argument (in the order that is
    /// reasonable for this particular traversal type).
    ///
    /// The first argument needs to be updated to represent a traversal position that points to the
    /// last element provided to the sink.  This way next time the callback is called, it can
    /// continue form the last point of interruption.  Sink should be called as long as it is
    /// returning "true" or as long as there are any entries to return.  End of listing is reported
    /// by just not calling the sink at all.  For example if the directory has been empty in the
    /// first place or if the end of the list has been reached during the previous call.
    get_entry_names: GetEntryNames,

    /// This callback is invoked to get an actual directory entry object that corresponds to the
    /// specified name.  Note that this is never going to be called with ".", but otherwise might
    /// be called with names that has not been necessarily returned by the get_entry_names() callback.
    get_entry: GetEntry,

    /// Entries that have active connections to them.
    live_entries: Vec<Box<DirectoryEntry + 'entries>>,

    connections: FuturesUnordered<StreamFuture<DirectoryConnection<TraversalPosition>>>,
}

/// Return type for Lazy::handle_request().
enum ConnectionState {
    Alive,
    Closed,
}

impl<'entries, TraversalPosition, GetEntryNames, GetEntry>
    Lazy<'entries, TraversalPosition, GetEntryNames, GetEntry>
where
    TraversalPosition: Default + Send,
    GetEntryNames: FnMut(
            TraversalPosition,
            &mut FnMut(&EntryInfo, &str) -> Result<bool, GetEntryNameSinkError>,
        ) -> (TraversalPosition, Result<(), Status>)
        + Send,
    GetEntry: FnMut(&str) -> Result<Box<DirectoryEntry + 'entries>, Status> + Send,
{
    fn add_connection(
        &mut self,
        parent_flags: u32,
        flags: u32,
        mode: u32,
        server_end: ServerEnd<NodeMarker>,
    ) {
        if let Some(connection) =
            DirectoryConnection::<TraversalPosition>::connect(parent_flags, flags, mode, server_end)
        {
            self.connections.push(connection);
        }
    }

    fn handle_request(
        &mut self,
        req: DirectoryRequest,
        connection: &mut DirectoryConnection<TraversalPosition>,
    ) -> Result<ConnectionState, failure::Error> {
        match req {
            DirectoryRequest::Clone { flags, object, control_handle: _ } => {
                self.add_connection(connection.flags, flags, 0, object);
            }
            DirectoryRequest::Close { responder } => {
                responder.send(ZX_OK)?;
                return Ok(ConnectionState::Closed);
            }
            DirectoryRequest::Describe { responder } => {
                let mut info = NodeInfo::Directory(DirectoryObject);
                responder.send(&mut info)?;
            }
            DirectoryRequest::Sync { responder } => {
                responder.send(ZX_ERR_NOT_SUPPORTED)?;
            }
            DirectoryRequest::GetAttr { responder } => {
                let mut attrs = NodeAttributes {
                    mode: MODE_TYPE_DIRECTORY | self.protection_attributes,
                    id: INO_UNKNOWN,
                    content_size: 0,
                    storage_size: 0,
                    link_count: 1,
                    creation_time: 0,
                    modification_time: 0,
                };
                responder.send(ZX_OK, &mut attrs)?;
            }
            DirectoryRequest::SetAttr { flags: _, attributes: _, responder } => {
                // According to zircon/system/fidl/fuchsia-io/io.fidl the only flag that might be
                // modified through this call is OPEN_FLAG_APPEND, and it is not supported by a
                // Lazy directory.
                responder.send(ZX_ERR_NOT_SUPPORTED)?;
            }
            DirectoryRequest::Ioctl { opcode: _, max_out: _, handles: _, in_: _, responder } => {
                responder.send(ZX_ERR_NOT_SUPPORTED, &mut iter::empty(), &mut iter::empty())?;
            }
            DirectoryRequest::Open { flags, mode, path, object, control_handle: _ } => {
                self.handle_open(flags, mode, &path, object);
            }
            DirectoryRequest::Unlink { path: _, responder } => {
                responder.send(ZX_ERR_NOT_SUPPORTED)?;
            }
            DirectoryRequest::ReadDirents { max_bytes, responder } => {
                self.handle_read_dirents(connection, max_bytes, |status, entries| {
                    responder.send(status.into_raw(), entries)
                })?;
            }
            DirectoryRequest::Rewind { responder } => {
                connection.seek = Default::default();
                responder.send(ZX_OK)?;
            }
            DirectoryRequest::GetToken { responder } => {
                responder.send(ZX_ERR_NOT_SUPPORTED, None)?;
            }
            DirectoryRequest::Rename { src: _, dst_parent_token: _, dst: _, responder } => {
                responder.send(ZX_ERR_NOT_SUPPORTED)?;
            }
            DirectoryRequest::Link { src: _, dst_parent_token: _, dst: _, responder } => {
                responder.send(ZX_ERR_NOT_SUPPORTED)?;
            }
            DirectoryRequest::Watch { mask: _, options, watcher: _, responder } => {
                if options != 0 {
                    responder.send(ZX_ERR_INVALID_ARGS)?;
                } else {
                    // TODO Watchers support is coming in the next change.
                    responder.send(ZX_ERR_NOT_SUPPORTED)?;
                }
            }
        }
        Ok(ConnectionState::Alive)
    }

    fn handle_open(
        &mut self,
        flags: u32,
        mut mode: u32,
        path: &str,
        server_end: ServerEnd<NodeMarker>,
    ) {
        if path == "/" {
            send_on_open_with_error(flags, server_end, Status::INVALID_ARGS);
            return;
        }

        if path == "." {
            self.open(flags, mode, &mut iter::empty(), server_end);
            return;
        }

        let (mut names, is_dir) = match validate_and_split_path(path) {
            Ok(v) => v,
            Err(status) => {
                send_on_open_with_error(flags, server_end, status);
                return;
            }
        };

        if is_dir {
            mode |= MODE_TYPE_DIRECTORY;
        }

        // It is up to the open method to handle OPEN_FLAG_DESCRIBE from this point on.
        self.open(flags, mode, &mut names, server_end);
    }

    fn handle_read_dirents<R>(
        &mut self,
        connection: &mut DirectoryConnection<TraversalPosition>,
        max_bytes: u64,
        responder: R,
    ) -> Result<(), fidl::Error>
    where
        R: FnOnce(Status, &mut ExactSizeIterator<Item = u8>) -> Result<(), fidl::Error>,
    {
        let mut buf = Vec::new();
        let mut fit_one = false;
        let mut called_once = false;

        // It would be nice if there would be something like `replace` but that would transform a
        // value using a function and then will put it back in.  As TraversalPosition has to
        // implement Default we can abuse it here, but otherwise this seems a bit messy.
        let seek = replace(&mut connection.seek, Default::default());
        let (new_seek, res) = (self.get_entry_names)(seek, &mut |entry_info, name| {
            called_once = true;

            if name.len() >= MAX_FILENAME as usize {
                return Err(GetEntryNameSinkError::NameTooLong);
            }

            if !encode_dirent(&mut buf, max_bytes, entry_info, name) {
                return Ok(false);
            }

            fit_one = true;
            Ok(true)
        });
        connection.seek = new_seek;

        if let Err(status) = res {
            return responder(status, &mut buf.iter().cloned());
        }

        if !called_once {
            return responder(Status::OK, &mut iter::empty());
        }

        if !fit_one {
            return responder(Status::BUFFER_TOO_SMALL, &mut buf.iter().cloned());
        }

        return responder(Status::OK, &mut buf.iter().cloned());
    }
}

impl<'entries, TraversalPosition, GetEntryNames, GetEntry> DirectoryEntry
    for Lazy<'entries, TraversalPosition, GetEntryNames, GetEntry>
where
    TraversalPosition: Default + Send,
    GetEntryNames: FnMut(
            TraversalPosition,
            &mut FnMut(&EntryInfo, &str) -> Result<bool, GetEntryNameSinkError>,
        ) -> (TraversalPosition, Result<(), Status>)
        + Send,
    GetEntry: FnMut(&str) -> Result<Box<DirectoryEntry + 'entries>, Status> + Send,
{
    fn open(
        &mut self,
        flags: u32,
        mode: u32,
        path: &mut Iterator<Item = &str>,
        server_end: ServerEnd<NodeMarker>,
    ) {
        let name = match path.next() {
            Some(name) => name,
            None => {
                self.add_connection(!0, flags, mode, server_end);
                return;
            }
        };

        let mut entry = match (self.get_entry)(name) {
            Ok(entry) => entry,
            Err(status) => {
                send_on_open_with_error(flags, server_end, status);
                return;
            }
        };

        // While this function is recursive, and Rust does not support TCO at the moment, recursion
        // here does not seem to be too bad.  I've tested a method with a very similar layout:
        //
        //     fn open(&mut self, a: u32, b: u32, path: &mut Iterator<Item = &str>, v: u64) -> Result<(), Error>;
        //
        // You can run it here:
        //
        //     https://play.rust-lang.org/?version=nightly&gist=5471f93c52f3adb7c8d6741ea96f9bce
        //
        // Given a path with 2048 components, which is the maximum possible path, considering the
        // MAX_PATH restriction of 4096, the function used 290KBs of stack.  Rust, by default, uses
        // 2MB stacks.
        //
        // Considering that the open method will only use recursion for the pseudo directories
        // created by the server, it is not very likely that the server will create such a deep
        // tree in the first place.
        //
        // Removing recursion is a bit inconvenient, as open() is the API for the tree entries.
        // One way to remove the recursion that I can think of, is to introduce a
        //
        //     open_next_entry_or_consume(flags, mode, entry_name, path, server_end) -> Option<&mut DirectoryEntry>
        //
        // method that would either return the next DirectoryEntry or will consume the path further
        // down (recursively) returning None.  This would allow traversal to happen in a fixed
        // stack space, still allowing nodes like mount points to intercept the traversal process.
        // It seems like it will complicate the API for the DirectoryEntry implementations though.

        entry.open(flags, mode, path, server_end);
        self.live_entries.push(entry);
    }

    fn entry_info(&self) -> EntryInfo {
        EntryInfo::new(INO_UNKNOWN, DIRENT_TYPE_DIRECTORY)
    }
}

impl<'entries, TraversalPosition, GetEntryNames, GetEntry> Unpin
    for Lazy<'entries, TraversalPosition, GetEntryNames, GetEntry>
where
    TraversalPosition: Default + Send,
    GetEntryNames: FnMut(
            TraversalPosition,
            &mut FnMut(&EntryInfo, &str) -> Result<bool, GetEntryNameSinkError>,
        ) -> (TraversalPosition, Result<(), Status>)
        + Send,
    GetEntry: FnMut(&str) -> Result<Box<DirectoryEntry + 'entries>, Status> + Send,
{
}

impl<'entries, TraversalPosition, GetEntryNames, GetEntry> Future
    for Lazy<'entries, TraversalPosition, GetEntryNames, GetEntry>
where
    TraversalPosition: Default + Send,
    GetEntryNames: FnMut(
            TraversalPosition,
            &mut FnMut(&EntryInfo, &str) -> Result<bool, GetEntryNameSinkError>,
        ) -> (TraversalPosition, Result<(), Status>)
        + Send,
    GetEntry: FnMut(&str) -> Result<Box<DirectoryEntry + 'entries>, Status> + Send,
{
    type Output = Void;

    fn poll(mut self: Pin<&mut Self>, waker: &Waker) -> Poll<Self::Output> {
        // This loop is needed to make sure we do not miss any activations of the futures we are
        // managing.  For example, if a stream was activated and has several outstanding items, if
        // we do not loop, we would only process the first item and then exit the `poll` method.
        // And we would leave item(s) in the stream and would not process them until the next
        // activation due to another item been added.  So we need to poll the stream while we
        // receive Poll::Pending.
        //
        // This approach has a downside, as we do not give up control until if we have more items
        // coming in.  Ideally we would want to check if there is anything else left in the stream
        // and just set the waker to activate us again, giving the executor (and other futures
        // sharing this task) to do work.  Unfortunately, Stream does not provide an ability to see
        // if there are any items pending.
        loop {
            match self.connections.poll_next_unpin(waker) {
                Poll::Ready(Some((maybe_request, mut connection))) => {
                    if let Some(Ok(request)) = maybe_request {
                        match self.handle_request(request, &mut connection) {
                            Ok(ConnectionState::Alive) => {
                                self.connections.push(connection.into_future())
                            }
                            Ok(ConnectionState::Closed) => (),
                            // An error occurred while processing a request.  We will just close
                            // the connection, effectively closing the underlying channel in the
                            // destructor.
                            _ => (),
                        }
                    }
                    // Similarly to the error that occurs while handing a FIDL request, any
                    // connection level errors cause the connection to be closed.
                }
                // Even when we have no connections any more we still report Pending state, as we
                // may get more connections open in the future.  We will return Poll::Pending
                // below.  Getting any of these two values means that we have processed all the
                // items that might have been triggered current waker activation.
                Poll::Ready(None) | Poll::Pending => break,
            }
        }

        {
            // It would be nice if Vec would provide a method that would give mutable (or better
            // owning) access to all the elements, and would allow to drop those that are unneeded.
            // `drain_filter` does something similar, but it is unstable (rust-lang/rust#43244).
            // As we do not need to preserve the order, we can get away with `swap_remove`, but it
            // is a bit ugly.
            let mut i = 0;
            while i < self.live_entries.len() {
                let entry = &mut self.live_entries[i];

                match entry.poll_unpin(waker) {
                    Poll::Pending => (),
                    Poll::Ready(x) => unreachable(x),
                }

                if entry.is_terminated() {
                    self.live_entries.swap_remove(i);
                } else {
                    i += 1;
                }
            }
        }

        Poll::Pending
    }
}

impl<'entries, TraversalPosition, GetEntryNames, GetEntry> FusedFuture
    for Lazy<'entries, TraversalPosition, GetEntryNames, GetEntry>
where
    TraversalPosition: Default + Send,
    GetEntryNames: FnMut(
            TraversalPosition,
            &mut FnMut(&EntryInfo, &str) -> Result<bool, GetEntryNameSinkError>,
        ) -> (TraversalPosition, Result<(), Status>)
        + Send,
    GetEntry: FnMut(&str) -> Result<Box<DirectoryEntry + 'entries>, Status> + Send,
{
    fn is_terminated(&self) -> bool {
        // We have already checked is_terminated() value in `Future::poll` above.  My assumption is
        // that as the only way for the contained objects to change their state is through the
        // `poll` call, they should not change their `is_terminated` value either.  But if they do,
        // the only change can be from "false" to "true", and then the object will be destroyed
        // during the next `poll` call above (thought it seems to be a broken case from the entry
        // implementer side).
        if !self.live_entries.is_empty() {
            return false;
        }

        // As a pseudo directory blocks when no connections are available, it can not use
        // `connections.is_terminated()`.  `FuturesUnordered::is_terminated()` will return `false`
        // for an empty set of connections for the first time, while `Lazy::poll()` will return
        // `Pending` in the same situation.  If we do not return `true` here for the empty
        // connections case for the first time instead, we will hang.
        self.connections.len() == 0
    }
}

#[cfg(test)]
mod tests {
    use super::{lazy, lazy_attr, GetEntryNameSinkError};

    use {
        crate::directory::{
            entry::{DirectoryEntry, EntryInfo},
            test_utils::{run_server_client, DirentsSameInodeBuilder},
            traversal_position::AlphabeticalTraversal,
        },
        crate::file::simple::read_only,
        fidl_fuchsia_io::{
            DirectoryEvent, DirectoryMarker, DirectoryObject, FileEvent, FileMarker, FileObject,
            NodeAttributes, NodeInfo, DIRENT_TYPE_DIRECTORY, DIRENT_TYPE_FILE, INO_UNKNOWN,
            MODE_TYPE_DIRECTORY, OPEN_FLAG_DESCRIBE, OPEN_RIGHT_READABLE,
        },
        fuchsia_zircon::Status,
        futures::stream::StreamExt,
        libc::{S_IRGRP, S_IROTH, S_IRUSR, S_IXGRP, S_IXOTH, S_IXUSR},
        proc_macro_hack::proc_macro_hack,
    };

    // Crate level import of this macro does not affect nested modules.  And as attributes can only
    // be applied to the whole "use" directive, this need to be present here and need to be
    // separate form the above.  "use crate::pseudo_directory" generates a warning referring to
    // "issue #52234 <https://github.com/rust-lang/rust/issues/52234>".
    #[proc_macro_hack(support_nested)]
    use fuchsia_vfs_pseudo_fs_macros::pseudo_directory;

    /// A helper to generate `get_entry_names` callbacks for the lazy directories.  This helper
    /// generates callbacks that return the same content every time and the entries are
    /// alphabetically sorted (the later is convenient when traversal position need to be
    /// remembered).
    // I wish I would be able to move an impl type declaration into a where clause, but that would
    // require me to add generic arguments to build_sorted_static_get_entry_names() and that breaks
    // inference, as the return type is not specific enough.
    //
    // In other words, I would better write this function as
    //
    //     build_sorted_static_get_entry_names<Res>(...) -> impl Res
    //     where
    //         Res: FnMut(...) -> (...)
    //
    // but if I do that, then the caller can specify what `Res` is and that is wrong.  I think
    // trait aliases should help here as soon as they are stabilized (rust-lang/rust#41517).
    fn build_sorted_static_get_entry_names(
        mut entries: Vec<(u8, &'static str)>,
    ) -> impl FnMut(
        AlphabeticalTraversal,
        &mut FnMut(&EntryInfo, &str) -> Result<bool, GetEntryNameSinkError>,
    ) -> (AlphabeticalTraversal, Result<(), Status>) {
        use AlphabeticalTraversal::{Dot, End, Name, Start};

        entries.sort_unstable_by_key(|&(_, name)| name);

        let entries = {
            let mut res = vec![(Dot, EntryInfo::new(INO_UNKNOWN, DIRENT_TYPE_DIRECTORY))];
            res.extend(entries.into_iter().map(|(dirent_type, name)| {
                (Name(name.to_string()), EntryInfo::new(INO_UNKNOWN, dirent_type))
            }));
            res
        };

        let dot_entry_info = EntryInfo::new(INO_UNKNOWN, DIRENT_TYPE_DIRECTORY);

        move |p, sink: &mut FnMut(&EntryInfo, &str) -> Result<bool, GetEntryNameSinkError>| {
            let mut i = match entries.binary_search_by(|(candidate_pos, _)| candidate_pos.cmp(&p)) {
                Ok(i) => i + 1,
                Err(i) => i,
            };

            let mut last_retruned = p;

            while i < entries.len() {
                let (pos, entry_info) = &entries[i];
                let sink_res = sink(
                    match &pos {
                        Start => panic!("`entries` does not contain Start"),
                        Dot => &dot_entry_info,
                        Name(_) => &entry_info,
                        End => panic!("`entries` does not contain End"),
                    },
                    match &pos {
                        Start => panic!("`entries` does not contain Start"),
                        Dot => ".",
                        Name(name) => name.as_str(),
                        End => panic!("`entries` does not contain End"),
                    },
                );
                match sink_res {
                    Ok(true) => i += 1,
                    Ok(false) => return (last_retruned, Ok(())),
                    Err(GetEntryNameSinkError::NameTooLong) => {
                        panic!("sink returned NameTooLong for '{:?}'", entries[i])
                    }
                }
                last_retruned = pos.clone();
            }

            return (End, Ok(()));
        }
    }

    #[test]
    fn empty_lazy() {
        run_server_client(
            OPEN_RIGHT_READABLE,
            lazy(|_p, _sink| (AlphabeticalTraversal::End, Ok(())), |_name| Err(Status::NOT_FOUND)),
            async move |root| {
                assert_close!(root);
            },
        );
    }

    #[test]
    fn empty_lazy_get_attr() {
        run_server_client(
            OPEN_RIGHT_READABLE,
            lazy(|_p, _sink| (AlphabeticalTraversal::End, Ok(())), |_name| Err(Status::NOT_FOUND)),
            async move |root| {
                assert_get_attr!(
                    root,
                    NodeAttributes {
                        mode: MODE_TYPE_DIRECTORY | S_IRUSR,
                        id: INO_UNKNOWN,
                        content_size: 0,
                        storage_size: 0,
                        link_count: 1,
                        creation_time: 0,
                        modification_time: 0,
                    }
                );
                assert_close!(root);
            },
        );
    }

    #[test]
    fn lazy_attr_directory_get_attr() {
        run_server_client(
            OPEN_RIGHT_READABLE,
            lazy_attr(
                S_IXOTH | S_IROTH | S_IXGRP | S_IRGRP | S_IXUSR | S_IRUSR,
                |_p, _sink| (AlphabeticalTraversal::End, Ok(())),
                |_name| Err(Status::NOT_FOUND),
            ),
            async move |root| {
                assert_get_attr!(
                    root,
                    NodeAttributes {
                        mode: MODE_TYPE_DIRECTORY
                            | (S_IXOTH | S_IROTH | S_IXGRP | S_IRGRP | S_IXUSR | S_IRUSR),
                        id: INO_UNKNOWN,
                        content_size: 0,
                        storage_size: 0,
                        link_count: 1,
                        creation_time: 0,
                        modification_time: 0,
                    }
                );
                assert_close!(root);
            },
        );
    }

    #[test]
    fn static_listing() {
        let get_entry_names = build_sorted_static_get_entry_names(vec![
            (DIRENT_TYPE_FILE, "one"),
            (DIRENT_TYPE_FILE, "two"),
            (DIRENT_TYPE_FILE, "three"),
        ]);

        run_server_client(
            OPEN_RIGHT_READABLE,
            lazy(get_entry_names, |_name| Err(Status::NOT_FOUND)),
            async move |root| {
                {
                    let mut expected = DirentsSameInodeBuilder::new(INO_UNKNOWN);
                    // Note that the build_sorted_static_get_entry_names() will sort entries
                    // alphabetically when returning them, so we see a different order here.
                    expected
                        .add(DIRENT_TYPE_DIRECTORY, b".")
                        .add(DIRENT_TYPE_FILE, b"one")
                        .add(DIRENT_TYPE_FILE, b"three")
                        .add(DIRENT_TYPE_FILE, b"two");

                    assert_read_dirents!(root, 1000, expected.into_vec());
                }

                assert_close!(root);
            },
        );
    }

    #[test]
    fn static_entries() {
        let get_entry_names = build_sorted_static_get_entry_names(vec![
            (DIRENT_TYPE_FILE, "one"),
            (DIRENT_TYPE_FILE, "two"),
            (DIRENT_TYPE_FILE, "three"),
        ]);

        // Explicit type here is necessary, as rustc seems to be missing the point that
        // `PseudoFile` returned by the `read_only` call implements `DirectoryEntry`.  Yet with an
        // explicit type everything works.  It would be nice to understand why is this happening.
        let get_entry: &mut (FnMut(&str) -> Result<Box<DirectoryEntry>, Status> + Send) =
            &mut |name: &str| {
                let name = name.to_string();
                Ok(Box::new(read_only(move || {
                    let content = format!("File {} content", name);
                    Ok(content.into_bytes())
                })))
            };

        run_server_client(
            OPEN_RIGHT_READABLE,
            lazy(get_entry_names, get_entry),
            async move |root| {
                let flags = OPEN_RIGHT_READABLE | OPEN_FLAG_DESCRIBE;
                open_as_file_assert_content!(&root, flags, "one", "File one content");
                open_as_file_assert_content!(&root, flags, "two", "File two content");
                open_as_file_assert_content!(&root, flags, "three", "File three content");

                assert_close!(root);
            },
        );
    }

    #[test]
    fn static_entries_with_traversal() {
        let get_entry_names = build_sorted_static_get_entry_names(vec![
            (DIRENT_TYPE_DIRECTORY, "etc"),
            (DIRENT_TYPE_FILE, "files"),
        ]);

        // Explicit type here is necessary, as rustc seems to be missing the point that
        // `PseudoFile` returned by the `read_only` call implements `DirectoryEntry`.  Yet with an
        // explicit type everything works.  It would be nice to understand why is this happening.
        let get_entry: &mut (FnMut(&str) -> Result<Box<DirectoryEntry>, Status> + Send) =
            &mut |name: &str| match name {
                "etc" => Ok(Box::new(pseudo_directory! {
                    "fstab" => read_only(|| Ok(b"/dev/fs /".to_vec())),
                    "ssh" => pseudo_directory! {
                        "sshd_config" => read_only(|| Ok(b"# Empty".to_vec())),
                    },
                })),
                "files" => Ok(Box::new(read_only(|| Ok(b"Content".to_vec())))),
                _ => Err(Status::NOT_FOUND),
            };

        run_server_client(
            OPEN_RIGHT_READABLE,
            lazy(get_entry_names, get_entry),
            async move |root| {
                let flags = OPEN_RIGHT_READABLE | OPEN_FLAG_DESCRIBE;
                {
                    let mut expected = DirentsSameInodeBuilder::new(INO_UNKNOWN);
                    expected
                        .add(DIRENT_TYPE_DIRECTORY, b".")
                        .add(DIRENT_TYPE_DIRECTORY, b"etc")
                        .add(DIRENT_TYPE_FILE, b"files");

                    assert_read_dirents!(root, 1000, expected.into_vec());
                }

                {
                    let etc_dir = open_get_directory_proxy_assert_ok!(&root, flags, "etc");

                    let mut expected = DirentsSameInodeBuilder::new(INO_UNKNOWN);
                    expected
                        .add(DIRENT_TYPE_DIRECTORY, b".")
                        .add(DIRENT_TYPE_FILE, b"fstab")
                        .add(DIRENT_TYPE_DIRECTORY, b"ssh");

                    assert_read_dirents!(etc_dir, 1000, expected.into_vec());
                    assert_close!(etc_dir);
                }

                {
                    let ssh_dir = open_get_directory_proxy_assert_ok!(&root, flags, "etc/ssh");

                    let mut expected = DirentsSameInodeBuilder::new(INO_UNKNOWN);
                    expected.add(DIRENT_TYPE_DIRECTORY, b".").add(DIRENT_TYPE_FILE, b"sshd_config");

                    assert_read_dirents!(ssh_dir, 1000, expected.into_vec());
                    assert_close!(ssh_dir);
                }

                open_as_file_assert_content!(&root, flags, "etc/fstab", "/dev/fs /");
                open_as_file_assert_content!(&root, flags, "files", "Content");

                assert_close!(root);
            },
        );
    }

    #[test]
    fn dynamic_listing() {
        let mut listing1 = build_sorted_static_get_entry_names(vec![
            (DIRENT_TYPE_FILE, "one"),
            (DIRENT_TYPE_FILE, "two"),
        ]);
        let mut listing2 = build_sorted_static_get_entry_names(vec![
            (DIRENT_TYPE_FILE, "two"),
            (DIRENT_TYPE_FILE, "three"),
        ]);

        let get_entry_names = {
            enum Stage {
                One,
                Two,
            };
            let mut stage = Stage::One;
            move |p, sink: &mut FnMut(&EntryInfo, &str) -> Result<bool, GetEntryNameSinkError>| {
                match stage {
                    Stage::One => {
                        let (p, res) = listing1(p, sink);
                        if p == AlphabeticalTraversal::End {
                            stage = Stage::Two;
                        }
                        (p, res)
                    }
                    Stage::Two => listing2(p, sink),
                }
            }
        };

        run_server_client(
            OPEN_RIGHT_READABLE,
            lazy(get_entry_names, |_name| Err(Status::NOT_FOUND)),
            async move |root| {
                {
                    let mut expected = DirentsSameInodeBuilder::new(INO_UNKNOWN);
                    // Note that the build_sorted_static_get_entry_names() will sort entries
                    // alphabetically when returning them, so we see a different order here.
                    expected
                        .add(DIRENT_TYPE_DIRECTORY, b".")
                        .add(DIRENT_TYPE_FILE, b"one")
                        .add(DIRENT_TYPE_FILE, b"two");

                    assert_read_dirents!(root, 1000, expected.into_vec());
                }

                assert_rewind!(root);

                {
                    let mut expected = DirentsSameInodeBuilder::new(INO_UNKNOWN);
                    // Note that the build_sorted_static_get_entry_names() will sort entries
                    // alphabetically when returning them, so we see a different order here.
                    expected
                        .add(DIRENT_TYPE_DIRECTORY, b".")
                        .add(DIRENT_TYPE_FILE, b"three")
                        .add(DIRENT_TYPE_FILE, b"two");

                    assert_read_dirents!(root, 1000, expected.into_vec());
                }

                assert_close!(root);
            },
        );
    }

    #[test]
    fn dynamic_entries() {
        let get_entry_names = build_sorted_static_get_entry_names(vec![
            (DIRENT_TYPE_FILE, "file1"),
            (DIRENT_TYPE_FILE, "file2"),
        ]);

        // Explicit type here is necessary, as rustc seems to be missing the point that
        // `PseudoFile` returned by the `read_only` call implements `DirectoryEntry`.  Yet with an
        // explicit type everything works.  It would be nice to understand why is this happening.
        let get_entry: &mut (FnMut(&str) -> Result<Box<DirectoryEntry>, Status> + Send) = {
            let mut count = 0;

            &mut move |name: &str| match name {
                "file1" => {
                    count += 1;
                    Ok(Box::new(read_only(move || {
                        let content = format!("Content: {}", count);
                        Ok(content.into_bytes())
                    })))
                }
                "file2" => {
                    count += 10;
                    Ok(Box::new(read_only(move || {
                        let content = format!("Content: {}", count);
                        Ok(content.into_bytes())
                    })))
                }
                _ => Err(Status::NOT_FOUND),
            }
        };

        run_server_client(
            OPEN_RIGHT_READABLE,
            lazy(get_entry_names, get_entry),
            async move |root| {
                let flags = OPEN_RIGHT_READABLE | OPEN_FLAG_DESCRIBE;

                open_as_file_assert_content!(&root, flags, "file1", "Content: 1");
                open_as_file_assert_content!(&root, flags, "file1", "Content: 2");
                open_as_file_assert_content!(&root, flags, "file2", "Content: 12");
                open_as_file_assert_content!(&root, flags, "file2", "Content: 22");
                open_as_file_assert_content!(&root, flags, "file1", "Content: 23");

                assert_close!(root);
            },
        );
    }

    #[test]
    fn read_dirents_small_buffer() {
        let get_entry_names = build_sorted_static_get_entry_names(vec![
            (DIRENT_TYPE_DIRECTORY, "etc"),
            (DIRENT_TYPE_FILE, "files"),
            (DIRENT_TYPE_FILE, "more"),
            (DIRENT_TYPE_FILE, "uname"),
        ]);

        run_server_client(
            OPEN_RIGHT_READABLE,
            lazy(get_entry_names, |_name| Err(Status::NOT_FOUND)),
            async move |root| {
                {
                    let mut expected = DirentsSameInodeBuilder::new(INO_UNKNOWN);
                    // Entry header is 10 bytes + length of the name in bytes.
                    // (10 + 1) = 11
                    expected.add(DIRENT_TYPE_DIRECTORY, b".");
                    assert_read_dirents!(root, 11, expected.into_vec());
                }

                {
                    let mut expected = DirentsSameInodeBuilder::new(INO_UNKNOWN);
                    expected
                        // (10 + 3) = 13
                        .add(DIRENT_TYPE_DIRECTORY, b"etc")
                        // 13 + (10 + 5) = 28
                        .add(DIRENT_TYPE_FILE, b"files");
                    assert_read_dirents!(root, 28, expected.into_vec());
                }

                {
                    let mut expected = DirentsSameInodeBuilder::new(INO_UNKNOWN);
                    expected.add(DIRENT_TYPE_FILE, b"more").add(DIRENT_TYPE_FILE, b"uname");
                    assert_read_dirents!(root, 100, expected.into_vec());
                }

                assert_read_dirents!(root, 100, vec![]);
            },
        );
    }

    #[test]
    fn read_dirents_very_small_buffer() {
        let get_entry_names = build_sorted_static_get_entry_names(vec![(DIRENT_TYPE_FILE, "file")]);

        run_server_client(
            OPEN_RIGHT_READABLE,
            lazy(get_entry_names, |_name| Err(Status::NOT_FOUND)),
            async move |root| {
                // Entry header is 10 bytes, so this read should not be able to return a single entry.
                assert_read_dirents_err!(root, 8, Status::BUFFER_TOO_SMALL);

                {
                    let mut expected = DirentsSameInodeBuilder::new(INO_UNKNOWN);
                    expected.add(DIRENT_TYPE_DIRECTORY, b".").add(DIRENT_TYPE_FILE, b"file");
                    assert_read_dirents!(root, 100, expected.into_vec());
                }
            },
        );
    }
}

// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

//! Watchers handles a list of watcher connections attached to a directory.  Watchers as described
//! in io.fidl.

use {
    failure::Fail,
    fidl_fuchsia_io::{
        WatchedEvent, MAX_FILENAME, WATCH_EVENT_EXISTING, WATCH_EVENT_IDLE, WATCH_MASK_EXISTING,
        WATCH_MASK_IDLE,
    },
    fuchsia_async::Channel,
    fuchsia_zircon::MessageBuf,
    futures::{task::Waker, Poll},
    std::iter,
};

/// Type of the errors that might be generated by the [`Watchers::add`] method.
#[derive(Debug, Fail)]
pub enum WatchersAddError {
    /// Provided name of an entry was longer than MAX_FILENAME bytes.  Watcher connection will be
    /// dropped.
    #[fail(display = "Provided entry name exceeds MAX_FILENAME bytes")]
    NameTooLong,
    /// FIDL communication error.  Failure occured while trying to send initial events to the newly
    /// connected watcher.  Watcher connection will be dropped.
    #[fail(display = "Error sending initial list of entries due to a FIDL error")]
    FIDL(fidl::Error),
}

/// Type of the errors that might be generated when trying to send new event to watchers.
#[derive(Debug, Fail)]
pub enum WatchersSendError {
    /// Provided name of an entry was longer than MAX_FILENAME bytes.
    #[fail(display = "Provided entry name exceeds MAX_FILENAME bytes")]
    NameTooLong,
}

/// Wraps all watcher connections observing one directory.  The directory is responsible for
/// calling [`send_event`], [`remove_dead`] and [`add`] methods when appropriate to make sure
/// watchers are observing a consistent view.
pub struct Watchers {
    connections: Vec<WatcherConnection>,
}

impl Watchers {
    /// Constructs a new Watchers instance with no connected watchers.
    pub fn new() -> Self {
        Watchers { connections: Vec::new() }
    }

    pub fn add(
        &mut self,
        names: &mut Iterator<Item = &str>,
        mask: u32,
        channel: Channel,
    ) -> Result<(), WatchersAddError> {
        let conn = WatcherConnection::new(mask, channel);

        conn.send_events_existing(names)?;
        conn.send_event_idle()?;

        self.connections.push(conn);
        Ok(())
    }

    /// Informs all the connected watchers about the specified event.  While `mask` and `event`
    /// carry the same information, as they are represented by `WATCH_MASK_*` and `WATCH_EVENT_*`
    /// constants in io.fidl, it is easier when both forms are provided.  `mask` is used to filter
    /// out those watchers that did not request for observation of this event and `event` is used
    /// to construct the event object.  The method will operate correctly only if `mask` and
    /// `event` match.
    ///
    /// In case of a communication error with any of the watchers, connection to this watcher is
    /// closed.
    pub fn send_event(
        &mut self,
        mask: u32,
        event: u8,
        name: &str,
    ) -> Result<(), WatchersSendError> {
        if name.len() >= MAX_FILENAME as usize {
            return Err(WatchersSendError::NameTooLong);
        }

        self.connections.retain(|watcher| match watcher.send_event_check_mask(mask, event, name) {
            Ok(()) => true,
            Err(ConnectionSendError::NameTooLong) => {
                // This assertion is never expected to trigger as we checked the name length above.
                // It should indicate some kind of bug in the send_event_check_mask() logic.
                panic!(
                    "send_event_check_mask() returned NameTooLong.\n\
                     Max length in bytes: {}\n\
                     Name length: '{}'\n\
                     Name: '{}'",
                    MAX_FILENAME,
                    name.len(),
                    name
                );
            }
            Err(ConnectionSendError::FIDL(_)) => false,
        });

        Ok(())
    }

    pub fn remove_dead(&mut self, lw: &Waker) {
        self.connections.retain(|watcher| !watcher.is_dead(lw));
    }

    pub fn has_connections(&self) -> bool {
        self.connections.len() != 0
    }
}

struct WatcherConnection {
    mask: u32,
    channel: Channel,
}

/// Type of the errors that may occure when trying to send a message over one connection.
enum ConnectionSendError {
    /// Provided name was longer than MAX_FILENAME bytes.
    NameTooLong,
    /// FIDL communication error.
    FIDL(fidl::Error),
}

impl From<ConnectionSendError> for WatchersAddError {
    fn from(err: ConnectionSendError) -> WatchersAddError {
        match err {
            ConnectionSendError::NameTooLong => WatchersAddError::NameTooLong,
            ConnectionSendError::FIDL(err) => WatchersAddError::FIDL(err),
        }
    }
}

impl From<fidl::Error> for ConnectionSendError {
    fn from(err: fidl::Error) -> ConnectionSendError {
        ConnectionSendError::FIDL(err)
    }
}

impl WatcherConnection {
    fn new(mask: u32, channel: Channel) -> Self {
        WatcherConnection { mask, channel }
    }

    /// A helper used by other send_event*() methods.  Sends a collection of
    /// fidl_fuchsia_io::WatchEvent instances over this watcher connection.  Will check to make
    /// sure that `name` fields in the [`WatchedEvent`] instances do not exceed [`MAX_FILENAME`].
    /// Will skip those entries where `name` exceeds the [`MAX_FILENAME`] bytes and will return
    /// [`ConnectionSendError::NameTooLong`] error in that case.
    /// `len` field should be `0`, it will be set to be equal to the length of the `name` field.
    fn send_event_structs(
        &self,
        events: &mut Iterator<Item = WatchedEvent>,
    ) -> Result<(), ConnectionSendError> {
        // Unfortunately, io.fidl currently does not provide encoding for the watcher events.
        // Seems to be due to
        //
        //     https://fuchsia.atlassian.net/browse/ZX-2645
        //
        // As soon as that is fixed we should switch to the generated binding.
        //
        // For now this code duplicates what the C++ version is doing:
        //
        //     https://fuchsia.googlesource.com/zircon/+/1dcb46aa1c4001e9d1d68b8ff5d8fae0c00fbb49/system/ulib/fs/watcher.cpp
        //
        // There is no Transaction wrapping the messages, as for the full blown FIDL events.

        let mut res = Ok(());

        let buffer = &mut vec![];
        let (bytes, handles) = (&mut vec![], &mut vec![]);
        for mut event in events {
            // Make an attempt to send as many names as possible, skipping those that exceed the
            // limit.
            if event.name.len() >= MAX_FILENAME as usize {
                if res.is_ok() {
                    res = Err(ConnectionSendError::NameTooLong);
                }
                continue;
            }

            // `len` has to match the length of the `name` field.  There is no reason to allow the
            // caller to specify anything but 0 here.  We make sure `name` is bounded above, and
            // now we can actually calculate correct value for `len`.
            assert_eq!(event.len, 0);
            event.len = event.name.len() as u8;

            // Keep bytes and handles across loop iterations, to reduce reallocations.
            bytes.clear();
            handles.clear();
            fidl::encoding::Encoder::encode(bytes, handles, &mut event)
                .map_err(ConnectionSendError::FIDL)?;
            if handles.len() > 0 {
                panic!("WatchedEvent struct is not expected to contain any handles")
            }

            if buffer.len() + bytes.len() >= fidl_fuchsia_io::MAX_BUF as usize {
                self.channel
                    .write(&*buffer, &mut vec![])
                    .map_err(fidl::Error::ServerResponseWrite)?;

                buffer.clear();
            }

            buffer.append(bytes);
        }

        if buffer.len() > 0 {
            self.channel.write(&*buffer, &mut vec![]).map_err(fidl::Error::ServerResponseWrite)?;
        }

        res
    }

    /// Constructs and sends a fidl_fuchsia_io::WatchEvent instance over the watcher connection.
    ///
    /// `event` is one of the WATCH_EVENT_* constants, with the values used to populate the `event`
    /// field.
    fn send_event(&self, event: u8, name: &str) -> Result<(), ConnectionSendError> {
        self.send_event_structs(&mut iter::once(WatchedEvent {
            event,
            len: 0,
            name: name.as_bytes().to_vec(),
        }))
    }

    /// Constructs and sends a fidl_fuchsia_io::WatchEvent instance over the watcher connection,
    /// skipping the operation if the watcher did not request this kind of events to be delivered -
    /// filtered by the mask value.
    fn send_event_check_mask(
        &self,
        mask: u32,
        event: u8,
        name: &str,
    ) -> Result<(), ConnectionSendError> {
        if self.mask & mask == 0 {
            return Ok(());
        }

        self.send_event(event, name)
    }

    /// Sends one fidl_fuchsia_io::WatchEvent instance of type WATCH_EVENT_EXISTING, for every name
    /// in the list.  If the watcher has requested this kind of events - similar to to
    /// [`send_event_check_mask`] above, but with a predefined mask and event type.
    fn send_events_existing(
        &self,
        names: &mut Iterator<Item = &str>,
    ) -> Result<(), ConnectionSendError> {
        if self.mask & WATCH_MASK_EXISTING == 0 {
            return Ok(());
        }

        self.send_event_structs(&mut names.map(|name| WatchedEvent {
            event: WATCH_EVENT_EXISTING,
            len: 0,
            name: name.as_bytes().to_vec(),
        }))
    }

    /// Sends one instance of fidl_fuchsia_io::WatchEvent of type WATCH_MASK_IDLE.  If the watcher
    /// has requested this kind of events - similar to to [`send_event_check_mask`] above, but with
    /// the predefined mask and event type.
    fn send_event_idle(&self) -> Result<(), ConnectionSendError> {
        if self.mask & WATCH_MASK_IDLE == 0 {
            return Ok(());
        }

        self.send_event(WATCH_EVENT_IDLE, "")
    }

    /// Checks if the watcher has closed the connection.  And sets the waker to trigger when the
    /// connection is closed if it was still opened during the call.
    fn is_dead(&self, lw: &Waker) -> bool {
        let channel = &self.channel;

        if channel.is_closed() {
            return true;
        }

        // Make sure we will be notified when the watcher has closed its connected or when any
        // message is send.
        //
        // We are going to close the connection when we receive any message as this is currently an
        // error.  When we fix ZX-2645 and wrap the watcher connection with FIDL, it would be up to
        // the binding code to fail on any unexpected messages.  At that point we can switch to
        // fuchsia_async::OnSignals and only monitor for the close event.
        //
        // We rely on [`Channel::recv_from()`] to invoke [`Channel::poll_read()`], which would call
        // [`RWHandle::poll_read()`] that would set the signal mask to `READABLE | CLOSE`.
        let mut msg = MessageBuf::new();
        match channel.recv_from(&mut msg, lw) {
            // We are not expecting any messages.  Returning true would cause this watcher
            // connection to be dropped and closed as a result.
            Poll::Ready(_) => true,
            // Poll::Pending is actually the only value we are expecting to see from a watcher that
            // did not close it's side of the connection.  And when the connection is closed, we
            // are expecting Poll::Ready(Err(Status::PEER_CLOSED.into_raw())), but that is covered
            // by the case above.
            Poll::Pending => false,
        }
    }
}

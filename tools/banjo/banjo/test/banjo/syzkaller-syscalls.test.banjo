// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

library banjo.examples.syzkaller.syscalls;

//
//
// Time
//
//

enum zx_clock_id : zx.clock {
    ZX_CLOCK_MONOTONIC = 0;
    ZX_CLOCK_UTC = 1;
    ZX_CLOCK_THREAD = 2;
};

//
//
// System information
//
//

enum zx_feature_kind : uint32 {
    ZX_FEATURE_KIND_CPU = 0;
    ZX_FEATURE_KIND_HW_BREAKPOINT_COUNT = 1;
    ZX_FEATURE_KIND_HW_WATCHPOINT_COUNT = 2;
};

//
//
// Abstraction of machine operations
//
//

enum zx_cache_flush_options : uint32 {
    ZX_CACHE_FLUSH_DATA = 1;        // 1u << 0
    ZX_CACHE_FLUSH_INVALIDATE = 2;  // 1u << 1
    ZX_CACHE_FLUSH_INSN = 4;        // 1u << 2
};

//
//
// Generic handle operations
//
//

enum zx_rights_options : zx.rights {
    ZX_RIGHT_NONE = 0;                  // 0u
    ZX_RIGHT_DUPLICATE = 1;             // 1u << 0
    ZX_RIGHT_TRANSFER = 2;              // 1u << 1
    ZX_RIGHT_READ = 4;                  // 1u << 2
    ZX_RIGHT_WRITE = 8;                 // 1u << 3
    ZX_RIGHT_EXECUTE = 16;              // 1u << 4
    ZX_RIGHT_MAP = 32;                  // 1u << 5
    ZX_RIGHT_GET_PROPERTY = 64;         // 1u << 6
    ZX_RIGHT_SET_PROPERTY = 128;        // 1u << 7
    ZX_RIGHT_ENUMERATE = 256;           // 1u << 8
    ZX_RIGHT_DESTROY = 512;             // 1u << 9
    ZX_RIGHT_SET_POLICY = 1024;         // 1u << 10
    ZX_RIGHT_GET_POLICY = 2048;         // 1u << 11
    ZX_RIGHT_SIGNAL = 4096;             // 1u << 12
    ZX_RIGHT_SIGNAL_PEER = 8192;        // 1u << 13
    ZX_RIGHT_WAIT = 16384;              // 1u << 14
    ZX_RIGHT_INSPECT = 32768;           // 1u << 15
    ZX_RIGHT_MANAGE_JOB = 65536;        // 1u << 16
    ZX_RIGHT_MANAGE_PROCESS = 131072;   // 1u << 17
    ZX_RIGHT_MANAGE_THREAD = 262144;    // 1u << 18
    ZX_RIGHT_APPLY_PROFILE = 524288;    // 1u << 19
    ZX_RIGHT_SAME_RIGHTS = 2147483648;  // 1u << 31
};

//
//
// Generic object operations
//
//

enum zx_object_info_topics : uint32 {
    ZX_INFO_NONE = 0;
    ZX_INFO_HANDLE_VALID = 1;
    ZX_INFO_HANDLE_BASIC = 2;
    ZX_INFO_PROCESS = 3;
    ZX_INFO_PROCESS_THREADS = 4;
    ZX_INFO_VMAR = 7;
    ZX_INFO_JOB_CHILDREN = 8;
    ZX_INFO_JOB_PROCESSES = 9;
    ZX_INFO_THREAD = 10;
    ZX_INFO_THREAD_EXCEPTION_REPORT = 11;
    ZX_INFO_TASK_STATS = 12;
    ZX_INFO_PROCESS_MAPS = 13;
    ZX_INFO_PROCESS_VMOS = 14;
    ZX_INFO_THREAD_STATS = 15;
    ZX_INFO_CPU_STATS = 16;
    ZX_INFO_KMEM_STATS = 17;
    ZX_INFO_RESOURCE = 18;
    ZX_INFO_HANDLE_COUNT = 19;
    ZX_INFO_BTI = 20;
    ZX_INFO_PROCESS_HANDLE_STATS = 21;
    ZX_INFO_SOCKET = 22;
    ZX_INFO_VMO = 23;
    ZX_INFO_JOB = 24;
};

// 1-1 mapping with object_info_topics
[argtype = "type1 OUT",
 argtype = "type2 OUT",
 argtype = "type3 OUT",
 argtype = "type4 OUT",
 argtype = "type5 OUT",
 argtype = "type6 OUT",
 argtype = "type7 OUT",
 argtype = "type8 OUT",
 argtype = "type9 OUT",
 argtype = "type10 OUT",
 argtype = "type11 OUT"
 argtype = "type12 OUT",
 argtype = "type13 OUT",
 argtype = "type14 OUT",
 argtype = "type15 OUT",
 argtype = "type16 OUT",
 argtype = "type17 OUT",
 argtype = "type18 OUT",
 argtype = "type19 OUT",
 argtype = "type20 OUT",
 argtype = "type21 OUT",
 argtype = "type22 OUT",
 const = "type1 0",
 const = "type2 0"]
union zx_object_info_types {
    array<int32>:1 type1;
    array<int32>:1 type2;
    array<zx_info_handle_basic>:1 type3;
    array<zx_info_process>:1 type4;
    array<zx.koid>:unknown type5;
    array<zx_info_vmar>:1 type6;
    array<zx.koid>:unknown type6;
    array<zx.koid>:unknown type7;
    array<zx_info_thread>:1 type8;
    array<zx_exception_report>:1 type9;
    array<zx_info_task_stats>:1 type10;
    array<zx_info_maps>:unknown type11;
    array<zx_info_vmo>:unknown type12;
    array<zx_info_thread_stats>:1 type13;
    array<zx_info_cpu_stats>:unknown type14;
    array<zx_info_kmem_stats>:1 type15;
    array<zx_info_resource>:1 type16;
    array<zx_info_handle_count>:1 type17;
    array<zx_info_bti>:1 type18;
    array<zx_info_process_handle_stats>:1 type19;
    array<zx_info_socket>:1 type20;
    array<zx_info_vmo>:1 type21;
    array<zx_info_job>:1 type22;
};

// TODO: conditional declaration
enum zx_object_property_values : uint32 {
    ZX_PROP_NAME = 3;
    // if __x86_64__
    ZX_PROP_REGISTER_GS = 2;
    ZX_PROP_REGISTER_FS = 4;
    // #endif
    ZX_PROP_PROCESS_DEBUG_ADDR = 5;
    ZX_PROP_PROCESS_VDSO_BASE_ADDRESS = 6;
    ZX_PROP_SOCKET_RX_THRESHOLD = 12;
    ZX_PROP_SOCKET_TX_THRESHOLD = 13;
    ZX_PROP_JOB_KILL_ON_OOM = 15;
    ZX_PROP_EXCEPTION_STATE = 16;
};

enum zx_obj_props : uint32 {
    ZX_OBJ_PROP_NONE = 0;
    ZX_OBJ_PROP_WAITABLE = 1;
};

enum zx_obj_types : uint32 {
    ZX_OBJ_TYPE_NONE = 0;
    ZX_OBJ_TYPE_PROCESS = 1;
    ZX_OBJ_TYPE_THREAD = 2;
    ZX_OBJ_TYPE_VMO = 3;
    ZX_OBJ_TYPE_CHANNEL = 4;
    ZX_OBJ_TYPE_EVENT = 5;
    ZX_OBJ_TYPE_PORT = 6;
    ZX_OBJ_TYPE_INTERRUPT = 9;
    ZX_OBJ_TYPE_PCI_DEVICE = 11;
    ZX_OBJ_TYPE_LOG = 12;
    ZX_OBJ_TYPE_SOCKET = 14;
    ZX_OBJ_TYPE_RESOURCE = 15;
    ZX_OBJ_TYPE_EVENTPAIR = 16;
    ZX_OBJ_TYPE_JOB = 17;
    ZX_OBJ_TYPE_VMAR = 18;
    ZX_OBJ_TYPE_FIFO = 19;
    ZX_OBJ_TYPE_GUEST = 20;
    ZX_OBJ_TYPE_VCPU = 21;
    ZX_OBJ_TYPE_TIMER = 22;
    ZX_OBJ_TYPE_IOMMU = 23;
    ZX_OBJ_TYPE_BTI = 24;
    ZX_OBJ_TYPE_PROFILE = 25;
    ZX_OBJ_TYPE_PMT = 26;
    ZX_OBJ_TYPE_SUSPEND_TOKEN = 27;
    ZX_OBJ_TYPE_PAGER = 28;
    ZX_OBJ_TYPE_EXCEPTION = 29;
};

// TODO: get rid of valueset
[valueset = "props zx_obj_props",
 valueset = "type zx_obj_types"]
struct zx_info_handle_basic {
    zx.koid koid;
    zx.rights rights;
    zx_obj_types type;
    zx.koid related_koid;
    zx_obj_props props;
};

struct zx_info_handle_count {
    uint32 handle_count;
};

[argtype = "handle_count OUT"]
struct zx_info_process_handle_stats {
    array<uint32>:64 handle_count; // #define ZX_OBJ_TYPE_UPPER_BOUND ((zx_obj_type_t)64u)
};

struct zx_info_process {
    int64 return_code;
    bool started;
    bool exited;
    bool debugger_attached;
};

struct zx_info_job {
    int64 return_code;
    bool exited;
    bool kill_on_oom;
    bool debugger_attached;
};

enum zx_thread_state_values : uint32 {
    ZX_THREAD_STATE_NEW = 0;                    // 0x0000u
    ZX_THREAD_STATE_RUNNING = 1;                // 0x0001u
    ZX_THREAD_STATE_SUSPENDED = 2;              // 0x0002u
    ZX_THREAD_STATE_BLOCKED = 3;                // 0x0003u
    ZX_THREAD_STATE_DYING = 4;                  // 0x0004u
    ZX_THREAD_STATE_DEAD = 5;                   // 0x0005u
    ZX_THREAD_STATE_BLOCKED_EXCEPTION = 259;    // 0x0103u
    ZX_THREAD_STATE_BLOCKED_SLEEPING = 515;     // 0x0203u
    ZX_THREAD_STATE_BLOCKED_FUTEX = 771;        // 0x0303u
    ZX_THREAD_STATE_BLOCKED_PORT = 1027;        // 0x0403u
    ZX_THREAD_STATE_BLOCKED_CHANNEL = 1283;     // 0x0503u
    ZX_THREAD_STATE_BLOCKED_WAIT_ONE = 1539;    // 0x0603u
    ZX_THREAD_STATE_BLOCKED_WAIT_MANY = 1795;   // 0x0703u
    ZX_THREAD_STATE_BLOCKED_INTERRUPT = 2051;   // 0x0803u
    ZX_THREAD_STATE_BLOCKED_PAGER = 2307;       // 0x0903u
};

enum zx_exception_channel_types : uint32 {
    ZX_EXCEPTION_CHANNEL_TYPE_NONE = 0;
    ZX_EXCEPTION_CHANNEL_TYPE_DEBUGGER = 1;
    ZX_EXCEPTION_CHANNEL_TYPE_THREAD = 2;
    ZX_EXCEPTION_CHANNEL_TYPE_PROCESS = 3;
    ZX_EXCEPTION_CHANNEL_TYPE_JOB = 4;
    ZX_EXCEPTION_CHANNEL_TYPE_JOB_DEBUGGER = 5;
};

enum zx_exception_port_types : uint32 {
    ZX_EXCEPTION_PORT_TYPE_NONE = 0;
    ZX_EXCEPTION_PORT_TYPE_DEBUGGER = 1;
    ZX_EXCEPTION_PORT_TYPE_THREAD = 2;
    ZX_EXCEPTION_PORT_TYPE_PROCESS = 3;
    ZX_EXCEPTION_PORT_TYPE_JOB = 4;
    ZX_EXCEPTION_PORT_TYPE_JOB_DEBUGGER = 5;
};


// TODO: get rid of valueset
// TODO: anonymous union
[valueset = "state zx_thread_state_values"]
struct zx_info_thread {
    zx_thread_state_values state;
    //[valueset = "wait_exception_channel_type zx_exception_channel_types",
    //valueset = "wait_exception_port_type zx_exception_port_types"]
    //union {
        //zx_exception_channel_types wait_exception_channel_type;
        //zx_exception_port_types wait_exception_port_type;
    //};
};

struct zx_info_thread_stats {
    zx.duration total_runtime;
};

struct zx_info_task_stats {
    usize mem_mapped_bytes;
    usize mem_private_bytes;
    usize mem_shared_bytes;
    usize mem_scaled_shared_bytes;
};

struct zx_info_vmar {
    usize base;     // uintptr_t base;
    usize len;
};

struct zx_info_bti {
    uint64 minimum_contiguity;
    uint64 aspace_size;
};

[valueset = "options zx_socket_create_options"]
struct zx_info_socket {
    zx_socket_create_options options;
    usize rx_buf_max;
    usize rx_buf_size;
    usize rx_buf_available;
    usize tx_buf_max;
    usize tx_buf_size;
};

struct zx_info_maps_mapping {
    zx.vm_option mmu_flags;
    zx.koid vmo_koid;
    uint64 vmo_offset;
    usize committed_pages;
};

enum zx_info_maps_type_vals : uint32 {
    ZX_INFO_MAPS_TYPE_NONE = 0;
    ZX_INFO_MAPS_TYPE_ASPACE = 1;
    ZX_INFO_MAPS_TYPE_VMAR = 2;
    ZX_INFO_MAPS_TYPE_MAPPING = 3;
};

// TODO: get rid of valueset
// TODO: nested named union
[valueset = "type zx_info_maps_type_vals",
 argtype = "name IN"]
struct zx_info_maps {
    // TODO: #define ZX_MAX_NAME_LEN ((size_t)32u)
    array<int8>:32 name;
    zx.vaddr base;
    usize size;
    usize depth;
    zx_info_maps_type_vals type;
    //union {
        //zx_info_maps_mapping mapping;
    //} u;
};

enum zx_cache_policy_options {
    ZX_CACHE_POLICY_CACHED = 0;
    ZX_CACHE_POLICY_UNCACHED = 1;
    ZX_CACHE_POLICY_UNCACHED_DEVICE = 2;
    ZX_CACHE_POLICY_WRITE_COMBINING = 3;
    ZX_CACHE_POLICY_MASK = 3;
};

// TODO: bitwise or of flag values also needed
enum zx_info_vmo_type_vals : uint32 {
    ZX_INFO_VMO_TYPE_PAGED = 1;     // 1u << 0
    ZX_INFO_VMO_TYPE_PHYSICAL = 0;  // 0u << 0
    ZX_INFO_VMO_RESIZABLE = 2;      // 1u << 1
    ZX_INFO_VMO_IS_COW_CLONE = 4;   // 1u << 2
    ZX_INFO_VMO_VIA_HANDLE = 8;     // 1u << 3
    ZX_INFO_VMO_VIA_MAPPING = 16;   // 1u << 4
    ZX_INFO_VMO_PAGER_BACKED = 32;  // 1u << 5
    ZX_INFO_VMO_CONTIGUOUS = 64;    // 1u << 6
};

// TODO: get rid of valueset
[valueset = "cache_policy zx_cache_policy_options",
 valueset = "flags zx_info_vmo_type_vals",
 argtype = "name IN"]
struct zx_info_vmo {
    zx.koid koid;
    // TODO: #define ZX_MAX_NAME_LEN ((size_t)32u)
    array<int8>:32 name;
    uint64 size_bytes;
    zx.koid parent_koid;
    usize num_children;
    usize num_mappings;
    usize share_count;
    zx_info_vmo_type_vals flags;
    uint64 committed_bytes;
    zx.rights handle_rights;
    zx_cache_policy_options cache_policy;
};

struct zx_info_cpu_stats {
    uint32 cpu_number;
    uint32 flags;
    zx.duration idle_time;
    uint64 reschedules;
    uint64 context_switches;
    uint64 irq_preempts;
    uint64 preempts;
    uint64 yields;
    uint64 ints;
    uint64 timer_ints;
    uint64 timers;
    uint64 page_faults;
    uint64 exceptions;
    uint64 syscalls;
    uint64 reschedule_ipis;
    uint64 generic_ipis;
};

struct zx_info_kmem_stats {
    uint64 total_bytes;
    uint64 free_bytes;
    uint64 wired_bytes;
    uint64 total_heap_bytes;
    uint64 free_heap_bytes;
    uint64 vmo_bytes;
    uint64 mmu_overhead_bytes;
    uint64 ipc_bytes;
    uint64 other_bytes;
};

[valuset = "kind zx_rsrc_kind_vals",
 argtype = "name IN"]
struct zx_info_resource {
    zx_rsrc_kind_vals kind;
    uint32 flags;
    uint64 base;
    usize size;
    // TODO: #define ZX_MAX_NAME_LEN ((size_t)32u)
    array<int8>:32 name;
};

struct zx_wait_item {
    handle handle;
    zx.signals waitfor;
    zx.signals pending;
};

struct zx_exception_header {
    uint32 size;
    uint32 type; // zx_excp_type_t type;
};

struct zx_x86_64_exc_data {
    uint64 vector;
    uint64 err_code;
    uint64 cr2;
};

struct zx_arm64_exc_data {
    uint32 esr;
    uint64 far;
};

struct zx_exception_context {
    //struct {
        //union {
            //zx_x86_64_exc_data x86_64;
            //zx_arm64_exc_data  arm_64;
        //} u;
    //} arch;
};

struct zx_exception_report {
    zx_exception_header header;
    zx_exception_context context;
};

//
//
// IPC: Sockets
//
//

enum zx_socket_create_options : uint32 {
    ZX_SOCKET_STREAM = 0;       // 0u
    ZX_SOCKET_DATAGRAM = 1;     // 1u << 0
    ZX_SOCKET_HAS_CONTROL = 2;  // 1u << 1
    ZX_SOCKET_HAS_ACCEPT = 4;   // 1u << 2
};

enum zx_socket_read_options : uint32 {
    ZX_SOCKET_CONTROL = 4;  // 1u << 2
    ZX_SOCKET_PEEK = 8;     // 1u << 3
};

enum zx_socket_write_options : uint32 {
    ZX_SOCKET_CONTROL = 4;  // 1u << 2

};

enum zx_socket_shutdown_options : uint32 {
    ZX_SOCKET_SHUTDOWN_WRITE = 1;   // 1u << 0
    ZX_SOCKET_SHUTDOWN_READ = 2;    // 1u << 1
};


//
//
// Threads
//
//

enum thread_state_kind : uint32 {
    ZX_THREAD_STATE_GENERAL_REGS = 0;
    ZX_THREAD_STATE_FP_REGS = 1;
    ZX_THREAD_STATE_VECTOR_REGS = 2;
    ZX_THREAD_STATE_DEBUG_REGS = 4;
    ZX_THREAD_STATE_SINGLE_STEP = 5;
    ZX_THREAD_X86_REGISTER_FS = 6;
    ZX_THREAD_X86_REGISTER_GS = 7;
};

// 1-1 mapping with thread_state_kind
[argtype = "type1 OUT",
 argtype = "type2 OUT",
 argtype = "type3 OUT",
 argtype = "type4 OUT",
 argtype = "type5 OUT",
 argtype = "type6 OUT",
 argtype = "type7 OUT"]
union zx_thread_read_state_types {
    array<zx_thread_state_general_regs>:1 type1;
    array<zx_thread_state_fp_regs>:1 type2;
    array<zx_thread_state_vector_regs>:1 type3;
    array<zx_thread_state_debug_regs>:1 type4;
    array<uint32>:1 type5;
    array<uint32>:1 type6;
    array<uint32>:1 type7;
};

// 1-1 mapping with thread_state_kind
[argtype = "type1 IN",
 argtype = "type2 IN",
 argtype = "type3 IN",
 argtype = "type4 IN",
 argtype = "type5 IN",
 argtype = "type6 IN",
 argtype = "type7 IN"]
union zx_thread_write_state_types {
    array<zx_thread_state_general_regs>:1 type1;
    array<zx_thread_state_fp_regs>:1 type2;
    array<zx_thread_state_vector_regs>:1 type3;
    array<zx_thread_state_debug_regs>:1 type4;
    array<uint32>:1 type5;
    array<uint32>:1 type6;
    array<uint32>:1 type7;
};

// TODO: conditional declaration
//#if defined(__x86_64__)
struct zx_thread_state_general_regs {
    uint64 rax;
    uint64 rbx;
    uint64 rcx;
    uint64 rdx;
    uint64 rsi;
    uint64 rdi;
    uint64 rbp;
    uint64 rsp;
    uint64 r8;
    uint64 r9;
    uint64 r10;
    uint64 r11;
    uint64 r12;
    uint64 r13;
    uint64 r14;
    uint64 r15;
    uint64 rip;
    uint64 rflags;
    uint64 fs_base;
    uint64 gs_base;
};

struct zx_thread_state_fp_regs {
    uint16 fcw; // Control word.
    uint16 fsw; // Status word.
    uint8 ftw;  // Tag word.
    uint8 reserved;
    uint16 fop; // Opcode.
    uint64 fip; // Instruction pointer.
    uint64 fdp; // Data pointer.
    //__ALIGNED(16)
    //struct {
        //uint64 low;
        //uint64 high;
    //} st[8];
};


[argtype = "opmask IN"]
struct zx_thread_state_vector_regs {
    //struct {
        //uint64 v[8];
    //} zmm[32];
    array<uint64>:8 opmask;
    uint32 mxcsr;
};

[argtype = "dr IN"]
struct zx_thread_state_debug_regs {
    array<uint64>:4 dr;
    uint64 dr6;
    uint64 dr7;
    uint64 dr6_status;
    uint64 dr7_control;
};

//#elif defined(__aarch64__)
//#endif

//
//
// Jobs
//
//

enum zx_job_policy_options : uint32 {
    ZX_JOB_POL_RELATIVE = 0;
    ZX_JOB_POL_ABSOLUTE = 1;
};

enum zx_job_policy_topic : uint32 {
    ZX_JOB_POL_BASIC = 0;
    ZX_JOB_POL_TIMER_SLACK = 1;
};

// 1-1 mapping with zx_job_policy_topic
[argtype = "type1 IN",
 argtype = "type2 IN"]
union zx_job_policy_types {
    array<zx_policy_basic>:1 type1;
    array<zx_policy_timer_slack>:1 type2;
};

struct zx_policy_basic {
    uint32 condition;
    uint32 policy;
};

struct zx_policy_timer_slack {
    zx.duration min_slack;
    uint32 default_mode;
};

enum zx_job_policy_conditions : uint32 {
    ZX_POL_BAD_HANDLE = 0;
    ZX_POL_WRONG_OBJECT = 1;
    ZX_POL_VMAR_WX = 2;
    ZX_POL_NEW_ANY = 3;
    ZX_POL_NEW_VMO = 4;
    ZX_POL_NEW_CHANNEL = 5;
    ZX_POL_NEW_EVENT = 6;
    ZX_POL_NEW_EVENTPAIR = 7;
    ZX_POL_NEW_PORT = 8;
    ZX_POL_NEW_SOCKET = 9;
    ZX_POL_NEW_FIFO = 10;
    ZX_POL_NEW_TIMER = 11;
    ZX_POL_NEW_PROCESS = 12;
    ZX_POL_NEW_PROFILE = 13;
    ZX_POL_AMBIENT_MARK_VMO_EXEC = 14;
    // #ifdef _KERNEL
    //ZX_POL_MAX = 15;
    // #endif
};

enum zx_job_policy_actions : uint32 {
    ZX_POL_ACTION_ALLOW = 0;
    ZX_POL_ACTION_DENY = 1;
    ZX_POL_ACTION_ALLOW_EXCEPTION = 2;
    ZX_POL_ACTION_DENY_EXCEPTION = 3;
    ZX_POL_ACTION_KILL = 4;
    // #ifdef _KERNEL
    //ZX_POL_ACTION_MAX = 5;
    // #endif
};

//
//
// Synchronization
//
//

// TODO: declare ZX_EVENT_DEFAULT in headers
enum zx_event_create_options : uint32 {
    ZX_EVENT_DEFAULT = 0;
};

// TODO: declare ZX_EVENTPAIR_DEFAULT in headers
enum zx_eventpair_create_options : uint32 {
    ZX_EVENTPAIR_DEFAULT = 0;
};

//
//
// Ports
//
//

// TODO: declare ZX_PORT_DEFAULT in headers
enum zx_port_create_options : uint32 {
    ZX_PORT_DEFAULT = 0;
    ZX_PORT_BIND_TO_INTERRUPT = 1;  // 0x1u << 0

};

enum zx_port_packet_type : uint32 {
    ZX_PKT_TYPE_USER = 0;           // 0x00u
    ZX_PKT_TYPE_SIGNAL_ONE = 1;     // 0x01u
    ZX_PKT_TYPE_SIGNAL_REP = 2;     // 0x02u
    ZX_PKT_TYPE_GUEST_BELL = 3;     // 0x03u
    ZX_PKT_TYPE_GUEST_MEM = 4;      // 0x04u
    ZX_PKT_TYPE_GUEST_IO = 5;       // 0x05u
    ZX_PKT_TYPE_GUEST_VCPU = 6;     // 0x06u
    ZX_PKT_TYPE_INTERRUPT = 7;      // 0x07u
    ZX_PKT_TYPE_PAGE_REQUEST = 9;   // 0x09u
};

[argtype = "u64 IN",
 argtype = "u32 IN",
 argtype = "u16 IN",
 argtype = "c8 IN"]
union zx_packet_user {
    array<uint64>:4 u64;
    array<uint32>:8 u32;
    array<uint16>:16 u16;
    array<int8>:32 c8;
};

struct zx_packet_signal {
    zx.signals trigger;
    zx.signals observed;
    uint64 count;
    uint64 reserved0;
    uint64 reserved1;
};

struct zx_packet_exception {
    uint64 pid;
    uint64 tid;
    uint64 reserved0;
    uint64 reserved1;
};

struct zx_packet_guest_bell {
    zx.gpaddr addr;
    uint64 reserved0;
    uint64 reserved1;
    uint64 reserved2;
};

// TODO: conditional declaration
[argtype = "inst_buf IN",
 argtype = "reserved IN"]
struct zx_packet_guest_mem {
    zx.gpaddr addr;
//#if __aarch64__
    //uint8 access_size;
    //bool sign_extend;
    //uint8 xt;
    //bool read;
    //uint64 data;
    //uint64 reserved;
//#elif __x86_64__
    uint8 inst_len;
    array<int8>:15 inst_buf;
    uint8 default_operand_size;
    array<uint8>:7 reserved;
//#endif
};

// TODO: anonymous union
struct zx_packet_guest_io {
    uint16 port;
    uint8 access_size;
    bool input;
    //union {
        //uint8 u8;
        //uint16 u16;
        //uint32 u32;
        //array<uint8>:4 data;
    //};
    uint64 reserved0;
    uint64 reserved1;
    uint64 reserved2;
};

// TODO: anonymous union
struct zx_packet_guest_vcpu {
    //union {
        //struct {
            //uint64 mask;
            //uint8 vector;
        //} interrupt;
        //struct {
            //uint64 id;
            //zx.gpaddr entry;
        //} startup;
    //};
    uint8 type;
    uint64 reserved;
};

struct zx_packet_interrupt {
    zx.time timestamp;
    uint64 reserved0;
    uint64 reserved1;
    uint64 reserved2;
};

struct zx_packet_page_request {
    uint16 command;
    uint16 flags;
    uint32 reserved0;
    uint64 offset;
    uint64 length;
    uint64 reserved1;
};

// TODO: anonymous union
struct zx_port_packet {
    uint64 key;
    uint32 type;
    zx.status status;
    //union {
        //zx_packet_user user;
        //zx_packet_signal signal;
        //zx_packet_exception exception;
        //zx_packet_guest_bell guest_bell;
        //zx_packet_guest_mem guest_mem;
        //zx_packet_guest_io guest_io;
        //zx_packet_guest_vcpu guest_vcpu;
        //zx_packet_interrupt interrupt;
        //zx_packet_page_request page_request;
    //};
};


//
//
// Timers
//
//

enum zx_timer_options : uint32 {
    ZX_TIMER_SLACK_CENTER = 0;
    ZX_TIMER_SLACK_EARLY = 1;
    ZX_TIMER_SLACK_LATE = 2;
};

//
//
// Memory management
//
//

// TODO: declare ZX_VMO_DEFAULT in headers
enum zx_vmo_create_options : uint32 {
    ZX_VMO_DEFAULT = 0;
    ZX_VMO_RESIZABLE = 2;   // 1u << 1
};

enum zx_vmo_opcodes : uint32 {
    ZX_VMO_OP_COMMIT = 1;
    ZX_VMO_OP_DECOMMIT = 2;
    ZX_VMO_OP_LOCK = 3;
    ZX_VMO_OP_UNLOCK = 4;
    // opcode 5 was ZX_VMO_OP_LOOKUP, but is now unused.
    ZX_VMO_OP_CACHE_SYNC = 6;
    ZX_VMO_OP_CACHE_INVALIDATE = 7;
    ZX_VMO_OP_CACHE_CLEAN = 8;
    ZX_VMO_OP_CACHE_CLEAN_INVALIDATE = 9;
};

enum zx_vmo_cache_policy_options : uint32 {
    ZX_CACHE_POLICY_CACHED = 0;
    ZX_CACHE_POLICY_UNCACHED = 1;
    ZX_CACHE_POLICY_UNCACHED_DEVICE = 2;
    ZX_CACHE_POLICY_WRITE_COMBINING = 3;
    ZX_CACHE_POLICY_MASK = 3;
};

enum zx_vmo_clone_options : uint32 {
    ZX_VMO_CLONE_COPY_ON_WRITE = 1; // 1u << 0
    ZX_VMO_CHILD_COPY_ON_WRITE = 1; // 1u << 0
    ZX_VMO_CHILD_RESIZABLE = 4;     // 1u << 2
};

//
//
// Address space management
//
//

enum zx_vmar_allocate_map_options : zx.vm_option {
    ZX_VM_PERM_READ = 1;                // 1u << 0
    ZX_VM_PERM_WRITE = 2;               // 1u << 1
    ZX_VM_PERM_EXECUTE = 4;             // 1u << 2
    ZX_VM_COMPACT = 8;                  // 1u << 3
    ZX_VM_SPECIFIC = 16;                // 1u << 4
    ZX_VM_SPECIFIC_OVERWRITE = 32;      // 1u << 5
    ZX_VM_CAN_MAP_SPECIFIC = 64;        // 1u << 6
    ZX_VM_CAN_MAP_READ = 128;           // 1u << 7
    ZX_VM_CAN_MAP_WRITE = 256;          // 1u << 8
    ZX_VM_CAN_MAP_EXECUTE = 512;        // 1u << 9
    ZX_VM_MAP_RANGE = 1024;             // 1u << 10
    ZX_VM_REQUIRE_NON_RESIZABLE = 2048; // 1u << 11
    ZX_VM_ALLOW_FAULTS = 4096;          // 1u << 12

    ZX_VM_ALIGN_1KB = 167772160;        // 10u << 24
    ZX_VM_ALIGN_2KB = 184549376;        // 11u << 24
    ZX_VM_ALIGN_4KB = 201326592;        // 12u << 24
    ZX_VM_ALIGN_8KB = 218103808;        // 13u << 24
    ZX_VM_ALIGN_16KB = 234881024;       // 14u << 24
    ZX_VM_ALIGN_32KB = 251658240;       // 15u << 24
    ZX_VM_ALIGN_64KB = 268435456;       // 16u << 24
    ZX_VM_ALIGN_128KB = 285212672;      // 17u << 24
    ZX_VM_ALIGN_256KB = 301989888;      // 18u << 24
    ZX_VM_ALIGN_512KB = 318767104;      // 19u << 24
    ZX_VM_ALIGN_1MB = 335544320;        // 20u << 24
    ZX_VM_ALIGN_2MB = 352321536;        // 21u << 24
    ZX_VM_ALIGN_4MB = 369098752;        // 22u << 24
    ZX_VM_ALIGN_8MB = 385875968;        // 23u << 24
    ZX_VM_ALIGN_16MB = 402653184;       // 24u << 24
    ZX_VM_ALIGN_32MB = 419430400;       // 25u << 24
    ZX_VM_ALIGN_64MB = 436207616;       // 26u << 24
    ZX_VM_ALIGN_128MB = 452984832;      // 27u << 24
    ZX_VM_ALIGN_256MB = 469762048;      // 28u << 24
    ZX_VM_ALIGN_512MB = 486539264;      // 29u << 24
    ZX_VM_ALIGN_1GB = 503316480;        // 30u << 24
    ZX_VM_ALIGN_2GB = 520093696;        // 31u << 24
    ZX_VM_ALIGN_4GB = 536870912;        // 32u << 24
};

enum zx_vmar_protect_options : zx.vm_option {
    ZX_VM_PERM_READ = 1;    // 1u << 0
    ZX_VM_PERM_WRITE = 2;   // 1u << 1
    ZX_VM_PERM_EXECUTE = 4; // 1u << 2
};

//
//
// Profiles
//
//

enum zx_profile_scheduler_priority : int32 {
    ZX_PRIORITY_LOWEST = 0;
    ZX_PRIORITY_LOW = 8;
    ZX_PRIORITY_DEFAULT = 16;
    ZX_PRIORITY_HIGH = 24;
    ZX_PRIORITY_HIGHEST = 31;
};

enum zx_profile_info_type : uint32 {
    ZX_PROFILE_INFO_SCHEDULER = 1;
};

struct zx_profile_scheduler {
    int32 priority;
    uint32 boost;
    uint32 deboost;
    uint32 quantum;
};


// TODO: get rid of valueset
// TODO: anonymous union
[valuetype = "type zx_profile_info_type"]
struct zx_profile_info {
    zx_profile_info_type type;
    //union {
        //zx_profile_scheduler scheduler;
    //};
};

//
//
// Logging
//
//

enum zx_debuglog_options : uint32 {
    ZX_LOG_FLAG_READABLE = 1073741824;  // 0x40000000
};


//
//
// DDK Syscalls: Interrupts
//
//

enum zx_interrupt_options : uint32 {
    ZX_INTERRUPT_REMAP_IRQ = 1;         // 0x1u
    ZX_INTERRUPT_MODE_DEFAULT = 0;      // 0u << 1
    ZX_INTERRUPT_MODE_EDGE_LOW = 2;     // 1u << 1
    ZX_INTERRUPT_MODE_EDGE_HIGH = 4;    // 2u << 1
    ZX_INTERRUPT_MODE_LEVEL_LOW = 6;    // 3u << 1
    ZX_INTERRUPT_MODE_LEVEL_HIGH = 8;   // 4u << 1
    ZX_INTERRUPT_MODE_EDGE_BOTH = 10;   // 5u << 1
    ZX_INTERRUPT_MODE_MASK = 14;        // 0xe
    ZX_INTERRUPT_VIRTUAL = 16;          // 0x10
};

//
//
// DDK Syscalls: Device Memory Access
//
//

enum zx_iommu_type : uint32 {
    ZX_IOMMU_TYPE_DUMMY = 0;
    ZX_IOMMU_TYPE_INTEL = 1;
};

// 1-1 mapping with zx_iommu_type
[argtype = "type1 IN",
 argtype = "type2 IN"]
union zx_iommu_types {
    array<zx_iommu_desc_dummy>:1 type1;
    array<zx_iommu_desc_intel>:1 type2;
};

struct zx_iommu_desc_dummy {
    uint8 reserved;
};

// TODO: include commented out structs from iommu.h
[argtype = "_reserved IN"]
struct zx_iommu_desc_intel {
    uint64 register_base;
    uint16 pci_segment;
    bool whole_segment;
    uint8 scope_bytes;
    uint16 reserved_memory_bytes;
    array<uint8>:2 _reserved;
};

enum zx_bti_options : uint32 {
    ZX_BTI_PERM_READ = 1;       // 1u << 0
    ZX_BTI_PERM_WRITE = 2;      // 1u << 1
    ZX_BTI_PERM_EXECUTE = 4;    // 1u << 2
    ZX_BTI_COMPRESS = 8;        // 1u << 3
    ZX_BTI_CONTIGUOUS = 16;     // 1u << 4
};

//
//
// DDK Syscalls: PCI
//
//

struct zx_pci_bar {
    uint32 id;
    uint32 type;
    usize size;
    //union {
        //usize addr; // uintptr_t addr
        //handle handle;
    //};
};

struct zx_pcie_device_info {
    uint16 vendor_id;
    uint16 device_id;
    uint8  base_class;
    uint8  sub_class;
    uint8  program_interface;
    uint8  revision_id;
    uint8  bus_id;
    uint8  dev_id;
    uint8  func_id;
};

struct zx_pci_init_arg {
    //zx_pci_irq_swizzle_lut_t dev_pin_to_global_irq;
    uint32 num_irqs;
    //struct {
        //uint32 global_irq;
        //bool level_triggered;
        //bool active_high;
    //} irqs[ZX_PCI_MAX_IRQS];
    uint32 addr_window_count;
    //struct {
        //uint64_t base;
        //size_t size;
        //uint8 bus_start;
        //uint8 bus_end;
        //uint8 cfg_space_type;
        //bool has_ecam;
    //} addr_windows[];
};

//
//
// DDK Syscalls: SMC Calls
//
//

struct zx_smc_parameters {
    uint32 func_id;
    uint64 arg1;
    uint64 arg2;
    uint64 arg3;
    uint64 arg4;
    uint64 arg5;
    uint64 arg6;
    uint16 client_id;
    uint16 secure_os_id;
};

struct zx_smc_result {
    uint64 arg0;
    uint64 arg1;
    uint64 arg2;
    uint64 arg3;
    uint64 arg6;
};

//
//
// Resources
//
//

enum zx_rsrc_kind_vals : uint32 {
    ZX_RSRC_KIND_MMIO = 0;
    ZX_RSRC_KIND_IRQ = 1;
    ZX_RSRC_KIND_IOPORT = 2;
    ZX_RSRC_KIND_HYPERVISOR = 3;
    ZX_RSRC_KIND_ROOT = 4;
    ZX_RSRC_KIND_VMEX = 5;
    ZX_RSRC_KIND_SMC = 6;
};

//
//
// Hypervisor
//
//

enum zx_guest_trap_kind : uint32 {
    ZX_GUEST_TRAP_BELL = 0;
    ZX_GUEST_TRAP_MEM = 1;
    ZX_GUEST_TRAP_IO = 2;
};

enum zx_vcpu_read_state_kind : uint32 {
    ZX_VCPU_STATE = 0;
};

enum zx_vcpu_write_state_kind : uint32 {
    ZX_VCPU_STATE = 0;
    ZX_VCPU_IO = 1;
};

// 1-1 mapping with zx_vcpu_read_state_kind
[argtype = "type1 OUT"]
union zx_vcpu_read_state_types {
    array<zx_vcpu_state>:1 type1;
};

// 1-1 mapping with zx_vcpu_write_state_kind
[argtype = "type1 IN",
 argtype = "type2 IN"]
union zx_vcpu_write_state_types {
    array<zx_vcpu_state>:1 type1;
    array<zx_vcpu_io>:1 type2;
};

// TODO: conditional declaration
struct zx_vcpu_state {
//#if __aarch64__
    //array<uint64>:31 x;
    //uint64 sp;
    // Contains only the user-controllable upper 4-bits (NZCV).
    //uint32 cpsr;
//#elif __x86_64__
    uint64 rax;
    uint64 rcx;
    uint64 rdx;
    uint64 rbx;
    uint64 rsp;
    uint64 rbp;
    uint64 rsi;
    uint64 rdi;
    uint64 r8;
    uint64 r9;
    uint64 r10;
    uint64 r11;
    uint64 r12;
    uint64 r13;
    uint64 r14;
    uint64 r15;
    // Contains only the user-controllable lower 32-bits.
    uint64 rflags;
//#endif
};

// TODO: anonymous union
struct zx_vcpu_io {
    uint8 access_size;
    //union {
        //uint8 u8;
        //uint16 u16;
        //uint32 u32;
        //array<uint8>:4 data;
    //};
};

//
//
// System Control
//
//

enum zx_system_powerctl_cmd : uint32 {
    ZX_SYSTEM_POWERCTL_ENABLE_ALL_CPUS = 1;
    ZX_SYSTEM_POWERCTL_DISABLE_ALL_CPUS_BUT_PRIMARY = 2;
    ZX_SYSTEM_POWERCTL_ACPI_TRANSITION_S_STATE = 3;
    ZX_SYSTEM_POWERCTL_X86_SET_PKG_PL1 = 4;
    ZX_SYSTEM_POWERCTL_REBOOT = 5;
    ZX_SYSTEM_POWERCTL_REBOOT_BOOTLOADER = 6;
    ZX_SYSTEM_POWERCTL_REBOOT_RECOVERY = 7;
    ZX_SYSTEM_POWERCTL_SHUTDOWN = 8;
};

struct zx_system_powerctl_arg {
    //union {
        //struct {
            //uint8 target_s_state;
            //uint8 sleep_type_a;
            //uint8 sleep_type_b;
        //} acpi_transition_s_state;
        //struct {
            //uint32 power_limit;
            //uint32 time_window;
            //uint8 clamp;
            //uint8 enable;
        //} x86_power_limit;
    //};
};

// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "tools/kazoo/output_util.h"

#include "src/lib/fxl/logging.h"
#include "src/lib/fxl/strings/join_strings.h"
#include "src/lib/fxl/strings/string_printf.h"

bool CopyrightHeaderWithCppComments(Writer* writer) {
  return writer->Puts(R"(// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// WARNING: THIS FILE IS MACHINE GENERATED BY //tools/kazoo. DO NOT EDIT.

)");
}

bool CopyrightHeaderWithHashComments(Writer* writer) {
  return writer->Puts(R"(# Copyright 2019 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# WARNING: THIS FILE IS MACHINE GENERATED BY //tools/kazoo. DO NOT EDIT.

)");
}

std::string ToLowerAscii(const std::string& input) {
  std::string ret = input;
  std::transform(ret.begin(), ret.end(), ret.begin(), fxl::ToLowerASCII);
  return ret;
}

std::string CamelToSnake(const std::string& camel_fidl) {
  auto is_transition = [](char prev, char cur, char peek) {
    enum { Upper, Lower, Other };
    auto categorize = [](char c) {
      if (c == 0)
        return Other;
      if (c >= 'a' && c <= 'z')
        return Lower;
      if (c >= 'A' && c <= 'Z')
        return Upper;
      if ((c >= '0' && c <= '9') || c == '_')
        return Other;
      FXL_DCHECK(false);
      return Other;
    };
    auto prev_type = categorize(prev);
    auto cur_type = categorize(cur);
    auto peek_type = categorize(peek);

    bool lower_to_upper = prev_type != Upper && cur_type == Upper;
    bool multiple_caps_to_lower =
        peek && (prev_type == Upper && cur_type == Upper && peek_type == Lower);

    return lower_to_upper || multiple_caps_to_lower;
  };
  std::vector<std::string> parts;
  char prev = 0;
  std::string current_word;
  for (size_t i = 0; i < camel_fidl.size(); ++i) {
    char cur = camel_fidl[i];
    char peek = i + 1 < camel_fidl.size() ? camel_fidl[i + 1] : 0;
    if (current_word.size() > 1 && is_transition(prev, cur, peek)) {
      parts.push_back(ToLowerAscii(current_word));
      current_word = cur;
    } else {
      current_word += cur;
    }
    prev = cur;
  }

  if (!current_word.empty()) {
    parts.push_back(ToLowerAscii(current_word));
  }

  return fxl::JoinStrings(parts, "_");
}

std::string GetCName(const Type& type) {
  struct {
   public:
    void operator()(const std::monostate&) { ret = "<TODO!>"; }
    void operator()(const TypeBool&) { ret = "bool"; }
    void operator()(const TypeChar&) { ret = "char"; }
    void operator()(const TypeInt32&) { ret = "int32_t"; }
    void operator()(const TypeInt64&) { ret = "int64_t"; }
    void operator()(const TypeSizeT&) { ret = "size_t"; }
    void operator()(const TypeUint16&) { ret = "uint16_t"; }
    void operator()(const TypeUint32&) { ret = "uint32_t"; }
    void operator()(const TypeUint64&) { ret = "uint64_t"; }
    void operator()(const TypeUint8&) { ret = "uint8_t"; }
    void operator()(const TypeUintptrT&) { ret = "uintptr_t"; }
    void operator()(const TypeVoid&) { ret = "void"; }
    void operator()(const TypeZxBasicAlias& zx_basic_alias) { ret = zx_basic_alias.name(); }

    void operator()(const TypeEnum& enm) { ret = enm.enum_data().name(); }
    void operator()(const TypeHandle& handle) {
      ret = "zx_handle_t";
      // TOOD(syscall-fidl-transition): Once we're not trying to match abigen, it might be nice to
      // add the underlying handle type here like "zx_handle_t /*vmo*/ handle" or similar.
    }
    void operator()(const TypePointer& pointer) {
      FXL_CHECK(constness != Constness::kUnspecified)
          << "Pointer should be explictly const or mutable by output time";
      ret = (constness == Constness::kConst ? "const " : "") + GetCName(pointer.pointed_to_type()) +
            "*";
    }
    void operator()(const TypeString&) {
      FXL_DCHECK(false) << "can't convert string to C directly";
      ret = "<!>";
    }
    void operator()(const TypeStruct& strukt) { ret = strukt.struct_data().name(); }
    void operator()(const TypeVector&) {
      FXL_DCHECK(false) << "can't convert vector to C directly";
      ret = "<!>";
    }

    Constness constness;
    std::string ret;
  } name_visitor;
  name_visitor.constness = type.constness();
  std::visit(name_visitor, type.type_data());
  return name_visitor.ret;
}

void CDeclaration(const Syscall& syscall, const char* prefix, const char* name_prefix,
                  Writer* writer) {
  writer->Printf("%sextern ", prefix);
  writer->Printf("%s ", GetCName(syscall.kernel_return_type()).c_str());
  writer->Printf("%s%s(\n", name_prefix, syscall.name().c_str());

  std::vector<std::string> non_nulls;
  if (syscall.kernel_arguments().size() == 0) {
    writer->Printf("    void");
  } else {
    for (size_t i = 0; i < syscall.kernel_arguments().size(); ++i) {
      const StructMember& arg = syscall.kernel_arguments()[i];
      const bool last = i == syscall.kernel_arguments().size() - 1;
      writer->Printf("    %s %s%s", GetCName(arg.type()).c_str(), arg.name().c_str(),
                     last ? "" : ",\n");
      if (arg.type().IsPointer() && arg.type().optionality() == Optionality::kOutputNonOptional) {
        non_nulls.push_back(fxl::StringPrintf("%zu", i + 1));
      }
    }
  }
  writer->Printf(")");

  // TODO(syscall-fidl-transition): The order of these post-declaration markup is maintained, but
  // perhaps it could be simplified once it doesn't need to match.

  if (!non_nulls.empty()) {
    // TODO(syscall-fidl-transition): abigen only tags non-optional arguments as non-null, but
    // other input pointers could also perhaps be usefully tagged as well.
    writer->Printf(" __NONNULL((%s))", fxl::JoinStrings(non_nulls, ", ").c_str());
  }
  writer->Printf(" __LEAF_FN");
  if (syscall.HasAttribute("Const")) {
    writer->Printf(" __CONST");
  }
  if (syscall.HasAttribute("Noreturn")) {
    writer->Printf(" __NO_RETURN");
  }
  writer->Printf(";\n\n");
}
